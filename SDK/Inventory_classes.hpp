#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Inventory

#include "Basic.hpp"

#include "IWCore_structs.hpp"
#include "IWCore_classes.hpp"
#include "Inventory_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// Class Inventory.InventoryComponent
// 0x0180 (0x0220 - 0x00A0)
class UInventoryComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnItemAdded;                                       // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInventoryChangedClient;                          // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemRemovedClient;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FItemInstanceArray                     InventoryArray;                                    // 0x00D0(0x0140)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UItemDefinition>> StartingItems;                                     // 0x0210(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	class UItemInstance* AddItemDefinition(TSoftObjectPtr<class UItemDefinition> Definition, int32 StackCount);
	void BroadcastItemChanged(const class UItemInstance* ItemInstance);
	void ClientReactToInventoryChange(const struct FItemInstanceArrayEntry& ItemInstanceArrayEntry);
	void ClientReactToInventoryItemRemoved(TSoftObjectPtr<class UItemDefinition> ItemDefinition);
	void CopyInventoryTo(class UInventoryComponent* InventoryComponent);
	TArray<class UItemInstance*> GetAllItemsOfType(TSoftObjectPtr<class UItemDefinition> Definition);
	TArray<class UItemInstance*> GetAllItemsWithAction(TSubclassOf<class UItemAction> Definition);
	TArray<class UItemInstance*> GetAllItemsWithoutAction(TSubclassOf<class UItemAction> Definition);
	class UItemInstance* GetFirstItemOfType(TSoftObjectPtr<class UItemDefinition> Definition);
	void InventoryChangedClient__DelegateSignature(const struct FItemInstanceArrayEntry& ItemInstanceArrayEntry);
	void InventoryChangedDelegate__DelegateSignature(class UItemInstance* ItemInstance);
	void InventoryItemRemovedClient__DelegateSignature(TSoftObjectPtr<class UItemDefinition> ItemDefinition);
	void PlayItemDestroyAudio(class UItemInstance* ItemInstance);
	void RemoveItem(class UItemInstance* Item);
	void UpdateShopViewModelWithInventory();

	TArray<class UItemInstance*> GetAllItems() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryComponent">();
	}
	static class UInventoryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryComponent>();
	}
};
static_assert(alignof(UInventoryComponent) == 0x000008, "Wrong alignment on UInventoryComponent");
static_assert(sizeof(UInventoryComponent) == 0x000220, "Wrong size on UInventoryComponent");
static_assert(offsetof(UInventoryComponent, OnItemAdded) == 0x0000A0, "Member 'UInventoryComponent::OnItemAdded' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnInventoryChangedClient) == 0x0000B0, "Member 'UInventoryComponent::OnInventoryChangedClient' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, OnItemRemovedClient) == 0x0000C0, "Member 'UInventoryComponent::OnItemRemovedClient' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, InventoryArray) == 0x0000D0, "Member 'UInventoryComponent::InventoryArray' has a wrong offset!");
static_assert(offsetof(UInventoryComponent, StartingItems) == 0x000210, "Member 'UInventoryComponent::StartingItems' has a wrong offset!");

// Class Inventory.ItemAction
// 0x0000 (0x0028 - 0x0028)
class UItemAction : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction">();
	}
	static class UItemAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction>();
	}
};
static_assert(alignof(UItemAction) == 0x000008, "Wrong alignment on UItemAction");
static_assert(sizeof(UItemAction) == 0x000028, "Wrong size on UItemAction");

// Class Inventory.ItemAction_TagStacks
// 0x0050 (0x0078 - 0x0028)
class UItemAction_TagStacks final : public UItemAction
{
public:
	TMap<struct FGameplayTag, int32>              TagsToGrant;                                       // 0x0028(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_TagStacks">();
	}
	static class UItemAction_TagStacks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_TagStacks>();
	}
};
static_assert(alignof(UItemAction_TagStacks) == 0x000008, "Wrong alignment on UItemAction_TagStacks");
static_assert(sizeof(UItemAction_TagStacks) == 0x000078, "Wrong size on UItemAction_TagStacks");
static_assert(offsetof(UItemAction_TagStacks, TagsToGrant) == 0x000028, "Member 'UItemAction_TagStacks::TagsToGrant' has a wrong offset!");

// Class Inventory.ItemDefinition
// 0x0088 (0x00C0 - 0x0038)
class UItemDefinition final : public UTagLookupPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0058(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UItemAction*>                    Actions;                                           // 0x0080(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ItemTags;                                          // 0x0090(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class USoundCue*                              DestroyAudio;                                      // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PurchaseAudio;                                     // 0x00B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static TSoftObjectPtr<class UItemDefinition> TryGetItemDefinition(const struct FGameplayTag& ItemId, bool* Succeeded);

	const class UItemAction* FindActionByType(TSubclassOf<class UItemAction> ActionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemDefinition">();
	}
	static class UItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemDefinition>();
	}
};
static_assert(alignof(UItemDefinition) == 0x000008, "Wrong alignment on UItemDefinition");
static_assert(sizeof(UItemDefinition) == 0x0000C0, "Wrong size on UItemDefinition");
static_assert(offsetof(UItemDefinition, DisplayName) == 0x000038, "Member 'UItemDefinition::DisplayName' has a wrong offset!");
static_assert(offsetof(UItemDefinition, Description) == 0x000048, "Member 'UItemDefinition::Description' has a wrong offset!");
static_assert(offsetof(UItemDefinition, Icon) == 0x000058, "Member 'UItemDefinition::Icon' has a wrong offset!");
static_assert(offsetof(UItemDefinition, Actions) == 0x000080, "Member 'UItemDefinition::Actions' has a wrong offset!");
static_assert(offsetof(UItemDefinition, ItemTags) == 0x000090, "Member 'UItemDefinition::ItemTags' has a wrong offset!");
static_assert(offsetof(UItemDefinition, DestroyAudio) == 0x0000B0, "Member 'UItemDefinition::DestroyAudio' has a wrong offset!");
static_assert(offsetof(UItemDefinition, PurchaseAudio) == 0x0000B8, "Member 'UItemDefinition::PurchaseAudio' has a wrong offset!");

// Class Inventory.ItemInstance
// 0x01F8 (0x0220 - 0x0028)
class UItemInstance final : public UObject
{
public:
	FMulticastInlineDelegateProperty_             OnItemRemoved;                                     // 0x0028(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnItemMarkedForRemoval;                            // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameplayTagStacksChanged;                        // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RemovalTimerHandle;                                // 0x0068(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemDefinition>         ItemDefinitionType;                                // 0x0070(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTagStackContainer             Tags;                                              // 0x0098(0x0180)(BlueprintVisible, BlueprintReadOnly, Net, NativeAccessSpecifierPrivate)
	uint8                                         Pad_218[0x8];                                      // 0x0218(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTagStacks(const struct FGameplayTag& Tag, const int32 AmountToAdd);
	class UTexture2D* GetItemIconBlocking();
	class FText GetItemName(bool* NameFound);
	void RemoveTag(const struct FGameplayTag& Tag);
	void SetTagStacks(const struct FGameplayTag& Tag, const int32 NewAmount);
	void SubtractTagStacks(const struct FGameplayTag& Tag, const int32 AmountToRemove);

	bool ContainsTag(const struct FGameplayTag& Tag) const;
	const class UItemAction* FindActionByType(TSubclassOf<class UItemAction> ActionType) const;
	int32 GetTagStackCount(const struct FGameplayTag& Tag) const;
	bool HasDefinitionTag(const struct FGameplayTag& Tag) const;
	void OnTagStackChanged(const struct FGameplayTag& Tag, int32 NewStacks) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemInstance">();
	}
	static class UItemInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemInstance>();
	}
};
static_assert(alignof(UItemInstance) == 0x000008, "Wrong alignment on UItemInstance");
static_assert(sizeof(UItemInstance) == 0x000220, "Wrong size on UItemInstance");
static_assert(offsetof(UItemInstance, OnItemRemoved) == 0x000028, "Member 'UItemInstance::OnItemRemoved' has a wrong offset!");
static_assert(offsetof(UItemInstance, OnItemMarkedForRemoval) == 0x000038, "Member 'UItemInstance::OnItemMarkedForRemoval' has a wrong offset!");
static_assert(offsetof(UItemInstance, OnGameplayTagStacksChanged) == 0x000048, "Member 'UItemInstance::OnGameplayTagStacksChanged' has a wrong offset!");
static_assert(offsetof(UItemInstance, RemovalTimerHandle) == 0x000068, "Member 'UItemInstance::RemovalTimerHandle' has a wrong offset!");
static_assert(offsetof(UItemInstance, ItemDefinitionType) == 0x000070, "Member 'UItemInstance::ItemDefinitionType' has a wrong offset!");
static_assert(offsetof(UItemInstance, Tags) == 0x000098, "Member 'UItemInstance::Tags' has a wrong offset!");

}

