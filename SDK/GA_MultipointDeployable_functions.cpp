#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GA_MultipointDeployable

#include "Basic.hpp"

#include "GA_MultipointDeployable_classes.hpp"
#include "GA_MultipointDeployable_parameters.hpp"


namespace SDK
{

// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Add Point
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::Add_Point()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Add Point");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.AddDeployingGameplayEffect
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::AddDeployingGameplayEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "AddDeployingGameplayEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Added_A0072EF3441974EDF04C3F901EEDDD3D
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::Added_A0072EF3441974EDF04C3F901EEDDD3D()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Added_A0072EF3441974EDF04C3F901EEDDD3D");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.AnimPrimaryPressed
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::AnimPrimaryPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "AnimPrimaryPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.AnimSecondaryPressed
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::AnimSecondaryPressed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "AnimSecondaryPressed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Auth_SpawnItem
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FHitResult>               TraceHits                                              (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FRotator                         PreviewRotation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double                                  OptionalAngle_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OptionalVector_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::Auth_SpawnItem(const TArray<struct FHitResult>& TraceHits, const struct FRotator& PreviewRotation, double OptionalAngle_0, const struct FVector& OptionalVector_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Auth_SpawnItem");

	Params::GA_MultipointDeployable_C_Auth_SpawnItem Parms{};

	Parms.TraceHits = std::move(TraceHits);
	Parms.PreviewRotation = std::move(PreviewRotation);
	Parms.OptionalAngle_0 = OptionalAngle_0;
	Parms.OptionalVector_0 = std::move(OptionalVector_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Blocked by Dynamic Object
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    NotBlocked                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::Blocked_by_Dynamic_Object(bool* NotBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Blocked by Dynamic Object");

	Params::GA_MultipointDeployable_C_Blocked_by_Dynamic_Object Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NotBlocked != nullptr)
		*NotBlocked = Parms.NotBlocked;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.BoxTraceEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UGA_MultipointDeployable_C::BoxTraceEnd()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "BoxTraceEnd");

	Params::GA_MultipointDeployable_C_BoxTraceEnd Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.BoxTraceHalfSize
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  X                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Y                                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::BoxTraceHalfSize(double* X, double* Y)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "BoxTraceHalfSize");

	Params::GA_MultipointDeployable_C_BoxTraceHalfSize Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (X != nullptr)
		*X = Parms.X;

	if (Y != nullptr)
		*Y = Parms.Y;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.CloneSpawnPreviewMesh
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::CloneSpawnPreviewMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "CloneSpawnPreviewMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.CollisionBetweenPoints
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_MultipointDeployable_C::CollisionBetweenPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "CollisionBetweenPoints");

	Params::GA_MultipointDeployable_C_CollisionBetweenPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.ConstructCosmetics
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::ConstructCosmetics(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "ConstructCosmetics");

	Params::GA_MultipointDeployable_C_ConstructCosmetics Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.DebugPlacement
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::DebugPlacement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "DebugPlacement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.EndWaitDelayTaskIfExists
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::EndWaitDelayTaskIfExists()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "EndWaitDelayTaskIfExists");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.EndWaitTagTaskIfExists
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::EndWaitTagTaskIfExists()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "EndWaitTagTaskIfExists");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.ExecuteUbergraph_GA_MultipointDeployable
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::ExecuteUbergraph_GA_MultipointDeployable(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "ExecuteUbergraph_GA_MultipointDeployable");

	Params::GA_MultipointDeployable_C_ExecuteUbergraph_GA_MultipointDeployable Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetAllowedObjectTypes
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<EObjectTypeQuery>                AllowedObjectTypes                                     (Parm, OutParm)

void UGA_MultipointDeployable_C::GetAllowedObjectTypes(TArray<EObjectTypeQuery>* AllowedObjectTypes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetAllowedObjectTypes");

	Params::GA_MultipointDeployable_C_GetAllowedObjectTypes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AllowedObjectTypes != nullptr)
		*AllowedObjectTypes = std::move(Parms.AllowedObjectTypes);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetEquipmentCasted
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UBP_MultipointDeployableEquipmentInstance_C*AsBP_Deployable_Equipment_Instance                     (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::GetEquipmentCasted(class UBP_MultipointDeployableEquipmentInstance_C** AsBP_Deployable_Equipment_Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetEquipmentCasted");

	Params::GA_MultipointDeployable_C_GetEquipmentCasted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AsBP_Deployable_Equipment_Instance != nullptr)
		*AsBP_Deployable_Equipment_Instance = Parms.AsBP_Deployable_Equipment_Instance;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetItemInstance
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UItemInstance*                    ItemInstance_0                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::GetItemInstance(class UItemInstance** ItemInstance_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetItemInstance");

	Params::GA_MultipointDeployable_C_GetItemInstance Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ItemInstance_0 != nullptr)
		*ItemInstance_0 = Parms.ItemInstance_0;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetItemTag
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash)

struct FGameplayTag UGA_MultipointDeployable_C::GetItemTag()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetItemTag");

	Params::GA_MultipointDeployable_C_GetItemTag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetOwnerAnimBPs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UAnimInstance*>            Array_Element                                          (Parm, OutParm)

void UGA_MultipointDeployable_C::GetOwnerAnimBPs(TArray<class UAnimInstance*>* Array_Element)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetOwnerAnimBPs");

	Params::GA_MultipointDeployable_C_GetOwnerAnimBPs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Array_Element != nullptr)
		*Array_Element = std::move(Parms.Array_Element);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetPreviewMaterial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ValidPlacement                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               NewParam                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::GetPreviewMaterial(bool ValidPlacement, class UMaterialInterface** NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetPreviewMaterial");

	Params::GA_MultipointDeployable_C_GetPreviewMaterial Parms{};

	Parms.ValidPlacement = ValidPlacement;

	UObject::ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = Parms.NewParam;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetPreviewMeshRotation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

struct FRotator UGA_MultipointDeployable_C::GetPreviewMeshRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetPreviewMeshRotation");

	Params::GA_MultipointDeployable_C_GetPreviewMeshRotation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetResidentCasted
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_ResidentCharacter_C*          AsBPResidentCharacter                                  (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::GetResidentCasted(class ABP_ResidentCharacter_C** AsBPResidentCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetResidentCasted");

	Params::GA_MultipointDeployable_C_GetResidentCasted Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (AsBPResidentCharacter != nullptr)
		*AsBPResidentCharacter = Parms.AsBPResidentCharacter;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetSphereTraceStartEnd
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       StartHit                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FHitResult                       EndHit                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FVector                          Start                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          End                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::GetSphereTraceStartEnd(const struct FHitResult& StartHit, const struct FHitResult& EndHit, struct FVector* Start, struct FVector* End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetSphereTraceStartEnd");

	Params::GA_MultipointDeployable_C_GetSphereTraceStartEnd Parms{};

	Parms.StartHit = std::move(StartHit);
	Parms.EndHit = std::move(EndHit);

	UObject::ProcessEvent(Func, &Parms);

	if (Start != nullptr)
		*Start = std::move(Parms.Start);

	if (End != nullptr)
		*End = std::move(Parms.End);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetTagCount
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTag                     Tag                                                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   Count                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::GetTagCount(const struct FGameplayTag& Tag, int32* Count)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetTagCount");

	Params::GA_MultipointDeployable_C_GetTagCount Parms{};

	Parms.Tag = std::move(Tag);

	UObject::ProcessEvent(Func, &Parms);

	if (Count != nullptr)
		*Count = Parms.Count;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GetTracePoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Start                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          End                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::GetTracePoints(class UObject* Object, struct FVector* Start, struct FVector* End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GetTracePoints");

	Params::GA_MultipointDeployable_C_GetTracePoints Parms{};

	Parms.Object = Object;

	UObject::ProcessEvent(Func, &Parms);

	if (Start != nullptr)
		*Start = std::move(Parms.Start);

	if (End != nullptr)
		*End = std::move(Parms.End);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.GrantRewardToPlayer
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UEconomyDefinition*               EconomyToAdd                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::GrantRewardToPlayer(class UEconomyDefinition* EconomyToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "GrantRewardToPlayer");

	Params::GA_MultipointDeployable_C_GrantRewardToPlayer Parms{};

	Parms.EconomyToAdd = EconomyToAdd;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.HidePreviewMesh
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::HidePreviewMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "HidePreviewMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.IncrementPlacement
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::IncrementPlacement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "IncrementPlacement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Init
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::Init()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Init");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.InitializePreviewMeshes
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::InitializePreviewMeshes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "InitializePreviewMeshes");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.InitializeResultPreviewMesh
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::InitializeResultPreviewMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "InitializeResultPreviewMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.IsAboveMinHeight
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::IsAboveMinHeight(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "IsAboveMinHeight");

	Params::GA_MultipointDeployable_C_IsAboveMinHeight Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.IsInsideBlocker
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsInside                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::IsInsideBlocker(bool* IsInside)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "IsInsideBlocker");

	Params::GA_MultipointDeployable_C_IsInsideBlocker Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsInside != nullptr)
		*IsInside = Parms.IsInside;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.IsNotOnEnemyPlot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    NotOnEnemyPlot                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::IsNotOnEnemyPlot(bool* NotOnEnemyPlot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "IsNotOnEnemyPlot");

	Params::GA_MultipointDeployable_C_IsNotOnEnemyPlot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NotOnEnemyPlot != nullptr)
		*NotOnEnemyPlot = Parms.NotOnEnemyPlot;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.IsOwnerChargingADropThrow
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_MultipointDeployable_C::IsOwnerChargingADropThrow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "IsOwnerChargingADropThrow");

	Params::GA_MultipointDeployable_C_IsOwnerChargingADropThrow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.K2_ActivateAbility
// (Event, Protected, BlueprintEvent)

void UGA_MultipointDeployable_C::K2_ActivateAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "K2_ActivateAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.K2_OnAbilityAdded
// (Event, Protected, BlueprintEvent)

void UGA_MultipointDeployable_C::K2_OnAbilityAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "K2_OnAbilityAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.K2_OnEndAbility
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bWasCancelled                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::K2_OnEndAbility(bool bWasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "K2_OnEndAbility");

	Params::GA_MultipointDeployable_C_K2_OnEndAbility Parms{};

	Parms.bWasCancelled = bWasCancelled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.LegalAngle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_MultipointDeployable_C::LegalAngle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "LegalAngle");

	Params::GA_MultipointDeployable_C_LegalAngle Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.LegalLengthBetweenPoints
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_MultipointDeployable_C::LegalLengthBetweenPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "LegalLengthBetweenPoints");

	Params::GA_MultipointDeployable_C_LegalLengthBetweenPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.LegalPreviewMeshCollision
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    Return_Value                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           HitActor                                               (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::LegalPreviewMeshCollision(bool* Return_Value, class AActor** HitActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "LegalPreviewMeshCollision");

	Params::GA_MultipointDeployable_C_LegalPreviewMeshCollision Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return_Value != nullptr)
		*Return_Value = Parms.Return_Value;

	if (HitActor != nullptr)
		*HitActor = Parms.HitActor;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.LegalTeam
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    OnTeamGrounds                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::LegalTeam(bool* OnTeamGrounds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "LegalTeam");

	Params::GA_MultipointDeployable_C_LegalTeam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (OnTeamGrounds != nullptr)
		*OnTeamGrounds = Parms.OnTeamGrounds;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.MovePreviewMeshToTrace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::MovePreviewMeshToTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "MovePreviewMeshToTrace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.OnFinish_05BA4BA74289495EA234D5980470C09E
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::OnFinish_05BA4BA74289495EA234D5980470C09E()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "OnFinish_05BA4BA74289495EA234D5980470C09E");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.OnFinished_C433343E4649B5EAE596A8A8637F5ECF
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ActionNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::OnFinished_C433343E4649B5EAE596A8A8637F5ECF(int32 ActionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "OnFinished_C433343E4649B5EAE596A8A8637F5ECF");

	Params::GA_MultipointDeployable_C_OnFinished_C433343E4649B5EAE596A8A8637F5ECF Parms{};

	Parms.ActionNumber = ActionNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.OnPerformAction_C433343E4649B5EAE596A8A8637F5ECF
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   ActionNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::OnPerformAction_C433343E4649B5EAE596A8A8637F5ECF(int32 ActionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "OnPerformAction_C433343E4649B5EAE596A8A8637F5ECF");

	Params::GA_MultipointDeployable_C_OnPerformAction_C433343E4649B5EAE596A8A8637F5ECF Parms{};

	Parms.ActionNumber = ActionNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.OnPress_B1785CF84B0B601BA84D17A61C5C9E32
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TimeWaited                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::OnPress_B1785CF84B0B601BA84D17A61C5C9E32(float TimeWaited)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "OnPress_B1785CF84B0B601BA84D17A61C5C9E32");

	Params::GA_MultipointDeployable_C_OnPress_B1785CF84B0B601BA84D17A61C5C9E32 Parms{};

	Parms.TimeWaited = TimeWaited;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.OnRelease_796AF87F43799A4D551C0D998EBAE204
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   TimeHeld                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::OnRelease_796AF87F43799A4D551C0D998EBAE204(float TimeHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "OnRelease_796AF87F43799A4D551C0D998EBAE204");

	Params::GA_MultipointDeployable_C_OnRelease_796AF87F43799A4D551C0D998EBAE204 Parms{};

	Parms.TimeHeld = TimeHeld;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.OverrideInputStart
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::OverrideInputStart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "OverrideInputStart");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.PlacementLegalityMessage
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::PlacementLegalityMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "PlacementLegalityMessage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.PlacePointCosmetics
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::PlacePointCosmetics(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "PlacePointCosmetics");

	Params::GA_MultipointDeployable_C_PlacePointCosmetics Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.PreviewMeshMovementTick
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::PreviewMeshMovementTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "PreviewMeshMovementTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Re-wait
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::ReMinuswait()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Re-wait");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.RemoveDeployingGameplayEffect
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::RemoveDeployingGameplayEffect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "RemoveDeployingGameplayEffect");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.RequiredAmountOfPoints
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_MultipointDeployable_C::RequiredAmountOfPoints()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "RequiredAmountOfPoints");

	Params::GA_MultipointDeployable_C_RequiredAmountOfPoints Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.ResetPreviewMeshMovementTick
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::ResetPreviewMeshMovementTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "ResetPreviewMeshMovementTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.RestartTrace
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::RestartTrace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "RestartTrace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Set Materials
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UMaterialInterface*               InMaterial                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InPrimitive                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::Set_Materials(class UMaterialInterface* InMaterial, class UPrimitiveComponent* InPrimitive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Set Materials");

	Params::GA_MultipointDeployable_C_Set_Materials Parms{};

	Parms.InMaterial = InMaterial;
	Parms.InPrimitive = InPrimitive;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.SetBuildingOutlinePPEnabled
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::SetBuildingOutlinePPEnabled(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "SetBuildingOutlinePPEnabled");

	Params::GA_MultipointDeployable_C_SetBuildingOutlinePPEnabled Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Spawn Item
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FHitResult>               TraceHits                                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FRotator                         PreviewRotation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UGA_MultipointDeployable_C::Spawn_Item(TArray<struct FHitResult>& TraceHits, const struct FRotator& PreviewRotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Spawn Item");

	Params::GA_MultipointDeployable_C_Spawn_Item Parms{};

	Parms.TraceHits = std::move(TraceHits);
	Parms.PreviewRotation = std::move(PreviewRotation);

	UObject::ProcessEvent(Func, &Parms);

	TraceHits = std::move(Parms.TraceHits);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.SpawnDeployable
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<struct FHitResult>               HitResults                                             (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, ContainsInstancedReference)
// struct FRotator                         PreviewRotation                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// double                                  OptionalAngle_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          OptionalVector_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::SpawnDeployable(TArray<struct FHitResult>& HitResults, const struct FRotator& PreviewRotation, double OptionalAngle_0, const struct FVector& OptionalVector_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "SpawnDeployable");

	Params::GA_MultipointDeployable_C_SpawnDeployable Parms{};

	Parms.HitResults = std::move(HitResults);
	Parms.PreviewRotation = std::move(PreviewRotation);
	Parms.OptionalAngle_0 = OptionalAngle_0;
	Parms.OptionalVector_0 = std::move(OptionalVector_0);

	UObject::ProcessEvent(Func, &Parms);

	HitResults = std::move(Parms.HitResults);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.SphereTraceBetweenPoints
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       StartHit                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FHitResult                       EndHit                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_MultipointDeployable_C::SphereTraceBetweenPoints(const struct FHitResult& StartHit, const struct FHitResult& EndHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "SphereTraceBetweenPoints");

	Params::GA_MultipointDeployable_C_SphereTraceBetweenPoints Parms{};

	Parms.StartHit = std::move(StartHit);
	Parms.EndHit = std::move(EndHit);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.StartPreviewMeshMovementTick
// (BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::StartPreviewMeshMovementTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "StartPreviewMeshMovementTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.ToggleM2GreyOut
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    GreyedOut                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_MultipointDeployable_C::ToggleM2GreyOut(bool GreyedOut)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "ToggleM2GreyOut");

	Params::GA_MultipointDeployable_C_ToggleM2GreyOut Parms{};

	Parms.GreyedOut = GreyedOut;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Trace
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::Trace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Trace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.TraceHitContainsIllegalPhysicsMaterial
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_MultipointDeployable_C::TraceHitContainsIllegalPhysicsMaterial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "TraceHitContainsIllegalPhysicsMaterial");

	Params::GA_MultipointDeployable_C_TraceHitContainsIllegalPhysicsMaterial Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.Update Placement Legalality
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    IsLegal                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FText                             DeploymentMessage                                      (Parm, OutParm)

void UGA_MultipointDeployable_C::Update_Placement_Legalality(bool* IsLegal, class FText* DeploymentMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "Update Placement Legalality");

	Params::GA_MultipointDeployable_C_Update_Placement_Legalality Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (IsLegal != nullptr)
		*IsLegal = Parms.IsLegal;

	if (DeploymentMessage != nullptr)
		*DeploymentMessage = std::move(Parms.DeploymentMessage);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.UpdateResultPreviewMesh
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_MultipointDeployable_C::UpdateResultPreviewMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "UpdateResultPreviewMesh");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_MultipointDeployable.GA_MultipointDeployable_C.K2_CanActivateAbility
// (Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// struct FGameplayAbilitySpecHandle       Handle                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            RelevantTags                                           (Parm, OutParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_MultipointDeployable_C::K2_CanActivateAbility(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle, struct FGameplayTagContainer* RelevantTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_MultipointDeployable_C", "K2_CanActivateAbility");

	Params::GA_MultipointDeployable_C_K2_CanActivateAbility Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.Handle = std::move(Handle);

	UObject::ProcessEvent(Func, &Parms);

	if (RelevantTags != nullptr)
		*RelevantTags = std::move(Parms.RelevantTags);

	return Parms.ReturnValue;
}

}

