#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BlueprintFunctionLibraryJP

#include "Basic.hpp"

#include "BlueprintFunctionLibraryJP_classes.hpp"
#include "BlueprintFunctionLibraryJP_parameters.hpp"


namespace SDK
{

// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Add Tutorial
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerControllerJP_MatchBP_C*    Owning_PlayerController                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UClass*                           Tutorial                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::Add_Tutorial(class APlayerControllerJP_MatchBP_C* Owning_PlayerController, class UClass* Tutorial, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Add Tutorial");

	Params::BlueprintFunctionLibraryJP_C_Add_Tutorial Parms{};

	Parms.Owning_PlayerController = Owning_PlayerController;
	Parms.Tutorial = Tutorial;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.AddTextChatMapping
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Add                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::AddTextChatMapping(class APlayerController* PlayerController, bool Add, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "AddTextChatMapping");

	Params::BlueprintFunctionLibraryJP_C_AddTextChatMapping Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Add = Add;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.ApplyGameplayEffectToSelfByDuration
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UGameplayAbility*                 Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// float                                   Duration                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::ApplyGameplayEffectToSelfByDuration(class UGameplayAbility* Target, float Duration, TSubclassOf<class UGameplayEffect> GameplayEffectClass, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "ApplyGameplayEffectToSelfByDuration");

	Params::BlueprintFunctionLibraryJP_C_ApplyGameplayEffectToSelfByDuration Parms{};

	Parms.Target = Target;
	Parms.Duration = Duration;
	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Auth_SendEventMessage
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FS_EventMessageParams            Message                                                (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::Auth_SendEventMessage(const struct FS_EventMessageParams& Message, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Auth_SendEventMessage");

	Params::BlueprintFunctionLibraryJP_C_Auth_SendEventMessage Parms{};

	Parms.Message = std::move(Message);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Auth_SendMessage
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                Controller_Reference                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// EMessageRecipient                       Recipients                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Message                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// EMessageCategory                        Category                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Translate_Using_String_Table                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             String_Table_ID                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::Auth_SendMessage(class APlayerController* Controller_Reference, EMessageRecipient Recipients, const class FString& Message, EMessageCategory Category, bool Translate_Using_String_Table, class FName String_Table_ID, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Auth_SendMessage");

	Params::BlueprintFunctionLibraryJP_C_Auth_SendMessage Parms{};

	Parms.Controller_Reference = Controller_Reference;
	Parms.Recipients = Recipients;
	Parms.Message = std::move(Message);
	Parms.Category = Category;
	Parms.Translate_Using_String_Table = Translate_Using_String_Table;
	Parms.String_Table_ID = String_Table_ID;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Auth_SendMessageVerbose
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FPlayerMessage                   Message_Specification                                  (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::Auth_SendMessageVerbose(const struct FPlayerMessage& Message_Specification, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Auth_SendMessageVerbose");

	Params::BlueprintFunctionLibraryJP_C_Auth_SendMessageVerbose Parms{};

	Parms.Message_Specification = std::move(Message_Specification);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Get BP Tweakable Data
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UBP_TweakableData_C*              AsBP_Tweakable_Data                                    (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::Get_BP_Tweakable_Data(class UObject* __WorldContext, class UBP_TweakableData_C** AsBP_Tweakable_Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Get BP Tweakable Data");

	Params::BlueprintFunctionLibraryJP_C_Get_BP_Tweakable_Data Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AsBP_Tweakable_Data != nullptr)
		*AsBP_Tweakable_Data = Parms.AsBP_Tweakable_Data;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Get ClassLog Name
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          Object                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FString                           Name_0                                                 (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::Get_ClassLog_Name(const class UObject* Object, class UObject* __WorldContext, class FString* Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Get ClassLog Name");

	Params::BlueprintFunctionLibraryJP_C_Get_ClassLog_Name Parms{};

	Parms.Object = Object;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Name_0 != nullptr)
		*Name_0 = std::move(Parms.Name_0);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Get Groundskeeper from Team
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   TeamId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class Abp_groundskeeper_C*              GroundsKeeper                                          (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::Get_Groundskeeper_from_Team(uint8 TeamId, class UObject* __WorldContext, class Abp_groundskeeper_C** GroundsKeeper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Get Groundskeeper from Team");

	Params::BlueprintFunctionLibraryJP_C_Get_Groundskeeper_from_Team Parms{};

	Parms.TeamId = TeamId;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (GroundsKeeper != nullptr)
		*GroundsKeeper = Parms.GroundsKeeper;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Get Relative Team Color as Text Clientside
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   TeamId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          WorldContext                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FText                             TeamColor                                              (Parm, OutParm)

void UBlueprintFunctionLibraryJP_C::Get_Relative_Team_Color_as_Text_Clientside(uint8 TeamId, class UObject* WorldContext, class UObject* __WorldContext, class FText* TeamColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Get Relative Team Color as Text Clientside");

	Params::BlueprintFunctionLibraryJP_C_Get_Relative_Team_Color_as_Text_Clientside Parms{};

	Parms.TeamId = TeamId;
	Parms.WorldContext = WorldContext;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (TeamColor != nullptr)
		*TeamColor = std::move(Parms.TeamColor);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Get Relative Team Color as Text Serverside
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// uint8                                   TeamId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APlayerController*                PlayerController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FText                             TeamColor                                              (Parm, OutParm)

void UBlueprintFunctionLibraryJP_C::Get_Relative_Team_Color_as_Text_Serverside(uint8 TeamId, class APlayerController* PlayerController, class UObject* __WorldContext, class FText* TeamColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Get Relative Team Color as Text Serverside");

	Params::BlueprintFunctionLibraryJP_C_Get_Relative_Team_Color_as_Text_Serverside Parms{};

	Parms.TeamId = TeamId;
	Parms.PlayerController = PlayerController;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (TeamColor != nullptr)
		*TeamColor = std::move(Parms.TeamColor);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetAllPlayerMasterIds
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>                   PlayerIdsTeam1                                         (Parm, OutParm)
// TArray<class FString>                   PlayerIdsTeam2                                         (Parm, OutParm)

void UBlueprintFunctionLibraryJP_C::GetAllPlayerMasterIds(class UObject* __WorldContext, TArray<class FString>* PlayerIdsTeam1, TArray<class FString>* PlayerIdsTeam2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetAllPlayerMasterIds");

	Params::BlueprintFunctionLibraryJP_C_GetAllPlayerMasterIds Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (PlayerIdsTeam1 != nullptr)
		*PlayerIdsTeam1 = std::move(Parms.PlayerIdsTeam1);

	if (PlayerIdsTeam2 != nullptr)
		*PlayerIdsTeam2 = std::move(Parms.PlayerIdsTeam2);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetAllPlayerTitleIds
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<class FString>                   PlayerIdsTeam1                                         (Parm, OutParm)
// TArray<class FString>                   PlayerIdsTeam2                                         (Parm, OutParm)

void UBlueprintFunctionLibraryJP_C::GetAllPlayerTitleIds(class UObject* __WorldContext, TArray<class FString>* PlayerIdsTeam1, TArray<class FString>* PlayerIdsTeam2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetAllPlayerTitleIds");

	Params::BlueprintFunctionLibraryJP_C_GetAllPlayerTitleIds Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (PlayerIdsTeam1 != nullptr)
		*PlayerIdsTeam1 = std::move(Parms.PlayerIdsTeam1);

	if (PlayerIdsTeam2 != nullptr)
		*PlayerIdsTeam2 = std::move(Parms.PlayerIdsTeam2);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetBadColor
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FLinearColor                     Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::GetBadColor(class UObject* __WorldContext, struct FLinearColor* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetBadColor");

	Params::BlueprintFunctionLibraryJP_C_GetBadColor Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = std::move(Parms.Return);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetDefaultPerkColorSlate
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FSlateColor                      SlateColor                                             (Parm, OutParm)

void UBlueprintFunctionLibraryJP_C::GetDefaultPerkColorSlate(class UObject* __WorldContext, struct FSlateColor* SlateColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetDefaultPerkColorSlate");

	Params::BlueprintFunctionLibraryJP_C_GetDefaultPerkColorSlate Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SlateColor != nullptr)
		*SlateColor = std::move(Parms.SlateColor);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetIncomeNotificationManager
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class ABP_IncomeNotificationManager_C*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash)

class ABP_IncomeNotificationManager_C* UBlueprintFunctionLibraryJP_C::GetIncomeNotificationManager(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetIncomeNotificationManager");

	Params::BlueprintFunctionLibraryJP_C_GetIncomeNotificationManager Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetInventorySize
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APlayerState*                     PlayerState                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   ModifiedSize                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::GetInventorySize(class APlayerState* PlayerState, class UObject* __WorldContext, int32* ModifiedSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetInventorySize");

	Params::BlueprintFunctionLibraryJP_C_GetInventorySize Parms{};

	Parms.PlayerState = PlayerState;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ModifiedSize != nullptr)
		*ModifiedSize = Parms.ModifiedSize;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetLocalVelocity
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LocalSpaceVelocity                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::GetLocalVelocity(class AActor* Target, class UObject* __WorldContext, struct FVector* LocalSpaceVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetLocalVelocity");

	Params::BlueprintFunctionLibraryJP_C_GetLocalVelocity Parms{};

	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (LocalSpaceVelocity != nullptr)
		*LocalSpaceVelocity = std::move(Parms.LocalSpaceVelocity);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetNextTeam
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FTeam                            CurrentTeam                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FTeam                            NextTeam                                               (Parm, OutParm, NoDestructor)

void UBlueprintFunctionLibraryJP_C::GetNextTeam(const struct FTeam& CurrentTeam, class UObject* __WorldContext, struct FTeam* NextTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetNextTeam");

	Params::BlueprintFunctionLibraryJP_C_GetNextTeam Parms{};

	Parms.CurrentTeam = std::move(CurrentTeam);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NextTeam != nullptr)
		*NextTeam = std::move(Parms.NextTeam);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetPerkColorSlate
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UPerkDefinition*                  Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FSlateColor                      SlateColor                                             (Parm, OutParm)

void UBlueprintFunctionLibraryJP_C::GetPerkColorSlate(class UPerkDefinition* Target, class UObject* __WorldContext, struct FSlateColor* SlateColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetPerkColorSlate");

	Params::BlueprintFunctionLibraryJP_C_GetPerkColorSlate Parms{};

	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SlateColor != nullptr)
		*SlateColor = std::move(Parms.SlateColor);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetShopItemCategoryForItemDefinition
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// EShopItemCategory                       ShopItemCategory                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   StencilValue                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::GetShopItemCategoryForItemDefinition(class UItemDefinition* ItemDefinition, class UObject* __WorldContext, EShopItemCategory* ShopItemCategory, bool* Success, int32* StencilValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "GetShopItemCategoryForItemDefinition");

	Params::BlueprintFunctionLibraryJP_C_GetShopItemCategoryForItemDefinition Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ShopItemCategory != nullptr)
		*ShopItemCategory = Parms.ShopItemCategory;

	if (Success != nullptr)
		*Success = Parms.Success;

	if (StencilValue != nullptr)
		*StencilValue = Parms.StencilValue;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.IsWorldStatic
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UBlueprintFunctionLibraryJP_C::IsWorldStatic(class UPrimitiveComponent* Component, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "IsWorldStatic");

	Params::BlueprintFunctionLibraryJP_C_IsWorldStatic Parms{};

	Parms.Component = Component;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.ModifyOutgoingDamageByPerk
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  OutgoingDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class AActor*                           Causer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponent*          HitActorASC                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ModifiedOutgoingDamage                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::ModifyOutgoingDamageByPerk(double OutgoingDamage, const struct FHitResult& HitResult, class AActor* Causer, class UAbilitySystemComponent* HitActorASC, class UObject* __WorldContext, double* ModifiedOutgoingDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "ModifyOutgoingDamageByPerk");

	Params::BlueprintFunctionLibraryJP_C_ModifyOutgoingDamageByPerk Parms{};

	Parms.OutgoingDamage = OutgoingDamage;
	Parms.HitResult = std::move(HitResult);
	Parms.Causer = Causer;
	Parms.HitActorASC = HitActorASC;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ModifiedOutgoingDamage != nullptr)
		*ModifiedOutgoingDamage = Parms.ModifiedOutgoingDamage;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.ModifyStructureDamageByPerk
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TSoftObjectPtr<class UItemDefinition>   ItemDefinition                                         (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// double                                  OriginalMultiplier                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ModifiedMultiplier                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::ModifyStructureDamageByPerk(class APawn* Pawn, TSoftObjectPtr<class UItemDefinition> ItemDefinition, double OriginalMultiplier, class UObject* __WorldContext, double* ModifiedMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "ModifyStructureDamageByPerk");

	Params::BlueprintFunctionLibraryJP_C_ModifyStructureDamageByPerk Parms{};

	Parms.Pawn = Pawn;
	Parms.ItemDefinition = ItemDefinition;
	Parms.OriginalMultiplier = OriginalMultiplier;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ModifiedMultiplier != nullptr)
		*ModifiedMultiplier = Parms.ModifiedMultiplier;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.PlayIncomeNotificationAtLocation
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Score                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8                                   TeamId                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::PlayIncomeNotificationAtLocation(const struct FVector& Location, double Score, uint8 TeamId, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "PlayIncomeNotificationAtLocation");

	Params::BlueprintFunctionLibraryJP_C_PlayIncomeNotificationAtLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.Score = Score;
	Parms.TeamId = TeamId;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.ReceptacleSetComparison
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TSet<EReceptacleType>                   A                                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// TSet<EReceptacleType>                   B                                                      (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Match                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::ReceptacleSetComparison(const TSet<EReceptacleType>& A, const TSet<EReceptacleType>& B, class UObject* __WorldContext, bool* Match)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "ReceptacleSetComparison");

	Params::BlueprintFunctionLibraryJP_C_ReceptacleSetComparison Parms{};

	Parms.A = std::move(A);
	Parms.B = std::move(B);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Match != nullptr)
		*Match = Parms.Match;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.RoomEnumToTextTranslated
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// ERooms                                  ERooms                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText UBlueprintFunctionLibraryJP_C::RoomEnumToTextTranslated(ERooms ERooms, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "RoomEnumToTextTranslated");

	Params::BlueprintFunctionLibraryJP_C_RoomEnumToTextTranslated Parms{};

	Parms.ERooms = ERooms;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.Switch To Menu Input Mappings
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APlayerController*                PlayerController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Invert                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::Switch_To_Menu_Input_Mappings(class APlayerController* PlayerController, bool Invert, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "Switch To Menu Input Mappings");

	Params::BlueprintFunctionLibraryJP_C_Switch_To_Menu_Input_Mappings Parms{};

	Parms.PlayerController = PlayerController;
	Parms.Invert = Invert;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.ToggleHighlightOnTask
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Activate                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FS_HighlightParameters           Params_0                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::ToggleHighlightOnTask(bool Activate, const struct FS_HighlightParameters& Params_0, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "ToggleHighlightOnTask");

	Params::BlueprintFunctionLibraryJP_C_ToggleHighlightOnTask Parms{};

	Parms.Activate = Activate;
	Parms.Params_0 = std::move(Params_0);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.ToolEnumToTextTranslated
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_Tools                                 ETools                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm)

class FText UBlueprintFunctionLibraryJP_C::ToolEnumToTextTranslated(E_Tools ETools, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "ToolEnumToTextTranslated");

	Params::BlueprintFunctionLibraryJP_C_ToolEnumToTextTranslated Parms{};

	Parms.ETools = ETools;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.TraceForHit
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   SphereRadius                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Range                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TraceFromLocation                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         TraceRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           Owner                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<struct FHitResult>               AcceptedHits                                           (Parm, OutParm, ContainsInstancedReference)

void UBlueprintFunctionLibraryJP_C::TraceForHit(float SphereRadius, double Range, const struct FVector& TraceFromLocation, const struct FRotator& TraceRotation, class AActor* Owner, class UObject* __WorldContext, TArray<struct FHitResult>* AcceptedHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "TraceForHit");

	Params::BlueprintFunctionLibraryJP_C_TraceForHit Parms{};

	Parms.SphereRadius = SphereRadius;
	Parms.Range = Range;
	Parms.TraceFromLocation = std::move(TraceFromLocation);
	Parms.TraceRotation = std::move(TraceRotation);
	Parms.Owner = Owner;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AcceptedHits != nullptr)
		*AcceptedHits = std::move(Parms.AcceptedHits);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.TraceForHitWithInterface
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  Range                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Width                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Height                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  TraceHightOffset                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TraceFromLocation                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         TraceRotation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           Owner                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TSubclassOf<class IInterface>           Interface                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// bool                                    Debug                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OwningActorShield                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IgnoreTeammates                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// TArray<struct FHitResult>               AcceptedHits                                           (Parm, OutParm, ContainsInstancedReference)
// bool                                    NoHits                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    OnlyHitWorldStatic                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       InitialTraceHit                                        (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UBlueprintFunctionLibraryJP_C::TraceForHitWithInterface(double Range, double Width, double Height, double TraceHightOffset, const struct FVector& TraceFromLocation, const struct FRotator& TraceRotation, class AActor* Owner, TSubclassOf<class IInterface> Interface, bool Debug, class AActor* OwningActorShield, bool IgnoreTeammates, class UObject* __WorldContext, TArray<struct FHitResult>* AcceptedHits, bool* NoHits, bool* OnlyHitWorldStatic, struct FHitResult* InitialTraceHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "TraceForHitWithInterface");

	Params::BlueprintFunctionLibraryJP_C_TraceForHitWithInterface Parms{};

	Parms.Range = Range;
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.TraceHightOffset = TraceHightOffset;
	Parms.TraceFromLocation = std::move(TraceFromLocation);
	Parms.TraceRotation = std::move(TraceRotation);
	Parms.Owner = Owner;
	Parms.Interface = Interface;
	Parms.Debug = Debug;
	Parms.OwningActorShield = OwningActorShield;
	Parms.IgnoreTeammates = IgnoreTeammates;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AcceptedHits != nullptr)
		*AcceptedHits = std::move(Parms.AcceptedHits);

	if (NoHits != nullptr)
		*NoHits = Parms.NoHits;

	if (OnlyHitWorldStatic != nullptr)
		*OnlyHitWorldStatic = Parms.OnlyHitWorldStatic;

	if (InitialTraceHit != nullptr)
		*InitialTraceHit = std::move(Parms.InitialTraceHit);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.TriggerOverlaps
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              ComponentToCheckOverlaps                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::TriggerOverlaps(class UPrimitiveComponent* ComponentToCheckOverlaps, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "TriggerOverlaps");

	Params::BlueprintFunctionLibraryJP_C_TriggerOverlaps Parms{};

	Parms.ComponentToCheckOverlaps = ComponentToCheckOverlaps;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.WrapValue
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Min                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Max                                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

int32 UBlueprintFunctionLibraryJP_C::WrapValue(int32 Value, int32 Min, int32 Max, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP_C", "WrapValue");

	Params::BlueprintFunctionLibraryJP_C_WrapValue Parms{};

	Parms.Value = Value;
	Parms.Min = Min;
	Parms.Max = Max;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.ConvertLevelNameToFriendlyName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FString                           MapName                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class FText                             Return                                                 (Parm, OutParm)

void UBlueprintFunctionLibraryJP_C::ConvertLevelNameToFriendlyName(const class FString& MapName, class UObject* __WorldContext, class FText* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlueprintFunctionLibraryJP_C", "ConvertLevelNameToFriendlyName");

	Params::BlueprintFunctionLibraryJP_C_ConvertLevelNameToFriendlyName Parms{};

	Parms.MapName = std::move(MapName);
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = std::move(Parms.Return);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetTeamIDFromPawn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class APawn*                            Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

uint8 UBlueprintFunctionLibraryJP_C::GetTeamIDFromPawn(class APawn* Target, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlueprintFunctionLibraryJP_C", "GetTeamIDFromPawn");

	Params::BlueprintFunctionLibraryJP_C_GetTeamIDFromPawn Parms{};

	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.SpawnDamageValue
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// double                                  IncomingHealthDelta                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          WorldLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AController*                      Instigator                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UBlueprintFunctionLibraryJP_C::SpawnDamageValue(double IncomingHealthDelta, const struct FVector& WorldLocation, class AController* Instigator, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlueprintFunctionLibraryJP_C", "SpawnDamageValue");

	Params::BlueprintFunctionLibraryJP_C_SpawnDamageValue Parms{};

	Parms.IncomingHealthDelta = IncomingHealthDelta;
	Parms.WorldLocation = std::move(WorldLocation);
	Parms.Instigator = Instigator;
	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BlueprintFunctionLibraryJP.BlueprintFunctionLibraryJP_C.GetServerWorldTimeSafe
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double UBlueprintFunctionLibraryJP_C::GetServerWorldTimeSafe(class UObject* __WorldContext) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BlueprintFunctionLibraryJP_C", "GetServerWorldTimeSafe");

	Params::BlueprintFunctionLibraryJP_C_GetServerWorldTimeSafe Parms{};

	Parms.__WorldContext = __WorldContext;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

