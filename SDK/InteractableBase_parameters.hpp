#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InteractableBase

#include "Basic.hpp"

#include "SlateCore_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"


namespace SDK::Params
{

// Function InteractableBase.InteractableBase_C.CancelInteraction
// 0x0008 (0x0008 - 0x0000)
struct InteractableBase_C_CancelInteraction final
{
public:
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_CancelInteraction) == 0x000008, "Wrong alignment on InteractableBase_C_CancelInteraction");
static_assert(sizeof(InteractableBase_C_CancelInteraction) == 0x000008, "Wrong size on InteractableBase_C_CancelInteraction");
static_assert(offsetof(InteractableBase_C_CancelInteraction, InteractionComponent) == 0x000000, "Member 'InteractableBase_C_CancelInteraction::InteractionComponent' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.ExecuteUbergraph_InteractableBase
// 0x00A0 (0x00A0 - 0x0000)
struct InteractableBase_C_ExecuteUbergraph_InteractableBase final
{
public:
	int32                                         EntryPoint;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 K2Node_Event_InteractingActor;                     // 0x0008(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    K2Node_Event_InteractionComponent;                 // 0x0010(0x0008)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    K2Node_Event_InteractionComponent_5;               // 0x0018(0x0008)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    K2Node_Event_InteractionComponent_4;               // 0x0020(0x0008)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 K2Node_Event_InteractingActor_5;                   // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    K2Node_Event_InteractionComponent_3;               // 0x0030(0x0008)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    K2Node_Event_InteractionComponent_2;               // 0x0038(0x0008)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 K2Node_Event_InteractingActor_4;                   // 0x0040(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    K2Node_Event_InteractionComponent_1;               // 0x0048(0x0008)(ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 K2Node_Event_InteractingActor_3;                   // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 K2Node_Event_InteractingActor_2;                   // 0x0058(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 K2Node_Event_InteractingActor_1;                   // 0x0060(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 K2Node_Event_Focusing_Actor;                       // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_CustomEvent_InFocus;                        // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 K2Node_CustomEvent_InteractingActor;               // 0x0078(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	TDelegate<void()>                             K2Node_CreateDelegate_OutputDelegate;              // 0x0080(0x0010)(ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	struct FTimerHandle                           CallFunc_K2_SetTimerDelegate_ReturnValue;          // 0x0090(0x0008)(NoDestructor, HasGetValueTypeHash)
	bool                                          CallFunc_HasAuthority_ReturnValue;                 // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_Event_Interactable;                         // 0x0099(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_CustomEvent_Interactable;                   // 0x009A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          K2Node_CustomEvent_Visibility;                     // 0x009B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CallFunc_K2_SetTimerDelegate_Time_ImplicitCast;    // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_ExecuteUbergraph_InteractableBase) == 0x000008, "Wrong alignment on InteractableBase_C_ExecuteUbergraph_InteractableBase");
static_assert(sizeof(InteractableBase_C_ExecuteUbergraph_InteractableBase) == 0x0000A0, "Wrong size on InteractableBase_C_ExecuteUbergraph_InteractableBase");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, EntryPoint) == 0x000000, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::EntryPoint' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractingActor) == 0x000008, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractingActor' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractionComponent) == 0x000010, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractionComponent' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractionComponent_5) == 0x000018, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractionComponent_5' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractionComponent_4) == 0x000020, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractionComponent_4' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractingActor_5) == 0x000028, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractingActor_5' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractionComponent_3) == 0x000030, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractionComponent_3' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractionComponent_2) == 0x000038, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractionComponent_2' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractingActor_4) == 0x000040, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractingActor_4' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractionComponent_1) == 0x000048, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractionComponent_1' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractingActor_3) == 0x000050, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractingActor_3' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractingActor_2) == 0x000058, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractingActor_2' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_InteractingActor_1) == 0x000060, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_InteractingActor_1' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_Focusing_Actor) == 0x000068, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_Focusing_Actor' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_CustomEvent_InFocus) == 0x000070, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_CustomEvent_InFocus' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_CustomEvent_InteractingActor) == 0x000078, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_CustomEvent_InteractingActor' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_CreateDelegate_OutputDelegate) == 0x000080, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_CreateDelegate_OutputDelegate' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, CallFunc_K2_SetTimerDelegate_ReturnValue) == 0x000090, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::CallFunc_K2_SetTimerDelegate_ReturnValue' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, CallFunc_HasAuthority_ReturnValue) == 0x000098, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::CallFunc_HasAuthority_ReturnValue' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_Event_Interactable) == 0x000099, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_Event_Interactable' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_CustomEvent_Interactable) == 0x00009A, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_CustomEvent_Interactable' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, K2Node_CustomEvent_Visibility) == 0x00009B, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::K2Node_CustomEvent_Visibility' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_ExecuteUbergraph_InteractableBase, CallFunc_K2_SetTimerDelegate_Time_ImplicitCast) == 0x00009C, "Member 'InteractableBase_C_ExecuteUbergraph_InteractableBase::CallFunc_K2_SetTimerDelegate_Time_ImplicitCast' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.GetNewWidgetColor
// 0x0028 (0x0028 - 0x0000)
struct InteractableBase_C_GetNewWidgetColor final
{
public:
	struct FSlateColor                            NewColor;                                          // 0x0000(0x0014)(Parm, OutParm)
	struct FSlateColor                            K2Node_MakeStruct_SlateColor;                      // 0x0014(0x0014)()
};
static_assert(alignof(InteractableBase_C_GetNewWidgetColor) == 0x000004, "Wrong alignment on InteractableBase_C_GetNewWidgetColor");
static_assert(sizeof(InteractableBase_C_GetNewWidgetColor) == 0x000028, "Wrong size on InteractableBase_C_GetNewWidgetColor");
static_assert(offsetof(InteractableBase_C_GetNewWidgetColor, NewColor) == 0x000000, "Member 'InteractableBase_C_GetNewWidgetColor::NewColor' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetNewWidgetColor, K2Node_MakeStruct_SlateColor) == 0x000014, "Member 'InteractableBase_C_GetNewWidgetColor::K2Node_MakeStruct_SlateColor' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.GetOptionalText
// 0x0030 (0x0030 - 0x0000)
struct InteractableBase_C_GetOptionalText final
{
public:
	class FText                                   Return;                                            // 0x0000(0x0010)(Parm, OutParm)
	class FText                                   Optional_Second_Line;                              // 0x0010(0x0010)(Parm, OutParm)
	class FText                                   CallFunc_GetEmptyText_ReturnValue;                 // 0x0020(0x0010)()
};
static_assert(alignof(InteractableBase_C_GetOptionalText) == 0x000008, "Wrong alignment on InteractableBase_C_GetOptionalText");
static_assert(sizeof(InteractableBase_C_GetOptionalText) == 0x000030, "Wrong size on InteractableBase_C_GetOptionalText");
static_assert(offsetof(InteractableBase_C_GetOptionalText, Return) == 0x000000, "Member 'InteractableBase_C_GetOptionalText::Return' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetOptionalText, Optional_Second_Line) == 0x000010, "Member 'InteractableBase_C_GetOptionalText::Optional_Second_Line' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetOptionalText, CallFunc_GetEmptyText_ReturnValue) == 0x000020, "Member 'InteractableBase_C_GetOptionalText::CallFunc_GetEmptyText_ReturnValue' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.GetPriority
// 0x0004 (0x0004 - 0x0000)
struct InteractableBase_C_GetPriority final
{
public:
	int32                                         Priority_0;                                        // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_GetPriority) == 0x000004, "Wrong alignment on InteractableBase_C_GetPriority");
static_assert(sizeof(InteractableBase_C_GetPriority) == 0x000004, "Wrong size on InteractableBase_C_GetPriority");
static_assert(offsetof(InteractableBase_C_GetPriority, Priority_0) == 0x000000, "Member 'InteractableBase_C_GetPriority::Priority_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.GetWidgetLocation
// 0x0030 (0x0030 - 0x0000)
struct InteractableBase_C_GetWidgetLocation final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x0018)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                CallFunc_K2_GetComponentLocation_ReturnValue;      // 0x0018(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_GetWidgetLocation) == 0x000008, "Wrong alignment on InteractableBase_C_GetWidgetLocation");
static_assert(sizeof(InteractableBase_C_GetWidgetLocation) == 0x000030, "Wrong size on InteractableBase_C_GetWidgetLocation");
static_assert(offsetof(InteractableBase_C_GetWidgetLocation, Location) == 0x000000, "Member 'InteractableBase_C_GetWidgetLocation::Location' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetWidgetLocation, CallFunc_K2_GetComponentLocation_ReturnValue) == 0x000018, "Member 'InteractableBase_C_GetWidgetLocation::CallFunc_K2_GetComponentLocation_ReturnValue' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.HideInteractionWidget
// 0x0001 (0x0001 - 0x0000)
struct InteractableBase_C_HideInteractionWidget final
{
public:
	bool                                          Return;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_HideInteractionWidget) == 0x000001, "Wrong alignment on InteractableBase_C_HideInteractionWidget");
static_assert(sizeof(InteractableBase_C_HideInteractionWidget) == 0x000001, "Wrong size on InteractableBase_C_HideInteractionWidget");
static_assert(offsetof(InteractableBase_C_HideInteractionWidget, Return) == 0x000000, "Member 'InteractableBase_C_HideInteractionWidget::Return' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.Interact Pressed Succes
// 0x0008 (0x0008 - 0x0000)
struct InteractableBase_C_Interact_Pressed_Succes final
{
public:
	class AActor*                                 InteractingActor_0;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_Interact_Pressed_Succes) == 0x000008, "Wrong alignment on InteractableBase_C_Interact_Pressed_Succes");
static_assert(sizeof(InteractableBase_C_Interact_Pressed_Succes) == 0x000008, "Wrong size on InteractableBase_C_Interact_Pressed_Succes");
static_assert(offsetof(InteractableBase_C_Interact_Pressed_Succes, InteractingActor_0) == 0x000000, "Member 'InteractableBase_C_Interact_Pressed_Succes::InteractingActor_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.Interactable Cosmetics
// 0x0001 (0x0001 - 0x0000)
struct InteractableBase_C_Interactable_Cosmetics final
{
public:
	bool                                          Interactable_0;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_Interactable_Cosmetics) == 0x000001, "Wrong alignment on InteractableBase_C_Interactable_Cosmetics");
static_assert(sizeof(InteractableBase_C_Interactable_Cosmetics) == 0x000001, "Wrong size on InteractableBase_C_Interactable_Cosmetics");
static_assert(offsetof(InteractableBase_C_Interactable_Cosmetics, Interactable_0) == 0x000000, "Member 'InteractableBase_C_Interactable_Cosmetics::Interactable_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.Interactable In Focus
// 0x0001 (0x0001 - 0x0000)
struct InteractableBase_C_Interactable_In_Focus final
{
public:
	bool                                          InFocus;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_Interactable_In_Focus) == 0x000001, "Wrong alignment on InteractableBase_C_Interactable_In_Focus");
static_assert(sizeof(InteractableBase_C_Interactable_In_Focus) == 0x000001, "Wrong size on InteractableBase_C_Interactable_In_Focus");
static_assert(offsetof(InteractableBase_C_Interactable_In_Focus, InFocus) == 0x000000, "Member 'InteractableBase_C_Interactable_In_Focus::InFocus' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.InteractableCancelInteraction
// 0x0008 (0x0008 - 0x0000)
struct InteractableBase_C_InteractableCancelInteraction final
{
public:
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_InteractableCancelInteraction) == 0x000008, "Wrong alignment on InteractableBase_C_InteractableCancelInteraction");
static_assert(sizeof(InteractableBase_C_InteractableCancelInteraction) == 0x000008, "Wrong size on InteractableBase_C_InteractableCancelInteraction");
static_assert(offsetof(InteractableBase_C_InteractableCancelInteraction, InteractionComponent) == 0x000000, "Member 'InteractableBase_C_InteractableCancelInteraction::InteractionComponent' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.InteractPressed
// 0x0008 (0x0008 - 0x0000)
struct InteractableBase_C_InteractPressed final
{
public:
	class AActor*                                 InteractingActor_0;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_InteractPressed) == 0x000008, "Wrong alignment on InteractableBase_C_InteractPressed");
static_assert(sizeof(InteractableBase_C_InteractPressed) == 0x000008, "Wrong size on InteractableBase_C_InteractPressed");
static_assert(offsetof(InteractableBase_C_InteractPressed, InteractingActor_0) == 0x000000, "Member 'InteractableBase_C_InteractPressed::InteractingActor_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.InteractReleased
// 0x0008 (0x0008 - 0x0000)
struct InteractableBase_C_InteractReleased final
{
public:
	class AActor*                                 InteractingActor_0;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_InteractReleased) == 0x000008, "Wrong alignment on InteractableBase_C_InteractReleased");
static_assert(sizeof(InteractableBase_C_InteractReleased) == 0x000008, "Wrong size on InteractableBase_C_InteractReleased");
static_assert(offsetof(InteractableBase_C_InteractReleased, InteractingActor_0) == 0x000000, "Member 'InteractableBase_C_InteractReleased::InteractingActor_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.IsInFocus
// 0x0008 (0x0008 - 0x0000)
struct InteractableBase_C_IsInFocus final
{
public:
	class AActor*                                 Focusing_Actor;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_IsInFocus) == 0x000008, "Wrong alignment on InteractableBase_C_IsInFocus");
static_assert(sizeof(InteractableBase_C_IsInFocus) == 0x000008, "Wrong size on InteractableBase_C_IsInFocus");
static_assert(offsetof(InteractableBase_C_IsInFocus, Focusing_Actor) == 0x000000, "Member 'InteractableBase_C_IsInFocus::Focusing_Actor' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.IsInteractable
// 0x0001 (0x0001 - 0x0000)
struct InteractableBase_C_IsInteractable final
{
public:
	bool                                          Interactable_0;                                    // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_IsInteractable) == 0x000001, "Wrong alignment on InteractableBase_C_IsInteractable");
static_assert(sizeof(InteractableBase_C_IsInteractable) == 0x000001, "Wrong size on InteractableBase_C_IsInteractable");
static_assert(offsetof(InteractableBase_C_IsInteractable, Interactable_0) == 0x000000, "Member 'InteractableBase_C_IsInteractable::Interactable_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.PostInteract
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_PostInteract final
{
public:
	class AActor*                                 InteractingActor_0;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_PostInteract) == 0x000008, "Wrong alignment on InteractableBase_C_PostInteract");
static_assert(sizeof(InteractableBase_C_PostInteract) == 0x000010, "Wrong size on InteractableBase_C_PostInteract");
static_assert(offsetof(InteractableBase_C_PostInteract, InteractingActor_0) == 0x000000, "Member 'InteractableBase_C_PostInteract::InteractingActor_0' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_PostInteract, InteractionComponent) == 0x000008, "Member 'InteractableBase_C_PostInteract::InteractionComponent' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.PreInteract
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_PreInteract final
{
public:
	class AActor*                                 InteractingActor_0;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_PreInteract) == 0x000008, "Wrong alignment on InteractableBase_C_PreInteract");
static_assert(sizeof(InteractableBase_C_PreInteract) == 0x000010, "Wrong size on InteractableBase_C_PreInteract");
static_assert(offsetof(InteractableBase_C_PreInteract, InteractingActor_0) == 0x000000, "Member 'InteractableBase_C_PreInteract::InteractingActor_0' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_PreInteract, InteractionComponent) == 0x000008, "Member 'InteractableBase_C_PreInteract::InteractionComponent' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.RegisterInteracter
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_RegisterInteracter final
{
public:
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 InteractingActor_0;                                // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_RegisterInteracter) == 0x000008, "Wrong alignment on InteractableBase_C_RegisterInteracter");
static_assert(sizeof(InteractableBase_C_RegisterInteracter) == 0x000010, "Wrong size on InteractableBase_C_RegisterInteracter");
static_assert(offsetof(InteractableBase_C_RegisterInteracter, InteractionComponent) == 0x000000, "Member 'InteractableBase_C_RegisterInteracter::InteractionComponent' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_RegisterInteracter, InteractingActor_0) == 0x000008, "Member 'InteractableBase_C_RegisterInteracter::InteractingActor_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.ReloadAfterHousesLoaded
// 0x0001 (0x0001 - 0x0000)
struct InteractableBase_C_ReloadAfterHousesLoaded final
{
public:
	bool                                          Return;                                            // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_ReloadAfterHousesLoaded) == 0x000001, "Wrong alignment on InteractableBase_C_ReloadAfterHousesLoaded");
static_assert(sizeof(InteractableBase_C_ReloadAfterHousesLoaded) == 0x000001, "Wrong size on InteractableBase_C_ReloadAfterHousesLoaded");
static_assert(offsetof(InteractableBase_C_ReloadAfterHousesLoaded, Return) == 0x000000, "Member 'InteractableBase_C_ReloadAfterHousesLoaded::Return' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.Set Interact Visibility
// 0x0001 (0x0001 - 0x0000)
struct InteractableBase_C_Set_Interact_Visibility final
{
public:
	bool                                          Visibility;                                        // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_Set_Interact_Visibility) == 0x000001, "Wrong alignment on InteractableBase_C_Set_Interact_Visibility");
static_assert(sizeof(InteractableBase_C_Set_Interact_Visibility) == 0x000001, "Wrong size on InteractableBase_C_Set_Interact_Visibility");
static_assert(offsetof(InteractableBase_C_Set_Interact_Visibility, Visibility) == 0x000000, "Member 'InteractableBase_C_Set_Interact_Visibility::Visibility' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.SetHoveredComponent
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_SetHoveredComponent final
{
public:
	class UInteractionComponent_C*                HoveredComponent;                                  // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          Void;                                              // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_SetHoveredComponent) == 0x000008, "Wrong alignment on InteractableBase_C_SetHoveredComponent");
static_assert(sizeof(InteractableBase_C_SetHoveredComponent) == 0x000010, "Wrong size on InteractableBase_C_SetHoveredComponent");
static_assert(offsetof(InteractableBase_C_SetHoveredComponent, HoveredComponent) == 0x000000, "Member 'InteractableBase_C_SetHoveredComponent::HoveredComponent' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_SetHoveredComponent, Void) == 0x000008, "Member 'InteractableBase_C_SetHoveredComponent::Void' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.SetInteractable
// 0x0001 (0x0001 - 0x0000)
struct InteractableBase_C_SetInteractable final
{
public:
	bool                                          Interactable_0;                                    // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_SetInteractable) == 0x000001, "Wrong alignment on InteractableBase_C_SetInteractable");
static_assert(sizeof(InteractableBase_C_SetInteractable) == 0x000001, "Wrong size on InteractableBase_C_SetInteractable");
static_assert(offsetof(InteractableBase_C_SetInteractable, Interactable_0) == 0x000000, "Member 'InteractableBase_C_SetInteractable::Interactable_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.UnregisterInteracter
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_UnregisterInteracter final
{
public:
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	class AActor*                                 InteractingActor_0;                                // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_UnregisterInteracter) == 0x000008, "Wrong alignment on InteractableBase_C_UnregisterInteracter");
static_assert(sizeof(InteractableBase_C_UnregisterInteracter) == 0x000010, "Wrong size on InteractableBase_C_UnregisterInteracter");
static_assert(offsetof(InteractableBase_C_UnregisterInteracter, InteractionComponent) == 0x000000, "Member 'InteractableBase_C_UnregisterInteracter::InteractionComponent' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_UnregisterInteracter, InteractingActor_0) == 0x000008, "Member 'InteractableBase_C_UnregisterInteracter::InteractingActor_0' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.GetInteractionDuration
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_GetInteractionDuration final
{
public:
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_GetInteractionDuration) == 0x000008, "Wrong alignment on InteractableBase_C_GetInteractionDuration");
static_assert(sizeof(InteractableBase_C_GetInteractionDuration) == 0x000010, "Wrong size on InteractableBase_C_GetInteractionDuration");
static_assert(offsetof(InteractableBase_C_GetInteractionDuration, InteractionComponent) == 0x000000, "Member 'InteractableBase_C_GetInteractionDuration::InteractionComponent' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetInteractionDuration, ReturnValue) == 0x000008, "Member 'InteractableBase_C_GetInteractionDuration::ReturnValue' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.GetPostInteractSyncType
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_GetPostInteractSyncType final
{
public:
	bool                                          bShouldSync;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EAbilityTaskNetSyncType                       Type;                                              // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_GetPostInteractSyncType) == 0x000008, "Wrong alignment on InteractableBase_C_GetPostInteractSyncType");
static_assert(sizeof(InteractableBase_C_GetPostInteractSyncType) == 0x000010, "Wrong size on InteractableBase_C_GetPostInteractSyncType");
static_assert(offsetof(InteractableBase_C_GetPostInteractSyncType, bShouldSync) == 0x000000, "Member 'InteractableBase_C_GetPostInteractSyncType::bShouldSync' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetPostInteractSyncType, Type) == 0x000001, "Member 'InteractableBase_C_GetPostInteractSyncType::Type' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetPostInteractSyncType, InteractionComponent) == 0x000008, "Member 'InteractableBase_C_GetPostInteractSyncType::InteractionComponent' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.GetPreInteractSyncType
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_GetPreInteractSyncType final
{
public:
	bool                                          bShouldSync;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	EAbilityTaskNetSyncType                       Type;                                              // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_GetPreInteractSyncType) == 0x000008, "Wrong alignment on InteractableBase_C_GetPreInteractSyncType");
static_assert(sizeof(InteractableBase_C_GetPreInteractSyncType) == 0x000010, "Wrong size on InteractableBase_C_GetPreInteractSyncType");
static_assert(offsetof(InteractableBase_C_GetPreInteractSyncType, bShouldSync) == 0x000000, "Member 'InteractableBase_C_GetPreInteractSyncType::bShouldSync' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetPreInteractSyncType, Type) == 0x000001, "Member 'InteractableBase_C_GetPreInteractSyncType::Type' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_GetPreInteractSyncType, InteractionComponent) == 0x000008, "Member 'InteractableBase_C_GetPreInteractSyncType::InteractionComponent' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.IsAvailableForEnemyTeam
// 0x0010 (0x0010 - 0x0000)
struct InteractableBase_C_IsAvailableForEnemyTeam final
{
public:
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_IsAvailableForEnemyTeam) == 0x000008, "Wrong alignment on InteractableBase_C_IsAvailableForEnemyTeam");
static_assert(sizeof(InteractableBase_C_IsAvailableForEnemyTeam) == 0x000010, "Wrong size on InteractableBase_C_IsAvailableForEnemyTeam");
static_assert(offsetof(InteractableBase_C_IsAvailableForEnemyTeam, InteractionComponent) == 0x000000, "Member 'InteractableBase_C_IsAvailableForEnemyTeam::InteractionComponent' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_IsAvailableForEnemyTeam, ReturnValue) == 0x000008, "Member 'InteractableBase_C_IsAvailableForEnemyTeam::ReturnValue' has a wrong offset!");

// Function InteractableBase.InteractableBase_C.IsAvailableForInteraction
// 0x0018 (0x0018 - 0x0000)
struct InteractableBase_C_IsAvailableForInteraction final
{
public:
	class AActor*                                 InteractingActor_0;                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
	class UPrimitiveComponent*                    InteractionComponent;                              // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
};
static_assert(alignof(InteractableBase_C_IsAvailableForInteraction) == 0x000008, "Wrong alignment on InteractableBase_C_IsAvailableForInteraction");
static_assert(sizeof(InteractableBase_C_IsAvailableForInteraction) == 0x000018, "Wrong size on InteractableBase_C_IsAvailableForInteraction");
static_assert(offsetof(InteractableBase_C_IsAvailableForInteraction, InteractingActor_0) == 0x000000, "Member 'InteractableBase_C_IsAvailableForInteraction::InteractingActor_0' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_IsAvailableForInteraction, InteractionComponent) == 0x000008, "Member 'InteractableBase_C_IsAvailableForInteraction::InteractionComponent' has a wrong offset!");
static_assert(offsetof(InteractableBase_C_IsAvailableForInteraction, ReturnValue) == 0x000010, "Member 'InteractableBase_C_IsAvailableForInteraction::ReturnValue' has a wrong offset!");

}

