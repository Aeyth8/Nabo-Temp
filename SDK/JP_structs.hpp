#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JP

#include "Basic.hpp"

#include "NetCore_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "CommonInput_structs.hpp"
#include "IWCore_structs.hpp"
#include "GameplayAbilities_structs.hpp"
#include "SlateCore_structs.hpp"
#include "GASIW_structs.hpp"

#undef ERROR

namespace SDK
{

// Enum JP.ECharacterRole
// NumValues: 0x0007
enum class ECharacterRole : uint8
{
	None                                     = 0,
	Gardener                                 = 1,
	Cook                                     = 2,
	Carpenter                                = 3,
	Mechanic                                 = 4,
	Maid                                     = 5,
	ECharacterRole_MAX                       = 6,
};

// Enum JP.ECharacterName
// NumValues: 0x000C
enum class ECharacterName : uint8
{
	None                                     = 0,
	Chad                                     = 1,
	Gramps                                   = 2,
	Doreen                                   = 3,
	Kim                                      = 4,
	Louie                                    = 5,
	Kevin                                    = 6,
	Mary                                     = 7,
	PerArne                                  = 8,
	Stacy                                    = 9,
	Cookie                                   = 10,
	ECharacterName_MAX                       = 11,
};

// Enum JP.EJPOnJoinSessionCompleteResult
// NumValues: 0x0007
enum class EJPOnJoinSessionCompleteResult : uint8
{
	Success                                  = 0,
	SessionIsFull                            = 1,
	SessionDoesNotExist                      = 2,
	CouldNotRetrieveAddress                  = 3,
	AlreadyInSession                         = 4,
	UnknownError                             = 5,
	EJPOnJoinSessionCompleteResult_MAX       = 6,
};

// Enum JP.EOnlineItemUnlockRequirement
// NumValues: 0x0004
enum class EOnlineItemUnlockRequirement : uint8
{
	None                                     = 0,
	VirtualCurrency                          = 1,
	BattlePass                               = 2,
	EOnlineItemUnlockRequirement_MAX         = 3,
};

// Enum JP.EShopItemCategory
// NumValues: 0x0005
enum class EShopItemCategory : uint8
{
	Offense                                  = 0,
	Defense                                  = 1,
	Support                                  = 2,
	Delivery                                 = 3,
	EShopItemCategory_MAX                    = 4,
};

// Enum JP.ERegionOverride
// NumValues: 0x0009
enum class ERegionOverride : uint32
{
	Auto                                     = 0,
	WestEurope                               = 1,
	NorthEurope                              = 2,
	EastUs                                   = 3,
	WestUs                                   = 4,
	EastAsia                                 = 5,
	BrazilSouth                              = 6,
	AustraliaEast                            = 7,
	ERegionOverride_MAX                      = 8,
};

// Enum JP.ELyraDisplayablePerformanceStat
// NumValues: 0x0011
enum class ELyraDisplayablePerformanceStat : uint8
{
	ClientFPS                                = 0,
	ServerFPS                                = 1,
	IdleTime                                 = 2,
	FrameTime                                = 3,
	FrameTime_GameThread                     = 4,
	FrameTime_RenderThread                   = 5,
	FrameTime_RHIThread                      = 6,
	FrameTime_GPU                            = 7,
	Ping                                     = 8,
	PacketLoss_Incoming                      = 9,
	PacketLoss_Outgoing                      = 10,
	PacketRate_Incoming                      = 11,
	PacketRate_Outgoing                      = 12,
	PacketSize_Incoming                      = 13,
	PacketSize_Outgoing                      = 14,
	Count                                    = 15,
	ELyraDisplayablePerformanceStat_MAX      = 16,
};

// Enum JP.ELyraStatDisplayMode
// NumValues: 0x0005
enum class ELyraStatDisplayMode : uint8
{
	Hidden                                   = 0,
	TextOnly                                 = 1,
	GraphOnly                                = 2,
	TextAndGraph                             = 3,
	ELyraStatDisplayMode_MAX                 = 4,
};

// Enum JP.EAchievementStatUpdateMethod
// NumValues: 0x0003
enum class EAchievementStatUpdateMethod : uint8
{
	Sum                                      = 0,
	Highest                                  = 1,
	EAchievementStatUpdateMethod_MAX         = 2,
};

// Enum JP.EArithmeticOperators
// NumValues: 0x0005
enum class EArithmeticOperators : uint8
{
	Add                                      = 0,
	Subtract                                 = 1,
	Multiply                                 = 2,
	Divide                                   = 3,
	EArithmeticOperators_MAX                 = 4,
};

// Enum JP.ECharacterInput
// NumValues: 0x0005
enum class ECharacterInput : uint8
{
	None                                     = 0,
	PrimaryAction                            = 1,
	SecondaryAction                          = 2,
	Sprint                                   = 3,
	ECharacterInput_MAX                      = 4,
};

// Enum JP.ECharacterSize
// NumValues: 0x0006
enum class ECharacterSize : uint8
{
	None                                     = 0,
	Small                                    = 1,
	Medium                                   = 2,
	MediumLarge                              = 3,
	Large                                    = 4,
	ECharacterSize_MAX                       = 5,
};

// Enum JP.ECurrencies
// NumValues: 0x0003
enum class ECurrencies : uint8
{
	Money                                    = 0,
	Resources                                = 1,
	ECurrencies_MAX                          = 2,
};

// Enum JP.EDirectionAxis
// NumValues: 0x0005
enum class EDirectionAxis : uint8
{
	Up                                       = 0,
	Horizontal                               = 1,
	Down                                     = 2,
	Count                                    = 3,
	EDirectionAxis_MAX                       = 4,
};

// Enum JP.EDeathType
// NumValues: 0x0005
enum class EDeathType : uint8
{
	PlayerKnockedOutPlayer                   = 0,
	NonPlayerKnockedOutPlayer                = 1,
	PlayerDestroyedHouseEssential            = 2,
	None                                     = 3,
	EDeathType_MAX                           = 4,
};

// Enum JP.EGaitJP
// NumValues: 0x0007
enum class EGaitJP : uint8
{
	Walk                                     = 0,
	Run                                      = 1,
	Sprint                                   = 2,
	Crouch                                   = 3,
	Trapped                                  = 4,
	Count                                    = 5,
	EGaitJP_MAX                              = 6,
};

// Enum JP.EItemsJP
// NumValues: 0x0045
enum class EItemsJP : uint8
{
	Empty                                    = 0,
	Mop                                      = 1,
	FryingPan                                = 2,
	GolfClub                                 = 3,
	BaseballBat                              = 4,
	Egg                                      = 5,
	Tincan                                   = 6,
	Twohand                                  = 7,
	Singlehand                               = 8,
	Stick                                    = 9,
	Beartrap                                 = 10,
	OrangeCanon                              = 11,
	Lockpick                                 = 12,
	Mud                                      = 13,
	MasterVibrator                           = 14,
	HedgeTrimmer                             = 15,
	SabotageTool                             = 16,
	Wrench                                   = 17,
	WaterBucket                              = 18,
	RepairKit                                = 19,
	Pie                                      = 20,
	Shield                                   = 21,
	Slingshot                                = 22,
	BoxingGloves                             = 23,
	Medkit                                   = 24,
	PopGun                                   = 25,
	VacuumCleaner                            = 26,
	LeafBlower                               = 27,
	ChainHedgeTrimmer                        = 28,
	WaterPistol                              = 29,
	Binoculars                               = 30,
	WateringCan                              = 31,
	SpringTrap                               = 32,
	TrashBag                                 = 33,
	Barricade                                = 34,
	AlarmClock                               = 35,
	Branch                                   = 36,
	Apple                                    = 37,
	Tomato                                   = 38,
	Saw                                      = 39,
	Ladder                                   = 40,
	FireworkBox                              = 41,
	GrappleHook                              = 42,
	Hammer                                   = 43,
	BarbedWire                               = 44,
	Seagull130                               = 45,
	SeedPack                                 = 46,
	HouseAdditionDeployable                  = 47,
	ThrowableHands                           = 48,
	Umbrella                                 = 49,
	Rake                                     = 50,
	Banana                                   = 51,
	Carrot                                   = 52,
	Sledgehammer                             = 53,
	Knittingneedles                          = 54,
	Steak                                    = 55,
	Potato                                   = 56,
	PlungerGun                               = 57,
	ResourceCrate                            = 58,
	Firewood                                 = 59,
	Jetpack                                  = 60,
	Crowbar                                  = 61,
	Jackhammer                               = 62,
	Cane                                     = 63,
	RollingPin                               = 64,
	Iron                                     = 65,
	PAHelmet                                 = 66,
	Count                                    = 67,
	EItemsJP_MAX                             = 68,
};

// Enum JP.EStanceJP
// NumValues: 0x0004
enum class EStanceJP : uint8
{
	Standing                                 = 0,
	Crouching                                = 1,
	Count                                    = 2,
	EStanceJP_MAX                            = 3,
};

// Enum JP.EFacialStatesJP
// NumValues: 0x0009
enum class EFacialStatesJP : uint8
{
	Angry                                    = 0,
	Dead                                     = 1,
	Happy                                    = 2,
	Neutral                                  = 3,
	Pain                                     = 4,
	Sad                                      = 5,
	Surprise                                 = 6,
	Count                                    = 7,
	EFacialStatesJP_MAX                      = 8,
};

// Enum JP.EVoteState
// NumValues: 0x0004
enum class EVoteState : uint8
{
	NotStarted                               = 0,
	InProgress                               = 1,
	Finished                                 = 2,
	EVoteState_MAX                           = 3,
};

// Enum JP.EListenServerBackfillingState
// NumValues: 0x0007
enum class EListenServerBackfillingState : uint8
{
	None                                     = 0,
	StartingSearch                           = 1,
	Searching                                = 2,
	GettingMatch                             = 3,
	WaitingForPlayers                        = 4,
	MatchFull                                = 5,
	EListenServerBackfillingState_MAX        = 6,
};

// Enum JP.EDeadzoneStick
// NumValues: 0x0003
enum class EDeadzoneStick : uint8
{
	MoveStick                                = 0,
	LookStick                                = 1,
	EDeadzoneStick_MAX                       = 2,
};

// Enum JP.ELyraTargetingType
// NumValues: 0x0003
enum class ELyraTargetingType : uint8
{
	Normal                                   = 0,
	ADS                                      = 1,
	ELyraTargetingType_MAX                   = 2,
};

// Enum JP.ELyraPlaystationDPadButton
// NumValues: 0x0005
enum class ELyraPlaystationDPadButton : uint8
{
	Up                                       = 0,
	Down                                     = 1,
	Left                                     = 2,
	Right                                    = 3,
	ELyraPlaystationDPadButton_MAX           = 4,
};

// Enum JP.EColorBlindMode
// NumValues: 0x0005
enum class EColorBlindMode : uint8
{
	Off                                      = 0,
	Deuteranope                              = 1,
	Protanope                                = 2,
	Tritanope                                = 3,
	EColorBlindMode_MAX                      = 4,
};

// Enum JP.ELyraAllowBackgroundAudioSetting
// NumValues: 0x0004
enum class ELyraAllowBackgroundAudioSetting : uint8
{
	Off                                      = 0,
	AllSounds                                = 1,
	Num                                      = 2,
	ELyraAllowBackgroundAudioSetting_MAX     = 3,
};

// Enum JP.ELyraGamepadSensitivity
// NumValues: 0x000C
enum class ELyraGamepadSensitivity : uint8
{
	Invalid                                  = 0,
	Slow                                     = 1,
	SlowPlus                                 = 2,
	SlowPlusPlus                             = 3,
	Normal                                   = 4,
	NormalPlus                               = 5,
	NormalPlusPlus                           = 6,
	Fast                                     = 7,
	FastPlus                                 = 8,
	FastPlusPlus                             = 9,
	Insane                                   = 10,
	MAX                                      = 11,
};

// Enum JP.EMessageType
// NumValues: 0x0002
enum class EMessageType : uint8
{
	All                                      = 0,
	EMessageType_MAX                         = 1,
};

// Enum JP.EMusicStates
// NumValues: 0x0006
enum class EMusicStates : uint8
{
	NoMusic                                  = 0,
	Day                                      = 1,
	Night                                    = 2,
	SuddenDeath                              = 3,
	Combat                                   = 4,
	EMusicStates_MAX                         = 5,
};

// Enum JP.EObjectiveState
// NumValues: 0x0004
enum class EObjectiveState : uint8
{
	None                                     = 0,
	InProgress                               = 1,
	Finished                                 = 2,
	EObjectiveState_MAX                      = 3,
};

// Enum JP.EOnlineServicesBooleanQuerySetting
// NumValues: 0x0004
enum class EOnlineServicesBooleanQuerySetting : uint8
{
	Disabled                                 = 0,
	EqualsTrue                               = 1,
	EqualsFalse                              = 2,
	EOnlineServicesBooleanQuerySetting_MAX   = 3,
};

// Enum JP.EOnlineServicesFriendStatus
// NumValues: 0x0006
enum class EOnlineServicesFriendStatus : uint8
{
	None                                     = 0,
	Offline                                  = 1,
	Online                                   = 2,
	PlayingOtherGame                         = 3,
	PlayingJP                                = 4,
	EOnlineServicesFriendStatus_MAX          = 5,
};

// Enum JP.EOnlineServicesInviteStatus
// NumValues: 0x0007
enum class EOnlineServicesInviteStatus : uint8
{
	Unknown                                  = 0,
	Accepted                                 = 1,
	PendingInbound                           = 2,
	PendingOutbound                          = 3,
	Blocked                                  = 4,
	Suggested                                = 5,
	EOnlineServicesInviteStatus_MAX          = 6,
};

// Enum JP.EPartyMatchState
// NumValues: 0x0007
enum class EPartyMatchState : uint8
{
	None                                     = 0,
	InLobby                                  = 1,
	LeavingLobby                             = 2,
	InMatch                                  = 3,
	LeavingMatch                             = 4,
	PostMatch                                = 5,
	EPartyMatchState_MAX                     = 6,
};

// Enum JP.EPerkCategories
// NumValues: 0x0005
enum class EPerkCategories : uint8
{
	None                                     = 0,
	Offense                                  = 1,
	Defense                                  = 2,
	Maintenance                              = 3,
	EPerkCategories_MAX                      = 4,
};

// Enum JP.MessageCategory
// NumValues: 0x0007
enum class EMessageCategory : uint8
{
	General                                  = 0,
	Item                                     = 1,
	Warning                                  = 2,
	Event                                    = 3,
	Trap                                     = 4,
	DeleteInAllCategories                    = 5,
	MessageCategory_MAX                      = 6,
};

// Enum JP.MessageRecipient
// NumValues: 0x0005
enum class EMessageRecipient : uint8
{
	PlayerOnly                               = 0,
	PlayersTeam                              = 1,
	EnemyTeam                                = 2,
	EveryPlayer                              = 3,
	MessageRecipient_MAX                     = 4,
};

// Enum JP.ERequestedSpawnType
// NumValues: 0x0005
enum class ERequestedSpawnType : uint8
{
	None                                     = 0,
	Home                                     = 1,
	BusStop                                  = 2,
	FrontYard                                = 3,
	ERequestedSpawnType_MAX                  = 4,
};

// Enum JP.EPlayerStateJoinStatus
// NumValues: 0x0004
enum class EPlayerStateJoinStatus : uint8
{
	NotJoined                                = 0,
	PendingConfirm                           = 1,
	ClearedToJoin                            = 2,
	EPlayerStateJoinStatus_MAX               = 3,
};

// Enum JP.EPreLobbyServerBrowserListSortMode
// NumValues: 0x0007
enum class EPreLobbyServerBrowserListSortMode : uint8
{
	NAME                                     = 0,
	NUM_PLAYERS_ASC                          = 1,
	NUM_PLAYERS_DESC                         = 2,
	GAMEMODE                                 = 3,
	COUNT                                    = 4,
	PASSWORD                                 = 5,
	EPreLobbyServerBrowserListSortMode_MAX   = 6,
};

// Enum JP.EPreLobbyServerBrowserState
// NumValues: 0x0005
enum class EPreLobbyServerBrowserState : uint8
{
	LOADING                                  = 0,
	LIST                                     = 1,
	ERROR                                    = 2,
	EMPTY                                    = 3,
	EPreLobbyServerBrowserState_MAX          = 4,
};

// Enum JP.EReceptacleType
// NumValues: 0x0016
enum class EReceptacleType : uint8
{
	None                                     = 0,
	Sofa                                     = 1,
	Bookshelf                                = 2,
	BedsideTable                             = 3,
	TelevisionTable                          = 4,
	DiningTable                              = 5,
	Drawer                                   = 6,
	ArmChair                                 = 7,
	Bed                                      = 8,
	Desk                                     = 9,
	ShelfHouse                               = 10,
	ShelfShed                                = 11,
	Fireplace                                = 12,
	Table                                    = 13,
	Terrace                                  = 14,
	Counterspace                             = 15,
	ChristmasTree                            = 16,
	Snowperson                               = 17,
	ResourceHolder                           = 18,
	Valuable                                 = 19,
	Count                                    = 20,
	EReceptacleType_MAX                      = 21,
};

// Enum JP.EResourceType
// NumValues: 0x0007
enum class EResourceType : uint8
{
	Money                                    = 0,
	Wood                                     = 1,
	Metal                                    = 2,
	Perfectness                              = 3,
	PassiveIncome                            = 4,
	None                                     = 5,
	EResourceType_MAX                        = 6,
};

// Enum JP.EResourceValueChange
// NumValues: 0x0008
enum class EResourceValueChange : uint8
{
	None                                     = 0,
	HighIncrease                             = 1,
	MediumIncrease                           = 2,
	LowIncrease                              = 3,
	LowDecrease                              = 4,
	MediumDecrease                           = 5,
	HighDecrease                             = 6,
	EResourceValueChange_MAX                 = 7,
};

// Enum JP.EResourceReceiver
// NumValues: 0x0004
enum class EResourceReceiver : uint8
{
	None                                     = 0,
	Personal                                 = 1,
	TeamBased                                = 2,
	EResourceReceiver_MAX                    = 3,
};

// Enum JP.ERooms
// NumValues: 0x000C
enum class ERooms : uint8
{
	None                                     = 0,
	Garage                                   = 1,
	ToolShed                                 = 2,
	Kitchen                                  = 3,
	Toilet                                   = 4,
	LivingRoom                               = 5,
	Bedroom                                  = 6,
	WashingRoom                              = 7,
	RoomCount                                = 8,
	Utility                                  = 9,
	Telephone                                = 10,
	ERooms_MAX                               = 11,
};

// Enum JP.ESeasonPassRewardType
// NumValues: 0x0004
enum class ESeasonPassRewardType : uint8
{
	None                                     = 0,
	CatalogItem                              = 1,
	Perk                                     = 2,
	ESeasonPassRewardType_MAX                = 3,
};

// Enum JP.ESocialListState
// NumValues: 0x0005
enum class ESocialListState : uint8
{
	Collapsed                                = 0,
	Party                                    = 1,
	Fill                                     = 2,
	Full                                     = 4,
	ESocialListState_MAX                     = 5,
};

// Enum JP.ETag
// NumValues: 0x0005
enum class ETag : uint8
{
	None                                     = 0,
	Effect_SetByCaller_StaminaDepletion      = 1,
	Effect_SetByCaller_StaminaRegeneration   = 2,
	Character_Location_AtHome                = 3,
	ETag_MAX                                 = 4,
};

// Enum JP.ETeamType
// NumValues: 0x0005
enum class ETeamType : uint8
{
	None                                     = 0,
	BlueTeam                                 = 1,
	RedTeam                                  = 2,
	YellowTeam                               = 3,
	ETeamType_MAX                            = 4,
};

// Enum JP.EVerbosity
// NumValues: 0x0006
enum class EVerbosity : uint8
{
	Error                                    = 5,
	Warning                                  = 4,
	Log                                      = 3,
	Verbose                                  = 2,
	VeryVerbose                              = 1,
	EVerbosity_MAX                           = 6,
};

// Enum JP.ELyraFramePacingMode
// NumValues: 0x0004
enum class ELyraFramePacingMode : uint8
{
	DesktopStyle                             = 0,
	ConsoleStyle                             = 1,
	MobileStyle                              = 2,
	ELyraFramePacingMode_MAX                 = 3,
};

// Enum JP.EActorCanvasProjectionMode
// NumValues: 0x0006
enum class EActorCanvasProjectionMode : uint8
{
	ComponentPoint                           = 0,
	ComponentBoundingBox                     = 1,
	ComponentScreenBoundingBox               = 2,
	ActorBoundingBox                         = 3,
	ActorScreenBoundingBox                   = 4,
	EActorCanvasProjectionMode_MAX           = 5,
};

// Enum JP.ELyraWidgetInputMode
// NumValues: 0x0005
enum class ELyraWidgetInputMode : uint8
{
	Default                                  = 0,
	GameAndMenu                              = 1,
	Game                                     = 2,
	Menu                                     = 3,
	ELyraWidgetInputMode_MAX                 = 4,
};

// ScriptStruct JP.LobbyLevelVoteSelectedLevelViewModel
// 0x0038 (0x0038 - 0x0000)
struct FLobbyLevelVoteSelectedLevelViewModel final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyLevelVoteSelectedLevelViewModel) == 0x000008, "Wrong alignment on FLobbyLevelVoteSelectedLevelViewModel");
static_assert(sizeof(FLobbyLevelVoteSelectedLevelViewModel) == 0x000038, "Wrong size on FLobbyLevelVoteSelectedLevelViewModel");
static_assert(offsetof(FLobbyLevelVoteSelectedLevelViewModel, DisplayName) == 0x000000, "Member 'FLobbyLevelVoteSelectedLevelViewModel::DisplayName' has a wrong offset!");
static_assert(offsetof(FLobbyLevelVoteSelectedLevelViewModel, Image) == 0x000010, "Member 'FLobbyLevelVoteSelectedLevelViewModel::Image' has a wrong offset!");

// ScriptStruct JP.CharacterRoleData
// 0x0058 (0x0060 - 0x0008)
struct FCharacterRoleData final : public FTableRowBase
{
public:
	ECharacterName                                ClassDisplayName;                                  // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterRole                                CharacterRole;                                     // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0010(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UItemDefinition>            StartItemActor;                                    // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   StartItemDisplayName;                              // 0x0040(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         StaminaRegenerationPerSecondMultiplier;            // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TEMP_NeighborIdentifier;                           // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCharacterRoleData) == 0x000008, "Wrong alignment on FCharacterRoleData");
static_assert(sizeof(FCharacterRoleData) == 0x000060, "Wrong size on FCharacterRoleData");
static_assert(offsetof(FCharacterRoleData, ClassDisplayName) == 0x000008, "Member 'FCharacterRoleData::ClassDisplayName' has a wrong offset!");
static_assert(offsetof(FCharacterRoleData, CharacterRole) == 0x000009, "Member 'FCharacterRoleData::CharacterRole' has a wrong offset!");
static_assert(offsetof(FCharacterRoleData, Icon) == 0x000010, "Member 'FCharacterRoleData::Icon' has a wrong offset!");
static_assert(offsetof(FCharacterRoleData, StartItemActor) == 0x000038, "Member 'FCharacterRoleData::StartItemActor' has a wrong offset!");
static_assert(offsetof(FCharacterRoleData, StartItemDisplayName) == 0x000040, "Member 'FCharacterRoleData::StartItemDisplayName' has a wrong offset!");
static_assert(offsetof(FCharacterRoleData, StaminaRegenerationPerSecondMultiplier) == 0x000050, "Member 'FCharacterRoleData::StaminaRegenerationPerSecondMultiplier' has a wrong offset!");
static_assert(offsetof(FCharacterRoleData, TEMP_NeighborIdentifier) == 0x000054, "Member 'FCharacterRoleData::TEMP_NeighborIdentifier' has a wrong offset!");

// ScriptStruct JP.TicketMemberAttributesDataObject
// 0x0018 (0x0018 - 0x0000)
struct FTicketMemberAttributesDataObject final
{
public:
	class FString                                 Region;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         IsServer;                                          // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTicketMemberAttributesDataObject) == 0x000008, "Wrong alignment on FTicketMemberAttributesDataObject");
static_assert(sizeof(FTicketMemberAttributesDataObject) == 0x000018, "Wrong size on FTicketMemberAttributesDataObject");
static_assert(offsetof(FTicketMemberAttributesDataObject, Region) == 0x000000, "Member 'FTicketMemberAttributesDataObject::Region' has a wrong offset!");
static_assert(offsetof(FTicketMemberAttributesDataObject, IsServer) == 0x000010, "Member 'FTicketMemberAttributesDataObject::IsServer' has a wrong offset!");

// ScriptStruct JP.DeathRespawnTimeWindow
// 0x0010 (0x0010 - 0x0000)
struct FDeathRespawnTimeWindow final
{
public:
	double                                        StartServerWorldTimeSeconds;                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	double                                        EndServerWorldTimeSeconds;                         // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeathRespawnTimeWindow) == 0x000008, "Wrong alignment on FDeathRespawnTimeWindow");
static_assert(sizeof(FDeathRespawnTimeWindow) == 0x000010, "Wrong size on FDeathRespawnTimeWindow");
static_assert(offsetof(FDeathRespawnTimeWindow, StartServerWorldTimeSeconds) == 0x000000, "Member 'FDeathRespawnTimeWindow::StartServerWorldTimeSeconds' has a wrong offset!");
static_assert(offsetof(FDeathRespawnTimeWindow, EndServerWorldTimeSeconds) == 0x000008, "Member 'FDeathRespawnTimeWindow::EndServerWorldTimeSeconds' has a wrong offset!");

// ScriptStruct JP.OnlineStoreItemCost
// 0x000C (0x000C - 0x0000)
struct FOnlineStoreItemCost final
{
public:
	struct FGameplayTag                           CurrencyID;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineStoreItemCost) == 0x000004, "Wrong alignment on FOnlineStoreItemCost");
static_assert(sizeof(FOnlineStoreItemCost) == 0x00000C, "Wrong size on FOnlineStoreItemCost");
static_assert(offsetof(FOnlineStoreItemCost, CurrencyID) == 0x000000, "Member 'FOnlineStoreItemCost::CurrencyID' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemCost, Amount) == 0x000008, "Member 'FOnlineStoreItemCost::Amount' has a wrong offset!");

// ScriptStruct JP.OnlineStoreItemBattlePassRequirement
// 0x0010 (0x0010 - 0x0000)
struct FOnlineStoreItemBattlePassRequirement final
{
public:
	struct FGameplayTag                           BattlePassID;                                      // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsPremium;                                         // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnlineStoreItemBattlePassRequirement) == 0x000004, "Wrong alignment on FOnlineStoreItemBattlePassRequirement");
static_assert(sizeof(FOnlineStoreItemBattlePassRequirement) == 0x000010, "Wrong size on FOnlineStoreItemBattlePassRequirement");
static_assert(offsetof(FOnlineStoreItemBattlePassRequirement, BattlePassID) == 0x000000, "Member 'FOnlineStoreItemBattlePassRequirement::BattlePassID' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemBattlePassRequirement, Level) == 0x000008, "Member 'FOnlineStoreItemBattlePassRequirement::Level' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemBattlePassRequirement, IsPremium) == 0x00000C, "Member 'FOnlineStoreItemBattlePassRequirement::IsPremium' has a wrong offset!");

// ScriptStruct JP.OnlineStoreItemData
// 0x0048 (0x0048 - 0x0000)
struct FOnlineStoreItemData final
{
public:
	class FString                                 OnlineServicesID;                                  // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AssetID;                                           // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EOnlineItemUnlockRequirement                  UnlockRequirement;                                 // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsOwned;                                           // 0x0019(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FOnlineStoreItemCost                   Cost;                                              // 0x001C(0x000C)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FOnlineStoreItemBattlePassRequirement  BattlePassRequirement;                             // 0x0028(0x0010)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FOnlineStoreItemData) == 0x000008, "Wrong alignment on FOnlineStoreItemData");
static_assert(sizeof(FOnlineStoreItemData) == 0x000048, "Wrong size on FOnlineStoreItemData");
static_assert(offsetof(FOnlineStoreItemData, OnlineServicesID) == 0x000000, "Member 'FOnlineStoreItemData::OnlineServicesID' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemData, AssetID) == 0x000010, "Member 'FOnlineStoreItemData::AssetID' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemData, UnlockRequirement) == 0x000018, "Member 'FOnlineStoreItemData::UnlockRequirement' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemData, IsOwned) == 0x000019, "Member 'FOnlineStoreItemData::IsOwned' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemData, Cost) == 0x00001C, "Member 'FOnlineStoreItemData::Cost' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemData, BattlePassRequirement) == 0x000028, "Member 'FOnlineStoreItemData::BattlePassRequirement' has a wrong offset!");
static_assert(offsetof(FOnlineStoreItemData, Tags) == 0x000038, "Member 'FOnlineStoreItemData::Tags' has a wrong offset!");

// ScriptStruct JP.CosmeticsOnlineServicesDataContainer
// 0x0068 (0x0068 - 0x0000)
struct FCosmeticsOnlineServicesDataContainer final
{
public:
	TArray<struct FOnlineStoreItemData>           OwnedNeighborSkins;                                // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOnlineStoreItemData>           StoreNeighborSkins;                                // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOnlineStoreItemData>           OwnedItemSkins;                                    // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOnlineStoreItemData>           StoreItemSkins;                                    // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOnlineStoreItemData>           OwnedEmotes;                                       // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FOnlineStoreItemData>           StoreEmotes;                                       // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCosmeticsOnlineServicesDataContainer) == 0x000008, "Wrong alignment on FCosmeticsOnlineServicesDataContainer");
static_assert(sizeof(FCosmeticsOnlineServicesDataContainer) == 0x000068, "Wrong size on FCosmeticsOnlineServicesDataContainer");
static_assert(offsetof(FCosmeticsOnlineServicesDataContainer, OwnedNeighborSkins) == 0x000000, "Member 'FCosmeticsOnlineServicesDataContainer::OwnedNeighborSkins' has a wrong offset!");
static_assert(offsetof(FCosmeticsOnlineServicesDataContainer, StoreNeighborSkins) == 0x000010, "Member 'FCosmeticsOnlineServicesDataContainer::StoreNeighborSkins' has a wrong offset!");
static_assert(offsetof(FCosmeticsOnlineServicesDataContainer, OwnedItemSkins) == 0x000020, "Member 'FCosmeticsOnlineServicesDataContainer::OwnedItemSkins' has a wrong offset!");
static_assert(offsetof(FCosmeticsOnlineServicesDataContainer, StoreItemSkins) == 0x000030, "Member 'FCosmeticsOnlineServicesDataContainer::StoreItemSkins' has a wrong offset!");
static_assert(offsetof(FCosmeticsOnlineServicesDataContainer, OwnedEmotes) == 0x000040, "Member 'FCosmeticsOnlineServicesDataContainer::OwnedEmotes' has a wrong offset!");
static_assert(offsetof(FCosmeticsOnlineServicesDataContainer, StoreEmotes) == 0x000050, "Member 'FCosmeticsOnlineServicesDataContainer::StoreEmotes' has a wrong offset!");

// ScriptStruct JP.ServerDebugInformation
// 0x0030 (0x0030 - 0x0000)
struct FServerDebugInformation final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VmId;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ServerId;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerDebugInformation) == 0x000008, "Wrong alignment on FServerDebugInformation");
static_assert(sizeof(FServerDebugInformation) == 0x000030, "Wrong size on FServerDebugInformation");
static_assert(offsetof(FServerDebugInformation, Name) == 0x000000, "Member 'FServerDebugInformation::Name' has a wrong offset!");
static_assert(offsetof(FServerDebugInformation, VmId) == 0x000010, "Member 'FServerDebugInformation::VmId' has a wrong offset!");
static_assert(offsetof(FServerDebugInformation, ServerId) == 0x000020, "Member 'FServerDebugInformation::ServerId' has a wrong offset!");

// ScriptStruct JP.EndOfMatchPlayerData
// 0x0001 (0x0001 - 0x0000)
struct FEndOfMatchPlayerData final
{
public:
	bool                                          bDidWin;                                           // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEndOfMatchPlayerData) == 0x000001, "Wrong alignment on FEndOfMatchPlayerData");
static_assert(sizeof(FEndOfMatchPlayerData) == 0x000001, "Wrong size on FEndOfMatchPlayerData");
static_assert(offsetof(FEndOfMatchPlayerData, bDidWin) == 0x000000, "Member 'FEndOfMatchPlayerData::bDidWin' has a wrong offset!");

// ScriptStruct JP.RoomData
// 0x0018 (0x0018 - 0x0000)
struct FRoomData final
{
public:
	ERooms                                        Room;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoomLevel;                                         // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   RoomName;                                          // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomData) == 0x000008, "Wrong alignment on FRoomData");
static_assert(sizeof(FRoomData) == 0x000018, "Wrong size on FRoomData");
static_assert(offsetof(FRoomData, Room) == 0x000000, "Member 'FRoomData::Room' has a wrong offset!");
static_assert(offsetof(FRoomData, RoomLevel) == 0x000004, "Member 'FRoomData::RoomLevel' has a wrong offset!");
static_assert(offsetof(FRoomData, RoomName) == 0x000008, "Member 'FRoomData::RoomName' has a wrong offset!");

// ScriptStruct JP.ItemTier
// 0x0050 (0x0050 - 0x0000)
struct FItemTier final
{
public:
	TSoftObjectPtr<class UObject>                 ItemDefinition;                                    // 0x0000(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredHouseLevel;                                // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRoomData                              RequiredRoom;                                      // 0x0030(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UEconomyDefinition*                     Cost;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemTier) == 0x000008, "Wrong alignment on FItemTier");
static_assert(sizeof(FItemTier) == 0x000050, "Wrong size on FItemTier");
static_assert(offsetof(FItemTier, ItemDefinition) == 0x000000, "Member 'FItemTier::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FItemTier, RequiredHouseLevel) == 0x000028, "Member 'FItemTier::RequiredHouseLevel' has a wrong offset!");
static_assert(offsetof(FItemTier, RequiredRoom) == 0x000030, "Member 'FItemTier::RequiredRoom' has a wrong offset!");
static_assert(offsetof(FItemTier, Cost) == 0x000048, "Member 'FItemTier::Cost' has a wrong offset!");

// ScriptStruct JP.DefaultCharacterSettings
// 0x0008 (0x0008 - 0x0000)
struct FDefaultCharacterSettings final
{
public:
	struct FGameplayTag                           DefaultCharacterTag;                               // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefaultCharacterSettings) == 0x000004, "Wrong alignment on FDefaultCharacterSettings");
static_assert(sizeof(FDefaultCharacterSettings) == 0x000008, "Wrong size on FDefaultCharacterSettings");
static_assert(offsetof(FDefaultCharacterSettings, DefaultCharacterTag) == 0x000000, "Member 'FDefaultCharacterSettings::DefaultCharacterTag' has a wrong offset!");

// ScriptStruct JP.ItemDeliveryRewardMessage
// 0x0010 (0x0010 - 0x0000)
struct FItemDeliveryRewardMessage final
{
public:
	class UDataAsset*                             ActorToDeliver;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Team;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemDeliveryRewardMessage) == 0x000008, "Wrong alignment on FItemDeliveryRewardMessage");
static_assert(sizeof(FItemDeliveryRewardMessage) == 0x000010, "Wrong size on FItemDeliveryRewardMessage");
static_assert(offsetof(FItemDeliveryRewardMessage, ActorToDeliver) == 0x000000, "Member 'FItemDeliveryRewardMessage::ActorToDeliver' has a wrong offset!");
static_assert(offsetof(FItemDeliveryRewardMessage, Team) == 0x000008, "Member 'FItemDeliveryRewardMessage::Team' has a wrong offset!");

// ScriptStruct JP.LevelVoteData
// 0x0068 (0x0068 - 0x0000)
struct FLevelVoteData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  LevelPath;                                         // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SelectionWeight;                                   // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelVoteData) == 0x000008, "Wrong alignment on FLevelVoteData");
static_assert(sizeof(FLevelVoteData) == 0x000068, "Wrong size on FLevelVoteData");
static_assert(offsetof(FLevelVoteData, DisplayName) == 0x000000, "Member 'FLevelVoteData::DisplayName' has a wrong offset!");
static_assert(offsetof(FLevelVoteData, LevelPath) == 0x000010, "Member 'FLevelVoteData::LevelPath' has a wrong offset!");
static_assert(offsetof(FLevelVoteData, SelectionWeight) == 0x000038, "Member 'FLevelVoteData::SelectionWeight' has a wrong offset!");
static_assert(offsetof(FLevelVoteData, Image) == 0x000040, "Member 'FLevelVoteData::Image' has a wrong offset!");

// ScriptStruct JP.EndOfMatchGrantedStatistic
// 0x0018 (0x0018 - 0x0000)
struct FEndOfMatchGrantedStatistic final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndOfMatchGrantedStatistic) == 0x000008, "Wrong alignment on FEndOfMatchGrantedStatistic");
static_assert(sizeof(FEndOfMatchGrantedStatistic) == 0x000018, "Wrong size on FEndOfMatchGrantedStatistic");
static_assert(offsetof(FEndOfMatchGrantedStatistic, ID) == 0x000000, "Member 'FEndOfMatchGrantedStatistic::ID' has a wrong offset!");
static_assert(offsetof(FEndOfMatchGrantedStatistic, Amount) == 0x000010, "Member 'FEndOfMatchGrantedStatistic::Amount' has a wrong offset!");

// ScriptStruct JP.GameModeData
// 0x0038 (0x0038 - 0x0000)
struct FGameModeData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GameModeClass;                                     // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGameModeData) == 0x000008, "Wrong alignment on FGameModeData");
static_assert(sizeof(FGameModeData) == 0x000038, "Wrong size on FGameModeData");
static_assert(offsetof(FGameModeData, DisplayName) == 0x000000, "Member 'FGameModeData::DisplayName' has a wrong offset!");
static_assert(offsetof(FGameModeData, GameModeClass) == 0x000010, "Member 'FGameModeData::GameModeClass' has a wrong offset!");

// ScriptStruct JP.ItemLoadout
// 0x0010 (0x0010 - 0x0000)
struct FItemLoadout final
{
public:
	struct FGameplayTag                           ItemIdentifier;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SkinIdentifier;                                    // 0x0008(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemLoadout) == 0x000004, "Wrong alignment on FItemLoadout");
static_assert(sizeof(FItemLoadout) == 0x000010, "Wrong size on FItemLoadout");
static_assert(offsetof(FItemLoadout, ItemIdentifier) == 0x000000, "Member 'FItemLoadout::ItemIdentifier' has a wrong offset!");
static_assert(offsetof(FItemLoadout, SkinIdentifier) == 0x000008, "Member 'FItemLoadout::SkinIdentifier' has a wrong offset!");

// ScriptStruct JP.NeighborLoadout
// 0x0030 (0x0030 - 0x0000)
struct FNeighborLoadout final
{
public:
	struct FGameplayTag                           NeighborIdentifier;                                // 0x0000(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NeighborPerk;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           GeneralPerk;                                       // 0x0010(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NeighborSkin;                                      // 0x0018(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FItemLoadout>                   Items;                                             // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNeighborLoadout) == 0x000008, "Wrong alignment on FNeighborLoadout");
static_assert(sizeof(FNeighborLoadout) == 0x000030, "Wrong size on FNeighborLoadout");
static_assert(offsetof(FNeighborLoadout, NeighborIdentifier) == 0x000000, "Member 'FNeighborLoadout::NeighborIdentifier' has a wrong offset!");
static_assert(offsetof(FNeighborLoadout, NeighborPerk) == 0x000008, "Member 'FNeighborLoadout::NeighborPerk' has a wrong offset!");
static_assert(offsetof(FNeighborLoadout, GeneralPerk) == 0x000010, "Member 'FNeighborLoadout::GeneralPerk' has a wrong offset!");
static_assert(offsetof(FNeighborLoadout, NeighborSkin) == 0x000018, "Member 'FNeighborLoadout::NeighborSkin' has a wrong offset!");
static_assert(offsetof(FNeighborLoadout, Items) == 0x000020, "Member 'FNeighborLoadout::Items' has a wrong offset!");

// ScriptStruct JP.PlayerLoadout
// 0x0028 (0x0028 - 0x0000)
struct FPlayerLoadout final
{
public:
	struct FGameplayTag                           DefaultNeighborID;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HouseID;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FNeighborLoadout>               NeighborLoadouts;                                  // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsValid;                                          // 0x0020(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerLoadout) == 0x000008, "Wrong alignment on FPlayerLoadout");
static_assert(sizeof(FPlayerLoadout) == 0x000028, "Wrong size on FPlayerLoadout");
static_assert(offsetof(FPlayerLoadout, DefaultNeighborID) == 0x000000, "Member 'FPlayerLoadout::DefaultNeighborID' has a wrong offset!");
static_assert(offsetof(FPlayerLoadout, HouseID) == 0x000008, "Member 'FPlayerLoadout::HouseID' has a wrong offset!");
static_assert(offsetof(FPlayerLoadout, NeighborLoadouts) == 0x000010, "Member 'FPlayerLoadout::NeighborLoadouts' has a wrong offset!");
static_assert(offsetof(FPlayerLoadout, bIsValid) == 0x000020, "Member 'FPlayerLoadout::bIsValid' has a wrong offset!");

// ScriptStruct JP.CombatParticipant
// 0x0060 (0x0060 - 0x0000)
struct FCombatParticipant final
{
public:
	struct FGameplayTag                           Type;                                              // 0x0000(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0008(0x0010)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0018(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0040(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerMatchRecord*                     PlayerMatchRecord;                                 // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FActiveGameplayEffectHandle>    AffectingGameplayEffects;                          // 0x0050(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCombatParticipant) == 0x000008, "Wrong alignment on FCombatParticipant");
static_assert(sizeof(FCombatParticipant) == 0x000060, "Wrong size on FCombatParticipant");
static_assert(offsetof(FCombatParticipant, Type) == 0x000000, "Member 'FCombatParticipant::Type' has a wrong offset!");
static_assert(offsetof(FCombatParticipant, Name) == 0x000008, "Member 'FCombatParticipant::Name' has a wrong offset!");
static_assert(offsetof(FCombatParticipant, Icon) == 0x000018, "Member 'FCombatParticipant::Icon' has a wrong offset!");
static_assert(offsetof(FCombatParticipant, TeamId) == 0x000040, "Member 'FCombatParticipant::TeamId' has a wrong offset!");
static_assert(offsetof(FCombatParticipant, PlayerMatchRecord) == 0x000048, "Member 'FCombatParticipant::PlayerMatchRecord' has a wrong offset!");
static_assert(offsetof(FCombatParticipant, AffectingGameplayEffects) == 0x000050, "Member 'FCombatParticipant::AffectingGameplayEffects' has a wrong offset!");

// ScriptStruct JP.KillMethod
// 0x02E8 (0x02E8 - 0x0000)
struct FKillMethod final
{
public:
	TSoftObjectPtr<class UObject>                 ItemDefinition;                                    // 0x0000(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayEffectSpec                    GameplayEffect;                                    // 0x0028(0x0298)(BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   GameplayAbility;                                   // 0x02C0(0x0028)(BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillMethod) == 0x000008, "Wrong alignment on FKillMethod");
static_assert(sizeof(FKillMethod) == 0x0002E8, "Wrong size on FKillMethod");
static_assert(offsetof(FKillMethod, ItemDefinition) == 0x000000, "Member 'FKillMethod::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FKillMethod, GameplayEffect) == 0x000028, "Member 'FKillMethod::GameplayEffect' has a wrong offset!");
static_assert(offsetof(FKillMethod, GameplayAbility) == 0x0002C0, "Member 'FKillMethod::GameplayAbility' has a wrong offset!");

// ScriptStruct JP.GameplayEffectContextJP
// 0x0408 (0x04B0 - 0x00A8)
struct FGameplayEffectContextJP final : public FGameplayEffectContextIW
{
public:
	uint8                                         Pad_A8[0xC0];                                      // 0x00A8(0x00C0)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCombatParticipant                     CombatParticipant;                                 // 0x0168(0x0060)(Protected, NativeAccessSpecifierProtected)
	struct FKillMethod                            KillMethod;                                        // 0x01C8(0x02E8)(Protected, NativeAccessSpecifierProtected)
};
static_assert(alignof(FGameplayEffectContextJP) == 0x000008, "Wrong alignment on FGameplayEffectContextJP");
static_assert(sizeof(FGameplayEffectContextJP) == 0x0004B0, "Wrong size on FGameplayEffectContextJP");
static_assert(offsetof(FGameplayEffectContextJP, CombatParticipant) == 0x000168, "Member 'FGameplayEffectContextJP::CombatParticipant' has a wrong offset!");
static_assert(offsetof(FGameplayEffectContextJP, KillMethod) == 0x0001C8, "Member 'FGameplayEffectContextJP::KillMethod' has a wrong offset!");

// ScriptStruct JP.CheatSpawnedActorRow
// 0x0038 (0x0040 - 0x0008)
struct FCheatSpawnedActorRow final : public FTableRowBase
{
public:
	class FString                                 ActorName;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SoftActorClass;                                    // 0x0018(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCheatSpawnedActorRow) == 0x000008, "Wrong alignment on FCheatSpawnedActorRow");
static_assert(sizeof(FCheatSpawnedActorRow) == 0x000040, "Wrong size on FCheatSpawnedActorRow");
static_assert(offsetof(FCheatSpawnedActorRow, ActorName) == 0x000008, "Member 'FCheatSpawnedActorRow::ActorName' has a wrong offset!");
static_assert(offsetof(FCheatSpawnedActorRow, SoftActorClass) == 0x000018, "Member 'FCheatSpawnedActorRow::SoftActorClass' has a wrong offset!");

// ScriptStruct JP.MatchConfigurationItemViewModel
// 0x0048 (0x0048 - 0x0000)
struct FMatchConfigurationItemViewModel final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0018(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Enabled;                                           // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMatchConfigurationItemViewModel) == 0x000008, "Wrong alignment on FMatchConfigurationItemViewModel");
static_assert(sizeof(FMatchConfigurationItemViewModel) == 0x000048, "Wrong size on FMatchConfigurationItemViewModel");
static_assert(offsetof(FMatchConfigurationItemViewModel, Tag) == 0x000000, "Member 'FMatchConfigurationItemViewModel::Tag' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationItemViewModel, Name) == 0x000008, "Member 'FMatchConfigurationItemViewModel::Name' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationItemViewModel, Icon) == 0x000018, "Member 'FMatchConfigurationItemViewModel::Icon' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationItemViewModel, Enabled) == 0x000040, "Member 'FMatchConfigurationItemViewModel::Enabled' has a wrong offset!");

// ScriptStruct JP.DamageTakenGameplayMessage
// 0x0030 (0x0030 - 0x0000)
struct FDamageTakenGameplayMessage final
{
public:
	float                                         DamageDelta;                                       // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 OwningPlayer;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CriticalHit;                                       // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                WorldLocation;                                     // 0x0018(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDamageTakenGameplayMessage) == 0x000008, "Wrong alignment on FDamageTakenGameplayMessage");
static_assert(sizeof(FDamageTakenGameplayMessage) == 0x000030, "Wrong size on FDamageTakenGameplayMessage");
static_assert(offsetof(FDamageTakenGameplayMessage, DamageDelta) == 0x000000, "Member 'FDamageTakenGameplayMessage::DamageDelta' has a wrong offset!");
static_assert(offsetof(FDamageTakenGameplayMessage, OwningPlayer) == 0x000008, "Member 'FDamageTakenGameplayMessage::OwningPlayer' has a wrong offset!");
static_assert(offsetof(FDamageTakenGameplayMessage, CriticalHit) == 0x000010, "Member 'FDamageTakenGameplayMessage::CriticalHit' has a wrong offset!");
static_assert(offsetof(FDamageTakenGameplayMessage, WorldLocation) == 0x000018, "Member 'FDamageTakenGameplayMessage::WorldLocation' has a wrong offset!");

// ScriptStruct JP.AppliedBuffInfo
// 0x0010 (0x0010 - 0x0000)
struct FAppliedBuffInfo final
{
public:
	TSubclassOf<class UGameplayEffect>            BuffClass;                                         // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenInShopUI;                                   // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAppliedBuffInfo) == 0x000008, "Wrong alignment on FAppliedBuffInfo");
static_assert(sizeof(FAppliedBuffInfo) == 0x000010, "Wrong size on FAppliedBuffInfo");
static_assert(offsetof(FAppliedBuffInfo, BuffClass) == 0x000000, "Member 'FAppliedBuffInfo::BuffClass' has a wrong offset!");
static_assert(offsetof(FAppliedBuffInfo, bHiddenInShopUI) == 0x000008, "Member 'FAppliedBuffInfo::bHiddenInShopUI' has a wrong offset!");

// ScriptStruct JP.CharacterXP
// 0x000C (0x000C - 0x0000)
struct FCharacterXP final
{
public:
	struct FGameplayTag                           NeighborID;                                        // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         XP;                                                // 0x0008(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterXP) == 0x000004, "Wrong alignment on FCharacterXP");
static_assert(sizeof(FCharacterXP) == 0x00000C, "Wrong size on FCharacterXP");
static_assert(offsetof(FCharacterXP, NeighborID) == 0x000000, "Member 'FCharacterXP::NeighborID' has a wrong offset!");
static_assert(offsetof(FCharacterXP, XP) == 0x000008, "Member 'FCharacterXP::XP' has a wrong offset!");

// ScriptStruct JP.PlayerXP
// 0x0020 (0x0020 - 0x0000)
struct FPlayerXP final
{
public:
	int32                                         ProfileXP;                                         // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCharacterXP>                   CharacterXPs;                                      // 0x0008(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bIsInitialized;                                    // 0x0018(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerXP) == 0x000008, "Wrong alignment on FPlayerXP");
static_assert(sizeof(FPlayerXP) == 0x000020, "Wrong size on FPlayerXP");
static_assert(offsetof(FPlayerXP, ProfileXP) == 0x000000, "Member 'FPlayerXP::ProfileXP' has a wrong offset!");
static_assert(offsetof(FPlayerXP, CharacterXPs) == 0x000008, "Member 'FPlayerXP::CharacterXPs' has a wrong offset!");
static_assert(offsetof(FPlayerXP, bIsInitialized) == 0x000018, "Member 'FPlayerXP::bIsInitialized' has a wrong offset!");

// ScriptStruct JP.EndOfMatchRewardArguments
// 0x0028 (0x0028 - 0x0000)
struct FEndOfMatchRewardArguments final
{
public:
	class FString                                 TitleId;                                           // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DidWin;                                            // 0x0010(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UsedNeighborID;                                    // 0x0018(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEndOfMatchRewardArguments) == 0x000008, "Wrong alignment on FEndOfMatchRewardArguments");
static_assert(sizeof(FEndOfMatchRewardArguments) == 0x000028, "Wrong size on FEndOfMatchRewardArguments");
static_assert(offsetof(FEndOfMatchRewardArguments, TitleId) == 0x000000, "Member 'FEndOfMatchRewardArguments::TitleId' has a wrong offset!");
static_assert(offsetof(FEndOfMatchRewardArguments, DidWin) == 0x000010, "Member 'FEndOfMatchRewardArguments::DidWin' has a wrong offset!");
static_assert(offsetof(FEndOfMatchRewardArguments, UsedNeighborID) == 0x000018, "Member 'FEndOfMatchRewardArguments::UsedNeighborID' has a wrong offset!");

// ScriptStruct JP.Team
// 0x0038 (0x0038 - 0x0000)
struct FTeam final
{
public:
	uint8                                         ID;                                                // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           Color;                                             // 0x0004(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AGroundsKeeper*                         GroundsKeeper;                                     // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AEndCondition*                          EliminationReason;                                 // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           TeamHouseIdentifier;                               // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsServer;                                         // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FTeam) == 0x000008, "Wrong alignment on FTeam");
static_assert(sizeof(FTeam) == 0x000038, "Wrong size on FTeam");
static_assert(offsetof(FTeam, ID) == 0x000000, "Member 'FTeam::ID' has a wrong offset!");
static_assert(offsetof(FTeam, Color) == 0x000004, "Member 'FTeam::Color' has a wrong offset!");
static_assert(offsetof(FTeam, GroundsKeeper) == 0x000018, "Member 'FTeam::GroundsKeeper' has a wrong offset!");
static_assert(offsetof(FTeam, EliminationReason) == 0x000020, "Member 'FTeam::EliminationReason' has a wrong offset!");
static_assert(offsetof(FTeam, TeamHouseIdentifier) == 0x000028, "Member 'FTeam::TeamHouseIdentifier' has a wrong offset!");
static_assert(offsetof(FTeam, bIsServer) == 0x000030, "Member 'FTeam::bIsServer' has a wrong offset!");

// ScriptStruct JP.HouseEssentialId
// 0x0008 (0x0008 - 0x0000)
struct FHouseEssentialId final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseEssentialId) == 0x000004, "Wrong alignment on FHouseEssentialId");
static_assert(sizeof(FHouseEssentialId) == 0x000008, "Wrong size on FHouseEssentialId");
static_assert(offsetof(FHouseEssentialId, Tag) == 0x000000, "Member 'FHouseEssentialId::Tag' has a wrong offset!");

// ScriptStruct JP.ShopViewModel
// 0x0028 (0x0028 - 0x0000)
struct FShopViewModel final
{
public:
	uint8                                         DefenseTier;                                       // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         OffenseTier;                                       // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SupportTier;                                       // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DeliveryTier;                                      // 0x0003(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerMoney;                                       // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Resources;                                         // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EShopItemCategory>                     DisabledUpgradeCategories;                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EShopItemCategory                             LastOpenShopCategory;                              // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShopViewModel) == 0x000008, "Wrong alignment on FShopViewModel");
static_assert(sizeof(FShopViewModel) == 0x000028, "Wrong size on FShopViewModel");
static_assert(offsetof(FShopViewModel, DefenseTier) == 0x000000, "Member 'FShopViewModel::DefenseTier' has a wrong offset!");
static_assert(offsetof(FShopViewModel, OffenseTier) == 0x000001, "Member 'FShopViewModel::OffenseTier' has a wrong offset!");
static_assert(offsetof(FShopViewModel, SupportTier) == 0x000002, "Member 'FShopViewModel::SupportTier' has a wrong offset!");
static_assert(offsetof(FShopViewModel, DeliveryTier) == 0x000003, "Member 'FShopViewModel::DeliveryTier' has a wrong offset!");
static_assert(offsetof(FShopViewModel, PlayerMoney) == 0x000004, "Member 'FShopViewModel::PlayerMoney' has a wrong offset!");
static_assert(offsetof(FShopViewModel, Resources) == 0x000008, "Member 'FShopViewModel::Resources' has a wrong offset!");
static_assert(offsetof(FShopViewModel, DisabledUpgradeCategories) == 0x000010, "Member 'FShopViewModel::DisabledUpgradeCategories' has a wrong offset!");
static_assert(offsetof(FShopViewModel, LastOpenShopCategory) == 0x000020, "Member 'FShopViewModel::LastOpenShopCategory' has a wrong offset!");

// ScriptStruct JP.FirstTimeLoginRewardsData
// 0x0050 (0x0050 - 0x0000)
struct FFirstTimeLoginRewardsData final
{
public:
	TMap<struct FGameplayTag, int32>              LoginRewards;                                      // 0x0000(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFirstTimeLoginRewardsData) == 0x000008, "Wrong alignment on FFirstTimeLoginRewardsData");
static_assert(sizeof(FFirstTimeLoginRewardsData) == 0x000050, "Wrong size on FFirstTimeLoginRewardsData");
static_assert(offsetof(FFirstTimeLoginRewardsData, LoginRewards) == 0x000000, "Member 'FFirstTimeLoginRewardsData::LoginRewards' has a wrong offset!");

// ScriptStruct JP.ShopItemViewModel
// 0x0074 (0x0080 - 0x000C)
struct FShopItemViewModel final : public FFastArraySerializerItem
{
public:
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEconomyDefinition*                     Cost;                                              // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShopItemCategory                             Category;                                          // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RequiredShopLevel;                                 // 0x0034(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTagStack>              GameplayTagStacks;                                 // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemDefinition>         ItemDefinition;                                    // 0x0050(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Quantity;                                          // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanBeAfforded;                                     // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PlayerHasInventorySpaceForThisItem;                // 0x007A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DisabledByTutorial;                                // 0x007B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LastObservedQuantity;                              // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopItemViewModel) == 0x000008, "Wrong alignment on FShopItemViewModel");
static_assert(sizeof(FShopItemViewModel) == 0x000080, "Wrong size on FShopItemViewModel");
static_assert(offsetof(FShopItemViewModel, Name) == 0x000010, "Member 'FShopItemViewModel::Name' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, Icon) == 0x000020, "Member 'FShopItemViewModel::Icon' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, Cost) == 0x000028, "Member 'FShopItemViewModel::Cost' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, Category) == 0x000030, "Member 'FShopItemViewModel::Category' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, RequiredShopLevel) == 0x000034, "Member 'FShopItemViewModel::RequiredShopLevel' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, GameplayTagStacks) == 0x000040, "Member 'FShopItemViewModel::GameplayTagStacks' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, ItemDefinition) == 0x000050, "Member 'FShopItemViewModel::ItemDefinition' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, Quantity) == 0x000078, "Member 'FShopItemViewModel::Quantity' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, CanBeAfforded) == 0x000079, "Member 'FShopItemViewModel::CanBeAfforded' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, PlayerHasInventorySpaceForThisItem) == 0x00007A, "Member 'FShopItemViewModel::PlayerHasInventorySpaceForThisItem' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, DisabledByTutorial) == 0x00007B, "Member 'FShopItemViewModel::DisabledByTutorial' has a wrong offset!");
static_assert(offsetof(FShopItemViewModel, LastObservedQuantity) == 0x00007C, "Member 'FShopItemViewModel::LastObservedQuantity' has a wrong offset!");

// ScriptStruct JP.CharacterOnlineServicesData
// 0x0018 (0x0020 - 0x0008)
struct FCharacterOnlineServicesData final : public FTableRowBase
{
public:
	struct FGameplayTag                           NeighborID;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatCodeXP;                                        // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterOnlineServicesData) == 0x000008, "Wrong alignment on FCharacterOnlineServicesData");
static_assert(sizeof(FCharacterOnlineServicesData) == 0x000020, "Wrong size on FCharacterOnlineServicesData");
static_assert(offsetof(FCharacterOnlineServicesData, NeighborID) == 0x000008, "Member 'FCharacterOnlineServicesData::NeighborID' has a wrong offset!");
static_assert(offsetof(FCharacterOnlineServicesData, StatCodeXP) == 0x000010, "Member 'FCharacterOnlineServicesData::StatCodeXP' has a wrong offset!");

// ScriptStruct JP.TeamMaterialsData
// 0x0050 (0x0058 - 0x0008)
struct FTeamMaterialsData final : public FTableRowBase
{
public:
	TMap<uint8, TSoftObjectPtr<class UMaterialInstance>> Materials;                                         // 0x0008(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamMaterialsData) == 0x000008, "Wrong alignment on FTeamMaterialsData");
static_assert(sizeof(FTeamMaterialsData) == 0x000058, "Wrong size on FTeamMaterialsData");
static_assert(offsetof(FTeamMaterialsData, Materials) == 0x000008, "Member 'FTeamMaterialsData::Materials' has a wrong offset!");

// ScriptStruct JP.LoadedMappableConfigPair
// 0x0010 (0x0010 - 0x0000)
struct FLoadedMappableConfigPair final
{
public:
	class UPlayerMappableInputConfig*             Config;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommonInputType                              Type;                                              // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLoadedMappableConfigPair) == 0x000008, "Wrong alignment on FLoadedMappableConfigPair");
static_assert(sizeof(FLoadedMappableConfigPair) == 0x000010, "Wrong size on FLoadedMappableConfigPair");
static_assert(offsetof(FLoadedMappableConfigPair, Config) == 0x000000, "Member 'FLoadedMappableConfigPair::Config' has a wrong offset!");
static_assert(offsetof(FLoadedMappableConfigPair, Type) == 0x000008, "Member 'FLoadedMappableConfigPair::Type' has a wrong offset!");
static_assert(offsetof(FLoadedMappableConfigPair, bIsActive) == 0x000009, "Member 'FLoadedMappableConfigPair::bIsActive' has a wrong offset!");

// ScriptStruct JP.BattlePassLevelRewards
// 0x0020 (0x0020 - 0x0000)
struct FBattlePassLevelRewards final
{
public:
	TArray<struct FGameplayTag>                   FreeRewards;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   PremiumRewards;                                    // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattlePassLevelRewards) == 0x000008, "Wrong alignment on FBattlePassLevelRewards");
static_assert(sizeof(FBattlePassLevelRewards) == 0x000020, "Wrong size on FBattlePassLevelRewards");
static_assert(offsetof(FBattlePassLevelRewards, FreeRewards) == 0x000000, "Member 'FBattlePassLevelRewards::FreeRewards' has a wrong offset!");
static_assert(offsetof(FBattlePassLevelRewards, PremiumRewards) == 0x000010, "Member 'FBattlePassLevelRewards::PremiumRewards' has a wrong offset!");

// ScriptStruct JP.SeasonPassCatalogItem
// 0x0018 (0x0018 - 0x0000)
struct FSeasonPassCatalogItem final
{
public:
	class FString                                 CatalogId;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSeasonPassCatalogItem) == 0x000008, "Wrong alignment on FSeasonPassCatalogItem");
static_assert(sizeof(FSeasonPassCatalogItem) == 0x000018, "Wrong size on FSeasonPassCatalogItem");
static_assert(offsetof(FSeasonPassCatalogItem, CatalogId) == 0x000000, "Member 'FSeasonPassCatalogItem::CatalogId' has a wrong offset!");
static_assert(offsetof(FSeasonPassCatalogItem, Amount) == 0x000010, "Member 'FSeasonPassCatalogItem::Amount' has a wrong offset!");

// ScriptStruct JP.SeasonPassPerk
// 0x0010 (0x0010 - 0x0000)
struct FSeasonPassPerk final
{
public:
	class FString                                 PerkID;                                            // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonPassPerk) == 0x000008, "Wrong alignment on FSeasonPassPerk");
static_assert(sizeof(FSeasonPassPerk) == 0x000010, "Wrong size on FSeasonPassPerk");
static_assert(offsetof(FSeasonPassPerk, PerkID) == 0x000000, "Member 'FSeasonPassPerk::PerkID' has a wrong offset!");

// ScriptStruct JP.SeasonPassReward
// 0x0040 (0x0040 - 0x0000)
struct FSeasonPassReward final
{
public:
	class FString                                 Guid;                                              // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPremium;                                        // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSeasonPassCatalogItem                 Item;                                              // 0x0018(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FSeasonPassPerk                        Perk;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonPassReward) == 0x000008, "Wrong alignment on FSeasonPassReward");
static_assert(sizeof(FSeasonPassReward) == 0x000040, "Wrong size on FSeasonPassReward");
static_assert(offsetof(FSeasonPassReward, Guid) == 0x000000, "Member 'FSeasonPassReward::Guid' has a wrong offset!");
static_assert(offsetof(FSeasonPassReward, bIsPremium) == 0x000010, "Member 'FSeasonPassReward::bIsPremium' has a wrong offset!");
static_assert(offsetof(FSeasonPassReward, Item) == 0x000018, "Member 'FSeasonPassReward::Item' has a wrong offset!");
static_assert(offsetof(FSeasonPassReward, Perk) == 0x000030, "Member 'FSeasonPassReward::Perk' has a wrong offset!");

// ScriptStruct JP.SeasonPassTier
// 0x0018 (0x0018 - 0x0000)
struct FSeasonPassTier final
{
public:
	int32                                         Level;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredXP;                                        // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSeasonPassReward>              Rewards;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonPassTier) == 0x000008, "Wrong alignment on FSeasonPassTier");
static_assert(sizeof(FSeasonPassTier) == 0x000018, "Wrong size on FSeasonPassTier");
static_assert(offsetof(FSeasonPassTier, Level) == 0x000000, "Member 'FSeasonPassTier::Level' has a wrong offset!");
static_assert(offsetof(FSeasonPassTier, RequiredXP) == 0x000004, "Member 'FSeasonPassTier::RequiredXP' has a wrong offset!");
static_assert(offsetof(FSeasonPassTier, Rewards) == 0x000008, "Member 'FSeasonPassTier::Rewards' has a wrong offset!");

// ScriptStruct JP.SeasonPassTierViewModel
// 0x0028 (0x0028 - 0x0000)
struct FSeasonPassTierViewModel final
{
public:
	struct FSeasonPassTier                        Tier;                                              // 0x0000(0x0018)(Edit, BlueprintVisible, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bIsUnlocked;                                       // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TierProgressPercentage;                            // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstTier;                                      // 0x0020(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLastTier;                                       // 0x0021(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSeasonPassTierViewModel) == 0x000008, "Wrong alignment on FSeasonPassTierViewModel");
static_assert(sizeof(FSeasonPassTierViewModel) == 0x000028, "Wrong size on FSeasonPassTierViewModel");
static_assert(offsetof(FSeasonPassTierViewModel, Tier) == 0x000000, "Member 'FSeasonPassTierViewModel::Tier' has a wrong offset!");
static_assert(offsetof(FSeasonPassTierViewModel, bIsUnlocked) == 0x000018, "Member 'FSeasonPassTierViewModel::bIsUnlocked' has a wrong offset!");
static_assert(offsetof(FSeasonPassTierViewModel, TierProgressPercentage) == 0x00001C, "Member 'FSeasonPassTierViewModel::TierProgressPercentage' has a wrong offset!");
static_assert(offsetof(FSeasonPassTierViewModel, bIsFirstTier) == 0x000020, "Member 'FSeasonPassTierViewModel::bIsFirstTier' has a wrong offset!");
static_assert(offsetof(FSeasonPassTierViewModel, bIsLastTier) == 0x000021, "Member 'FSeasonPassTierViewModel::bIsLastTier' has a wrong offset!");

// ScriptStruct JP.LyraTabDescriptor
// 0x0110 (0x0110 - 0x0000)
struct FLyraTabDescriptor final
{
public:
	class FName                                   TabId;                                             // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TabText;                                           // 0x0008(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            IconBrush;                                         // 0x0020(0x00D0)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bHidden;                                           // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCommonButtonBase>          TabButtonType;                                     // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCommonUserWidget>          TabContentType;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                CreatedTabContentWidget;                           // 0x0108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLyraTabDescriptor) == 0x000010, "Wrong alignment on FLyraTabDescriptor");
static_assert(sizeof(FLyraTabDescriptor) == 0x000110, "Wrong size on FLyraTabDescriptor");
static_assert(offsetof(FLyraTabDescriptor, TabId) == 0x000000, "Member 'FLyraTabDescriptor::TabId' has a wrong offset!");
static_assert(offsetof(FLyraTabDescriptor, TabText) == 0x000008, "Member 'FLyraTabDescriptor::TabText' has a wrong offset!");
static_assert(offsetof(FLyraTabDescriptor, IconBrush) == 0x000020, "Member 'FLyraTabDescriptor::IconBrush' has a wrong offset!");
static_assert(offsetof(FLyraTabDescriptor, bHidden) == 0x0000F0, "Member 'FLyraTabDescriptor::bHidden' has a wrong offset!");
static_assert(offsetof(FLyraTabDescriptor, TabButtonType) == 0x0000F8, "Member 'FLyraTabDescriptor::TabButtonType' has a wrong offset!");
static_assert(offsetof(FLyraTabDescriptor, TabContentType) == 0x000100, "Member 'FLyraTabDescriptor::TabContentType' has a wrong offset!");
static_assert(offsetof(FLyraTabDescriptor, CreatedTabContentWidget) == 0x000108, "Member 'FLyraTabDescriptor::CreatedTabContentWidget' has a wrong offset!");

// ScriptStruct JP.DefenceUpgradeConstructionGameplayMessage
// 0x0014 (0x0014 - 0x0000)
struct FDefenceUpgradeConstructionGameplayMessage final
{
public:
	struct FGameplayTag                           UpgradeGroup;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ConstructionInProgress;                            // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 TargetObject;                                      // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefenceUpgradeConstructionGameplayMessage) == 0x000004, "Wrong alignment on FDefenceUpgradeConstructionGameplayMessage");
static_assert(sizeof(FDefenceUpgradeConstructionGameplayMessage) == 0x000014, "Wrong size on FDefenceUpgradeConstructionGameplayMessage");
static_assert(offsetof(FDefenceUpgradeConstructionGameplayMessage, UpgradeGroup) == 0x000000, "Member 'FDefenceUpgradeConstructionGameplayMessage::UpgradeGroup' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeConstructionGameplayMessage, TeamId) == 0x000008, "Member 'FDefenceUpgradeConstructionGameplayMessage::TeamId' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeConstructionGameplayMessage, ConstructionInProgress) == 0x000009, "Member 'FDefenceUpgradeConstructionGameplayMessage::ConstructionInProgress' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeConstructionGameplayMessage, TargetObject) == 0x00000C, "Member 'FDefenceUpgradeConstructionGameplayMessage::TargetObject' has a wrong offset!");

// ScriptStruct JP.ObjectiveTracker
// 0x0010 (0x0010 - 0x0000)
struct FObjectiveTracker final
{
public:
	class UObjectiveDefinition*                   TrackedObjective;                                  // 0x0000(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerStateJP*                         TrackingPlayer;                                    // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveTracker) == 0x000008, "Wrong alignment on FObjectiveTracker");
static_assert(sizeof(FObjectiveTracker) == 0x000010, "Wrong size on FObjectiveTracker");
static_assert(offsetof(FObjectiveTracker, TrackedObjective) == 0x000000, "Member 'FObjectiveTracker::TrackedObjective' has a wrong offset!");
static_assert(offsetof(FObjectiveTracker, TrackingPlayer) == 0x000008, "Member 'FObjectiveTracker::TrackingPlayer' has a wrong offset!");

// ScriptStruct JP.ObjectiveAndOwningPlayer
// 0x0010 (0x0010 - 0x0000)
struct FObjectiveAndOwningPlayer final
{
public:
	class UObjectiveDefinition*                   ObjectiveDefinition;                               // 0x0000(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerStateJP_Match*                   PlayerState;                                       // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveAndOwningPlayer) == 0x000008, "Wrong alignment on FObjectiveAndOwningPlayer");
static_assert(sizeof(FObjectiveAndOwningPlayer) == 0x000010, "Wrong size on FObjectiveAndOwningPlayer");
static_assert(offsetof(FObjectiveAndOwningPlayer, ObjectiveDefinition) == 0x000000, "Member 'FObjectiveAndOwningPlayer::ObjectiveDefinition' has a wrong offset!");
static_assert(offsetof(FObjectiveAndOwningPlayer, PlayerState) == 0x000008, "Member 'FObjectiveAndOwningPlayer::PlayerState' has a wrong offset!");

// ScriptStruct JP.BattlePassConfiguration
// 0x0040 (0x0040 - 0x0000)
struct FBattlePassConfiguration final
{
public:
	class FText                                   SeasonName;                                        // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SeasonDescription;                                 // 0x0010(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FDateTime                              SeasonStartTimestamp;                              // 0x0020(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              SeasonEndTimestamp;                                // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FBattlePassLevelRewards>        BattlePassLevels;                                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBattlePassConfiguration) == 0x000008, "Wrong alignment on FBattlePassConfiguration");
static_assert(sizeof(FBattlePassConfiguration) == 0x000040, "Wrong size on FBattlePassConfiguration");
static_assert(offsetof(FBattlePassConfiguration, SeasonName) == 0x000000, "Member 'FBattlePassConfiguration::SeasonName' has a wrong offset!");
static_assert(offsetof(FBattlePassConfiguration, SeasonDescription) == 0x000010, "Member 'FBattlePassConfiguration::SeasonDescription' has a wrong offset!");
static_assert(offsetof(FBattlePassConfiguration, SeasonStartTimestamp) == 0x000020, "Member 'FBattlePassConfiguration::SeasonStartTimestamp' has a wrong offset!");
static_assert(offsetof(FBattlePassConfiguration, SeasonEndTimestamp) == 0x000028, "Member 'FBattlePassConfiguration::SeasonEndTimestamp' has a wrong offset!");
static_assert(offsetof(FBattlePassConfiguration, BattlePassLevels) == 0x000030, "Member 'FBattlePassConfiguration::BattlePassLevels' has a wrong offset!");

// ScriptStruct JP.UEmoteWheelEntryData
// 0x0050 (0x0050 - 0x0000)
struct FUEmoteWheelEntryData final
{
public:
	TSubclassOf<class UGameplayAbility>           EmoteAbility;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Name;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUEmoteWheelEntryData) == 0x000008, "Wrong alignment on FUEmoteWheelEntryData");
static_assert(sizeof(FUEmoteWheelEntryData) == 0x000050, "Wrong size on FUEmoteWheelEntryData");
static_assert(offsetof(FUEmoteWheelEntryData, EmoteAbility) == 0x000000, "Member 'FUEmoteWheelEntryData::EmoteAbility' has a wrong offset!");
static_assert(offsetof(FUEmoteWheelEntryData, Icon) == 0x000008, "Member 'FUEmoteWheelEntryData::Icon' has a wrong offset!");
static_assert(offsetof(FUEmoteWheelEntryData, Name) == 0x000030, "Member 'FUEmoteWheelEntryData::Name' has a wrong offset!");
static_assert(offsetof(FUEmoteWheelEntryData, Description) == 0x000040, "Member 'FUEmoteWheelEntryData::Description' has a wrong offset!");

// ScriptStruct JP.CharacterId
// 0x0008 (0x0008 - 0x0000)
struct FCharacterId final
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCharacterId) == 0x000004, "Wrong alignment on FCharacterId");
static_assert(sizeof(FCharacterId) == 0x000008, "Wrong size on FCharacterId");
static_assert(offsetof(FCharacterId, Tag) == 0x000000, "Member 'FCharacterId::Tag' has a wrong offset!");

// ScriptStruct JP.NeighborCosmeticsOnlineServicesDataContainer
// 0x0070 (0x0070 - 0x0000)
struct alignas(0x08) FNeighborCosmeticsOnlineServicesDataContainer final
{
public:
	struct FGameplayTag                           NeighborID;                                        // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x68];                                       // 0x0008(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNeighborCosmeticsOnlineServicesDataContainer) == 0x000008, "Wrong alignment on FNeighborCosmeticsOnlineServicesDataContainer");
static_assert(sizeof(FNeighborCosmeticsOnlineServicesDataContainer) == 0x000070, "Wrong size on FNeighborCosmeticsOnlineServicesDataContainer");
static_assert(offsetof(FNeighborCosmeticsOnlineServicesDataContainer, NeighborID) == 0x000000, "Member 'FNeighborCosmeticsOnlineServicesDataContainer::NeighborID' has a wrong offset!");

// ScriptStruct JP.RewardsConfig
// 0x0001 (0x0001 - 0x0000)
struct FRewardsConfig final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRewardsConfig) == 0x000001, "Wrong alignment on FRewardsConfig");
static_assert(sizeof(FRewardsConfig) == 0x000001, "Wrong size on FRewardsConfig");

// ScriptStruct JP.InflightRewards
// 0x0001 (0x0001 - 0x0000)
struct FInflightRewards final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FInflightRewards) == 0x000001, "Wrong alignment on FInflightRewards");
static_assert(sizeof(FInflightRewards) == 0x000001, "Wrong size on FInflightRewards");

// ScriptStruct JP.DefenceUpgradeGameplayMessage
// 0x0028 (0x0028 - 0x0000)
struct FDefenceUpgradeGameplayMessage final
{
public:
	struct FGameplayTag                           UpgradeGroup;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewUpgradeLevel;                                   // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                UpgradeOrigin;                                     // 0x0010(0x0018)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefenceUpgradeGameplayMessage) == 0x000008, "Wrong alignment on FDefenceUpgradeGameplayMessage");
static_assert(sizeof(FDefenceUpgradeGameplayMessage) == 0x000028, "Wrong size on FDefenceUpgradeGameplayMessage");
static_assert(offsetof(FDefenceUpgradeGameplayMessage, UpgradeGroup) == 0x000000, "Member 'FDefenceUpgradeGameplayMessage::UpgradeGroup' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeGameplayMessage, TeamId) == 0x000008, "Member 'FDefenceUpgradeGameplayMessage::TeamId' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeGameplayMessage, NewUpgradeLevel) == 0x000009, "Member 'FDefenceUpgradeGameplayMessage::NewUpgradeLevel' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeGameplayMessage, UpgradeOrigin) == 0x000010, "Member 'FDefenceUpgradeGameplayMessage::UpgradeOrigin' has a wrong offset!");

// ScriptStruct JP.DefenceUpgradeHoverGameplayMessage
// 0x0014 (0x0014 - 0x0000)
struct FDefenceUpgradeHoverGameplayMessage final
{
public:
	struct FGameplayTag                           UpgradeGroup;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHovered;                                         // 0x0009(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UObject>                 TargetObject;                                      // 0x000C(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDefenceUpgradeHoverGameplayMessage) == 0x000004, "Wrong alignment on FDefenceUpgradeHoverGameplayMessage");
static_assert(sizeof(FDefenceUpgradeHoverGameplayMessage) == 0x000014, "Wrong size on FDefenceUpgradeHoverGameplayMessage");
static_assert(offsetof(FDefenceUpgradeHoverGameplayMessage, UpgradeGroup) == 0x000000, "Member 'FDefenceUpgradeHoverGameplayMessage::UpgradeGroup' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeHoverGameplayMessage, TeamId) == 0x000008, "Member 'FDefenceUpgradeHoverGameplayMessage::TeamId' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeHoverGameplayMessage, IsHovered) == 0x000009, "Member 'FDefenceUpgradeHoverGameplayMessage::IsHovered' has a wrong offset!");
static_assert(offsetof(FDefenceUpgradeHoverGameplayMessage, TargetObject) == 0x00000C, "Member 'FDefenceUpgradeHoverGameplayMessage::TargetObject' has a wrong offset!");

// ScriptStruct JP.EconomyPayload
// 0x0010 (0x0010 - 0x0000)
struct FEconomyPayload final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerEconomy*                         PlayerEconomy;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEconomyPayload) == 0x000008, "Wrong alignment on FEconomyPayload");
static_assert(sizeof(FEconomyPayload) == 0x000010, "Wrong size on FEconomyPayload");
static_assert(offsetof(FEconomyPayload, Owner) == 0x000000, "Member 'FEconomyPayload::Owner' has a wrong offset!");
static_assert(offsetof(FEconomyPayload, PlayerEconomy) == 0x000008, "Member 'FEconomyPayload::PlayerEconomy' has a wrong offset!");

// ScriptStruct JP.EndOfMatchGrantedCurrency
// 0x0018 (0x0018 - 0x0000)
struct FEndOfMatchGrantedCurrency final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0010(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FEndOfMatchGrantedCurrency) == 0x000008, "Wrong alignment on FEndOfMatchGrantedCurrency");
static_assert(sizeof(FEndOfMatchGrantedCurrency) == 0x000018, "Wrong size on FEndOfMatchGrantedCurrency");
static_assert(offsetof(FEndOfMatchGrantedCurrency, ID) == 0x000000, "Member 'FEndOfMatchGrantedCurrency::ID' has a wrong offset!");
static_assert(offsetof(FEndOfMatchGrantedCurrency, Amount) == 0x000010, "Member 'FEndOfMatchGrantedCurrency::Amount' has a wrong offset!");

// ScriptStruct JP.EndOfMatchRewardsResult
// 0x0020 (0x0020 - 0x0000)
struct FEndOfMatchRewardsResult final
{
public:
	TArray<struct FEndOfMatchGrantedCurrency>     GrantedCurrencies;                                 // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FEndOfMatchGrantedStatistic>    GrantedStatistics;                                 // 0x0010(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEndOfMatchRewardsResult) == 0x000008, "Wrong alignment on FEndOfMatchRewardsResult");
static_assert(sizeof(FEndOfMatchRewardsResult) == 0x000020, "Wrong size on FEndOfMatchRewardsResult");
static_assert(offsetof(FEndOfMatchRewardsResult, GrantedCurrencies) == 0x000000, "Member 'FEndOfMatchRewardsResult::GrantedCurrencies' has a wrong offset!");
static_assert(offsetof(FEndOfMatchRewardsResult, GrantedStatistics) == 0x000010, "Member 'FEndOfMatchRewardsResult::GrantedStatistics' has a wrong offset!");

// ScriptStruct JP.EnvironmentDefinition
// 0x0020 (0x0020 - 0x0000)
struct FEnvironmentDefinition final
{
public:
	class FString                                 TitleId;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEnvironmentDefinition) == 0x000008, "Wrong alignment on FEnvironmentDefinition");
static_assert(sizeof(FEnvironmentDefinition) == 0x000020, "Wrong size on FEnvironmentDefinition");
static_assert(offsetof(FEnvironmentDefinition, TitleId) == 0x000000, "Member 'FEnvironmentDefinition::TitleId' has a wrong offset!");
static_assert(offsetof(FEnvironmentDefinition, Name) == 0x000010, "Member 'FEnvironmentDefinition::Name' has a wrong offset!");

// ScriptStruct JP.DeployabeLegality
// 0x000B (0x000B - 0x0000)
struct FDeployabeLegality final
{
public:
	bool                                          TraceHit;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IllegalPhysicsMaterial;                            // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CollisionBetweenPoints;                            // 0x0002(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Length;                                            // 0x0003(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          PreviewMeshCollision;                              // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Angle;                                             // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Team;                                              // 0x0006(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotOnEnemyTeam;                                    // 0x0007(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotInsideBlocker;                                  // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          NotBlockedByDynamic;                               // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AboveMinimumHeight;                                // 0x000A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FDeployabeLegality) == 0x000001, "Wrong alignment on FDeployabeLegality");
static_assert(sizeof(FDeployabeLegality) == 0x00000B, "Wrong size on FDeployabeLegality");
static_assert(offsetof(FDeployabeLegality, TraceHit) == 0x000000, "Member 'FDeployabeLegality::TraceHit' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, IllegalPhysicsMaterial) == 0x000001, "Member 'FDeployabeLegality::IllegalPhysicsMaterial' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, CollisionBetweenPoints) == 0x000002, "Member 'FDeployabeLegality::CollisionBetweenPoints' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, Length) == 0x000003, "Member 'FDeployabeLegality::Length' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, PreviewMeshCollision) == 0x000004, "Member 'FDeployabeLegality::PreviewMeshCollision' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, Angle) == 0x000005, "Member 'FDeployabeLegality::Angle' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, Team) == 0x000006, "Member 'FDeployabeLegality::Team' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, NotOnEnemyTeam) == 0x000007, "Member 'FDeployabeLegality::NotOnEnemyTeam' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, NotInsideBlocker) == 0x000008, "Member 'FDeployabeLegality::NotInsideBlocker' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, NotBlockedByDynamic) == 0x000009, "Member 'FDeployabeLegality::NotBlockedByDynamic' has a wrong offset!");
static_assert(offsetof(FDeployabeLegality, AboveMinimumHeight) == 0x00000A, "Member 'FDeployabeLegality::AboveMinimumHeight' has a wrong offset!");

// ScriptStruct JP.KillData
// 0x00C0 (0x00C0 - 0x0000)
struct FKillData final
{
public:
	EDeathType                                    Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              AttackerIcon;                                      // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   AttackerName;                                      // 0x0030(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         AttackerTeam;                                      // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ActionText;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ActionIcon;                                        // 0x0058(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              ReceiverIcon;                                      // 0x0080(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReceiverName;                                      // 0x00A8(0x0010)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         ReceiverTeam;                                      // 0x00B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillData) == 0x000008, "Wrong alignment on FKillData");
static_assert(sizeof(FKillData) == 0x0000C0, "Wrong size on FKillData");
static_assert(offsetof(FKillData, Type) == 0x000000, "Member 'FKillData::Type' has a wrong offset!");
static_assert(offsetof(FKillData, AttackerIcon) == 0x000008, "Member 'FKillData::AttackerIcon' has a wrong offset!");
static_assert(offsetof(FKillData, AttackerName) == 0x000030, "Member 'FKillData::AttackerName' has a wrong offset!");
static_assert(offsetof(FKillData, AttackerTeam) == 0x000040, "Member 'FKillData::AttackerTeam' has a wrong offset!");
static_assert(offsetof(FKillData, ActionText) == 0x000048, "Member 'FKillData::ActionText' has a wrong offset!");
static_assert(offsetof(FKillData, ActionIcon) == 0x000058, "Member 'FKillData::ActionIcon' has a wrong offset!");
static_assert(offsetof(FKillData, ReceiverIcon) == 0x000080, "Member 'FKillData::ReceiverIcon' has a wrong offset!");
static_assert(offsetof(FKillData, ReceiverName) == 0x0000A8, "Member 'FKillData::ReceiverName' has a wrong offset!");
static_assert(offsetof(FKillData, ReceiverTeam) == 0x0000B8, "Member 'FKillData::ReceiverTeam' has a wrong offset!");

// ScriptStruct JP.OnlineLanguageChangedPayload
// 0x0001 (0x0001 - 0x0000)
struct FOnlineLanguageChangedPayload final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnlineLanguageChangedPayload) == 0x000001, "Wrong alignment on FOnlineLanguageChangedPayload");
static_assert(sizeof(FOnlineLanguageChangedPayload) == 0x000001, "Wrong size on FOnlineLanguageChangedPayload");

// ScriptStruct JP.HouseOnlineServicesData
// 0x0008 (0x0008 - 0x0000)
struct FHouseOnlineServicesData final
{
public:
	struct FGameplayTag                           Identifier;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseOnlineServicesData) == 0x000004, "Wrong alignment on FHouseOnlineServicesData");
static_assert(sizeof(FHouseOnlineServicesData) == 0x000008, "Wrong size on FHouseOnlineServicesData");
static_assert(offsetof(FHouseOnlineServicesData, Identifier) == 0x000000, "Member 'FHouseOnlineServicesData::Identifier' has a wrong offset!");

// ScriptStruct JP.HouseOnlineServicesContainer
// 0x0010 (0x0010 - 0x0000)
struct FHouseOnlineServicesContainer final
{
public:
	TArray<struct FHouseOnlineServicesData>       Houses;                                            // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseOnlineServicesContainer) == 0x000008, "Wrong alignment on FHouseOnlineServicesContainer");
static_assert(sizeof(FHouseOnlineServicesContainer) == 0x000010, "Wrong size on FHouseOnlineServicesContainer");
static_assert(offsetof(FHouseOnlineServicesContainer, Houses) == 0x000000, "Member 'FHouseOnlineServicesContainer::Houses' has a wrong offset!");

// ScriptStruct JP.HouseVotePopupEntryViewModel
// 0x000C (0x000C - 0x0000)
struct FHouseVotePopupEntryViewModel final
{
public:
	struct FGameplayTag                           HouseIdentifier;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Votes;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FHouseVotePopupEntryViewModel) == 0x000004, "Wrong alignment on FHouseVotePopupEntryViewModel");
static_assert(sizeof(FHouseVotePopupEntryViewModel) == 0x00000C, "Wrong size on FHouseVotePopupEntryViewModel");
static_assert(offsetof(FHouseVotePopupEntryViewModel, HouseIdentifier) == 0x000000, "Member 'FHouseVotePopupEntryViewModel::HouseIdentifier' has a wrong offset!");
static_assert(offsetof(FHouseVotePopupEntryViewModel, Votes) == 0x000008, "Member 'FHouseVotePopupEntryViewModel::Votes' has a wrong offset!");

// ScriptStruct JP.ItemWheelInfo
// 0x0020 (0x0020 - 0x0000)
struct FItemWheelInfo final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, NativeAccessSpecifierPublic)
	class UItemInstance*                          Item;                                              // 0x0010(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AmountTag;                                         // 0x0018(0x0008)(BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemWheelInfo) == 0x000008, "Wrong alignment on FItemWheelInfo");
static_assert(sizeof(FItemWheelInfo) == 0x000020, "Wrong size on FItemWheelInfo");
static_assert(offsetof(FItemWheelInfo, DisplayName) == 0x000000, "Member 'FItemWheelInfo::DisplayName' has a wrong offset!");
static_assert(offsetof(FItemWheelInfo, Item) == 0x000010, "Member 'FItemWheelInfo::Item' has a wrong offset!");
static_assert(offsetof(FItemWheelInfo, AmountTag) == 0x000018, "Member 'FItemWheelInfo::AmountTag' has a wrong offset!");

// ScriptStruct JP.ItemInformationRow
// 0x0070 (0x0078 - 0x0008)
struct FItemInformationRow final : public FTableRowBase
{
public:
	TSoftClassPtr<class UClass>                   PickupType;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemDefinition>         ItemType;                                          // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Mouse1Descriptor;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Mouse2Descriptor;                                  // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FItemInformationRow) == 0x000008, "Wrong alignment on FItemInformationRow");
static_assert(sizeof(FItemInformationRow) == 0x000078, "Wrong size on FItemInformationRow");
static_assert(offsetof(FItemInformationRow, PickupType) == 0x000008, "Member 'FItemInformationRow::PickupType' has a wrong offset!");
static_assert(offsetof(FItemInformationRow, ItemType) == 0x000030, "Member 'FItemInformationRow::ItemType' has a wrong offset!");
static_assert(offsetof(FItemInformationRow, Mouse1Descriptor) == 0x000058, "Member 'FItemInformationRow::Mouse1Descriptor' has a wrong offset!");
static_assert(offsetof(FItemInformationRow, Mouse2Descriptor) == 0x000068, "Member 'FItemInformationRow::Mouse2Descriptor' has a wrong offset!");

// ScriptStruct JP.JPTabPanelViewModel
// 0x0018 (0x0018 - 0x0000)
struct FJPTabPanelViewModel final
{
public:
	int32                                         InDirection;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FJPTabPanelViewModel) == 0x000008, "Wrong alignment on FJPTabPanelViewModel");
static_assert(sizeof(FJPTabPanelViewModel) == 0x000018, "Wrong size on FJPTabPanelViewModel");
static_assert(offsetof(FJPTabPanelViewModel, InDirection) == 0x000000, "Member 'FJPTabPanelViewModel::InDirection' has a wrong offset!");
static_assert(offsetof(FJPTabPanelViewModel, Title) == 0x000008, "Member 'FJPTabPanelViewModel::Title' has a wrong offset!");

// ScriptStruct JP.KillInfo
// 0x03D8 (0x03D8 - 0x0000)
struct FKillInfo final
{
public:
	struct FCombatParticipant                     Killer;                                            // 0x0000(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FCombatParticipant>             HealAssisters;                                     // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FCombatParticipant>             DeathAssisters;                                    // 0x0070(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCombatParticipant                     Victim;                                            // 0x0080(0x0060)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	struct FKillMethod                            Method;                                            // 0x00E0(0x02E8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<class UKillCircumstance*>              Circumstances;                                     // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillInfo) == 0x000008, "Wrong alignment on FKillInfo");
static_assert(sizeof(FKillInfo) == 0x0003D8, "Wrong size on FKillInfo");
static_assert(offsetof(FKillInfo, Killer) == 0x000000, "Member 'FKillInfo::Killer' has a wrong offset!");
static_assert(offsetof(FKillInfo, HealAssisters) == 0x000060, "Member 'FKillInfo::HealAssisters' has a wrong offset!");
static_assert(offsetof(FKillInfo, DeathAssisters) == 0x000070, "Member 'FKillInfo::DeathAssisters' has a wrong offset!");
static_assert(offsetof(FKillInfo, Victim) == 0x000080, "Member 'FKillInfo::Victim' has a wrong offset!");
static_assert(offsetof(FKillInfo, Method) == 0x0000E0, "Member 'FKillInfo::Method' has a wrong offset!");
static_assert(offsetof(FKillInfo, Circumstances) == 0x0003C8, "Member 'FKillInfo::Circumstances' has a wrong offset!");

// ScriptStruct JP.KillGameplayMessage
// 0x03D8 (0x03D8 - 0x0000)
struct FKillGameplayMessage final
{
public:
	struct FKillInfo                              KillInfo;                                          // 0x0000(0x03D8)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillGameplayMessage) == 0x000008, "Wrong alignment on FKillGameplayMessage");
static_assert(sizeof(FKillGameplayMessage) == 0x0003D8, "Wrong size on FKillGameplayMessage");
static_assert(offsetof(FKillGameplayMessage, KillInfo) == 0x000000, "Member 'FKillGameplayMessage::KillInfo' has a wrong offset!");

// ScriptStruct JP.KillReward
// 0x0018 (0x0018 - 0x0000)
struct FKillReward final
{
public:
	struct FGameplayTag                           KillerType;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           VictimType;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEconomyDefinition*                     Reward;                                            // 0x0010(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FKillReward) == 0x000008, "Wrong alignment on FKillReward");
static_assert(sizeof(FKillReward) == 0x000018, "Wrong size on FKillReward");
static_assert(offsetof(FKillReward, KillerType) == 0x000000, "Member 'FKillReward::KillerType' has a wrong offset!");
static_assert(offsetof(FKillReward, VictimType) == 0x000008, "Member 'FKillReward::VictimType' has a wrong offset!");
static_assert(offsetof(FKillReward, Reward) == 0x000010, "Member 'FKillReward::Reward' has a wrong offset!");

// ScriptStruct JP.KillTelemetryData
// 0x0048 (0x0048 - 0x0000)
struct FKillTelemetryData final
{
public:
	struct FGameplayTag                           VictimCharacter;                                   // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           KillerCharacter;                                   // 0x0008(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KillerItem;                                        // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KillerAbility;                                     // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 KillerEffect;                                      // 0x0030(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchDuration;                                     // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FKillTelemetryData) == 0x000008, "Wrong alignment on FKillTelemetryData");
static_assert(sizeof(FKillTelemetryData) == 0x000048, "Wrong size on FKillTelemetryData");
static_assert(offsetof(FKillTelemetryData, VictimCharacter) == 0x000000, "Member 'FKillTelemetryData::VictimCharacter' has a wrong offset!");
static_assert(offsetof(FKillTelemetryData, KillerCharacter) == 0x000008, "Member 'FKillTelemetryData::KillerCharacter' has a wrong offset!");
static_assert(offsetof(FKillTelemetryData, KillerItem) == 0x000010, "Member 'FKillTelemetryData::KillerItem' has a wrong offset!");
static_assert(offsetof(FKillTelemetryData, KillerAbility) == 0x000020, "Member 'FKillTelemetryData::KillerAbility' has a wrong offset!");
static_assert(offsetof(FKillTelemetryData, KillerEffect) == 0x000030, "Member 'FKillTelemetryData::KillerEffect' has a wrong offset!");
static_assert(offsetof(FKillTelemetryData, MatchDuration) == 0x000040, "Member 'FKillTelemetryData::MatchDuration' has a wrong offset!");

// ScriptStruct JP.LevelProgressionData
// 0x0008 (0x0008 - 0x0000)
struct FLevelProgressionData final
{
public:
	float                                         BaseLevelRequirement;                              // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         XPRequirementIncrement;                            // 0x0004(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLevelProgressionData) == 0x000004, "Wrong alignment on FLevelProgressionData");
static_assert(sizeof(FLevelProgressionData) == 0x000008, "Wrong size on FLevelProgressionData");
static_assert(offsetof(FLevelProgressionData, BaseLevelRequirement) == 0x000000, "Member 'FLevelProgressionData::BaseLevelRequirement' has a wrong offset!");
static_assert(offsetof(FLevelProgressionData, XPRequirementIncrement) == 0x000004, "Member 'FLevelProgressionData::XPRequirementIncrement' has a wrong offset!");

// ScriptStruct JP.PlayFabEntity
// 0x0020 (0x0020 - 0x0000)
struct FPlayFabEntity final
{
public:
	class FString                                 ID;                                                // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Type;                                              // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayFabEntity) == 0x000008, "Wrong alignment on FPlayFabEntity");
static_assert(sizeof(FPlayFabEntity) == 0x000020, "Wrong size on FPlayFabEntity");
static_assert(offsetof(FPlayFabEntity, ID) == 0x000000, "Member 'FPlayFabEntity::ID' has a wrong offset!");
static_assert(offsetof(FPlayFabEntity, Type) == 0x000010, "Member 'FPlayFabEntity::Type' has a wrong offset!");

// ScriptStruct JP.TicketMemberAttributes
// 0x0018 (0x0018 - 0x0000)
struct FTicketMemberAttributes final
{
public:
	struct FTicketMemberAttributesDataObject      DataObject;                                        // 0x0000(0x0018)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FTicketMemberAttributes) == 0x000008, "Wrong alignment on FTicketMemberAttributes");
static_assert(sizeof(FTicketMemberAttributes) == 0x000018, "Wrong size on FTicketMemberAttributes");
static_assert(offsetof(FTicketMemberAttributes, DataObject) == 0x000000, "Member 'FTicketMemberAttributes::DataObject' has a wrong offset!");

// ScriptStruct JP.TicketMember
// 0x0058 (0x0058 - 0x0000)
struct FTicketMember final
{
public:
	struct FTicketMemberAttributes                Attributes;                                        // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	struct FPlayFabEntity                         Entity;                                            // 0x0018(0x0020)(NativeAccessSpecifierPublic)
	class FString                                 EOS_ID;                                            // 0x0038(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TeamId;                                            // 0x0048(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTicketMember) == 0x000008, "Wrong alignment on FTicketMember");
static_assert(sizeof(FTicketMember) == 0x000058, "Wrong size on FTicketMember");
static_assert(offsetof(FTicketMember, Attributes) == 0x000000, "Member 'FTicketMember::Attributes' has a wrong offset!");
static_assert(offsetof(FTicketMember, Entity) == 0x000018, "Member 'FTicketMember::Entity' has a wrong offset!");
static_assert(offsetof(FTicketMember, EOS_ID) == 0x000038, "Member 'FTicketMember::EOS_ID' has a wrong offset!");
static_assert(offsetof(FTicketMember, TeamId) == 0x000048, "Member 'FTicketMember::TeamId' has a wrong offset!");

// ScriptStruct JP.ServerDetails
// 0x0010 (0x0010 - 0x0000)
struct FServerDetails final
{
public:
	class FString                                 IPV4Address;                                       // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FServerDetails) == 0x000008, "Wrong alignment on FServerDetails");
static_assert(sizeof(FServerDetails) == 0x000010, "Wrong size on FServerDetails");
static_assert(offsetof(FServerDetails, IPV4Address) == 0x000000, "Member 'FServerDetails::IPV4Address' has a wrong offset!");

// ScriptStruct JP.CreateBackfillTicketFunctionArguments
// 0x0038 (0x0038 - 0x0000)
struct FCreateBackfillTicketFunctionArguments final
{
public:
	TArray<struct FTicketMember>                  Members;                                           // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	struct FServerDetails                         ServerDetails;                                     // 0x0010(0x0010)(NativeAccessSpecifierPublic)
	int32                                         GiveUpAfterSeconds;                                // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 QueueName;                                         // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCreateBackfillTicketFunctionArguments) == 0x000008, "Wrong alignment on FCreateBackfillTicketFunctionArguments");
static_assert(sizeof(FCreateBackfillTicketFunctionArguments) == 0x000038, "Wrong size on FCreateBackfillTicketFunctionArguments");
static_assert(offsetof(FCreateBackfillTicketFunctionArguments, Members) == 0x000000, "Member 'FCreateBackfillTicketFunctionArguments::Members' has a wrong offset!");
static_assert(offsetof(FCreateBackfillTicketFunctionArguments, ServerDetails) == 0x000010, "Member 'FCreateBackfillTicketFunctionArguments::ServerDetails' has a wrong offset!");
static_assert(offsetof(FCreateBackfillTicketFunctionArguments, GiveUpAfterSeconds) == 0x000020, "Member 'FCreateBackfillTicketFunctionArguments::GiveUpAfterSeconds' has a wrong offset!");
static_assert(offsetof(FCreateBackfillTicketFunctionArguments, QueueName) == 0x000028, "Member 'FCreateBackfillTicketFunctionArguments::QueueName' has a wrong offset!");

// ScriptStruct JP.GetBackfillTicketFunctionArguments
// 0x0020 (0x0020 - 0x0000)
struct FGetBackfillTicketFunctionArguments final
{
public:
	class FString                                 TicketId;                                          // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QueueName;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FGetBackfillTicketFunctionArguments) == 0x000008, "Wrong alignment on FGetBackfillTicketFunctionArguments");
static_assert(sizeof(FGetBackfillTicketFunctionArguments) == 0x000020, "Wrong size on FGetBackfillTicketFunctionArguments");
static_assert(offsetof(FGetBackfillTicketFunctionArguments, TicketId) == 0x000000, "Member 'FGetBackfillTicketFunctionArguments::TicketId' has a wrong offset!");
static_assert(offsetof(FGetBackfillTicketFunctionArguments, QueueName) == 0x000010, "Member 'FGetBackfillTicketFunctionArguments::QueueName' has a wrong offset!");

// ScriptStruct JP.LobbyConfiguration
// 0x0038 (0x0038 - 0x0000)
struct FLobbyConfiguration final
{
public:
	bool                                          bIsQuickPlayMatch;                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 LobbyName;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCustomMatchConfiguration;                   // 0x0018(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TeamSize;                                          // 0x001C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Teams;                                             // 0x0020(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInviteOnly;                                       // 0x0024(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLANOnly;                                          // 0x0025(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowJoinInProgress;                              // 0x0026(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePasswordProtected;                          // 0x0027(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Password;                                          // 0x0028(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyConfiguration) == 0x000008, "Wrong alignment on FLobbyConfiguration");
static_assert(sizeof(FLobbyConfiguration) == 0x000038, "Wrong size on FLobbyConfiguration");
static_assert(offsetof(FLobbyConfiguration, bIsQuickPlayMatch) == 0x000000, "Member 'FLobbyConfiguration::bIsQuickPlayMatch' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, LobbyName) == 0x000008, "Member 'FLobbyConfiguration::LobbyName' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, bEnableCustomMatchConfiguration) == 0x000018, "Member 'FLobbyConfiguration::bEnableCustomMatchConfiguration' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, TeamSize) == 0x00001C, "Member 'FLobbyConfiguration::TeamSize' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, Teams) == 0x000020, "Member 'FLobbyConfiguration::Teams' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, bInviteOnly) == 0x000024, "Member 'FLobbyConfiguration::bInviteOnly' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, bLANOnly) == 0x000025, "Member 'FLobbyConfiguration::bLANOnly' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, bAllowJoinInProgress) == 0x000026, "Member 'FLobbyConfiguration::bAllowJoinInProgress' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, bEnablePasswordProtected) == 0x000027, "Member 'FLobbyConfiguration::bEnablePasswordProtected' has a wrong offset!");
static_assert(offsetof(FLobbyConfiguration, Password) == 0x000028, "Member 'FLobbyConfiguration::Password' has a wrong offset!");

// ScriptStruct JP.LobbyConfigurationSummaryViewModel
// 0x0001 (0x0001 - 0x0000)
struct FLobbyConfigurationSummaryViewModel final
{
public:
	bool                                          bCanUserEdit;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyConfigurationSummaryViewModel) == 0x000001, "Wrong alignment on FLobbyConfigurationSummaryViewModel");
static_assert(sizeof(FLobbyConfigurationSummaryViewModel) == 0x000001, "Wrong size on FLobbyConfigurationSummaryViewModel");
static_assert(offsetof(FLobbyConfigurationSummaryViewModel, bCanUserEdit) == 0x000000, "Member 'FLobbyConfigurationSummaryViewModel::bCanUserEdit' has a wrong offset!");

// ScriptStruct JP.LobbyConfigurationViewModel
// 0x0030 (0x0030 - 0x0000)
struct FLobbyConfigurationViewModel final
{
public:
	class FString                                 LobbyName;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTeamSize;                                       // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInviteOnly;                                       // 0x0014(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLANOnly;                                          // 0x0015(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCustomMatch;                                      // 0x0016(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowJoinInProgress;                              // 0x0017(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePasswordProtected;                          // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Password;                                          // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyConfigurationViewModel) == 0x000008, "Wrong alignment on FLobbyConfigurationViewModel");
static_assert(sizeof(FLobbyConfigurationViewModel) == 0x000030, "Wrong size on FLobbyConfigurationViewModel");
static_assert(offsetof(FLobbyConfigurationViewModel, LobbyName) == 0x000000, "Member 'FLobbyConfigurationViewModel::LobbyName' has a wrong offset!");
static_assert(offsetof(FLobbyConfigurationViewModel, MaxTeamSize) == 0x000010, "Member 'FLobbyConfigurationViewModel::MaxTeamSize' has a wrong offset!");
static_assert(offsetof(FLobbyConfigurationViewModel, bInviteOnly) == 0x000014, "Member 'FLobbyConfigurationViewModel::bInviteOnly' has a wrong offset!");
static_assert(offsetof(FLobbyConfigurationViewModel, bLANOnly) == 0x000015, "Member 'FLobbyConfigurationViewModel::bLANOnly' has a wrong offset!");
static_assert(offsetof(FLobbyConfigurationViewModel, bCustomMatch) == 0x000016, "Member 'FLobbyConfigurationViewModel::bCustomMatch' has a wrong offset!");
static_assert(offsetof(FLobbyConfigurationViewModel, bAllowJoinInProgress) == 0x000017, "Member 'FLobbyConfigurationViewModel::bAllowJoinInProgress' has a wrong offset!");
static_assert(offsetof(FLobbyConfigurationViewModel, bEnablePasswordProtected) == 0x000018, "Member 'FLobbyConfigurationViewModel::bEnablePasswordProtected' has a wrong offset!");
static_assert(offsetof(FLobbyConfigurationViewModel, Password) == 0x000020, "Member 'FLobbyConfigurationViewModel::Password' has a wrong offset!");

// ScriptStruct JP.LobbyHouseSelectorViewModel
// 0x000C (0x000C - 0x0000)
struct FLobbyHouseSelectorViewModel final
{
public:
	struct FGameplayTag                           HouseIdentifier;                                   // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Votes;                                             // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyHouseSelectorViewModel) == 0x000004, "Wrong alignment on FLobbyHouseSelectorViewModel");
static_assert(sizeof(FLobbyHouseSelectorViewModel) == 0x00000C, "Wrong size on FLobbyHouseSelectorViewModel");
static_assert(offsetof(FLobbyHouseSelectorViewModel, HouseIdentifier) == 0x000000, "Member 'FLobbyHouseSelectorViewModel::HouseIdentifier' has a wrong offset!");
static_assert(offsetof(FLobbyHouseSelectorViewModel, Votes) == 0x000008, "Member 'FLobbyHouseSelectorViewModel::Votes' has a wrong offset!");

// ScriptStruct JP.LobbyLevelVoteEntryViewModel
// 0x0040 (0x0040 - 0x0000)
struct FLobbyLevelVoteEntryViewModel final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Image;                                             // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Votes;                                             // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyLevelVoteEntryViewModel) == 0x000008, "Wrong alignment on FLobbyLevelVoteEntryViewModel");
static_assert(sizeof(FLobbyLevelVoteEntryViewModel) == 0x000040, "Wrong size on FLobbyLevelVoteEntryViewModel");
static_assert(offsetof(FLobbyLevelVoteEntryViewModel, DisplayName) == 0x000000, "Member 'FLobbyLevelVoteEntryViewModel::DisplayName' has a wrong offset!");
static_assert(offsetof(FLobbyLevelVoteEntryViewModel, Image) == 0x000010, "Member 'FLobbyLevelVoteEntryViewModel::Image' has a wrong offset!");
static_assert(offsetof(FLobbyLevelVoteEntryViewModel, Votes) == 0x000038, "Member 'FLobbyLevelVoteEntryViewModel::Votes' has a wrong offset!");

// ScriptStruct JP.LobbyLocalPlayerSwitchTeamViewModel
// 0x0002 (0x0002 - 0x0000)
struct FLobbyLocalPlayerSwitchTeamViewModel final
{
public:
	uint8                                         TeamId;                                            // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanChangeTeams;                                   // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyLocalPlayerSwitchTeamViewModel) == 0x000001, "Wrong alignment on FLobbyLocalPlayerSwitchTeamViewModel");
static_assert(sizeof(FLobbyLocalPlayerSwitchTeamViewModel) == 0x000002, "Wrong size on FLobbyLocalPlayerSwitchTeamViewModel");
static_assert(offsetof(FLobbyLocalPlayerSwitchTeamViewModel, TeamId) == 0x000000, "Member 'FLobbyLocalPlayerSwitchTeamViewModel::TeamId' has a wrong offset!");
static_assert(offsetof(FLobbyLocalPlayerSwitchTeamViewModel, bCanChangeTeams) == 0x000001, "Member 'FLobbyLocalPlayerSwitchTeamViewModel::bCanChangeTeams' has a wrong offset!");

// ScriptStruct JP.LobbyNeighborSelectorViewModel
// 0x0048 (0x0048 - 0x0000)
struct FLobbyNeighborSelectorViewModel final
{
public:
	struct FOnlineStoreItemData                   NeighborStoreItem;                                 // 0x0000(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyNeighborSelectorViewModel) == 0x000008, "Wrong alignment on FLobbyNeighborSelectorViewModel");
static_assert(sizeof(FLobbyNeighborSelectorViewModel) == 0x000048, "Wrong size on FLobbyNeighborSelectorViewModel");
static_assert(offsetof(FLobbyNeighborSelectorViewModel, NeighborStoreItem) == 0x000000, "Member 'FLobbyNeighborSelectorViewModel::NeighborStoreItem' has a wrong offset!");

// ScriptStruct JP.LobbyPlayerStateGroup
// 0x0018 (0x0018 - 0x0000)
struct FLobbyPlayerStateGroup final
{
public:
	uint8                                         TeamId;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerStateJP_Lobby*>           PlayerStates;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyPlayerStateGroup) == 0x000008, "Wrong alignment on FLobbyPlayerStateGroup");
static_assert(sizeof(FLobbyPlayerStateGroup) == 0x000018, "Wrong size on FLobbyPlayerStateGroup");
static_assert(offsetof(FLobbyPlayerStateGroup, TeamId) == 0x000000, "Member 'FLobbyPlayerStateGroup::TeamId' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerStateGroup, PlayerStates) == 0x000008, "Member 'FLobbyPlayerStateGroup::PlayerStates' has a wrong offset!");

// ScriptStruct JP.LobbyPlayerAvatarViewModel
// 0x0040 (0x0040 - 0x0000)
struct FLobbyPlayerAvatarViewModel final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0010(0x0028)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsReady;                                           // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInParty;                                         // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsHost;                                            // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyPlayerAvatarViewModel) == 0x000008, "Wrong alignment on FLobbyPlayerAvatarViewModel");
static_assert(sizeof(FLobbyPlayerAvatarViewModel) == 0x000040, "Wrong size on FLobbyPlayerAvatarViewModel");
static_assert(offsetof(FLobbyPlayerAvatarViewModel, Name) == 0x000000, "Member 'FLobbyPlayerAvatarViewModel::Name' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerAvatarViewModel, Icon) == 0x000010, "Member 'FLobbyPlayerAvatarViewModel::Icon' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerAvatarViewModel, IsReady) == 0x000038, "Member 'FLobbyPlayerAvatarViewModel::IsReady' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerAvatarViewModel, IsInParty) == 0x000039, "Member 'FLobbyPlayerAvatarViewModel::IsInParty' has a wrong offset!");
static_assert(offsetof(FLobbyPlayerAvatarViewModel, IsHost) == 0x00003A, "Member 'FLobbyPlayerAvatarViewModel::IsHost' has a wrong offset!");

// ScriptStruct JP.LobbyReadyStateViewModel
// 0x0003 (0x0003 - 0x0000)
struct FLobbyReadyStateViewModel final
{
public:
	bool                                          IsReady;                                           // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanReadyUp;                                        // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CanForceTravel;                                    // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyReadyStateViewModel) == 0x000001, "Wrong alignment on FLobbyReadyStateViewModel");
static_assert(sizeof(FLobbyReadyStateViewModel) == 0x000003, "Wrong size on FLobbyReadyStateViewModel");
static_assert(offsetof(FLobbyReadyStateViewModel, IsReady) == 0x000000, "Member 'FLobbyReadyStateViewModel::IsReady' has a wrong offset!");
static_assert(offsetof(FLobbyReadyStateViewModel, CanReadyUp) == 0x000001, "Member 'FLobbyReadyStateViewModel::CanReadyUp' has a wrong offset!");
static_assert(offsetof(FLobbyReadyStateViewModel, CanForceTravel) == 0x000002, "Member 'FLobbyReadyStateViewModel::CanForceTravel' has a wrong offset!");

// ScriptStruct JP.LobbySearchRequest
// 0x0078 (0x0078 - 0x0000)
struct FLobbySearchRequest final
{
public:
	class FString                                 NameQuery;                                         // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowCustomMatchConfiguration;                     // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<int32>                                   TeamSizes;                                         // 0x0018(0x0050)(NativeAccessSpecifierPublic)
	int32                                         Teams;                                             // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriendsOnly;                                      // 0x006C(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Region;                                            // 0x0070(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbySearchRequest) == 0x000008, "Wrong alignment on FLobbySearchRequest");
static_assert(sizeof(FLobbySearchRequest) == 0x000078, "Wrong size on FLobbySearchRequest");
static_assert(offsetof(FLobbySearchRequest, NameQuery) == 0x000000, "Member 'FLobbySearchRequest::NameQuery' has a wrong offset!");
static_assert(offsetof(FLobbySearchRequest, bShowCustomMatchConfiguration) == 0x000010, "Member 'FLobbySearchRequest::bShowCustomMatchConfiguration' has a wrong offset!");
static_assert(offsetof(FLobbySearchRequest, TeamSizes) == 0x000018, "Member 'FLobbySearchRequest::TeamSizes' has a wrong offset!");
static_assert(offsetof(FLobbySearchRequest, Teams) == 0x000068, "Member 'FLobbySearchRequest::Teams' has a wrong offset!");
static_assert(offsetof(FLobbySearchRequest, bFriendsOnly) == 0x00006C, "Member 'FLobbySearchRequest::bFriendsOnly' has a wrong offset!");
static_assert(offsetof(FLobbySearchRequest, Region) == 0x000070, "Member 'FLobbySearchRequest::Region' has a wrong offset!");

// ScriptStruct JP.LobbyToGameplayLevelTravelDataTeamEntry
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FLobbyToGameplayLevelTravelDataTeamEntry final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyToGameplayLevelTravelDataTeamEntry) == 0x000004, "Wrong alignment on FLobbyToGameplayLevelTravelDataTeamEntry");
static_assert(sizeof(FLobbyToGameplayLevelTravelDataTeamEntry) == 0x00000C, "Wrong size on FLobbyToGameplayLevelTravelDataTeamEntry");

// ScriptStruct JP.LobbyToGameplayLevelTravelData
// 0x0010 (0x0010 - 0x0000)
struct alignas(0x08) FLobbyToGameplayLevelTravelData final
{
public:
	uint8                                         Pad_0[0x10];                                       // 0x0000(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLobbyToGameplayLevelTravelData) == 0x000008, "Wrong alignment on FLobbyToGameplayLevelTravelData");
static_assert(sizeof(FLobbyToGameplayLevelTravelData) == 0x000010, "Wrong size on FLobbyToGameplayLevelTravelData");

// ScriptStruct JP.LobbyCountdownViewModel
// 0x0004 (0x0004 - 0x0000)
struct FLobbyCountdownViewModel final
{
public:
	float                                         EndTimestamp;                                      // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLobbyCountdownViewModel) == 0x000004, "Wrong alignment on FLobbyCountdownViewModel");
static_assert(sizeof(FLobbyCountdownViewModel) == 0x000004, "Wrong size on FLobbyCountdownViewModel");
static_assert(offsetof(FLobbyCountdownViewModel, EndTimestamp) == 0x000000, "Member 'FLobbyCountdownViewModel::EndTimestamp' has a wrong offset!");

// ScriptStruct JP.MappableConfigPair
// 0x0078 (0x0078 - 0x0000)
struct FMappableConfigPair final
{
public:
	TSoftObjectPtr<class UPlayerMappableInputConfig> Config;                                            // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECommonInputType                              Type;                                              // 0x0028(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DependentPlatformTraits;                           // 0x0030(0x0020)(Edit, NativeAccessSpecifierPublic)
	struct FGameplayTagContainer                  ExcludedPlatformTraits;                            // 0x0050(0x0020)(Edit, NativeAccessSpecifierPublic)
	bool                                          bShouldActivateAutomatically;                      // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMappableConfigPair) == 0x000008, "Wrong alignment on FMappableConfigPair");
static_assert(sizeof(FMappableConfigPair) == 0x000078, "Wrong size on FMappableConfigPair");
static_assert(offsetof(FMappableConfigPair, Config) == 0x000000, "Member 'FMappableConfigPair::Config' has a wrong offset!");
static_assert(offsetof(FMappableConfigPair, Type) == 0x000028, "Member 'FMappableConfigPair::Type' has a wrong offset!");
static_assert(offsetof(FMappableConfigPair, DependentPlatformTraits) == 0x000030, "Member 'FMappableConfigPair::DependentPlatformTraits' has a wrong offset!");
static_assert(offsetof(FMappableConfigPair, ExcludedPlatformTraits) == 0x000050, "Member 'FMappableConfigPair::ExcludedPlatformTraits' has a wrong offset!");
static_assert(offsetof(FMappableConfigPair, bShouldActivateAutomatically) == 0x000070, "Member 'FMappableConfigPair::bShouldActivateAutomatically' has a wrong offset!");

// ScriptStruct JP.LyraScalabilitySnapshot
// 0x0060 (0x0060 - 0x0000)
struct alignas(0x08) FLyraScalabilitySnapshot final
{
public:
	uint8                                         Pad_0[0x60];                                       // 0x0000(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLyraScalabilitySnapshot) == 0x000008, "Wrong alignment on FLyraScalabilitySnapshot");
static_assert(sizeof(FLyraScalabilitySnapshot) == 0x000060, "Wrong size on FLyraScalabilitySnapshot");

// ScriptStruct JP.MapData
// 0x0038 (0x0038 - 0x0000)
struct FMapData final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  LevelPtr;                                          // 0x0010(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMapData) == 0x000008, "Wrong alignment on FMapData");
static_assert(sizeof(FMapData) == 0x000038, "Wrong size on FMapData");
static_assert(offsetof(FMapData, DisplayName) == 0x000000, "Member 'FMapData::DisplayName' has a wrong offset!");
static_assert(offsetof(FMapData, LevelPtr) == 0x000010, "Member 'FMapData::LevelPtr' has a wrong offset!");

// ScriptStruct JP.MatchConfiguration
// 0x0058 (0x0058 - 0x0000)
struct FMatchConfiguration final
{
public:
	bool                                          bEnableWarmup;                                     // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarmupDurationMinutes;                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomCharacterSelection;                         // 0x0008(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNeighborDuplicatesAllowed;                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWinConditionDeed;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWinConditionDestruction;                          // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWinConditionTeamDeathmatch;                       // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillCountForWin;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimerMultiplier;                            // 0x0018(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HouseEssentialDestructionAmount;                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingResources;                                 // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialAbilityInitialCooldown;                     // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DayLengthMinutes;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NightLengthMinutes;                                // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuddenDeathEnabled;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuddenDeathMinutes;                                // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGuardDog;                                   // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingMoney;                                     // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PassiveIncome;                                     // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   DisabledItems;                                     // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchConfiguration) == 0x000008, "Wrong alignment on FMatchConfiguration");
static_assert(sizeof(FMatchConfiguration) == 0x000058, "Wrong size on FMatchConfiguration");
static_assert(offsetof(FMatchConfiguration, bEnableWarmup) == 0x000000, "Member 'FMatchConfiguration::bEnableWarmup' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, WarmupDurationMinutes) == 0x000004, "Member 'FMatchConfiguration::WarmupDurationMinutes' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, bRandomCharacterSelection) == 0x000008, "Member 'FMatchConfiguration::bRandomCharacterSelection' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, MaxNeighborDuplicatesAllowed) == 0x00000C, "Member 'FMatchConfiguration::MaxNeighborDuplicatesAllowed' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, bWinConditionDeed) == 0x000010, "Member 'FMatchConfiguration::bWinConditionDeed' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, bWinConditionDestruction) == 0x000011, "Member 'FMatchConfiguration::bWinConditionDestruction' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, bWinConditionTeamDeathmatch) == 0x000012, "Member 'FMatchConfiguration::bWinConditionTeamDeathmatch' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, KillCountForWin) == 0x000014, "Member 'FMatchConfiguration::KillCountForWin' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, RespawnTimerMultiplier) == 0x000018, "Member 'FMatchConfiguration::RespawnTimerMultiplier' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, HouseEssentialDestructionAmount) == 0x00001C, "Member 'FMatchConfiguration::HouseEssentialDestructionAmount' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, StartingResources) == 0x000020, "Member 'FMatchConfiguration::StartingResources' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, SpecialAbilityInitialCooldown) == 0x000024, "Member 'FMatchConfiguration::SpecialAbilityInitialCooldown' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, DayLengthMinutes) == 0x000028, "Member 'FMatchConfiguration::DayLengthMinutes' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, NightLengthMinutes) == 0x00002C, "Member 'FMatchConfiguration::NightLengthMinutes' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, bSuddenDeathEnabled) == 0x000030, "Member 'FMatchConfiguration::bSuddenDeathEnabled' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, SuddenDeathMinutes) == 0x000034, "Member 'FMatchConfiguration::SuddenDeathMinutes' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, bEnableGuardDog) == 0x000038, "Member 'FMatchConfiguration::bEnableGuardDog' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, StartingMoney) == 0x00003C, "Member 'FMatchConfiguration::StartingMoney' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, PassiveIncome) == 0x000040, "Member 'FMatchConfiguration::PassiveIncome' has a wrong offset!");
static_assert(offsetof(FMatchConfiguration, DisabledItems) == 0x000048, "Member 'FMatchConfiguration::DisabledItems' has a wrong offset!");

// ScriptStruct JP.MatchConfigurationViewModel
// 0x0088 (0x0088 - 0x0000)
struct FMatchConfigurationViewModel final
{
public:
	bool                                          bEditable;                                         // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableWarmup;                                     // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WarmupDurationMinutes;                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomCharacterSelection;                         // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxNeighborDuplicatesAllowed;                      // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWinConditionDeed;                                 // 0x0010(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWinConditionDestruction;                          // 0x0011(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWinConditionTeamDeathmatch;                       // 0x0012(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x1];                                       // 0x0013(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         KillCountForWin;                                   // 0x0014(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RespawnTimerMultiplier;                            // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HouseEssentialDestructionAmount;                   // 0x001C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DayLengthMinutes;                                  // 0x0020(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NightLengthMinutes;                                // 0x0024(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSuddenDeathEnabled;                               // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SuddenDeathMinutes;                                // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableGuardDog;                                   // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartingMoney;                                     // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PassiveIncome;                                     // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartingResources;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpecialAbilityInitialCooldown;                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FMatchConfigurationItemViewModel> OffenceItems;                                      // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatchConfigurationItemViewModel> DefenceItems;                                      // 0x0058(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatchConfigurationItemViewModel> SupportItems;                                      // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatchConfigurationItemViewModel> DeliveryItems;                                     // 0x0078(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchConfigurationViewModel) == 0x000008, "Wrong alignment on FMatchConfigurationViewModel");
static_assert(sizeof(FMatchConfigurationViewModel) == 0x000088, "Wrong size on FMatchConfigurationViewModel");
static_assert(offsetof(FMatchConfigurationViewModel, bEditable) == 0x000000, "Member 'FMatchConfigurationViewModel::bEditable' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, bEnableWarmup) == 0x000001, "Member 'FMatchConfigurationViewModel::bEnableWarmup' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, WarmupDurationMinutes) == 0x000004, "Member 'FMatchConfigurationViewModel::WarmupDurationMinutes' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, bRandomCharacterSelection) == 0x000008, "Member 'FMatchConfigurationViewModel::bRandomCharacterSelection' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, MaxNeighborDuplicatesAllowed) == 0x00000C, "Member 'FMatchConfigurationViewModel::MaxNeighborDuplicatesAllowed' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, bWinConditionDeed) == 0x000010, "Member 'FMatchConfigurationViewModel::bWinConditionDeed' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, bWinConditionDestruction) == 0x000011, "Member 'FMatchConfigurationViewModel::bWinConditionDestruction' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, bWinConditionTeamDeathmatch) == 0x000012, "Member 'FMatchConfigurationViewModel::bWinConditionTeamDeathmatch' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, KillCountForWin) == 0x000014, "Member 'FMatchConfigurationViewModel::KillCountForWin' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, RespawnTimerMultiplier) == 0x000018, "Member 'FMatchConfigurationViewModel::RespawnTimerMultiplier' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, HouseEssentialDestructionAmount) == 0x00001C, "Member 'FMatchConfigurationViewModel::HouseEssentialDestructionAmount' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, DayLengthMinutes) == 0x000020, "Member 'FMatchConfigurationViewModel::DayLengthMinutes' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, NightLengthMinutes) == 0x000024, "Member 'FMatchConfigurationViewModel::NightLengthMinutes' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, bSuddenDeathEnabled) == 0x000028, "Member 'FMatchConfigurationViewModel::bSuddenDeathEnabled' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, SuddenDeathMinutes) == 0x00002C, "Member 'FMatchConfigurationViewModel::SuddenDeathMinutes' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, bEnableGuardDog) == 0x000030, "Member 'FMatchConfigurationViewModel::bEnableGuardDog' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, StartingMoney) == 0x000034, "Member 'FMatchConfigurationViewModel::StartingMoney' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, PassiveIncome) == 0x000038, "Member 'FMatchConfigurationViewModel::PassiveIncome' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, StartingResources) == 0x00003C, "Member 'FMatchConfigurationViewModel::StartingResources' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, SpecialAbilityInitialCooldown) == 0x000040, "Member 'FMatchConfigurationViewModel::SpecialAbilityInitialCooldown' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, OffenceItems) == 0x000048, "Member 'FMatchConfigurationViewModel::OffenceItems' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, DefenceItems) == 0x000058, "Member 'FMatchConfigurationViewModel::DefenceItems' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, SupportItems) == 0x000068, "Member 'FMatchConfigurationViewModel::SupportItems' has a wrong offset!");
static_assert(offsetof(FMatchConfigurationViewModel, DeliveryItems) == 0x000078, "Member 'FMatchConfigurationViewModel::DeliveryItems' has a wrong offset!");

// ScriptStruct JP.TeamCustomizationData
// 0x0008 (0x0008 - 0x0000)
struct FTeamCustomizationData final
{
public:
	class FName                                   HouseLevelInstanceName;                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTeamCustomizationData) == 0x000004, "Wrong alignment on FTeamCustomizationData");
static_assert(sizeof(FTeamCustomizationData) == 0x000008, "Wrong size on FTeamCustomizationData");
static_assert(offsetof(FTeamCustomizationData, HouseLevelInstanceName) == 0x000000, "Member 'FTeamCustomizationData::HouseLevelInstanceName' has a wrong offset!");

// ScriptStruct JP.MatchCustomizationData
// 0x0050 (0x0050 - 0x0000)
struct FMatchCustomizationData final
{
public:
	TMap<ETeamType, struct FTeamCustomizationData> TeamSpecificData;                                  // 0x0000(0x0050)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchCustomizationData) == 0x000008, "Wrong alignment on FMatchCustomizationData");
static_assert(sizeof(FMatchCustomizationData) == 0x000050, "Wrong size on FMatchCustomizationData");
static_assert(offsetof(FMatchCustomizationData, TeamSpecificData) == 0x000000, "Member 'FMatchCustomizationData::TeamSpecificData' has a wrong offset!");

// ScriptStruct JP.MatchPlayerStateGroup
// 0x0018 (0x0018 - 0x0000)
struct FMatchPlayerStateGroup final
{
public:
	uint8                                         TeamId;                                            // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APlayerStateJP_Match*>           PlayerStates;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchPlayerStateGroup) == 0x000008, "Wrong alignment on FMatchPlayerStateGroup");
static_assert(sizeof(FMatchPlayerStateGroup) == 0x000018, "Wrong size on FMatchPlayerStateGroup");
static_assert(offsetof(FMatchPlayerStateGroup, TeamId) == 0x000000, "Member 'FMatchPlayerStateGroup::TeamId' has a wrong offset!");
static_assert(offsetof(FMatchPlayerStateGroup, PlayerStates) == 0x000008, "Member 'FMatchPlayerStateGroup::PlayerStates' has a wrong offset!");

// ScriptStruct JP.MatchRewardCurrency
// 0x000C (0x000C - 0x0000)
struct FMatchRewardCurrency final
{
public:
	struct FGameplayTag                           ID;                                                // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchRewardCurrency) == 0x000004, "Wrong alignment on FMatchRewardCurrency");
static_assert(sizeof(FMatchRewardCurrency) == 0x00000C, "Wrong size on FMatchRewardCurrency");
static_assert(offsetof(FMatchRewardCurrency, ID) == 0x000000, "Member 'FMatchRewardCurrency::ID' has a wrong offset!");
static_assert(offsetof(FMatchRewardCurrency, Amount) == 0x000008, "Member 'FMatchRewardCurrency::Amount' has a wrong offset!");

// ScriptStruct JP.MatchRewards
// 0x0020 (0x0020 - 0x0000)
struct FMatchRewards final
{
public:
	TArray<struct FMatchRewardCurrency>           GrantedCurrencies;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         GrantedProfileXP;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NeighborID;                                        // 0x0014(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GrantedNeighborXP;                                 // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchRewards) == 0x000008, "Wrong alignment on FMatchRewards");
static_assert(sizeof(FMatchRewards) == 0x000020, "Wrong size on FMatchRewards");
static_assert(offsetof(FMatchRewards, GrantedCurrencies) == 0x000000, "Member 'FMatchRewards::GrantedCurrencies' has a wrong offset!");
static_assert(offsetof(FMatchRewards, GrantedProfileXP) == 0x000010, "Member 'FMatchRewards::GrantedProfileXP' has a wrong offset!");
static_assert(offsetof(FMatchRewards, NeighborID) == 0x000014, "Member 'FMatchRewards::NeighborID' has a wrong offset!");
static_assert(offsetof(FMatchRewards, GrantedNeighborXP) == 0x00001C, "Member 'FMatchRewards::GrantedNeighborXP' has a wrong offset!");

// ScriptStruct JP.XPUpdateInfo
// 0x0038 (0x0038 - 0x0000)
struct FXPUpdateInfo final
{
public:
	class FString                                 UserId;                                            // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerXPStatCode;                                  // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CharacterXPStatCode;                               // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDidWin;                                           // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FXPUpdateInfo) == 0x000008, "Wrong alignment on FXPUpdateInfo");
static_assert(sizeof(FXPUpdateInfo) == 0x000038, "Wrong size on FXPUpdateInfo");
static_assert(offsetof(FXPUpdateInfo, UserId) == 0x000000, "Member 'FXPUpdateInfo::UserId' has a wrong offset!");
static_assert(offsetof(FXPUpdateInfo, PlayerXPStatCode) == 0x000010, "Member 'FXPUpdateInfo::PlayerXPStatCode' has a wrong offset!");
static_assert(offsetof(FXPUpdateInfo, CharacterXPStatCode) == 0x000020, "Member 'FXPUpdateInfo::CharacterXPStatCode' has a wrong offset!");
static_assert(offsetof(FXPUpdateInfo, bDidWin) == 0x000030, "Member 'FXPUpdateInfo::bDidWin' has a wrong offset!");

// ScriptStruct JP.MatchXPReward
// 0x0060 (0x0060 - 0x0000)
struct FMatchXPReward final
{
public:
	TArray<struct FXPUpdateInfo>                  XPUpdateInfos;                                     // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class APlayerStateJP*, int32>            PlayerRewards;                                     // 0x0010(0x0050)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchXPReward) == 0x000008, "Wrong alignment on FMatchXPReward");
static_assert(sizeof(FMatchXPReward) == 0x000060, "Wrong size on FMatchXPReward");
static_assert(offsetof(FMatchXPReward, XPUpdateInfos) == 0x000000, "Member 'FMatchXPReward::XPUpdateInfos' has a wrong offset!");
static_assert(offsetof(FMatchXPReward, PlayerRewards) == 0x000010, "Member 'FMatchXPReward::PlayerRewards' has a wrong offset!");

// ScriptStruct JP.MovementDataJP
// 0x0038 (0x0040 - 0x0008)
struct FMovementDataJP final : public FTableRowBase
{
public:
	float                                         InitialMovementSpeed;                              // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchMovementCoefficient;                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintCoefficient;                                 // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AimCoefficient;                                    // 0x0014(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrappedCoefficient;                                // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingBackwardsCoefficient;                       // 0x001C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkingSidewaysCoefficient;                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialJumpVelocity;                               // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialAirControl;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchedCoefficient;                               // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CrouchJumpVelocityCoefficient;                     // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SprintGaitThreshold;                               // 0x0034(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunGaitThreshold;                                  // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FMovementDataJP) == 0x000008, "Wrong alignment on FMovementDataJP");
static_assert(sizeof(FMovementDataJP) == 0x000040, "Wrong size on FMovementDataJP");
static_assert(offsetof(FMovementDataJP, InitialMovementSpeed) == 0x000008, "Member 'FMovementDataJP::InitialMovementSpeed' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, CrouchMovementCoefficient) == 0x00000C, "Member 'FMovementDataJP::CrouchMovementCoefficient' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, SprintCoefficient) == 0x000010, "Member 'FMovementDataJP::SprintCoefficient' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, AimCoefficient) == 0x000014, "Member 'FMovementDataJP::AimCoefficient' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, TrappedCoefficient) == 0x000018, "Member 'FMovementDataJP::TrappedCoefficient' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, WalkingBackwardsCoefficient) == 0x00001C, "Member 'FMovementDataJP::WalkingBackwardsCoefficient' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, WalkingSidewaysCoefficient) == 0x000020, "Member 'FMovementDataJP::WalkingSidewaysCoefficient' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, InitialJumpVelocity) == 0x000024, "Member 'FMovementDataJP::InitialJumpVelocity' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, InitialAirControl) == 0x000028, "Member 'FMovementDataJP::InitialAirControl' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, LaunchedCoefficient) == 0x00002C, "Member 'FMovementDataJP::LaunchedCoefficient' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, CrouchJumpVelocityCoefficient) == 0x000030, "Member 'FMovementDataJP::CrouchJumpVelocityCoefficient' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, SprintGaitThreshold) == 0x000034, "Member 'FMovementDataJP::SprintGaitThreshold' has a wrong offset!");
static_assert(offsetof(FMovementDataJP, RunGaitThreshold) == 0x000038, "Member 'FMovementDataJP::RunGaitThreshold' has a wrong offset!");

// ScriptStruct JP.NeighborOnlineServicesData
// 0x0008 (0x0008 - 0x0000)
struct FNeighborOnlineServicesData final
{
public:
	struct FGameplayTag                           Identifier;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNeighborOnlineServicesData) == 0x000004, "Wrong alignment on FNeighborOnlineServicesData");
static_assert(sizeof(FNeighborOnlineServicesData) == 0x000008, "Wrong size on FNeighborOnlineServicesData");
static_assert(offsetof(FNeighborOnlineServicesData, Identifier) == 0x000000, "Member 'FNeighborOnlineServicesData::Identifier' has a wrong offset!");

// ScriptStruct JP.NeighborOnlineServicesContainer
// 0x0010 (0x0010 - 0x0000)
struct FNeighborOnlineServicesContainer final
{
public:
	TArray<struct FNeighborOnlineServicesData>    Neighbors;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FNeighborOnlineServicesContainer) == 0x000008, "Wrong alignment on FNeighborOnlineServicesContainer");
static_assert(sizeof(FNeighborOnlineServicesContainer) == 0x000010, "Wrong size on FNeighborOnlineServicesContainer");
static_assert(offsetof(FNeighborOnlineServicesContainer, Neighbors) == 0x000000, "Member 'FNeighborOnlineServicesContainer::Neighbors' has a wrong offset!");

// ScriptStruct JP.NeighborSelectEntryViewModel
// 0x0050 (0x0050 - 0x0000)
struct FNeighborSelectEntryViewModel final
{
public:
	struct FOnlineStoreItemData                   OnlineStoreItemData;                               // 0x0000(0x0048)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsCurrentNeighbor;                                 // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsRestricted;                                      // 0x0049(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x6];                                       // 0x004A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FNeighborSelectEntryViewModel) == 0x000008, "Wrong alignment on FNeighborSelectEntryViewModel");
static_assert(sizeof(FNeighborSelectEntryViewModel) == 0x000050, "Wrong size on FNeighborSelectEntryViewModel");
static_assert(offsetof(FNeighborSelectEntryViewModel, OnlineStoreItemData) == 0x000000, "Member 'FNeighborSelectEntryViewModel::OnlineStoreItemData' has a wrong offset!");
static_assert(offsetof(FNeighborSelectEntryViewModel, IsCurrentNeighbor) == 0x000048, "Member 'FNeighborSelectEntryViewModel::IsCurrentNeighbor' has a wrong offset!");
static_assert(offsetof(FNeighborSelectEntryViewModel, IsRestricted) == 0x000049, "Member 'FNeighborSelectEntryViewModel::IsRestricted' has a wrong offset!");

// ScriptStruct JP.ObjectiveEndMessage
// 0x0008 (0x0008 - 0x0000)
struct FObjectiveEndMessage final
{
public:
	class UObjectiveInstance*                     ObjectiveInstance;                                 // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FObjectiveEndMessage) == 0x000008, "Wrong alignment on FObjectiveEndMessage");
static_assert(sizeof(FObjectiveEndMessage) == 0x000008, "Wrong size on FObjectiveEndMessage");
static_assert(offsetof(FObjectiveEndMessage, ObjectiveInstance) == 0x000000, "Member 'FObjectiveEndMessage::ObjectiveInstance' has a wrong offset!");

// ScriptStruct JP.ObjectiveGameplayMessage
// 0x0001 (0x0001 - 0x0000)
struct FObjectiveGameplayMessage final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectiveGameplayMessage) == 0x000001, "Wrong alignment on FObjectiveGameplayMessage");
static_assert(sizeof(FObjectiveGameplayMessage) == 0x000001, "Wrong size on FObjectiveGameplayMessage");

// ScriptStruct JP.ObjectivesDataTableRow
// 0x0028 (0x0030 - 0x0008)
struct FObjectivesDataTableRow final : public FTableRowBase
{
public:
	class FText                                   Title;                                             // 0x0008(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ProgressionText;                                   // 0x0018(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         Reward;                                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FObjectivesDataTableRow) == 0x000008, "Wrong alignment on FObjectivesDataTableRow");
static_assert(sizeof(FObjectivesDataTableRow) == 0x000030, "Wrong size on FObjectivesDataTableRow");
static_assert(offsetof(FObjectivesDataTableRow, Title) == 0x000008, "Member 'FObjectivesDataTableRow::Title' has a wrong offset!");
static_assert(offsetof(FObjectivesDataTableRow, ProgressionText) == 0x000018, "Member 'FObjectivesDataTableRow::ProgressionText' has a wrong offset!");
static_assert(offsetof(FObjectivesDataTableRow, Reward) == 0x000028, "Member 'FObjectivesDataTableRow::Reward' has a wrong offset!");

// ScriptStruct JP.ItemCacheCallbackContainer
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FItemCacheCallbackContainer final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FItemCacheCallbackContainer) == 0x000008, "Wrong alignment on FItemCacheCallbackContainer");
static_assert(sizeof(FItemCacheCallbackContainer) == 0x000020, "Wrong size on FItemCacheCallbackContainer");

// ScriptStruct JP.OnlineServicesLobbyQuerySettings
// 0x0001 (0x0001 - 0x0000)
struct FOnlineServicesLobbyQuerySettings final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FOnlineServicesLobbyQuerySettings) == 0x000001, "Wrong alignment on FOnlineServicesLobbyQuerySettings");
static_assert(sizeof(FOnlineServicesLobbyQuerySettings) == 0x000001, "Wrong size on FOnlineServicesLobbyQuerySettings");

// ScriptStruct JP.PartyInvite
// 0x0020 (0x0020 - 0x0000)
struct FPartyInvite final
{
public:
	class FString                                 SourceUserName;                                    // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x10];                                      // 0x0010(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPartyInvite) == 0x000008, "Wrong alignment on FPartyInvite");
static_assert(sizeof(FPartyInvite) == 0x000020, "Wrong size on FPartyInvite");
static_assert(offsetof(FPartyInvite, SourceUserName) == 0x000000, "Member 'FPartyInvite::SourceUserName' has a wrong offset!");

// ScriptStruct JP.PartyMemberCustomizationData
// 0x0018 (0x0018 - 0x0000)
struct FPartyMemberCustomizationData final
{
public:
	struct FGameplayTag                           NeighborIdentifier;                                // 0x0000(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           NeighborSkin;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ItemSkin;                                          // 0x0010(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPartyMemberCustomizationData) == 0x000004, "Wrong alignment on FPartyMemberCustomizationData");
static_assert(sizeof(FPartyMemberCustomizationData) == 0x000018, "Wrong size on FPartyMemberCustomizationData");
static_assert(offsetof(FPartyMemberCustomizationData, NeighborIdentifier) == 0x000000, "Member 'FPartyMemberCustomizationData::NeighborIdentifier' has a wrong offset!");
static_assert(offsetof(FPartyMemberCustomizationData, NeighborSkin) == 0x000008, "Member 'FPartyMemberCustomizationData::NeighborSkin' has a wrong offset!");
static_assert(offsetof(FPartyMemberCustomizationData, ItemSkin) == 0x000010, "Member 'FPartyMemberCustomizationData::ItemSkin' has a wrong offset!");

// ScriptStruct JP.ResourceData
// 0x0008 (0x0008 - 0x0000)
struct FResourceData final
{
public:
	EResourceType                                 Type;                                              // 0x0000(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0004(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FResourceData) == 0x000004, "Wrong alignment on FResourceData");
static_assert(sizeof(FResourceData) == 0x000008, "Wrong size on FResourceData");
static_assert(offsetof(FResourceData, Type) == 0x000000, "Member 'FResourceData::Type' has a wrong offset!");
static_assert(offsetof(FResourceData, Value) == 0x000004, "Member 'FResourceData::Value' has a wrong offset!");

// ScriptStruct JP.PerfectnessPayload
// 0x0028 (0x0028 - 0x0000)
struct FPerfectnessPayload final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FResourceData                          Resource;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         PerfectnessLevel;                                  // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level1Percentage;                                  // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level2Percentage;                                  // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level3Percentage;                                  // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level4Percentage;                                  // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerfectnessPayload) == 0x000008, "Wrong alignment on FPerfectnessPayload");
static_assert(sizeof(FPerfectnessPayload) == 0x000028, "Wrong size on FPerfectnessPayload");
static_assert(offsetof(FPerfectnessPayload, Owner) == 0x000000, "Member 'FPerfectnessPayload::Owner' has a wrong offset!");
static_assert(offsetof(FPerfectnessPayload, Resource) == 0x000008, "Member 'FPerfectnessPayload::Resource' has a wrong offset!");
static_assert(offsetof(FPerfectnessPayload, PerfectnessLevel) == 0x000010, "Member 'FPerfectnessPayload::PerfectnessLevel' has a wrong offset!");
static_assert(offsetof(FPerfectnessPayload, Level1Percentage) == 0x000014, "Member 'FPerfectnessPayload::Level1Percentage' has a wrong offset!");
static_assert(offsetof(FPerfectnessPayload, Level2Percentage) == 0x000018, "Member 'FPerfectnessPayload::Level2Percentage' has a wrong offset!");
static_assert(offsetof(FPerfectnessPayload, Level3Percentage) == 0x00001C, "Member 'FPerfectnessPayload::Level3Percentage' has a wrong offset!");
static_assert(offsetof(FPerfectnessPayload, Level4Percentage) == 0x000020, "Member 'FPerfectnessPayload::Level4Percentage' has a wrong offset!");

// ScriptStruct JP.PerkOnlineServicesData
// 0x0008 (0x0008 - 0x0000)
struct FPerkOnlineServicesData final
{
public:
	struct FGameplayTag                           Identifier;                                        // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkOnlineServicesData) == 0x000004, "Wrong alignment on FPerkOnlineServicesData");
static_assert(sizeof(FPerkOnlineServicesData) == 0x000008, "Wrong size on FPerkOnlineServicesData");
static_assert(offsetof(FPerkOnlineServicesData, Identifier) == 0x000000, "Member 'FPerkOnlineServicesData::Identifier' has a wrong offset!");

// ScriptStruct JP.PerkOnlineServicesDataCollection
// 0x0010 (0x0010 - 0x0000)
struct FPerkOnlineServicesDataCollection final
{
public:
	TArray<struct FPerkOnlineServicesData>        Perks;                                             // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkOnlineServicesDataCollection) == 0x000008, "Wrong alignment on FPerkOnlineServicesDataCollection");
static_assert(sizeof(FPerkOnlineServicesDataCollection) == 0x000010, "Wrong size on FPerkOnlineServicesDataCollection");
static_assert(offsetof(FPerkOnlineServicesDataCollection, Perks) == 0x000000, "Member 'FPerkOnlineServicesDataCollection::Perks' has a wrong offset!");

// ScriptStruct JP.PerkOnlineServicesContainer
// 0x0060 (0x0060 - 0x0000)
struct FPerkOnlineServicesContainer final
{
public:
	TArray<struct FPerkOnlineServicesData>        GeneralPerks;                                      // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, struct FPerkOnlineServicesDataCollection> NeighborPerks;                                     // 0x0010(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPerkOnlineServicesContainer) == 0x000008, "Wrong alignment on FPerkOnlineServicesContainer");
static_assert(sizeof(FPerkOnlineServicesContainer) == 0x000060, "Wrong size on FPerkOnlineServicesContainer");
static_assert(offsetof(FPerkOnlineServicesContainer, GeneralPerks) == 0x000000, "Member 'FPerkOnlineServicesContainer::GeneralPerks' has a wrong offset!");
static_assert(offsetof(FPerkOnlineServicesContainer, NeighborPerks) == 0x000010, "Member 'FPerkOnlineServicesContainer::NeighborPerks' has a wrong offset!");

// ScriptStruct JP.PerkSelectEntryViewModel
// 0x000C (0x000C - 0x0000)
struct FPerkSelectEntryViewModel final
{
public:
	struct FGameplayTag                           PerkIdentifier;                                    // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEquipped;                                        // 0x0008(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsUnlocked;                                        // 0x0009(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkSelectEntryViewModel) == 0x000004, "Wrong alignment on FPerkSelectEntryViewModel");
static_assert(sizeof(FPerkSelectEntryViewModel) == 0x00000C, "Wrong size on FPerkSelectEntryViewModel");
static_assert(offsetof(FPerkSelectEntryViewModel, PerkIdentifier) == 0x000000, "Member 'FPerkSelectEntryViewModel::PerkIdentifier' has a wrong offset!");
static_assert(offsetof(FPerkSelectEntryViewModel, IsEquipped) == 0x000008, "Member 'FPerkSelectEntryViewModel::IsEquipped' has a wrong offset!");
static_assert(offsetof(FPerkSelectEntryViewModel, IsUnlocked) == 0x000009, "Member 'FPerkSelectEntryViewModel::IsUnlocked' has a wrong offset!");

// ScriptStruct JP.PerkAndLevelRequirement
// 0x000C (0x000C - 0x0000)
struct alignas(0x04) FPerkAndLevelRequirement final
{
public:
	uint8                                         Pad_0[0xC];                                        // 0x0000(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPerkAndLevelRequirement) == 0x000004, "Wrong alignment on FPerkAndLevelRequirement");
static_assert(sizeof(FPerkAndLevelRequirement) == 0x00000C, "Wrong size on FPerkAndLevelRequirement");

// ScriptStruct JP.PingData
// 0x0090 (0x0090 - 0x0000)
struct FPingData final
{
public:
	float                                         Lifetime;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                GroundLocation;                                    // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamId;                                            // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeightOffset;                                      // 0x0024(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DownTraceDistance;                                 // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   VisualizationClass;                                // 0x0030(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, RepSkip, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ChatMessage;                                       // 0x0058(0x0010)(Edit, BlueprintVisible, DisableEditOnInstance, RepSkip, NativeAccessSpecifierPublic)
	bool                                          TracePingable;                                     // 0x0068(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class APlayerControllerJP_Match> Controller;                                        // 0x006C(0x0008)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0078(0x0018)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPingData) == 0x000008, "Wrong alignment on FPingData");
static_assert(sizeof(FPingData) == 0x000090, "Wrong size on FPingData");
static_assert(offsetof(FPingData, Lifetime) == 0x000000, "Member 'FPingData::Lifetime' has a wrong offset!");
static_assert(offsetof(FPingData, GroundLocation) == 0x000008, "Member 'FPingData::GroundLocation' has a wrong offset!");
static_assert(offsetof(FPingData, TeamId) == 0x000020, "Member 'FPingData::TeamId' has a wrong offset!");
static_assert(offsetof(FPingData, HeightOffset) == 0x000024, "Member 'FPingData::HeightOffset' has a wrong offset!");
static_assert(offsetof(FPingData, DownTraceDistance) == 0x000028, "Member 'FPingData::DownTraceDistance' has a wrong offset!");
static_assert(offsetof(FPingData, VisualizationClass) == 0x000030, "Member 'FPingData::VisualizationClass' has a wrong offset!");
static_assert(offsetof(FPingData, ChatMessage) == 0x000058, "Member 'FPingData::ChatMessage' has a wrong offset!");
static_assert(offsetof(FPingData, TracePingable) == 0x000068, "Member 'FPingData::TracePingable' has a wrong offset!");
static_assert(offsetof(FPingData, Controller) == 0x00006C, "Member 'FPingData::Controller' has a wrong offset!");
static_assert(offsetof(FPingData, Location) == 0x000078, "Member 'FPingData::Location' has a wrong offset!");

// ScriptStruct JP.PlayerLoadoutUpdatedMessage
// 0x0030 (0x0030 - 0x0000)
struct FPlayerLoadoutUpdatedMessage final
{
public:
	class APlayerStateJP*                         PlayerState;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerLoadout                         NewLoadout;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLoadoutUpdatedMessage) == 0x000008, "Wrong alignment on FPlayerLoadoutUpdatedMessage");
static_assert(sizeof(FPlayerLoadoutUpdatedMessage) == 0x000030, "Wrong size on FPlayerLoadoutUpdatedMessage");
static_assert(offsetof(FPlayerLoadoutUpdatedMessage, PlayerState) == 0x000000, "Member 'FPlayerLoadoutUpdatedMessage::PlayerState' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutUpdatedMessage, NewLoadout) == 0x000008, "Member 'FPlayerLoadoutUpdatedMessage::NewLoadout' has a wrong offset!");

// ScriptStruct JP.PlayerMessage
// 0x0058 (0x0058 - 0x0000)
struct FPlayerMessage final
{
public:
	class APlayerController*                      ControllerReference;                               // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMessageRecipient                             Recipient;                                         // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Message;                                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMessageCategory                              Category;                                          // 0x0020(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DeleteOtherInCategory;                             // 0x003C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              Sound;                                             // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          TranslateUsingStringTable;                         // 0x0048(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StringTableID;                                     // 0x004C(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerMessage) == 0x000008, "Wrong alignment on FPlayerMessage");
static_assert(sizeof(FPlayerMessage) == 0x000058, "Wrong size on FPlayerMessage");
static_assert(offsetof(FPlayerMessage, ControllerReference) == 0x000000, "Member 'FPlayerMessage::ControllerReference' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, Recipient) == 0x000008, "Member 'FPlayerMessage::Recipient' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, Message) == 0x000010, "Member 'FPlayerMessage::Message' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, Category) == 0x000020, "Member 'FPlayerMessage::Category' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, Priority) == 0x000024, "Member 'FPlayerMessage::Priority' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, Color) == 0x000028, "Member 'FPlayerMessage::Color' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, Time) == 0x000038, "Member 'FPlayerMessage::Time' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, DeleteOtherInCategory) == 0x00003C, "Member 'FPlayerMessage::DeleteOtherInCategory' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, Sound) == 0x000040, "Member 'FPlayerMessage::Sound' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, TranslateUsingStringTable) == 0x000048, "Member 'FPlayerMessage::TranslateUsingStringTable' has a wrong offset!");
static_assert(offsetof(FPlayerMessage, StringTableID) == 0x00004C, "Member 'FPlayerMessage::StringTableID' has a wrong offset!");

// ScriptStruct JP.PlayerOnlineSummaryData
// 0x0058 (0x0058 - 0x0000)
struct FPlayerOnlineSummaryData final
{
public:
	class FString                                 PlayerMasterId;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LoginTime;                                         // 0x0010(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LogoutTime;                                        // 0x0020(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          MatchHasEnded;                                     // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PlayerKills;                                       // 0x0034(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerDeaths;                                      // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamKills;                                         // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamDeaths;                                        // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamHouseEssentialLost;                            // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyHouseEssentialKilled;                         // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FriendlyResourcesCollected;                        // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnemyResourcesCollected;                           // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerOnlineSummaryData) == 0x000008, "Wrong alignment on FPlayerOnlineSummaryData");
static_assert(sizeof(FPlayerOnlineSummaryData) == 0x000058, "Wrong size on FPlayerOnlineSummaryData");
static_assert(offsetof(FPlayerOnlineSummaryData, PlayerMasterId) == 0x000000, "Member 'FPlayerOnlineSummaryData::PlayerMasterId' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, LoginTime) == 0x000010, "Member 'FPlayerOnlineSummaryData::LoginTime' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, LogoutTime) == 0x000020, "Member 'FPlayerOnlineSummaryData::LogoutTime' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, MatchHasEnded) == 0x000030, "Member 'FPlayerOnlineSummaryData::MatchHasEnded' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, PlayerKills) == 0x000034, "Member 'FPlayerOnlineSummaryData::PlayerKills' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, PlayerDeaths) == 0x000038, "Member 'FPlayerOnlineSummaryData::PlayerDeaths' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, TeamKills) == 0x00003C, "Member 'FPlayerOnlineSummaryData::TeamKills' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, TeamDeaths) == 0x000040, "Member 'FPlayerOnlineSummaryData::TeamDeaths' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, TeamHouseEssentialLost) == 0x000044, "Member 'FPlayerOnlineSummaryData::TeamHouseEssentialLost' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, EnemyHouseEssentialKilled) == 0x000048, "Member 'FPlayerOnlineSummaryData::EnemyHouseEssentialKilled' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, FriendlyResourcesCollected) == 0x00004C, "Member 'FPlayerOnlineSummaryData::FriendlyResourcesCollected' has a wrong offset!");
static_assert(offsetof(FPlayerOnlineSummaryData, EnemyResourcesCollected) == 0x000050, "Member 'FPlayerOnlineSummaryData::EnemyResourcesCollected' has a wrong offset!");

// ScriptStruct JP.PlayerRewardInfo
// 0x0068 (0x0068 - 0x0000)
struct alignas(0x08) FPlayerRewardInfo final
{
public:
	uint8                                         Pad_0[0x68];                                       // 0x0000(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerRewardInfo) == 0x000008, "Wrong alignment on FPlayerRewardInfo");
static_assert(sizeof(FPlayerRewardInfo) == 0x000068, "Wrong size on FPlayerRewardInfo");

// ScriptStruct JP.PlayerStartQueryRequest
// 0x0018 (0x0018 - 0x0000)
struct FPlayerStartQueryRequest final
{
public:
	class AController*                            Player;                                            // 0x0000(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x9];                                        // 0x0008(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	ERequestedSpawnType                           SpawnType;                                         // 0x0011(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPlayerStartQueryRequest) == 0x000008, "Wrong alignment on FPlayerStartQueryRequest");
static_assert(sizeof(FPlayerStartQueryRequest) == 0x000018, "Wrong size on FPlayerStartQueryRequest");
static_assert(offsetof(FPlayerStartQueryRequest, Player) == 0x000000, "Member 'FPlayerStartQueryRequest::Player' has a wrong offset!");
static_assert(offsetof(FPlayerStartQueryRequest, SpawnType) == 0x000011, "Member 'FPlayerStartQueryRequest::SpawnType' has a wrong offset!");

// ScriptStruct JP.PlayerStartQueryResult
// 0x0010 (0x0010 - 0x0000)
struct FPlayerStartQueryResult final
{
public:
	TArray<class APlayerStart*>                   AvailablePlayerStarts;                             // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerStartQueryResult) == 0x000008, "Wrong alignment on FPlayerStartQueryResult");
static_assert(sizeof(FPlayerStartQueryResult) == 0x000010, "Wrong size on FPlayerStartQueryResult");
static_assert(offsetof(FPlayerStartQueryResult, AvailablePlayerStarts) == 0x000000, "Member 'FPlayerStartQueryResult::AvailablePlayerStarts' has a wrong offset!");

// ScriptStruct JP.PlayerStateJPFullyReplicatedMessage
// 0x0008 (0x0008 - 0x0000)
struct FPlayerStateJPFullyReplicatedMessage final
{
public:
	class APlayerStateJP*                         PlayerState;                                       // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerStateJPFullyReplicatedMessage) == 0x000008, "Wrong alignment on FPlayerStateJPFullyReplicatedMessage");
static_assert(sizeof(FPlayerStateJPFullyReplicatedMessage) == 0x000008, "Wrong size on FPlayerStateJPFullyReplicatedMessage");
static_assert(offsetof(FPlayerStateJPFullyReplicatedMessage, PlayerState) == 0x000000, "Member 'FPlayerStateJPFullyReplicatedMessage::PlayerState' has a wrong offset!");

// ScriptStruct JP.PreLobbyServerBrowserEntryViewModel
// 0x0030 (0x0030 - 0x0000)
struct FPreLobbyServerBrowserEntryViewModel final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameMode;                                          // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Ping;                                              // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Players;                                           // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Slots;                                             // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPasswordProtected;                              // 0x002C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreLobbyServerBrowserEntryViewModel) == 0x000008, "Wrong alignment on FPreLobbyServerBrowserEntryViewModel");
static_assert(sizeof(FPreLobbyServerBrowserEntryViewModel) == 0x000030, "Wrong size on FPreLobbyServerBrowserEntryViewModel");
static_assert(offsetof(FPreLobbyServerBrowserEntryViewModel, Name) == 0x000000, "Member 'FPreLobbyServerBrowserEntryViewModel::Name' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserEntryViewModel, GameMode) == 0x000010, "Member 'FPreLobbyServerBrowserEntryViewModel::GameMode' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserEntryViewModel, Ping) == 0x000020, "Member 'FPreLobbyServerBrowserEntryViewModel::Ping' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserEntryViewModel, Players) == 0x000024, "Member 'FPreLobbyServerBrowserEntryViewModel::Players' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserEntryViewModel, Slots) == 0x000028, "Member 'FPreLobbyServerBrowserEntryViewModel::Slots' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserEntryViewModel, bIsPasswordProtected) == 0x00002C, "Member 'FPreLobbyServerBrowserEntryViewModel::bIsPasswordProtected' has a wrong offset!");

// ScriptStruct JP.PreLobbyServerBrowserListViewModel
// 0x0010 (0x0010 - 0x0000)
struct FPreLobbyServerBrowserListViewModel final
{
public:
	EPreLobbyServerBrowserListSortMode            SortMode;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPreLobbyServerBrowserState                   State;                                             // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PageIndex;                                         // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumPages;                                          // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ShowFullSevers;                                    // 0x000C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FPreLobbyServerBrowserListViewModel) == 0x000004, "Wrong alignment on FPreLobbyServerBrowserListViewModel");
static_assert(sizeof(FPreLobbyServerBrowserListViewModel) == 0x000010, "Wrong size on FPreLobbyServerBrowserListViewModel");
static_assert(offsetof(FPreLobbyServerBrowserListViewModel, SortMode) == 0x000000, "Member 'FPreLobbyServerBrowserListViewModel::SortMode' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserListViewModel, State) == 0x000001, "Member 'FPreLobbyServerBrowserListViewModel::State' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserListViewModel, PageIndex) == 0x000004, "Member 'FPreLobbyServerBrowserListViewModel::PageIndex' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserListViewModel, NumPages) == 0x000008, "Member 'FPreLobbyServerBrowserListViewModel::NumPages' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserListViewModel, ShowFullSevers) == 0x00000C, "Member 'FPreLobbyServerBrowserListViewModel::ShowFullSevers' has a wrong offset!");

// ScriptStruct JP.PreLobbyServerBrowserViewModel
// 0x0068 (0x0068 - 0x0000)
struct FPreLobbyServerBrowserViewModel final
{
public:
	class FString                                 NameQuery;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   TeamSizes;                                         // 0x0010(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bShowCustomMatchConfiguration;                     // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFriendsOnly;                                      // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x2];                                       // 0x0062(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Region;                                            // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPreLobbyServerBrowserViewModel) == 0x000008, "Wrong alignment on FPreLobbyServerBrowserViewModel");
static_assert(sizeof(FPreLobbyServerBrowserViewModel) == 0x000068, "Wrong size on FPreLobbyServerBrowserViewModel");
static_assert(offsetof(FPreLobbyServerBrowserViewModel, NameQuery) == 0x000000, "Member 'FPreLobbyServerBrowserViewModel::NameQuery' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserViewModel, TeamSizes) == 0x000010, "Member 'FPreLobbyServerBrowserViewModel::TeamSizes' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserViewModel, bShowCustomMatchConfiguration) == 0x000060, "Member 'FPreLobbyServerBrowserViewModel::bShowCustomMatchConfiguration' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserViewModel, bFriendsOnly) == 0x000061, "Member 'FPreLobbyServerBrowserViewModel::bFriendsOnly' has a wrong offset!");
static_assert(offsetof(FPreLobbyServerBrowserViewModel, Region) == 0x000064, "Member 'FPreLobbyServerBrowserViewModel::Region' has a wrong offset!");

// ScriptStruct JP.ProjectValidatorSettings
// 0x0002 (0x0002 - 0x0000)
struct FProjectValidatorSettings final
{
public:
	bool                                          EnableProjectValidation;                           // 0x0000(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ValidateLyraUICompatibility;                       // 0x0001(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FProjectValidatorSettings) == 0x000001, "Wrong alignment on FProjectValidatorSettings");
static_assert(sizeof(FProjectValidatorSettings) == 0x000002, "Wrong size on FProjectValidatorSettings");
static_assert(offsetof(FProjectValidatorSettings, EnableProjectValidation) == 0x000000, "Member 'FProjectValidatorSettings::EnableProjectValidation' has a wrong offset!");
static_assert(offsetof(FProjectValidatorSettings, ValidateLyraUICompatibility) == 0x000001, "Member 'FProjectValidatorSettings::ValidateLyraUICompatibility' has a wrong offset!");

// ScriptStruct JP.RedeemedSeasonPasses
// 0x0010 (0x0010 - 0x0000)
struct FRedeemedSeasonPasses final
{
public:
	TArray<class FString>                         RedeemedRewards;                                   // 0x0000(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRedeemedSeasonPasses) == 0x000008, "Wrong alignment on FRedeemedSeasonPasses");
static_assert(sizeof(FRedeemedSeasonPasses) == 0x000010, "Wrong size on FRedeemedSeasonPasses");
static_assert(offsetof(FRedeemedSeasonPasses, RedeemedRewards) == 0x000000, "Member 'FRedeemedSeasonPasses::RedeemedRewards' has a wrong offset!");

// ScriptStruct JP.RejoinSaveGameData
// 0x0020 (0x0020 - 0x0000)
struct FRejoinSaveGameData final
{
public:
	bool                                          bPlayerAbandonedMatch;                             // 0x0000(0x0001)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IP;                                                // 0x0008(0x0010)(ZeroConstructor, SaveGame, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Port;                                              // 0x0018(0x0004)(ZeroConstructor, SaveGame, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FRejoinSaveGameData) == 0x000008, "Wrong alignment on FRejoinSaveGameData");
static_assert(sizeof(FRejoinSaveGameData) == 0x000020, "Wrong size on FRejoinSaveGameData");
static_assert(offsetof(FRejoinSaveGameData, bPlayerAbandonedMatch) == 0x000000, "Member 'FRejoinSaveGameData::bPlayerAbandonedMatch' has a wrong offset!");
static_assert(offsetof(FRejoinSaveGameData, IP) == 0x000008, "Member 'FRejoinSaveGameData::IP' has a wrong offset!");
static_assert(offsetof(FRejoinSaveGameData, Port) == 0x000018, "Member 'FRejoinSaveGameData::Port' has a wrong offset!");

// ScriptStruct JP.ReplicatedSkinnedDecalData
// 0x0050 (0x0050 - 0x0000)
struct FReplicatedSkinnedDecalData final
{
public:
	struct FVector                                BoneLocalPosition;                                 // 0x0000(0x0018)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DecalIndex;                                        // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  Rotation;                                          // 0x0020(0x0020)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLocallyDiscovered;                                // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, RepSkip, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FReplicatedSkinnedDecalData) == 0x000010, "Wrong alignment on FReplicatedSkinnedDecalData");
static_assert(sizeof(FReplicatedSkinnedDecalData) == 0x000050, "Wrong size on FReplicatedSkinnedDecalData");
static_assert(offsetof(FReplicatedSkinnedDecalData, BoneLocalPosition) == 0x000000, "Member 'FReplicatedSkinnedDecalData::BoneLocalPosition' has a wrong offset!");
static_assert(offsetof(FReplicatedSkinnedDecalData, DecalIndex) == 0x000018, "Member 'FReplicatedSkinnedDecalData::DecalIndex' has a wrong offset!");
static_assert(offsetof(FReplicatedSkinnedDecalData, Rotation) == 0x000020, "Member 'FReplicatedSkinnedDecalData::Rotation' has a wrong offset!");
static_assert(offsetof(FReplicatedSkinnedDecalData, BoneName) == 0x000040, "Member 'FReplicatedSkinnedDecalData::BoneName' has a wrong offset!");
static_assert(offsetof(FReplicatedSkinnedDecalData, bLocallyDiscovered) == 0x000048, "Member 'FReplicatedSkinnedDecalData::bLocallyDiscovered' has a wrong offset!");

// ScriptStruct JP.ResourcePayload
// 0x0028 (0x0028 - 0x0000)
struct FResourcePayload final
{
public:
	class UObject*                                Owner;                                             // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FResourceData                          Resource;                                          // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EResourceValueChange                          Change;                                            // 0x0010(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        DepositedWorldTimeSeconds;                         // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EResourceReceiver                             Receiver;                                          // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FResourcePayload) == 0x000008, "Wrong alignment on FResourcePayload");
static_assert(sizeof(FResourcePayload) == 0x000028, "Wrong size on FResourcePayload");
static_assert(offsetof(FResourcePayload, Owner) == 0x000000, "Member 'FResourcePayload::Owner' has a wrong offset!");
static_assert(offsetof(FResourcePayload, Resource) == 0x000008, "Member 'FResourcePayload::Resource' has a wrong offset!");
static_assert(offsetof(FResourcePayload, Change) == 0x000010, "Member 'FResourcePayload::Change' has a wrong offset!");
static_assert(offsetof(FResourcePayload, DepositedWorldTimeSeconds) == 0x000018, "Member 'FResourcePayload::DepositedWorldTimeSeconds' has a wrong offset!");
static_assert(offsetof(FResourcePayload, Receiver) == 0x000020, "Member 'FResourcePayload::Receiver' has a wrong offset!");

// ScriptStruct JP.RewardOnlineServicesData
// 0x0010 (0x0010 - 0x0000)
struct FRewardOnlineServicesData final
{
public:
	TArray<struct FGameplayTag>                   Rewards;                                           // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardOnlineServicesData) == 0x000008, "Wrong alignment on FRewardOnlineServicesData");
static_assert(sizeof(FRewardOnlineServicesData) == 0x000010, "Wrong size on FRewardOnlineServicesData");
static_assert(offsetof(FRewardOnlineServicesData, Rewards) == 0x000000, "Member 'FRewardOnlineServicesData::Rewards' has a wrong offset!");

// ScriptStruct JP.RewardOnlineServicesDataByLevel
// 0x0050 (0x0050 - 0x0000)
struct FRewardOnlineServicesDataByLevel final
{
public:
	TMap<int32, struct FRewardOnlineServicesData> RewardsByLevel;                                    // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardOnlineServicesDataByLevel) == 0x000008, "Wrong alignment on FRewardOnlineServicesDataByLevel");
static_assert(sizeof(FRewardOnlineServicesDataByLevel) == 0x000050, "Wrong size on FRewardOnlineServicesDataByLevel");
static_assert(offsetof(FRewardOnlineServicesDataByLevel, RewardsByLevel) == 0x000000, "Member 'FRewardOnlineServicesDataByLevel::RewardsByLevel' has a wrong offset!");

// ScriptStruct JP.RewardOnlineServicesContainer
// 0x0050 (0x0050 - 0x0000)
struct FRewardOnlineServicesContainer final
{
public:
	TMap<struct FGameplayTag, struct FRewardOnlineServicesDataByLevel> NeighborRewards;                                   // 0x0000(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRewardOnlineServicesContainer) == 0x000008, "Wrong alignment on FRewardOnlineServicesContainer");
static_assert(sizeof(FRewardOnlineServicesContainer) == 0x000050, "Wrong size on FRewardOnlineServicesContainer");
static_assert(offsetof(FRewardOnlineServicesContainer, NeighborRewards) == 0x000000, "Member 'FRewardOnlineServicesContainer::NeighborRewards' has a wrong offset!");

// ScriptStruct JP.SeasonPassContainerViewModel
// 0x0004 (0x0004 - 0x0000)
struct FSeasonPassContainerViewModel final
{
public:
	int32                                         HighestTierUnlocked;                               // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonPassContainerViewModel) == 0x000004, "Wrong alignment on FSeasonPassContainerViewModel");
static_assert(sizeof(FSeasonPassContainerViewModel) == 0x000004, "Wrong size on FSeasonPassContainerViewModel");
static_assert(offsetof(FSeasonPassContainerViewModel, HighestTierUnlocked) == 0x000000, "Member 'FSeasonPassContainerViewModel::HighestTierUnlocked' has a wrong offset!");

// ScriptStruct JP.SeasonPassData
// 0x0030 (0x0030 - 0x0000)
struct FSeasonPassData final
{
public:
	class FString                                 PremiumPassItemId;                                 // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StatisticName;                                     // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FSeasonPassTier>                Tiers;                                             // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonPassData) == 0x000008, "Wrong alignment on FSeasonPassData");
static_assert(sizeof(FSeasonPassData) == 0x000030, "Wrong size on FSeasonPassData");
static_assert(offsetof(FSeasonPassData, PremiumPassItemId) == 0x000000, "Member 'FSeasonPassData::PremiumPassItemId' has a wrong offset!");
static_assert(offsetof(FSeasonPassData, StatisticName) == 0x000010, "Member 'FSeasonPassData::StatisticName' has a wrong offset!");
static_assert(offsetof(FSeasonPassData, Tiers) == 0x000020, "Member 'FSeasonPassData::Tiers' has a wrong offset!");

// ScriptStruct JP.SeasonPassRewardContent_CurrencyViewModel
// 0x0010 (0x0010 - 0x0000)
struct FSeasonPassRewardContent_CurrencyViewModel final
{
public:
	int32                                         Amount;                                            // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UOnlineCurrency*                        Definition;                                        // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonPassRewardContent_CurrencyViewModel) == 0x000008, "Wrong alignment on FSeasonPassRewardContent_CurrencyViewModel");
static_assert(sizeof(FSeasonPassRewardContent_CurrencyViewModel) == 0x000010, "Wrong size on FSeasonPassRewardContent_CurrencyViewModel");
static_assert(offsetof(FSeasonPassRewardContent_CurrencyViewModel, Amount) == 0x000000, "Member 'FSeasonPassRewardContent_CurrencyViewModel::Amount' has a wrong offset!");
static_assert(offsetof(FSeasonPassRewardContent_CurrencyViewModel, Definition) == 0x000008, "Member 'FSeasonPassRewardContent_CurrencyViewModel::Definition' has a wrong offset!");

// ScriptStruct JP.SeasonPassRewardContent_NeighborSkinViewModel
// 0x0028 (0x0028 - 0x0000)
struct FSeasonPassRewardContent_NeighborSkinViewModel final
{
public:
	TSoftObjectPtr<class UNeighborSkinDefinition> Definition;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonPassRewardContent_NeighborSkinViewModel) == 0x000008, "Wrong alignment on FSeasonPassRewardContent_NeighborSkinViewModel");
static_assert(sizeof(FSeasonPassRewardContent_NeighborSkinViewModel) == 0x000028, "Wrong size on FSeasonPassRewardContent_NeighborSkinViewModel");
static_assert(offsetof(FSeasonPassRewardContent_NeighborSkinViewModel, Definition) == 0x000000, "Member 'FSeasonPassRewardContent_NeighborSkinViewModel::Definition' has a wrong offset!");

// ScriptStruct JP.SeasonPassRewardContent_NeighborViewModel
// 0x0028 (0x0028 - 0x0000)
struct FSeasonPassRewardContent_NeighborViewModel final
{
public:
	TSoftObjectPtr<class UNeighborDefinition>     Definition;                                        // 0x0000(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSeasonPassRewardContent_NeighborViewModel) == 0x000008, "Wrong alignment on FSeasonPassRewardContent_NeighborViewModel");
static_assert(sizeof(FSeasonPassRewardContent_NeighborViewModel) == 0x000028, "Wrong size on FSeasonPassRewardContent_NeighborViewModel");
static_assert(offsetof(FSeasonPassRewardContent_NeighborViewModel, Definition) == 0x000000, "Member 'FSeasonPassRewardContent_NeighborViewModel::Definition' has a wrong offset!");

// ScriptStruct JP.GrantItemRequestDataContainer
// 0x0001 (0x0001 - 0x0000)
struct FGrantItemRequestDataContainer final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FGrantItemRequestDataContainer) == 0x000001, "Wrong alignment on FGrantItemRequestDataContainer");
static_assert(sizeof(FGrantItemRequestDataContainer) == 0x000001, "Wrong size on FGrantItemRequestDataContainer");

// ScriptStruct JP.SeasonPassRewardInitializer
// 0x0001 (0x0001 - 0x0000)
struct FSeasonPassRewardInitializer final
{
public:
	uint8                                         Pad_0[0x1];                                        // 0x0000(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSeasonPassRewardInitializer) == 0x000001, "Wrong alignment on FSeasonPassRewardInitializer");
static_assert(sizeof(FSeasonPassRewardInitializer) == 0x000001, "Wrong size on FSeasonPassRewardInitializer");

// ScriptStruct JP.CatalogItemKismet
// 0x0048 (0x0048 - 0x0000)
struct FCatalogItemKismet final
{
public:
	struct FGameplayTag                           FriendlyId;                                        // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentType;                                       // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ID;                                                // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Tags;                                              // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FString                                 Title;                                             // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCatalogItemKismet) == 0x000008, "Wrong alignment on FCatalogItemKismet");
static_assert(sizeof(FCatalogItemKismet) == 0x000048, "Wrong size on FCatalogItemKismet");
static_assert(offsetof(FCatalogItemKismet, FriendlyId) == 0x000000, "Member 'FCatalogItemKismet::FriendlyId' has a wrong offset!");
static_assert(offsetof(FCatalogItemKismet, ContentType) == 0x000008, "Member 'FCatalogItemKismet::ContentType' has a wrong offset!");
static_assert(offsetof(FCatalogItemKismet, ID) == 0x000018, "Member 'FCatalogItemKismet::ID' has a wrong offset!");
static_assert(offsetof(FCatalogItemKismet, Tags) == 0x000028, "Member 'FCatalogItemKismet::Tags' has a wrong offset!");
static_assert(offsetof(FCatalogItemKismet, Title) == 0x000038, "Member 'FCatalogItemKismet::Title' has a wrong offset!");

// ScriptStruct JP.SeasonPassSingleRewardEntryViewModel
// 0x0048 (0x0048 - 0x0000)
struct FSeasonPassSingleRewardEntryViewModel final
{
public:
	struct FSeasonPassReward                      Reward;                                            // 0x0000(0x0040)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bHasReward;                                        // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSeasonPassSingleRewardEntryViewModel) == 0x000008, "Wrong alignment on FSeasonPassSingleRewardEntryViewModel");
static_assert(sizeof(FSeasonPassSingleRewardEntryViewModel) == 0x000048, "Wrong size on FSeasonPassSingleRewardEntryViewModel");
static_assert(offsetof(FSeasonPassSingleRewardEntryViewModel, Reward) == 0x000000, "Member 'FSeasonPassSingleRewardEntryViewModel::Reward' has a wrong offset!");
static_assert(offsetof(FSeasonPassSingleRewardEntryViewModel, bHasReward) == 0x000040, "Member 'FSeasonPassSingleRewardEntryViewModel::bHasReward' has a wrong offset!");

// ScriptStruct JP.SelectedLevelData
// 0x0070 (0x0070 - 0x0000)
struct FSelectedLevelData final
{
public:
	struct FLevelVoteData                         LevelData;                                         // 0x0000(0x0068)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         LevelIndex;                                        // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CountdownEndServerTime;                            // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSelectedLevelData) == 0x000008, "Wrong alignment on FSelectedLevelData");
static_assert(sizeof(FSelectedLevelData) == 0x000070, "Wrong size on FSelectedLevelData");
static_assert(offsetof(FSelectedLevelData, LevelData) == 0x000000, "Member 'FSelectedLevelData::LevelData' has a wrong offset!");
static_assert(offsetof(FSelectedLevelData, LevelIndex) == 0x000068, "Member 'FSelectedLevelData::LevelIndex' has a wrong offset!");
static_assert(offsetof(FSelectedLevelData, CountdownEndServerTime) == 0x00006C, "Member 'FSelectedLevelData::CountdownEndServerTime' has a wrong offset!");

// ScriptStruct JP.ShopItemFastArray
// 0x0028 (0x0130 - 0x0108)
struct FShopItemFastArray final : public FFastArraySerializer
{
public:
	uint8                                         Pad_108[0x10];                                     // 0x0108(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FShopItemViewModel>             Items;                                             // 0x0118(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UActorComponent*                        Owner;                                             // 0x0128(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
};
static_assert(alignof(FShopItemFastArray) == 0x000008, "Wrong alignment on FShopItemFastArray");
static_assert(sizeof(FShopItemFastArray) == 0x000130, "Wrong size on FShopItemFastArray");
static_assert(offsetof(FShopItemFastArray, Items) == 0x000118, "Member 'FShopItemFastArray::Items' has a wrong offset!");
static_assert(offsetof(FShopItemFastArray, Owner) == 0x000128, "Member 'FShopItemFastArray::Owner' has a wrong offset!");

// ScriptStruct JP.ShopItemRow
// 0x0010 (0x0018 - 0x0008)
struct FShopItemRow final : public FTableRowBase
{
public:
	class UShopItemDataAsset*                     ShopItemDataAsset;                                 // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         StartingQuantity;                                  // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FShopItemRow) == 0x000008, "Wrong alignment on FShopItemRow");
static_assert(sizeof(FShopItemRow) == 0x000018, "Wrong size on FShopItemRow");
static_assert(offsetof(FShopItemRow, ShopItemDataAsset) == 0x000008, "Member 'FShopItemRow::ShopItemDataAsset' has a wrong offset!");
static_assert(offsetof(FShopItemRow, StartingQuantity) == 0x000010, "Member 'FShopItemRow::StartingQuantity' has a wrong offset!");

// ScriptStruct JP.TooltipTagCollection
// 0x0050 (0x0050 - 0x0000)
struct FTooltipTagCollection final
{
public:
	TSet<struct FGameplayTag>                     TooltipTags;                                       // 0x0000(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
};
static_assert(alignof(FTooltipTagCollection) == 0x000008, "Wrong alignment on FTooltipTagCollection");
static_assert(sizeof(FTooltipTagCollection) == 0x000050, "Wrong size on FTooltipTagCollection");
static_assert(offsetof(FTooltipTagCollection, TooltipTags) == 0x000000, "Member 'FTooltipTagCollection::TooltipTags' has a wrong offset!");

// ScriptStruct JP.QuickPlaySettings
// 0x0030 (0x0030 - 0x0000)
struct FQuickPlaySettings final
{
public:
	int32                                         QuickPlayEnabledChance;                            // 0x0000(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnabled;                                        // 0x0004(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHotJoinEnabled;                                 // 0x0005(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsListenServerEnabled;                            // 0x0006(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x1];                                        // 0x0007(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ShutdownSecondsEndOfMatch;                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TimeoutSeconds;                                    // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 QueueName;                                         // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Regions;                                           // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FQuickPlaySettings) == 0x000008, "Wrong alignment on FQuickPlaySettings");
static_assert(sizeof(FQuickPlaySettings) == 0x000030, "Wrong size on FQuickPlaySettings");
static_assert(offsetof(FQuickPlaySettings, QuickPlayEnabledChance) == 0x000000, "Member 'FQuickPlaySettings::QuickPlayEnabledChance' has a wrong offset!");
static_assert(offsetof(FQuickPlaySettings, bIsEnabled) == 0x000004, "Member 'FQuickPlaySettings::bIsEnabled' has a wrong offset!");
static_assert(offsetof(FQuickPlaySettings, bIsHotJoinEnabled) == 0x000005, "Member 'FQuickPlaySettings::bIsHotJoinEnabled' has a wrong offset!");
static_assert(offsetof(FQuickPlaySettings, bIsListenServerEnabled) == 0x000006, "Member 'FQuickPlaySettings::bIsListenServerEnabled' has a wrong offset!");
static_assert(offsetof(FQuickPlaySettings, ShutdownSecondsEndOfMatch) == 0x000008, "Member 'FQuickPlaySettings::ShutdownSecondsEndOfMatch' has a wrong offset!");
static_assert(offsetof(FQuickPlaySettings, TimeoutSeconds) == 0x00000C, "Member 'FQuickPlaySettings::TimeoutSeconds' has a wrong offset!");
static_assert(offsetof(FQuickPlaySettings, QueueName) == 0x000010, "Member 'FQuickPlaySettings::QueueName' has a wrong offset!");
static_assert(offsetof(FQuickPlaySettings, Regions) == 0x000020, "Member 'FQuickPlaySettings::Regions' has a wrong offset!");

// ScriptStruct JP.UpdateSeasonPassRewardsArguments
// 0x0010 (0x0010 - 0x0000)
struct FUpdateSeasonPassRewardsArguments final
{
public:
	class FString                                 SeasonPassName;                                    // 0x0000(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FUpdateSeasonPassRewardsArguments) == 0x000008, "Wrong alignment on FUpdateSeasonPassRewardsArguments");
static_assert(sizeof(FUpdateSeasonPassRewardsArguments) == 0x000010, "Wrong size on FUpdateSeasonPassRewardsArguments");
static_assert(offsetof(FUpdateSeasonPassRewardsArguments, SeasonPassName) == 0x000000, "Member 'FUpdateSeasonPassRewardsArguments::SeasonPassName' has a wrong offset!");

// ScriptStruct JP.LyraAudioSubmixEffectsChain
// 0x0018 (0x0018 - 0x0000)
struct FLyraAudioSubmixEffectsChain final
{
public:
	class USoundSubmix*                           Submix;                                            // 0x0000(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundEffectSubmixPreset*>       SubmixEffectChain;                                 // 0x0008(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLyraAudioSubmixEffectsChain) == 0x000008, "Wrong alignment on FLyraAudioSubmixEffectsChain");
static_assert(sizeof(FLyraAudioSubmixEffectsChain) == 0x000018, "Wrong size on FLyraAudioSubmixEffectsChain");
static_assert(offsetof(FLyraAudioSubmixEffectsChain, Submix) == 0x000000, "Member 'FLyraAudioSubmixEffectsChain::Submix' has a wrong offset!");
static_assert(offsetof(FLyraAudioSubmixEffectsChain, SubmixEffectChain) == 0x000008, "Member 'FLyraAudioSubmixEffectsChain::SubmixEffectChain' has a wrong offset!");

// ScriptStruct JP.LyraSubmixEffectChainMap
// 0x0038 (0x0038 - 0x0000)
struct FLyraSubmixEffectChainMap final
{
public:
	TSoftObjectPtr<class USoundSubmix>            Submix;                                            // 0x0000(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class USoundEffectSubmixPreset>> SubmixEffectChain;                                 // 0x0028(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLyraSubmixEffectChainMap) == 0x000008, "Wrong alignment on FLyraSubmixEffectChainMap");
static_assert(sizeof(FLyraSubmixEffectChainMap) == 0x000038, "Wrong size on FLyraSubmixEffectChainMap");
static_assert(offsetof(FLyraSubmixEffectChainMap, Submix) == 0x000000, "Member 'FLyraSubmixEffectChainMap::Submix' has a wrong offset!");
static_assert(offsetof(FLyraSubmixEffectChainMap, SubmixEffectChain) == 0x000028, "Member 'FLyraSubmixEffectChainMap::SubmixEffectChain' has a wrong offset!");

// ScriptStruct JP.PlayerLoadoutTelemetryData
// 0x0038 (0x0038 - 0x0000)
struct FPlayerLoadoutTelemetryData final
{
public:
	struct FGameplayTag                           HouseID;                                           // 0x0000(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FNeighborLoadout                       PlayerLoadout;                                     // 0x0008(0x0030)(NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLoadoutTelemetryData) == 0x000008, "Wrong alignment on FPlayerLoadoutTelemetryData");
static_assert(sizeof(FPlayerLoadoutTelemetryData) == 0x000038, "Wrong size on FPlayerLoadoutTelemetryData");
static_assert(offsetof(FPlayerLoadoutTelemetryData, HouseID) == 0x000000, "Member 'FPlayerLoadoutTelemetryData::HouseID' has a wrong offset!");
static_assert(offsetof(FPlayerLoadoutTelemetryData, PlayerLoadout) == 0x000008, "Member 'FPlayerLoadoutTelemetryData::PlayerLoadout' has a wrong offset!");

// ScriptStruct JP.LyraQualityDeviceProfileVariant
// 0x0028 (0x0028 - 0x0000)
struct FLyraQualityDeviceProfileVariant final
{
public:
	class FText                                   DisplayName;                                       // 0x0000(0x0010)(Edit, NativeAccessSpecifierPublic)
	class FString                                 DeviceProfileSuffix;                               // 0x0010(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinRefreshRate;                                    // 0x0020(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLyraQualityDeviceProfileVariant) == 0x000008, "Wrong alignment on FLyraQualityDeviceProfileVariant");
static_assert(sizeof(FLyraQualityDeviceProfileVariant) == 0x000028, "Wrong size on FLyraQualityDeviceProfileVariant");
static_assert(offsetof(FLyraQualityDeviceProfileVariant, DisplayName) == 0x000000, "Member 'FLyraQualityDeviceProfileVariant::DisplayName' has a wrong offset!");
static_assert(offsetof(FLyraQualityDeviceProfileVariant, DeviceProfileSuffix) == 0x000010, "Member 'FLyraQualityDeviceProfileVariant::DeviceProfileSuffix' has a wrong offset!");
static_assert(offsetof(FLyraQualityDeviceProfileVariant, MinRefreshRate) == 0x000020, "Member 'FLyraQualityDeviceProfileVariant::MinRefreshRate' has a wrong offset!");

// ScriptStruct JP.LyraPerformanceStatGroup
// 0x0098 (0x0098 - 0x0000)
struct FLyraPerformanceStatGroup final
{
public:
	struct FGameplayTagQuery                      VisibilityQuery;                                   // 0x0000(0x0048)(Edit, NativeAccessSpecifierPublic)
	TSet<ELyraDisplayablePerformanceStat>         AllowedStats;                                      // 0x0048(0x0050)(Edit, NativeAccessSpecifierPublic)
};
static_assert(alignof(FLyraPerformanceStatGroup) == 0x000008, "Wrong alignment on FLyraPerformanceStatGroup");
static_assert(sizeof(FLyraPerformanceStatGroup) == 0x000098, "Wrong size on FLyraPerformanceStatGroup");
static_assert(offsetof(FLyraPerformanceStatGroup, VisibilityQuery) == 0x000000, "Member 'FLyraPerformanceStatGroup::VisibilityQuery' has a wrong offset!");
static_assert(offsetof(FLyraPerformanceStatGroup, AllowedStats) == 0x000048, "Member 'FLyraPerformanceStatGroup::AllowedStats' has a wrong offset!");

}

