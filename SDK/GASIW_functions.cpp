#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GASIW

#include "Basic.hpp"

#include "GASIW_classes.hpp"
#include "GASIW_parameters.hpp"


namespace SDK
{

// Function GASIW.AbilitySystemComponentIW.AbilityInputTagPressed
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::AbilityInputTagPressed(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "AbilityInputTagPressed");

	Params::AbilitySystemComponentIW_AbilityInputTagPressed Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.AbilityInputTagReleased
// (Final, Native, Public)
// Parameters:
// struct FGameplayTag                     InputTag                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::AbilityInputTagReleased(const struct FGameplayTag& InputTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "AbilityInputTagReleased");

	Params::AbilitySystemComponentIW_AbilityInputTagReleased Parms{};

	Parms.InputTag = std::move(InputTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.AddGameplayCueLocal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "AddGameplayCueLocal");

	Params::AbilitySystemComponentIW_AddGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.ApplyGameplayEffectSpecToTargetWithChange
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Changed                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FActiveGameplayEffectHandle      ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FActiveGameplayEffectHandle UAbilitySystemComponentIW::ApplyGameplayEffectSpecToTargetWithChange(const struct FGameplayEffectSpecHandle& SpecHandle, class UAbilitySystemComponent* Target, bool* Changed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "ApplyGameplayEffectSpecToTargetWithChange");

	Params::AbilitySystemComponentIW_ApplyGameplayEffectSpecToTargetWithChange Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Changed != nullptr)
		*Changed = Parms.Changed;

	return Parms.ReturnValue;
}


// Function GASIW.AbilitySystemComponentIW.CancelAbilitiesByTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            GameplayTagContainer                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilitySystemComponentIW::CancelAbilitiesByTag(const struct FGameplayTagContainer& GameplayTagContainer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "CancelAbilitiesByTag");

	Params::AbilitySystemComponentIW_CancelAbilitiesByTag Parms{};

	Parms.GameplayTagContainer = std::move(GameplayTagContainer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.AbilitySystemComponentIW.CheckInputComponent
// (Final, Native, Private)

void UAbilitySystemComponentIW::CheckInputComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "CheckInputComponent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.ExecuteGameplayCueLocal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "ExecuteGameplayCueLocal");

	Params::AbilitySystemComponentIW_ExecuteGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.GetCooldownRemainingForTag
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            CooldownTags                                           (Parm, NativeAccessSpecifierPublic)
// float                                   TimeRemaining                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CooldownDuration                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilitySystemComponentIW::GetCooldownRemainingForTag(const struct FGameplayTagContainer& CooldownTags, float* TimeRemaining, float* CooldownDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "GetCooldownRemainingForTag");

	Params::AbilitySystemComponentIW_GetCooldownRemainingForTag Parms{};

	Parms.CooldownTags = std::move(CooldownTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TimeRemaining != nullptr)
		*TimeRemaining = Parms.TimeRemaining;

	if (CooldownDuration != nullptr)
		*CooldownDuration = Parms.CooldownDuration;

	return Parms.ReturnValue;
}


// Function GASIW.AbilitySystemComponentIW.GiveGameplaySet
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplaySet*                     GameplaySet                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplaySetHandle               ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplaySetHandle UAbilitySystemComponentIW::GiveGameplaySet(const class UGameplaySet* GameplaySet, class UObject* SourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "GiveGameplaySet");

	Params::AbilitySystemComponentIW_GiveGameplaySet Parms{};

	Parms.GameplaySet = GameplaySet;
	Parms.SourceObject = SourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.AbilitySystemComponentIW.GiveGameplaySets
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UGameplaySet*>             GameplaySets                                           (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplaySetHandle>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FGameplaySetHandle> UAbilitySystemComponentIW::GiveGameplaySets(const TArray<class UGameplaySet*>& GameplaySets, class UObject* SourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "GiveGameplaySets");

	Params::AbilitySystemComponentIW_GiveGameplaySets Parms{};

	Parms.GameplaySets = std::move(GameplaySets);
	Parms.SourceObject = SourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.AbilitySystemComponentIW.OnRep_ReplicatedAnimMontageForMesh
// (Native, Protected)

void UAbilitySystemComponentIW::OnRep_ReplicatedAnimMontageForMesh()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "OnRep_ReplicatedAnimMontageForMesh");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.ProcessInput
// (Final, Native, Protected)

void UAbilitySystemComponentIW::ProcessInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "ProcessInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.RemoveGameplayCueLocal
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     GameplayCueTag                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayCueParameters           GameplayCueParameters                                  (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "RemoveGameplayCueLocal");

	Params::AbilitySystemComponentIW_RemoveGameplayCueLocal Parms{};

	Parms.GameplayCueTag = std::move(GameplayCueTag);
	Parms.GameplayCueParameters = std::move(GameplayCueParameters);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.RemoveGameplaySet
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplaySetHandle               Handle                                                 (Parm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::RemoveGameplaySet(const struct FGameplaySetHandle& Handle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "RemoveGameplaySet");

	Params::AbilitySystemComponentIW_RemoveGameplaySet Parms{};

	Parms.Handle = std::move(Handle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.ServerCurrentMontageJumpToSectionNameForMesh
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ClientAnimMontage                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::ServerCurrentMontageJumpToSectionNameForMesh(class USkeletalMeshComponent* InMesh, class UAnimMontage* ClientAnimMontage, class FName SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "ServerCurrentMontageJumpToSectionNameForMesh");

	Params::AbilitySystemComponentIW_ServerCurrentMontageJumpToSectionNameForMesh Parms{};

	Parms.InMesh = InMesh;
	Parms.ClientAnimMontage = ClientAnimMontage;
	Parms.SectionName = SectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.ServerCurrentMontageSetNextSectionNameForMesh
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ClientAnimMontage                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ClientPosition                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             NextSectionName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::ServerCurrentMontageSetNextSectionNameForMesh(class USkeletalMeshComponent* InMesh, class UAnimMontage* ClientAnimMontage, float ClientPosition, class FName SectionName, class FName NextSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "ServerCurrentMontageSetNextSectionNameForMesh");

	Params::AbilitySystemComponentIW_ServerCurrentMontageSetNextSectionNameForMesh Parms{};

	Parms.InMesh = InMesh;
	Parms.ClientAnimMontage = ClientAnimMontage;
	Parms.ClientPosition = ClientPosition;
	Parms.SectionName = SectionName;
	Parms.NextSectionName = NextSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.ServerCurrentMontageSetPlayRateForMesh
// (Net, NetReliable, Native, Event, Protected, NetServer, NetValidate)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ClientAnimMontage                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InPlayRate                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySystemComponentIW::ServerCurrentMontageSetPlayRateForMesh(class USkeletalMeshComponent* InMesh, class UAnimMontage* ClientAnimMontage, float InPlayRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "ServerCurrentMontageSetPlayRateForMesh");

	Params::AbilitySystemComponentIW_ServerCurrentMontageSetPlayRateForMesh Parms{};

	Parms.InMesh = InMesh;
	Parms.ClientAnimMontage = ClientAnimMontage;
	Parms.InPlayRate = InPlayRate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilitySystemComponentIW.SetGameplayEffectDurationHandle
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FActiveGameplayEffectHandle      Handle                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewDuration                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilitySystemComponentIW::SetGameplayEffectDurationHandle(const struct FActiveGameplayEffectHandle& Handle, float NewDuration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "SetGameplayEffectDurationHandle");

	Params::AbilitySystemComponentIW_SetGameplayEffectDurationHandle Parms{};

	Parms.Handle = std::move(Handle);
	Parms.NewDuration = NewDuration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.AbilitySystemComponentIW.GetNumAbilities
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UAbilitySystemComponentIW::GetNumAbilities() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentIW", "GetNumAbilities");

	Params::AbilitySystemComponentIW_GetNumAbilities Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.PickupSpawner.AttemptPickUpItem
// (BlueprintAuthorityOnly, Native, Event, Public, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APickupSpawner::AttemptPickUpItem(class APawn* Pawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "AttemptPickUpItem");

	Params::PickupSpawner_AttemptPickUpItem Parms{};

	Parms.Pawn = Pawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.PickupSpawner.GivePickup
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UItemDefinition>   PickupItemClass                                        (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReceivingPawn                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APickupSpawner::GivePickup(TSoftObjectPtr<class UItemDefinition>* PickupItemClass, class APawn* ReceivingPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "GivePickup");

	Params::PickupSpawner_GivePickup Parms{};

	Parms.ReceivingPawn = ReceivingPawn;

	UObject::ProcessEvent(Func, &Parms);

	if (PickupItemClass != nullptr)
		*PickupItemClass = Parms.PickupItemClass;

	return Parms.ReturnValue;
}


// Function GASIW.PickupSpawner.OnCoolDownTimerComplete
// (Final, Native, Public)

void APickupSpawner::OnCoolDownTimerComplete()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "OnCoolDownTimerComplete");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.PickupSpawner.OnInteractBegin
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           OtherActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APickupSpawner::OnInteractBegin(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "OnInteractBegin");

	Params::PickupSpawner_OnInteractBegin Parms{};

	Parms.OtherActor = OtherActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.PickupSpawner.OnPickupAvailable
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    PickupAvailability                                     (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APickupSpawner::OnPickupAvailable(const bool PickupAvailability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "OnPickupAvailable");

	Params::PickupSpawner_OnPickupAvailable Parms{};

	Parms.PickupAvailability = PickupAvailability;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GASIW.PickupSpawner.OnRep_PickupAvailability
// (Final, Native, Public)

void APickupSpawner::OnRep_PickupAvailability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "OnRep_PickupAvailability");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.PickupSpawner.PlayPickupEffects
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void APickupSpawner::PlayPickupEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "PlayPickupEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.PickupSpawner.PlayRespawnEffects
// (BlueprintCosmetic, Native, Event, Public, BlueprintEvent)

void APickupSpawner::PlayRespawnEffects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "PlayRespawnEffects");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.PickupSpawner.ResetCoolDown
// (Final, Native, Public, BlueprintCallable)

void APickupSpawner::ResetCoolDown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PickupSpawner", "ResetCoolDown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.AbilityTask_RepeatContinuous.RepeatContinuousAction
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeBetweenActions                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TotalActionCount                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_RepeatContinuous*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_RepeatContinuous* UAbilityTask_RepeatContinuous::RepeatContinuousAction(class UGameplayAbility* OwningAbility, float TimeBetweenActions, int32 TotalActionCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_RepeatContinuous", "RepeatContinuousAction");

	Params::AbilityTask_RepeatContinuous_RepeatContinuousAction Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TimeBetweenActions = TimeBetweenActions;
	Parms.TotalActionCount = TotalActionCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.AbilityTask_AddTagStackOverTime.AddTagStackOverTimeAction
// (Final, BlueprintAuthorityOnly, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StacksPerTick                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TicksPerSecond                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MaxCharges                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TotalTime                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_AddTagStackOverTime* ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_AddTagStackOverTime* UAbilityTask_AddTagStackOverTime::AddTagStackOverTimeAction(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, int32 StacksPerTick, int32 TicksPerSecond, int32 MaxCharges, float TotalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_AddTagStackOverTime", "AddTagStackOverTimeAction");

	Params::AbilityTask_AddTagStackOverTime_AddTagStackOverTimeAction Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Tag = std::move(Tag);
	Parms.StacksPerTick = StacksPerTick;
	Parms.TicksPerSecond = TicksPerSecond;
	Parms.MaxCharges = MaxCharges;
	Parms.TotalTime = TotalTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.AbilityTask_AddTagStackOverTime.PerformAction
// (Final, Native, Protected)

void UAbilityTask_AddTagStackOverTime::PerformAction()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_AddTagStackOverTime", "PerformAction");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.PlayMontageForMeshAndWaitForEvent.PlayMontageForMeshAndWaitForEvent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             TaskInstanceName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USkeletalMeshComponent*           Mesh_0                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     MontageToPlay_0                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            EventTags_0                                            (Parm, NativeAccessSpecifierPublic)
// float                                   Rate_0                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             StartSection_0                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bStopWhenAbilityEnds_0                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimRootMotionTranslationScale_0                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReplicateMontage_0                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideBlendOutTimeForCancelAbility_0                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideBlendOutTimeForStopWhenEndAbility_0            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayMontageForMeshAndWaitForEvent*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPlayMontageForMeshAndWaitForEvent* UPlayMontageForMeshAndWaitForEvent::PlayMontageForMeshAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class USkeletalMeshComponent* Mesh_0, class UAnimMontage* MontageToPlay_0, const struct FGameplayTagContainer& EventTags_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0, bool bReplicateMontage_0, float OverrideBlendOutTimeForCancelAbility_0, float OverrideBlendOutTimeForStopWhenEndAbility_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayMontageForMeshAndWaitForEvent", "PlayMontageForMeshAndWaitForEvent");

	Params::PlayMontageForMeshAndWaitForEvent_PlayMontageForMeshAndWaitForEvent Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TaskInstanceName = TaskInstanceName;
	Parms.Mesh_0 = Mesh_0;
	Parms.MontageToPlay_0 = MontageToPlay_0;
	Parms.EventTags_0 = std::move(EventTags_0);
	Parms.Rate_0 = Rate_0;
	Parms.StartSection_0 = StartSection_0;
	Parms.bStopWhenAbilityEnds_0 = bStopWhenAbilityEnds_0;
	Parms.AnimRootMotionTranslationScale_0 = AnimRootMotionTranslationScale_0;
	Parms.bReplicateMontage_0 = bReplicateMontage_0;
	Parms.OverrideBlendOutTimeForCancelAbility_0 = OverrideBlendOutTimeForCancelAbility_0;
	Parms.OverrideBlendOutTimeForStopWhenEndAbility_0 = OverrideBlendOutTimeForStopWhenEndAbility_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.BlueprintFunctionLibraryIW.EffectContextAddTargetData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryIW::EffectContextAddTargetData(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FGameplayAbilityTargetDataHandle& TargetData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryIW", "EffectContextAddTargetData");

	Params::BlueprintFunctionLibraryIW_EffectContextAddTargetData Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);
	Parms.TargetData = std::move(TargetData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.BlueprintFunctionLibraryIW.EffectContextGetTargetData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContext                                          (Parm, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayAbilityTargetDataHandle UBlueprintFunctionLibraryIW::EffectContextGetTargetData(const struct FGameplayEffectContextHandle& EffectContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryIW", "EffectContextGetTargetData");

	Params::BlueprintFunctionLibraryIW_EffectContextGetTargetData Parms{};

	Parms.EffectContext = std::move(EffectContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.ItemAction_DamageMultiplierStructures.GetMultiplierActionFromDefinition
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UObject>              ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UItemAction_DamageMultiplierStructures*ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UItemAction_DamageMultiplierStructures* UItemAction_DamageMultiplierStructures::GetMultiplierActionFromDefinition(TSubclassOf<class UObject> ItemDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemAction_DamageMultiplierStructures", "GetMultiplierActionFromDefinition");

	Params::ItemAction_DamageMultiplierStructures_GetMultiplierActionFromDefinition Parms{};

	Parms.ItemDefinition = ItemDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentInstance.K2_OnEquipped
// (Event, Protected, BlueprintEvent)

void UEquipmentInstance::K2_OnEquipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "K2_OnEquipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GASIW.EquipmentInstance.K2_OnRemoved
// (Event, Protected, BlueprintEvent)

void UEquipmentInstance::K2_OnRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "K2_OnRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GASIW.EquipmentInstance.K2_OnUnequipped
// (Event, Protected, BlueprintEvent)

void UEquipmentInstance::K2_OnUnequipped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "K2_OnUnequipped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GASIW.EquipmentInstance.OnRep_Instigator
// (Final, Native, Private)

void UEquipmentInstance::OnRep_Instigator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "OnRep_Instigator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentInstance.OnRep_SpawnedActors
// (Final, Native, Private)

void UEquipmentInstance::OnRep_SpawnedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "OnRep_SpawnedActors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentInstance.SetPrimaryDescription
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             PrimaryDescription                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEquipmentInstance::SetPrimaryDescription(const class FText& PrimaryDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "SetPrimaryDescription");

	Params::EquipmentInstance_SetPrimaryDescription Parms{};

	Parms.PrimaryDescription = std::move(PrimaryDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentInstance.SetSecondaryDescription
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             SecondaryDescription                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEquipmentInstance::SetSecondaryDescription(const class FText& SecondaryDescription)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "SetSecondaryDescription");

	Params::EquipmentInstance_SetSecondaryDescription Parms{};

	Parms.SecondaryDescription = std::move(SecondaryDescription);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentInstance.FindActionByType
// (Final, Native, Public, BlueprintCallable, Const)
// Parameters:
// TSubclassOf<class UEquipmentAction>     ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const class UEquipmentAction*           ReturnValue                                            (ConstParm, ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UEquipmentAction* UEquipmentInstance::FindActionByType(TSubclassOf<class UEquipmentAction> ActionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "FindActionByType");

	Params::EquipmentInstance_FindActionByType Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentInstance.GetInstigator
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UEquipmentInstance::GetInstigator() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "GetInstigator");

	Params::EquipmentInstance_GetInstigator Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentInstance.GetPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UEquipmentInstance::GetPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "GetPawn");

	Params::EquipmentInstance_GetPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentInstance.GetSpawnedActors
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FSpawnedActorData>        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FSpawnedActorData> UEquipmentInstance::GetSpawnedActors() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "GetSpawnedActors");

	Params::EquipmentInstance_GetSpawnedActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentInstance.GetTypedPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class APawn>                PawnType                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UEquipmentInstance::GetTypedPawn(TSubclassOf<class APawn> PawnType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "GetTypedPawn");

	Params::EquipmentInstance_GetTypedPawn Parms{};

	Parms.PawnType = PawnType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentInstance.GetViewMode
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EEquipmentViewMode                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EEquipmentViewMode UEquipmentInstance::GetViewMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "GetViewMode");

	Params::EquipmentInstance_GetViewMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentInstance.OnGrantPassiveStacks
// (Final, Native, Private, Const)

void UEquipmentInstance::OnGrantPassiveStacks() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentInstance", "OnGrantPassiveStacks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.AddPerkModifiedEquipment
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UEquipmentDefinition> EquipmentDefinition                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplaySet*>             NewGameplaySet                                         (Parm, ZeroConstructor, NativeAccessSpecifierPublic)

void UEquipmentManagerComponent::AddPerkModifiedEquipment(TSubclassOf<class UEquipmentDefinition> EquipmentDefinition, const TArray<class UGameplaySet*>& NewGameplaySet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "AddPerkModifiedEquipment");

	Params::EquipmentManagerComponent_AddPerkModifiedEquipment Parms{};

	Parms.EquipmentDefinition = EquipmentDefinition;
	Parms.NewGameplaySet = std::move(NewGameplaySet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.AddSocketParent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EEquipmentViewMode                      ViewMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  Parent                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManagerComponent::AddSocketParent(EEquipmentViewMode ViewMode, class USceneComponent* Parent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "AddSocketParent");

	Params::EquipmentManagerComponent_AddSocketParent Parms{};

	Parms.ViewMode = ViewMode;
	Parms.Parent = Parent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.AssignEquipmentToSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UEquipmentInstance*               Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentManagerComponent::AssignEquipmentToSlot(class UEquipmentInstance* Instance, const struct FGameplayTag& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "AssignEquipmentToSlot");

	Params::EquipmentManagerComponent_AssignEquipmentToSlot Parms{};

	Parms.Instance = Instance;
	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.BindOnSlotAddedInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UEquipmentInstance* Instance)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManagerComponent::BindOnSlotAddedInstance(const struct FGameplayTag& Slot, TDelegate<void(class UEquipmentInstance* Instance)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "BindOnSlotAddedInstance");

	Params::EquipmentManagerComponent_BindOnSlotAddedInstance Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.BindOnSlotRemovedInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(class UEquipmentInstance* Instance)>Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManagerComponent::BindOnSlotRemovedInstance(const struct FGameplayTag& Slot, TDelegate<void(class UEquipmentInstance* Instance)> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "BindOnSlotRemovedInstance");

	Params::EquipmentManagerComponent_BindOnSlotRemovedInstance Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.ClearSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentManagerComponent::ClearSlot(const struct FGameplayTag& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "ClearSlot");

	Params::EquipmentManagerComponent_ClearSlot Parms{};

	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.DoesSlotContainInstance
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEquipmentInstance*               Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentManagerComponent::DoesSlotContainInstance(class UEquipmentInstance* Instance, const struct FGameplayTag& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "DoesSlotContainInstance");

	Params::EquipmentManagerComponent_DoesSlotContainInstance Parms{};

	Parms.Instance = Instance;
	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.DoesSlotContainItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemDefinition>   Item                                                   (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentManagerComponent::DoesSlotContainItem(const struct FGameplayTag& Slot, TSoftObjectPtr<class UItemDefinition> Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "DoesSlotContainItem");

	Params::EquipmentManagerComponent_DoesSlotContainItem Parms{};

	Parms.Slot = std::move(Slot);
	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.EquipDefinition
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UEquipmentDefinition> EquipmentDefinition                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          SourceObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEquipmentInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentInstance* UEquipmentManagerComponent::EquipDefinition(TSubclassOf<class UEquipmentDefinition> EquipmentDefinition, class UObject* SourceObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "EquipDefinition");

	Params::EquipmentManagerComponent_EquipDefinition Parms{};

	Parms.EquipmentDefinition = EquipmentDefinition;
	Parms.SourceObject = SourceObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.EquipItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UItemInstance*                    Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEquipmentInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentInstance* UEquipmentManagerComponent::EquipItem(class UItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "EquipItem");

	Params::EquipmentManagerComponent_EquipItem Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.ForceAssignEquipmentToSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UEquipmentInstance*               Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManagerComponent::ForceAssignEquipmentToSlot(class UEquipmentInstance* Instance, const struct FGameplayTag& Slot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "ForceAssignEquipmentToSlot");

	Params::EquipmentManagerComponent_ForceAssignEquipmentToSlot Parms{};

	Parms.Instance = Instance;
	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.GetFirstInstanceOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UEquipmentInstance>   InstanceType                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEquipmentInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentInstance* UEquipmentManagerComponent::GetFirstInstanceOfType(TSubclassOf<class UEquipmentInstance> InstanceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "GetFirstInstanceOfType");

	Params::EquipmentManagerComponent_GetFirstInstanceOfType Parms{};

	Parms.InstanceType = InstanceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.GetFirstSpawnedActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               ActorType                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UEquipmentManagerComponent::GetFirstSpawnedActor(TSubclassOf<class AActor> ActorType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "GetFirstSpawnedActor");

	Params::EquipmentManagerComponent_GetFirstSpawnedActor Parms{};

	Parms.ActorType = ActorType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.GetFirstSpawnedActorWithInterface
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class IInterface>           InterfaceType                                          (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* UEquipmentManagerComponent::GetFirstSpawnedActorWithInterface(TSubclassOf<class IInterface> InterfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "GetFirstSpawnedActorWithInterface");

	Params::EquipmentManagerComponent_GetFirstSpawnedActorWithInterface Parms{};

	Parms.InterfaceType = InterfaceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.GetGameplaySetModifiedByPerk
// (Final, Native, Public)
// Parameters:
// TSubclassOf<class UEquipmentDefinition> EquipmentDefinition                                    (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplaySet*>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UGameplaySet*> UEquipmentManagerComponent::GetGameplaySetModifiedByPerk(TSubclassOf<class UEquipmentDefinition> EquipmentDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "GetGameplaySetModifiedByPerk");

	Params::EquipmentManagerComponent_GetGameplaySetModifiedByPerk Parms{};

	Parms.EquipmentDefinition = EquipmentDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.GetInstanceFromSlot
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     Slot                                                   (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsInstanceValid                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEquipmentInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentInstance* UEquipmentManagerComponent::GetInstanceFromSlot(const struct FGameplayTag& Slot, bool* IsInstanceValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "GetInstanceFromSlot");

	Params::EquipmentManagerComponent_GetInstanceFromSlot Parms{};

	Parms.Slot = std::move(Slot);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IsInstanceValid != nullptr)
		*IsInstanceValid = Parms.IsInstanceValid;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.OnItemMarkedForRemoval
// (Final, Native, Private)
// Parameters:
// class UItemInstance*                    Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManagerComponent::OnItemMarkedForRemoval(class UItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "OnItemMarkedForRemoval");

	Params::EquipmentManagerComponent_OnItemMarkedForRemoval Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.OnItemRemoved
// (Final, Native, Private)
// Parameters:
// class UItemInstance*                    Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManagerComponent::OnItemRemoved(class UItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "OnItemRemoved");

	Params::EquipmentManagerComponent_OnItemRemoved Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.OnRep_EquipmentArray
// (Final, Native, Private)

void UEquipmentManagerComponent::OnRep_EquipmentArray()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "OnRep_EquipmentArray");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.RemoveInstanceFromSlot
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UEquipmentInstance*               Instance                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEquipmentManagerComponent::RemoveInstanceFromSlot(class UEquipmentInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "RemoveInstanceFromSlot");

	Params::EquipmentManagerComponent_RemoveInstanceFromSlot Parms{};

	Parms.Instance = Instance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.EquipmentManagerComponent.UnequipItem
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UEquipmentInstance*               ItemInstance                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEquipmentManagerComponent::UnequipItem(class UEquipmentInstance* ItemInstance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "UnequipItem");

	Params::EquipmentManagerComponent_UnequipItem Parms{};

	Parms.ItemInstance = ItemInstance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.EquipmentManagerComponent.GetEquipmentInstancesOfType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UEquipmentInstance>   InstanceType                                           (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UEquipmentInstance*>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UEquipmentInstance*> UEquipmentManagerComponent::GetEquipmentInstancesOfType(TSubclassOf<class UEquipmentInstance> InstanceType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EquipmentManagerComponent", "GetEquipmentInstancesOfType");

	Params::EquipmentManagerComponent_GetEquipmentInstancesOfType Parms{};

	Parms.InstanceType = InstanceType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityIW.ActivateStaminaCost
// (Final, Native, Public, BlueprintCallable)

void UGameplayAbilityIW::ActivateStaminaCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "ActivateStaminaCost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.GameplayAbilityIW.GetCurrentMontageForMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAnimMontage*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAnimMontage* UGameplayAbilityIW::GetCurrentMontageForMesh(class USkeletalMeshComponent* InMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "GetCurrentMontageForMesh");

	Params::GameplayAbilityIW_GetCurrentMontageForMesh Parms{};

	Parms.InMesh = InMesh;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityIW.K2_CanActivate
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            RelevantTags                                           (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayAbilityIW::K2_CanActivate(struct FGameplayTagContainer& RelevantTags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "K2_CanActivate");

	Params::GameplayAbilityIW_K2_CanActivate Parms{};

	Parms.RelevantTags = std::move(RelevantTags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	RelevantTags = std::move(Parms.RelevantTags);

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityIW.K2_GetHitActorsWithTags
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FHitResult>               Hits                                                   (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagsToLookFor                                          (Parm, NativeAccessSpecifierPublic)
// bool                                    AllTagsMustMatch                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   MatchingActors                                         (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    NoHits                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbilityIW::K2_GetHitActorsWithTags(const TArray<struct FHitResult>& Hits, const struct FGameplayTagContainer& TagsToLookFor, bool AllTagsMustMatch, TArray<class AActor*>* MatchingActors, bool* NoHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "K2_GetHitActorsWithTags");

	Params::GameplayAbilityIW_K2_GetHitActorsWithTags Parms{};

	Parms.Hits = std::move(Hits);
	Parms.TagsToLookFor = std::move(TagsToLookFor);
	Parms.AllTagsMustMatch = AllTagsMustMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (MatchingActors != nullptr)
		*MatchingActors = std::move(Parms.MatchingActors);

	if (NoHits != nullptr)
		*NoHits = Parms.NoHits;
}


// Function GASIW.GameplayAbilityIW.K2_IsActive
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayAbilityIW::K2_IsActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "K2_IsActive");

	Params::GameplayAbilityIW_K2_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityIW.K2_OnAbilityAdded
// (Event, Protected, BlueprintEvent)

void UGameplayAbilityIW::K2_OnAbilityAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "K2_OnAbilityAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GASIW.GameplayAbilityIW.K2_OnAbilityFailed
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            FailureReason                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameplayAbilityIW::K2_OnAbilityFailed(const struct FGameplayTagContainer& FailureReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "K2_OnAbilityFailed");

	Params::GameplayAbilityIW_K2_OnAbilityFailed Parms{};

	Parms.FailureReason = std::move(FailureReason);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GASIW.GameplayAbilityIW.K2_OnAbilityRemoved
// (Event, Public, BlueprintEvent)

void UGameplayAbilityIW::K2_OnAbilityRemoved()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "K2_OnAbilityRemoved");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GASIW.GameplayAbilityIW.MontageJumpToSectionForMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             SectionName                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbilityIW::MontageJumpToSectionForMesh(class USkeletalMeshComponent* InMesh, class FName SectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "MontageJumpToSectionForMesh");

	Params::GameplayAbilityIW_MontageJumpToSectionForMesh Parms{};

	Parms.InMesh = InMesh;
	Parms.SectionName = SectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.GameplayAbilityIW.MontageSetNextSectionNameForMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             FromSectionName                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             ToSectionName                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbilityIW::MontageSetNextSectionNameForMesh(class USkeletalMeshComponent* InMesh, class FName FromSectionName, class FName ToSectionName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "MontageSetNextSectionNameForMesh");

	Params::GameplayAbilityIW_MontageSetNextSectionNameForMesh Parms{};

	Parms.InMesh = InMesh;
	Parms.FromSectionName = FromSectionName;
	Parms.ToSectionName = ToSectionName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.GameplayAbilityIW.MontageStopForAllMeshes
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   OverrideBlendOutTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbilityIW::MontageStopForAllMeshes(float OverrideBlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "MontageStopForAllMeshes");

	Params::GameplayAbilityIW_MontageStopForAllMeshes Parms{};

	Parms.OverrideBlendOutTime = OverrideBlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.GameplayAbilityIW.MontageStopForMesh
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USkeletalMeshComponent*           InMesh                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OverrideBlendOutTime                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbilityIW::MontageStopForMesh(class USkeletalMeshComponent* InMesh, float OverrideBlendOutTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "MontageStopForMesh");

	Params::GameplayAbilityIW_MontageStopForMesh Parms{};

	Parms.InMesh = InMesh;
	Parms.OverrideBlendOutTime = OverrideBlendOutTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.GameplayAbilityIW.GetLastActivationTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UGameplayAbilityIW::GetLastActivationTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "GetLastActivationTime");

	Params::GameplayAbilityIW_GetLastActivationTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityIW.IsInCooldownGracePeriod
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// float                                   TotalDurationBeforeDeath                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayAbilityIW::IsInCooldownGracePeriod(float TotalDurationBeforeDeath) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "IsInCooldownGracePeriod");

	Params::GameplayAbilityIW_IsInCooldownGracePeriod Parms{};

	Parms.TotalDurationBeforeDeath = TotalDurationBeforeDeath;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityIW.K2_GetCooldownTimeRemainingAndDuration
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   TimeRemaining                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   CooldownDuration                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayAbilityIW::K2_GetCooldownTimeRemainingAndDuration(float* TimeRemaining, float* CooldownDuration) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "K2_GetCooldownTimeRemainingAndDuration");

	Params::GameplayAbilityIW_K2_GetCooldownTimeRemainingAndDuration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (TimeRemaining != nullptr)
		*TimeRemaining = Parms.TimeRemaining;

	if (CooldownDuration != nullptr)
		*CooldownDuration = Parms.CooldownDuration;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityIW.K2_IsInstantiated
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGameplayAbilityIW::K2_IsInstantiated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityIW", "K2_IsInstantiated");

	Params::GameplayAbilityIW_K2_IsInstantiated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityEquipment.OnTagStacksChanged
// (Final, Native, Private)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewStacks                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbilityEquipment::OnTagStacksChanged(const struct FGameplayTag& Tag, int32 NewStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityEquipment", "OnTagStacksChanged");

	Params::GameplayAbilityEquipment_OnTagStacksChanged Parms{};

	Parms.Tag = std::move(Tag);
	Parms.NewStacks = NewStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function GASIW.GameplayAbilityEquipment.GetEquipableSkeletalMesh
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USkeletalMeshComponent*           ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USkeletalMeshComponent* UGameplayAbilityEquipment::GetEquipableSkeletalMesh() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityEquipment", "GetEquipableSkeletalMesh");

	Params::GameplayAbilityEquipment_GetEquipableSkeletalMesh Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityEquipment.GetEquipableTargetCueParameters
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayCueParameters           ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FGameplayCueParameters UGameplayAbilityEquipment::GetEquipableTargetCueParameters() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityEquipment", "GetEquipableTargetCueParameters");

	Params::GameplayAbilityEquipment_GetEquipableTargetCueParameters Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityEquipment.GetTagStackCount
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayAbilityEquipment::GetTagStackCount(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityEquipment", "GetTagStackCount");

	Params::GameplayAbilityEquipment_GetTagStackCount Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityEquipment.GetTagStackCountSafe
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UGameplayAbilityEquipment::GetTagStackCountSafe(const struct FGameplayTag& Tag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityEquipment", "GetTagStackCountSafe");

	Params::GameplayAbilityEquipment_GetTagStackCountSafe Parms{};

	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityItemHandler.GetAssociatedEquipment
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UEquipmentInstance*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEquipmentInstance* IGameplayAbilityItemHandler::GetAssociatedEquipment() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityItemHandler", "GetAssociatedEquipment");

	Params::GameplayAbilityItemHandler_GetAssociatedEquipment Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.GameplayAbilityItemHandler.GetAssociatedItem
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UItemInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemInstance* IGameplayAbilityItemHandler::GetAssociatedItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityItemHandler", "GetAssociatedItem");

	Params::GameplayAbilityItemHandler_GetAssociatedItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function GASIW.SpawnedActorViewModeHandler.OnHandleViewMode
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// EEquipmentViewMode                      ViewMode                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ISpawnedActorViewModeHandler::OnHandleViewMode(EEquipmentViewMode ViewMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SpawnedActorViewModeHandler", "OnHandleViewMode");

	Params::SpawnedActorViewModeHandler_OnHandleViewMode Parms{};

	Parms.ViewMode = ViewMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

