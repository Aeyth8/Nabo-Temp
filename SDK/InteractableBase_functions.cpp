#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: InteractableBase

#include "Basic.hpp"

#include "InteractableBase_classes.hpp"
#include "InteractableBase_parameters.hpp"


namespace SDK
{

// Function InteractableBase.InteractableBase_C.CancelInteraction
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::CancelInteraction(class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "CancelInteraction");

	Params::InteractableBase_C_CancelInteraction Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.ExecuteUbergraph_InteractableBase
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::ExecuteUbergraph_InteractableBase(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "ExecuteUbergraph_InteractableBase");

	Params::InteractableBase_C_ExecuteUbergraph_InteractableBase Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.GetInteractSound
// (Public, BlueprintCallable, BlueprintEvent)

void AInteractableBase_C::GetInteractSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "GetInteractSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InteractableBase.InteractableBase_C.GetNewWidgetColor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSlateColor                      NewColor                                               (Parm, OutParm)

void AInteractableBase_C::GetNewWidgetColor(struct FSlateColor* NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "GetNewWidgetColor");

	Params::InteractableBase_C_GetNewWidgetColor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewColor != nullptr)
		*NewColor = std::move(Parms.NewColor);
}


// Function InteractableBase.InteractableBase_C.GetOptionalText
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Return                                                 (Parm, OutParm)
// class FText                             Optional_Second_Line                                   (Parm, OutParm)

void AInteractableBase_C::GetOptionalText(class FText* Return, class FText* Optional_Second_Line)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "GetOptionalText");

	Params::InteractableBase_C_GetOptionalText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = std::move(Parms.Return);

	if (Optional_Second_Line != nullptr)
		*Optional_Second_Line = std::move(Parms.Optional_Second_Line);
}


// Function InteractableBase.InteractableBase_C.GetPriority
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Priority_0                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::GetPriority(int32* Priority_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "GetPriority");

	Params::InteractableBase_C_GetPriority Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Priority_0 != nullptr)
		*Priority_0 = Parms.Priority_0;
}


// Function InteractableBase.InteractableBase_C.GetWidgetLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::GetWidgetLocation(struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "GetWidgetLocation");

	Params::InteractableBase_C_GetWidgetLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function InteractableBase.InteractableBase_C.HideInteractionWidget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::HideInteractionWidget(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "HideInteractionWidget");

	Params::InteractableBase_C_HideInteractionWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function InteractableBase.InteractableBase_C.Interact Pressed Succes
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::Interact_Pressed_Succes(class AActor* InteractingActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "Interact Pressed Succes");

	Params::InteractableBase_C_Interact_Pressed_Succes Parms{};

	Parms.InteractingActor_0 = InteractingActor_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.Interactable Cosmetics
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Interactable_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::Interactable_Cosmetics(bool Interactable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "Interactable Cosmetics");

	Params::InteractableBase_C_Interactable_Cosmetics Parms{};

	Parms.Interactable_0 = Interactable_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.Interactable In Focus
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    InFocus                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::Interactable_In_Focus(bool InFocus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "Interactable In Focus");

	Params::InteractableBase_C_Interactable_In_Focus Parms{};

	Parms.InFocus = InFocus;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.InteractableCancelInteraction
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::InteractableCancelInteraction(class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "InteractableCancelInteraction");

	Params::InteractableBase_C_InteractableCancelInteraction Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.InteractPressed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::InteractPressed(class AActor* InteractingActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "InteractPressed");

	Params::InteractableBase_C_InteractPressed Parms{};

	Parms.InteractingActor_0 = InteractingActor_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.InteractReleased
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::InteractReleased(class AActor* InteractingActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "InteractReleased");

	Params::InteractableBase_C_InteractReleased Parms{};

	Parms.InteractingActor_0 = InteractingActor_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.IsInFocus
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Focusing_Actor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::IsInFocus(class AActor* Focusing_Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "IsInFocus");

	Params::InteractableBase_C_IsInFocus Parms{};

	Parms.Focusing_Actor = Focusing_Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.IsInteractable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Interactable_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::IsInteractable(bool* Interactable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "IsInteractable");

	Params::InteractableBase_C_IsInteractable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Interactable_0 != nullptr)
		*Interactable_0 = Parms.Interactable_0;
}


// Function InteractableBase.InteractableBase_C.Multi_Interact Pressed Cosmetics
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void AInteractableBase_C::Multi_Interact_Pressed_Cosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "Multi_Interact Pressed Cosmetics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InteractableBase.InteractableBase_C.OnRep_Interactable
// (BlueprintCallable, BlueprintEvent)

void AInteractableBase_C::OnRep_Interactable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "OnRep_Interactable");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InteractableBase.InteractableBase_C.PostInteract
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::PostInteract(class AActor* InteractingActor_0, class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "PostInteract");

	Params::InteractableBase_C_PostInteract Parms{};

	Parms.InteractingActor_0 = InteractingActor_0;
	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.PreInteract
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::PreInteract(class AActor* InteractingActor_0, class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "PreInteract");

	Params::InteractableBase_C_PreInteract Parms{};

	Parms.InteractingActor_0 = InteractingActor_0;
	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void AInteractableBase_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InteractableBase.InteractableBase_C.RegisterInteracter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           InteractingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::RegisterInteracter(class UPrimitiveComponent* InteractionComponent, class AActor* InteractingActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "RegisterInteracter");

	Params::InteractableBase_C_RegisterInteracter Parms{};

	Parms.InteractionComponent = InteractionComponent;
	Parms.InteractingActor_0 = InteractingActor_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.ReloadAfterHousesLoaded
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::ReloadAfterHousesLoaded(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "ReloadAfterHousesLoaded");

	Params::InteractableBase_C_ReloadAfterHousesLoaded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function InteractableBase.InteractableBase_C.Reset Cooldown
// (BlueprintCallable, BlueprintEvent)

void AInteractableBase_C::Reset_Cooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "Reset Cooldown");

	UObject::ProcessEvent(Func, nullptr);
}


// Function InteractableBase.InteractableBase_C.Set Interact Visibility
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Visibility                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::Set_Interact_Visibility(bool Visibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "Set Interact Visibility");

	Params::InteractableBase_C_Set_Interact_Visibility Parms{};

	Parms.Visibility = Visibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.SetHoveredComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInteractionComponent_C*          HoveredComponent                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::SetHoveredComponent(class UInteractionComponent_C* HoveredComponent, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "SetHoveredComponent");

	Params::InteractableBase_C_SetHoveredComponent Parms{};

	Parms.HoveredComponent = HoveredComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}


// Function InteractableBase.InteractableBase_C.SetInteractable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Interactable_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::SetInteractable(bool Interactable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "SetInteractable");

	Params::InteractableBase_C_SetInteractable Parms{};

	Parms.Interactable_0 = Interactable_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.UnregisterInteracter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           InteractingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::UnregisterInteracter(class UPrimitiveComponent* InteractionComponent, class AActor* InteractingActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "UnregisterInteracter");

	Params::InteractableBase_C_UnregisterInteracter Parms{};

	Parms.InteractionComponent = InteractionComponent;
	Parms.InteractingActor_0 = InteractingActor_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function InteractableBase.InteractableBase_C.GetInteractionDuration
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float AInteractableBase_C::GetInteractionDuration(class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "GetInteractionDuration");

	Params::InteractableBase_C_GetInteractionDuration Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function InteractableBase.InteractableBase_C.GetPostInteractSyncType
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bShouldSync                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EAbilityTaskNetSyncType                 Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::GetPostInteractSyncType(bool* bShouldSync, EAbilityTaskNetSyncType* Type, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "GetPostInteractSyncType");

	Params::InteractableBase_C_GetPostInteractSyncType Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldSync != nullptr)
		*bShouldSync = Parms.bShouldSync;

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function InteractableBase.InteractableBase_C.GetPreInteractSyncType
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bShouldSync                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EAbilityTaskNetSyncType                 Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void AInteractableBase_C::GetPreInteractSyncType(bool* bShouldSync, EAbilityTaskNetSyncType* Type, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "GetPreInteractSyncType");

	Params::InteractableBase_C_GetPreInteractSyncType Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldSync != nullptr)
		*bShouldSync = Parms.bShouldSync;

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function InteractableBase.InteractableBase_C.IsAvailableForEnemyTeam
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool AInteractableBase_C::IsAvailableForEnemyTeam(class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "IsAvailableForEnemyTeam");

	Params::InteractableBase_C_IsAvailableForEnemyTeam Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function InteractableBase.InteractableBase_C.IsAvailableForInteraction
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           InteractingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool AInteractableBase_C::IsAvailableForInteraction(class AActor* InteractingActor_0, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("InteractableBase_C", "IsAvailableForInteraction");

	Params::InteractableBase_C_IsAvailableForInteraction Parms{};

	Parms.InteractingActor_0 = InteractingActor_0;
	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

