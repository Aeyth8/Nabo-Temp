#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_Goose

#include "Basic.hpp"

#include "BP_Goose_classes.hpp"
#include "BP_Goose_parameters.hpp"


namespace SDK
{

// Function BP_Goose.BP_Goose_C.ApplyDamage
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::ApplyDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "ApplyDamage");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.Attack Target
// (BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::Attack_Target()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "Attack Target");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.Auth_Teleport To Controlling Actor
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          DestLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::Auth_Teleport_To_Controlling_Actor(const struct FVector& DestLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "Auth_Teleport To Controlling Actor");

	Params::BP_Goose_C_Auth_Teleport_To_Controlling_Actor Parms{};

	Parms.DestLocation = std::move(DestLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.CancelInteraction
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::CancelInteraction(class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "CancelInteraction");

	Params::BP_Goose_C_CancelInteraction Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.ExecuteUbergraph_BP_Goose
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::ExecuteUbergraph_BP_Goose(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "ExecuteUbergraph_BP_Goose");

	Params::BP_Goose_C_ExecuteUbergraph_BP_Goose Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.GetClosestOverlappingActorWithInterface
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Return                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::GetClosestOverlappingActorWithInterface(class AActor** Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetClosestOverlappingActorWithInterface");

	Params::BP_Goose_C_GetClosestOverlappingActorWithInterface Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Goose.BP_Goose_C.GetEquipmentManager
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UEquipmentManagerComponent*       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash)

class UEquipmentManagerComponent* ABP_Goose_C::GetEquipmentManager()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetEquipmentManager");

	Params::BP_Goose_C_GetEquipmentManager Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Goose.BP_Goose_C.GetGooseController
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ControllingActor_0                                     (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::GetGooseController(class AActor** ControllingActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetGooseController");

	Params::BP_Goose_C_GetGooseController Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ControllingActor_0 != nullptr)
		*ControllingActor_0 = Parms.ControllingActor_0;
}


// Function BP_Goose.BP_Goose_C.GetInteractSound
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::GetInteractSound()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetInteractSound");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.GetNewWidgetColor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FSlateColor                      NewColor                                               (Parm, OutParm)

void ABP_Goose_C::GetNewWidgetColor(struct FSlateColor* NewColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetNewWidgetColor");

	Params::BP_Goose_C_GetNewWidgetColor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (NewColor != nullptr)
		*NewColor = std::move(Parms.NewColor);
}


// Function BP_Goose.BP_Goose_C.GetOptionalText
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FText                             Return                                                 (Parm, OutParm)
// class FText                             Optional_Second_Line                                   (Parm, OutParm)

void ABP_Goose_C::GetOptionalText(class FText* Return, class FText* Optional_Second_Line)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetOptionalText");

	Params::BP_Goose_C_GetOptionalText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = std::move(Parms.Return);

	if (Optional_Second_Line != nullptr)
		*Optional_Second_Line = std::move(Parms.Optional_Second_Line);
}


// Function BP_Goose.BP_Goose_C.GetOwnerAbilitySystemComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Return                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::GetOwnerAbilitySystemComponent(class UAbilitySystemComponent** Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetOwnerAbilitySystemComponent");

	Params::BP_Goose_C_GetOwnerAbilitySystemComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Goose.BP_Goose_C.GetPriority
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Priority                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::GetPriority(int32* Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetPriority");

	Params::BP_Goose_C_GetPriority Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Priority != nullptr)
		*Priority = Parms.Priority;
}


// Function BP_Goose.BP_Goose_C.GetWidgetLocation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::GetWidgetLocation(struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetWidgetLocation");

	Params::BP_Goose_C_GetWidgetLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BP_Goose.BP_Goose_C.GrantGoose
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::GrantGoose(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GrantGoose");

	Params::BP_Goose_C_GrantGoose Parms{};

	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.HideInteractionWidget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::HideInteractionWidget(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "HideInteractionWidget");

	Params::BP_Goose_C_HideInteractionWidget Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_Goose.BP_Goose_C.InteractableCancelInteraction
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::InteractableCancelInteraction(class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "InteractableCancelInteraction");

	Params::BP_Goose_C_InteractableCancelInteraction Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.InteractPressed
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::InteractPressed(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "InteractPressed");

	Params::BP_Goose_C_InteractPressed Parms{};

	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.InteractReleased
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::InteractReleased(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "InteractReleased");

	Params::BP_Goose_C_InteractReleased Parms{};

	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.IsInFocus
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Focusing_Actor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::IsInFocus(class AActor* Focusing_Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "IsInFocus");

	Params::BP_Goose_C_IsInFocus Parms{};

	Parms.Focusing_Actor = Focusing_Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.IsInteractable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Interactable_0                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::IsInteractable(bool* Interactable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "IsInteractable");

	Params::BP_Goose_C_IsInteractable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Interactable_0 != nullptr)
		*Interactable_0 = Parms.Interactable_0;
}


// Function BP_Goose.BP_Goose_C.Multi_Attack Cosmetics
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::Multi_Attack_Cosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "Multi_Attack Cosmetics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.On Owner Dead Event
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ACharacter*                       Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::On_Owner_Dead_Event(class ACharacter* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "On Owner Dead Event");

	Params::BP_Goose_C_On_Owner_Dead_Event Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.On Unequipped Item
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UEquipmentInstance*               Instance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::On_Unequipped_Item(class UEquipmentInstance* Instance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "On Unequipped Item");

	Params::BP_Goose_C_On_Unequipped_Item Parms{};

	Parms.Instance = Instance;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.On_AttackFinished__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::On_AttackFinished__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "On_AttackFinished__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.OnRep_GooseState
// (BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::OnRep_GooseState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "OnRep_GooseState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.PostInteract
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::PostInteract(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "PostInteract");

	Params::BP_Goose_C_PostInteract Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.PreInteract
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::PreInteract(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "PreInteract");

	Params::BP_Goose_C_PreInteract Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_Goose_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.ReceivePossessed
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class AController*                      NewController                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::ReceivePossessed(class AController* NewController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "ReceivePossessed");

	Params::BP_Goose_C_ReceivePossessed Parms{};

	Parms.NewController = NewController;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.RegisterInteracter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::RegisterInteracter(class UPrimitiveComponent* InteractionComponent, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "RegisterInteracter");

	Params::BP_Goose_C_RegisterInteracter Parms{};

	Parms.InteractionComponent = InteractionComponent;
	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.SendMessageToAllPlayers
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::SendMessageToAllPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SendMessageToAllPlayers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.SetBBControllingActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          ObjectValue                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Clear                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::SetBBControllingActor(class UObject* ObjectValue, bool Clear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SetBBControllingActor");

	Params::BP_Goose_C_SetBBControllingActor Parms{};

	Parms.ObjectValue = ObjectValue;
	Parms.Clear = Clear;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.SetBBGooseState
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_GooseStates                           GooseState_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::SetBBGooseState(E_GooseStates GooseState_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SetBBGooseState");

	Params::BP_Goose_C_SetBBGooseState Parms{};

	Parms.GooseState_0 = GooseState_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.SetGooseControlled
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           ControllingActor_0                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::SetGooseControlled(class AActor* ControllingActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SetGooseControlled");

	Params::BP_Goose_C_SetGooseControlled Parms{};

	Parms.ControllingActor_0 = ControllingActor_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.SetGooseNonControlled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::SetGooseNonControlled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SetGooseNonControlled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.SetGooseTargetActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          ObjectValue                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Clear                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::SetGooseTargetActor(class UObject* ObjectValue, bool Clear)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SetGooseTargetActor");

	Params::BP_Goose_C_SetGooseTargetActor Parms{};

	Parms.ObjectValue = ObjectValue;
	Parms.Clear = Clear;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.SetHoveredComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UInteractionComponent_C*          HoveredComponent                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::SetHoveredComponent(class UInteractionComponent_C* HoveredComponent, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SetHoveredComponent");

	Params::BP_Goose_C_SetHoveredComponent Parms{};

	Parms.HoveredComponent = HoveredComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}


// Function BP_Goose.BP_Goose_C.SetInteractable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Interactable_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::SetInteractable(bool Interactable_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SetInteractable");

	Params::BP_Goose_C_SetInteractable Parms{};

	Parms.Interactable_0 = Interactable_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.SetKillData
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayEffectSpecHandle        Spec                                                   (BlueprintVisible, BlueprintReadOnly, Parm)

void ABP_Goose_C::SetKillData(const struct FGameplayEffectSpecHandle& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "SetKillData");

	Params::BP_Goose_C_SetKillData Parms{};

	Parms.Spec = std::move(Spec);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.Trace For Target
// (BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::Trace_For_Target()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "Trace For Target");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.Trace For Targets
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::Trace_For_Targets(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "Trace For Targets");

	Params::BP_Goose_C_Trace_For_Targets Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.UnregisterInteracter
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::UnregisterInteracter(class UPrimitiveComponent* InteractionComponent, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "UnregisterInteracter");

	Params::BP_Goose_C_UnregisterInteracter Parms{};

	Parms.InteractionComponent = InteractionComponent;
	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_Goose.BP_Goose_C.UpdateMoveSpeedbasedOnState
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_Goose_C::UpdateMoveSpeedbasedOnState()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "UpdateMoveSpeedbasedOnState");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_Goose.BP_Goose_C.GetInteractionDuration
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float ABP_Goose_C::GetInteractionDuration(class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetInteractionDuration");

	Params::BP_Goose_C_GetInteractionDuration Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Goose.BP_Goose_C.GetPostInteractSyncType
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bShouldSync                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EAbilityTaskNetSyncType                 Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::GetPostInteractSyncType(bool* bShouldSync, EAbilityTaskNetSyncType* Type, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetPostInteractSyncType");

	Params::BP_Goose_C_GetPostInteractSyncType Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldSync != nullptr)
		*bShouldSync = Parms.bShouldSync;

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function BP_Goose.BP_Goose_C.GetPreInteractSyncType
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bShouldSync                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EAbilityTaskNetSyncType                 Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_Goose_C::GetPreInteractSyncType(bool* bShouldSync, EAbilityTaskNetSyncType* Type, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "GetPreInteractSyncType");

	Params::BP_Goose_C_GetPreInteractSyncType Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldSync != nullptr)
		*bShouldSync = Parms.bShouldSync;

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function BP_Goose.BP_Goose_C.IsAvailableForEnemyTeam
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Goose_C::IsAvailableForEnemyTeam(class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "IsAvailableForEnemyTeam");

	Params::BP_Goose_C_IsAvailableForEnemyTeam Parms{};

	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_Goose.BP_Goose_C.IsAvailableForInteraction
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              InteractionComponent                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_Goose_C::IsAvailableForInteraction(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_Goose_C", "IsAvailableForInteraction");

	Params::BP_Goose_C_IsAvailableForInteraction Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.InteractionComponent = InteractionComponent;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

