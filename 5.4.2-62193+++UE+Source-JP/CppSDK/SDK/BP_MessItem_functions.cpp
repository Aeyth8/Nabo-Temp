#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_MessItem

#include "Basic.hpp"

#include "BP_MessItem_classes.hpp"
#include "BP_MessItem_parameters.hpp"


namespace SDK
{

// Function BP_MessItem.BP_MessItem_C.CanActivateTrap
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_MessItem_C::CanActivateTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "CanActivateTrap");

	Params::BP_MessItem_C_CanActivateTrap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_MessItem.BP_MessItem_C.CheckMovement
// (BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::CheckMovement()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "CheckMovement");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.ExecuteUbergraph_BP_MessItem
// (Final, UbergraphFunction)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::ExecuteUbergraph_BP_MessItem(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "ExecuteUbergraph_BP_MessItem");

	Params::BP_MessItem_C_ExecuteUbergraph_BP_MessItem Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MessItem.BP_MessItem_C.FillSlot
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::FillSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "FillSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.GetValidASC
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponent*          ASC                                                    (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    Valid                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::GetValidASC(class AActor* Actor, class UAbilitySystemComponent** ASC, bool* Valid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "GetValidASC");

	Params::BP_MessItem_C_GetValidASC Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	if (ASC != nullptr)
		*ASC = Parms.ASC;

	if (Valid != nullptr)
		*Valid = Parms.Valid;
}


// Function BP_MessItem.BP_MessItem_C.Handle Damage Event
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::Handle_Damage_Event(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "Handle Damage Event");

	Params::BP_MessItem_C_Handle_Damage_Event Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MessItem.BP_MessItem_C.HideVisibleReceptaclesAndZones
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::HideVisibleReceptaclesAndZones()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "HideVisibleReceptaclesAndZones");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.IsInFocus
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Focusing_Actor                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::IsInFocus(class AActor* Focusing_Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "IsInFocus");

	Params::BP_MessItem_C_IsInFocus Parms{};

	Parms.Focusing_Actor = Focusing_Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MessItem.BP_MessItem_C.Knockback
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Velocity                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    XYOverride                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ZOverride                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  AirControlMultiplier                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Void                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::Knockback(const struct FVector& Velocity, bool XYOverride, bool ZOverride, double AirControlMultiplier, bool* Void)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "Knockback");

	Params::BP_MessItem_C_Knockback Parms{};

	Parms.Velocity = std::move(Velocity);
	Parms.XYOverride = XYOverride;
	Parms.ZOverride = ZOverride;
	Parms.AirControlMultiplier = AirControlMultiplier;

	UObject::ProcessEvent(Func, &Parms);

	if (Void != nullptr)
		*Void = Parms.Void;
}


// Function BP_MessItem.BP_MessItem_C.LeaveSlot
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::LeaveSlot()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "LeaveSlot");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.MulticastLaunch
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Impulse                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::MulticastLaunch(const struct FVector& Impulse)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "MulticastLaunch");

	Params::BP_MessItem_C_MulticastLaunch Parms{};

	Parms.Impulse = std::move(Impulse);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MessItem.BP_MessItem_C.OnDropped
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::OnDropped()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "OnDropped");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.OnGrabbed
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::OnGrabbed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "OnGrabbed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_MessItem_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.RetriggerEndOverlaps
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::RetriggerEndOverlaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "RetriggerEndOverlaps");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.RetriggerOverlapBegins
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::RetriggerOverlapBegins()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "RetriggerOverlapBegins");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.RetriggerOverlaps
// (BlueprintCallable, BlueprintEvent)

void ABP_MessItem_C::RetriggerOverlaps()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "RetriggerOverlaps");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_MessItem.BP_MessItem_C.ServerPush
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FVector                          LaunchVelocity                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::ServerPush(class AActor* TargetActor, const struct FVector& LaunchVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "ServerPush");

	Params::BP_MessItem_C_ServerPush Parms{};

	Parms.TargetActor = TargetActor;
	Parms.LaunchVelocity = std::move(LaunchVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_MessItem.BP_MessItem_C.SetVisibleReceptacles
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_ReceptacleFurnitureBase_C*>Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*                           User                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::SetVisibleReceptacles(TArray<class ABP_ReceptacleFurnitureBase_C*>& Array, class AActor* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "SetVisibleReceptacles");

	Params::BP_MessItem_C_SetVisibleReceptacles Parms{};

	Parms.Array = std::move(Array);
	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);
}


// Function BP_MessItem.BP_MessItem_C.SetVisibleScoreZones
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class ABP_ReceptacleFurnitureBase_C*>Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class AActor*                           User                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_MessItem_C::SetVisibleScoreZones(TArray<class ABP_ReceptacleFurnitureBase_C*>& Array, class AActor* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_MessItem_C", "SetVisibleScoreZones");

	Params::BP_MessItem_C_SetVisibleScoreZones Parms{};

	Parms.Array = std::move(Array);
	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);
}

}

