#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GA_Bash

#include "Basic.hpp"

#include "GA_Bash_classes.hpp"
#include "GA_Bash_parameters.hpp"


namespace SDK
{

// Function GA_Bash.GA_Bash_C.AddAffectedCue
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UGA_Bash_C::AddAffectedCue(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "AddAffectedCue");

	Params::GA_Bash_C_AddAffectedCue Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.AddGameplayCueToOwner
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::AddGameplayCueToOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "AddGameplayCueToOwner");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.ApplyGameplayEffectToHitActorASC
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// TSubclassOf<class UGameplayEffect>      GameplayEffectClass                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash)
// struct FGameplayTag                     DataTag                                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// double                                  Magnitude                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FGameplayTag                     StructureDamageTag                                     (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::ApplyGameplayEffectToHitActorASC(class UAbilitySystemComponent* Target, TSubclassOf<class UGameplayEffect> GameplayEffectClass, const struct FGameplayTag& DataTag, double Magnitude, const struct FHitResult& HitResult, const struct FGameplayTag& StructureDamageTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "ApplyGameplayEffectToHitActorASC");

	Params::GA_Bash_C_ApplyGameplayEffectToHitActorASC Parms{};

	Parms.Target = Target;
	Parms.GameplayEffectClass = GameplayEffectClass;
	Parms.DataTag = std::move(DataTag);
	Parms.Magnitude = Magnitude;
	Parms.HitResult = std::move(HitResult);
	Parms.StructureDamageTag = std::move(StructureDamageTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.ApplyKillAssistedEffect
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          TargetASC                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::ApplyKillAssistedEffect(class UAbilitySystemComponent* TargetASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "ApplyKillAssistedEffect");

	Params::GA_Bash_C_ApplyKillAssistedEffect Parms{};

	Parms.TargetASC = TargetASC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.Bash Trace
// (BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::Bash_Trace()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Bash Trace");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.Bash With Hit Delay
// (BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::Bash_With_Hit_Delay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Bash With Hit Delay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.CalculateChargeUsingTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  TimeHeld                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  Charge                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::CalculateChargeUsingTime(double TimeHeld, double* Charge)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "CalculateChargeUsingTime");

	Params::GA_Bash_C_CalculateChargeUsingTime Parms{};

	Parms.TimeHeld = TimeHeld;

	UObject::ProcessEvent(Func, &Parms);

	if (Charge != nullptr)
		*Charge = Parms.Charge;
}


// Function GA_Bash.GA_Bash_C.CanAffectTeam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::CanAffectTeam(class AActor* Target, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "CanAffectTeam");

	Params::GA_Bash_C_CanAffectTeam Parms{};

	Parms.Target = Target;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Bash.GA_Bash_C.CanApplyHit
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UAbilitySystemComponentIW*        HitActorASC                                            (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Bash_C::CanApplyHit(class AActor* Actor, const struct FHitResult& Hit, class UAbilitySystemComponentIW** HitActorASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "CanApplyHit");

	Params::GA_Bash_C_CanApplyHit Parms{};

	Parms.Actor = Actor;
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	if (HitActorASC != nullptr)
		*HitActorASC = Parms.HitActorASC;

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.CanUseStamina
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    HasBlockingTag                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::CanUseStamina(bool* HasBlockingTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "CanUseStamina");

	Params::GA_Bash_C_CanUseStamina Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (HasBlockingTag != nullptr)
		*HasBlockingTag = Parms.HasBlockingTag;
}


// Function GA_Bash.GA_Bash_C.ClearTimers
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::ClearTimers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "ClearTimers");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.CommitStaminaCost
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::CommitStaminaCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "CommitStaminaCost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.Create Cant Apply Hit Message
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAbilitySystemComponentIW*        HitActorASC                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class FText                             CantApplyHitMessage_0                                  (Parm, OutParm)

void UGA_Bash_C::Create_Cant_Apply_Hit_Message(class UAbilitySystemComponentIW* HitActorASC, class FText* CantApplyHitMessage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Create Cant Apply Hit Message");

	Params::GA_Bash_C_Create_Cant_Apply_Hit_Message Parms{};

	Parms.HitActorASC = HitActorASC;

	UObject::ProcessEvent(Func, &Parms);

	if (CantApplyHitMessage_0 != nullptr)
		*CantApplyHitMessage_0 = std::move(Parms.CantApplyHitMessage_0);
}


// Function GA_Bash.GA_Bash_C.CreateCosmeticProjectileCueParameters
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayCueParameters           ReturnValue                                            (Parm, OutParm, ReturnParm, ContainsInstancedReference)

struct FGameplayCueParameters UGA_Bash_C::CreateCosmeticProjectileCueParameters()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "CreateCosmeticProjectileCueParameters");

	Params::GA_Bash_C_CreateCosmeticProjectileCueParameters Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.Display Cant Apply Hit Message Auth
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_ResidentCharacter_C*          BP_ResidentCharacter                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponentIW*        TargetedActorASC                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::Display_Cant_Apply_Hit_Message_Auth(class ABP_ResidentCharacter_C* BP_ResidentCharacter, class UAbilitySystemComponentIW* TargetedActorASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Display Cant Apply Hit Message Auth");

	Params::GA_Bash_C_Display_Cant_Apply_Hit_Message_Auth Parms{};

	Parms.BP_ResidentCharacter = BP_ResidentCharacter;
	Parms.TargetedActorASC = TargetedActorASC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.DisplayCantHitMessage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponentIW*        TargetedActorASC                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UObject*                          Actor                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::DisplayCantHitMessage(class UAbilitySystemComponentIW* TargetedActorASC, const class UObject* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "DisplayCantHitMessage");

	Params::GA_Bash_C_DisplayCantHitMessage Parms{};

	Parms.TargetedActorASC = TargetedActorASC;
	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.DoesShieldIntercept
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Intercepted                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UGA_Bash_C::DoesShieldIntercept(bool* Intercepted, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "DoesShieldIntercept");

	Params::GA_Bash_C_DoesShieldIntercept Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Intercepted != nullptr)
		*Intercepted = Parms.Intercepted;

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);
}


// Function GA_Bash.GA_Bash_C.EnableTrailOnSpawnedActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enable                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::EnableTrailOnSpawnedActor(bool Enable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "EnableTrailOnSpawnedActor");

	Params::GA_Bash_C_EnableTrailOnSpawnedActor Parms{};

	Parms.Enable = Enable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.EndAbilityAfterDelay
// (BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::EndAbilityAfterDelay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "EndAbilityAfterDelay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.ExecuteUbergraph_GA_Bash
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::ExecuteUbergraph_GA_Bash(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "ExecuteUbergraph_GA_Bash");

	Params::GA_Bash_C_ExecuteUbergraph_GA_Bash Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.FinishedTracing
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::FinishedTracing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "FinishedTracing");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.GetCenterLocationForImpact
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ImpactLocation                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TraceFrom                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ForwardVector                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UGA_Bash_C::GetCenterLocationForImpact(const struct FVector& ImpactLocation, const struct FVector& TraceFrom, const struct FVector& ForwardVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetCenterLocationForImpact");

	Params::GA_Bash_C_GetCenterLocationForImpact Parms{};

	Parms.ImpactLocation = std::move(ImpactLocation);
	Parms.TraceFrom = std::move(TraceFrom);
	Parms.ForwardVector = std::move(ForwardVector);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.GetChargedTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double UGA_Bash_C::GetChargedTime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetChargedTime");

	Params::GA_Bash_C_GetChargedTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.GetCosmeticLocationAndNormal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetCosmeticLocationAndNormal(const struct FHitResult& Hit, struct FVector* Location, struct FVector* Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetCosmeticLocationAndNormal");

	Params::GA_Bash_C_GetCosmeticLocationAndNormal Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Normal != nullptr)
		*Normal = std::move(Parms.Normal);
}


// Function GA_Bash.GA_Bash_C.GetDamageToShield
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UAbilitySystemComponentIW*        HitActorASC                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   Damage                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetDamageToShield(const struct FHitResult& HitResult, class UAbilitySystemComponentIW* HitActorASC, int32* Damage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetDamageToShield");

	Params::GA_Bash_C_GetDamageToShield Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.HitActorASC = HitActorASC;

	UObject::ProcessEvent(Func, &Parms);

	if (Damage != nullptr)
		*Damage = Parms.Damage;
}


// Function GA_Bash.GA_Bash_C.GetEffectCauser
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           EffectCauser                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetEffectCauser(class AActor** EffectCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetEffectCauser");

	Params::GA_Bash_C_GetEffectCauser Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (EffectCauser != nullptr)
		*EffectCauser = Parms.EffectCauser;
}


// Function GA_Bash.GA_Bash_C.GetHitBashBoneName
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetHitBashBoneName(class FName* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetHitBashBoneName");

	Params::GA_Bash_C_GetHitBashBoneName Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Bash.GA_Bash_C.GetImpactEffectType
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// E_ImpactEffect                          Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetImpactEffectType(E_ImpactEffect* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetImpactEffectType");

	Params::GA_Bash_C_GetImpactEffectType Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Bash.GA_Bash_C.GetInitialBashSound
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundCue*                        InitialSound                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetInitialBashSound(class USoundCue** InitialSound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetInitialBashSound");

	Params::GA_Bash_C_GetInitialBashSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InitialSound != nullptr)
		*InitialSound = Parms.InitialSound;
}


// Function GA_Bash.GA_Bash_C.GetItemAffectedSound
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundCue*                        Return                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetItemAffectedSound(class USoundCue** Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetItemAffectedSound");

	Params::GA_Bash_C_GetItemAffectedSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Bash.GA_Bash_C.GetItemCompatibleSound
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class USoundCue*                        Return                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetItemCompatibleSound(class USoundCue** Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetItemCompatibleSound");

	Params::GA_Bash_C_GetItemCompatibleSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Bash.GA_Bash_C.GetNoAbilityCost
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Bash_C::GetNoAbilityCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetNoAbilityCost");

	Params::GA_Bash_C_GetNoAbilityCost Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.GetNormal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          Normal                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector                    ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

const struct FVector UGA_Bash_C::GetNormal(const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetNormal");

	Params::GA_Bash_C_GetNormal Parms{};

	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.GetOwnerAbilitySystemComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UAbilitySystemComponent*          Return                                                 (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetOwnerAbilitySystemComponent(class UAbilitySystemComponent** Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetOwnerAbilitySystemComponent");

	Params::GA_Bash_C_GetOwnerAbilitySystemComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Bash.GA_Bash_C.GetOwnerAnimBPs
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// TArray<class UAnimInstance*>            Array_Element                                          (Parm, OutParm)

void UGA_Bash_C::GetOwnerAnimBPs(TArray<class UAnimInstance*>* Array_Element)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetOwnerAnimBPs");

	Params::GA_Bash_C_GetOwnerAnimBPs Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Array_Element != nullptr)
		*Array_Element = std::move(Parms.Array_Element);
}


// Function GA_Bash.GA_Bash_C.GetOwnersBlockingVolume
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_BlockingVolume_C*             BlockingVolume                                         (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetOwnersBlockingVolume(class ABP_BlockingVolume_C** BlockingVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetOwnersBlockingVolume");

	Params::GA_Bash_C_GetOwnersBlockingVolume Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (BlockingVolume != nullptr)
		*BlockingVolume = Parms.BlockingVolume;
}


// Function GA_Bash.GA_Bash_C.GetPercentageCharged
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  Percentage                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetPercentageCharged(double* Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetPercentageCharged");

	Params::GA_Bash_C_GetPercentageCharged Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Percentage != nullptr)
		*Percentage = Parms.Percentage;
}


// Function GA_Bash.GA_Bash_C.GetPlayMaterialLayerSound
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetPlayMaterialLayerSound(bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetPlayMaterialLayerSound");

	Params::GA_Bash_C_GetPlayMaterialLayerSound Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Bash.GA_Bash_C.GetSpawnedActor
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Return                                                 (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::GetSpawnedActor(class AActor** Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetSpawnedActor");

	Params::GA_Bash_C_GetSpawnedActor Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function GA_Bash.GA_Bash_C.GetTeamFromActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    TeamFound                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

uint8 UGA_Bash_C::GetTeamFromActor(class UObject* Actor, bool* TeamFound)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "GetTeamFromActor");

	Params::GA_Bash_C_GetTeamFromActor Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	if (TeamFound != nullptr)
		*TeamFound = Parms.TeamFound;

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.HasMatchEnded
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Bash_C::HasMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "HasMatchEnded");

	Params::GA_Bash_C_HasMatchEnded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.Hit Actor
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UAbilitySystemComponentIW*        HitActorASC                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::Hit_Actor(const struct FHitResult& HitResult, class UAbilitySystemComponentIW* HitActorASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Hit Actor");

	Params::GA_Bash_C_Hit_Actor Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.HitActorASC = HitActorASC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.Hit Actor Now
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UGA_Bash_C::Hit_Actor_Now(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Hit Actor Now");

	Params::GA_Bash_C_Hit_Actor_Now Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.HitNonASCActor
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UGA_Bash_C::HitNonASCActor(class AActor* HitActor, const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "HitNonASCActor");

	Params::GA_Bash_C_HitNonASCActor Parms{};

	Parms.HitActor = HitActor;
	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.HitThisActorAlready
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Bash_C::HitThisActorAlready(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "HitThisActorAlready");

	Params::GA_Bash_C_HitThisActorAlready Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.IsBelowMinimumDurability
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Bash_C::IsBelowMinimumDurability()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "IsBelowMinimumDurability");

	Params::GA_Bash_C_IsBelowMinimumDurability Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function GA_Bash.GA_Bash_C.K2_ActivateAbility
// (Event, Protected, BlueprintEvent)

void UGA_Bash_C::K2_ActivateAbility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "K2_ActivateAbility");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.K2_OnAbilityAdded
// (Event, Protected, BlueprintEvent)

void UGA_Bash_C::K2_OnAbilityAdded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "K2_OnAbilityAdded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.K2_OnEndAbility
// (Event, Protected, BlueprintEvent)
// Parameters:
// bool                                    bWasCancelled                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::K2_OnEndAbility(bool bWasCancelled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "K2_OnEndAbility");

	Params::GA_Bash_C_K2_OnEndAbility Parms{};

	Parms.bWasCancelled = bWasCancelled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.Knockback
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ForwardVector                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    TargetIsPlayer                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::Knockback(const struct FVector& ForwardVector, class UObject* Target, bool TargetIsPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Knockback");

	Params::GA_Bash_C_Knockback Parms{};

	Parms.ForwardVector = std::move(ForwardVector);
	Parms.Target = Target;
	Parms.TargetIsPlayer = TargetIsPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.KnockBackTarget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          ForwardVector                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Force                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    TargetIsPlayer                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::KnockBackTarget(const struct FVector& ForwardVector, float Force, class UObject* Target, bool TargetIsPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "KnockBackTarget");

	Params::GA_Bash_C_KnockBackTarget Parms{};

	Parms.ForwardVector = std::move(ForwardVector);
	Parms.Force = Force;
	Parms.Target = Target;
	Parms.TargetIsPlayer = TargetIsPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.LocalBlockedCosmetics
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          SpawnedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::LocalBlockedCosmetics(class UObject* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "LocalBlockedCosmetics");

	Params::GA_Bash_C_LocalBlockedCosmetics Parms{};

	Parms.SpawnedActor = SpawnedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.MontageNotify
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             NotifyName                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::MontageNotify(class FName NotifyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "MontageNotify");

	Params::GA_Bash_C_MontageNotify Parms{};

	Parms.NotifyName = NotifyName;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.OnFinish_498B34F041C5F8AB11CA549501BA3FCD
// (BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::OnFinish_498B34F041C5F8AB11CA549501BA3FCD()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "OnFinish_498B34F041C5F8AB11CA549501BA3FCD");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.OnFinish_B44E43F4463396E0A71A699915EDF7AA
// (BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::OnFinish_B44E43F4463396E0A71A699915EDF7AA()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "OnFinish_B44E43F4463396E0A71A699915EDF7AA");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.Play Compatible Particle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::Play_Compatible_Particle(const struct FVector& Location, const struct FVector& Normal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Play Compatible Particle");

	Params::GA_Bash_C_Play_Compatible_Particle Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.PlayMontageBash
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::PlayMontageBash()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "PlayMontageBash");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.PlayPhysMatParticle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPhysicalMaterial*                PhysicalMat                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::PlayPhysMatParticle(const struct FVector& Location, const struct FVector& Normal, class UPhysicalMaterial* PhysicalMat)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "PlayPhysMatParticle");

	Params::GA_Bash_C_PlayPhysMatParticle Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.PhysicalMat = PhysicalMat;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.RanOutOfCost
// (Public, BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::RanOutOfCost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "RanOutOfCost");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.Swing Cosmetics
// (BlueprintCallable, BlueprintEvent)

void UGA_Bash_C::Swing_Cosmetics()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Swing Cosmetics");

	UObject::ProcessEvent(Func, nullptr);
}


// Function GA_Bash.GA_Bash_C.Try Spawn Hit Decal
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void UGA_Bash_C::Try_Spawn_Hit_Decal(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "Try Spawn Hit Decal");

	Params::GA_Bash_C_Try_Spawn_Hit_Decal Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.TryCallShieldBlocked
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UAbilitySystemComponentIW*        HitActorASC                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::TryCallShieldBlocked(const struct FHitResult& HitResult, class UAbilitySystemComponentIW* HitActorASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "TryCallShieldBlocked");

	Params::GA_Bash_C_TryCallShieldBlocked Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.HitActorASC = HitActorASC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.TryKnockbackMessItem
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    HitMessItem                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::TryKnockbackMessItem(class UObject* Actor, bool* HitMessItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "TryKnockbackMessItem");

	Params::GA_Bash_C_TryKnockbackMessItem Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	if (HitMessItem != nullptr)
		*HitMessItem = Parms.HitMessItem;
}


// Function GA_Bash.GA_Bash_C.TryPlayInitialSound
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           SpawnedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void UGA_Bash_C::TryPlayInitialSound(class AActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "TryPlayInitialSound");

	Params::GA_Bash_C_TryPlayInitialSound Parms{};

	Parms.SpawnedActor = SpawnedActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function GA_Bash.GA_Bash_C.K2_CanActivateAbility
// (Event, Protected, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// struct FGameplayAbilityActorInfo        ActorInfo                                              (BlueprintVisible, BlueprintReadOnly, Parm, ContainsInstancedReference)
// struct FGameplayAbilitySpecHandle       Handle                                                 (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTagContainer            RelevantTags                                           (Parm, OutParm)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool UGA_Bash_C::K2_CanActivateAbility(const struct FGameplayAbilityActorInfo& ActorInfo, const struct FGameplayAbilitySpecHandle& Handle, struct FGameplayTagContainer* RelevantTags) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_Bash_C", "K2_CanActivateAbility");

	Params::GA_Bash_C_K2_CanActivateAbility Parms{};

	Parms.ActorInfo = std::move(ActorInfo);
	Parms.Handle = std::move(Handle);

	UObject::ProcessEvent(Func, &Parms);

	if (RelevantTags != nullptr)
		*RelevantTags = std::move(Parms.RelevantTags);

	return Parms.ReturnValue;
}

}

