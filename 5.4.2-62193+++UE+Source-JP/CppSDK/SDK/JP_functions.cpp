#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JP

#include "Basic.hpp"

#include "JP_classes.hpp"
#include "JP_parameters.hpp"


namespace SDK
{

// Function JP.LobbyConfigurationSummaryWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyConfigurationSummaryViewModelInModel                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULobbyConfigurationSummaryWidget::ApplyViewModel(const struct FLobbyConfigurationSummaryViewModel& InModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationSummaryWidget", "ApplyViewModel");

	Params::LobbyConfigurationSummaryWidget_ApplyViewModel Parms{};

	Parms.InModel = std::move(InModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyConfigurationSummaryWidget.HandleConfigurationChanged
// (Final, Native, Private)

void ULobbyConfigurationSummaryWidget::HandleConfigurationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationSummaryWidget", "HandleConfigurationChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyConfigurationSummaryWidget.InspectConfiguration
// (Final, Native, Public, BlueprintCallable)

void ULobbyConfigurationSummaryWidget::InspectConfiguration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationSummaryWidget", "InspectConfiguration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyConfigurationSummaryWidget.CanUserEditConfiguration
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULobbyConfigurationSummaryWidget::CanUserEditConfiguration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationSummaryWidget", "CanUserEditConfiguration");

	Params::LobbyConfigurationSummaryWidget_CanUserEditConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_GetCurrencyAmountWhenReady.GetCurrencyAmountWhenReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     CurrencyTag                                            (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_GetCurrencyAmountWhenReady*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_GetCurrencyAmountWhenReady* UAsyncAction_GetCurrencyAmountWhenReady::GetCurrencyAmountWhenReady(class UObject* WorldContextObject, const struct FGameplayTag& CurrencyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_GetCurrencyAmountWhenReady", "GetCurrencyAmountWhenReady");

	Params::AsyncAction_GetCurrencyAmountWhenReady_GetCurrencyAmountWhenReady Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.CurrencyTag = std::move(CurrencyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassRewardEntryWidgetBase.StartLoadGuard
// (Event, Public, BlueprintEvent)

void USeasonPassRewardEntryWidgetBase::StartLoadGuard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassRewardEntryWidgetBase", "StartLoadGuard");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.SeasonPassSingleRewardEntryWidget.HandleRewardContentCreated
// (Event, Public, BlueprintEvent)
// Parameters:
// class UUserWidget*                      NewRewardWidget                                        (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ESeasonPassRewardType                   RewardType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USeasonPassSingleRewardEntryWidget::HandleRewardContentCreated(class UUserWidget* NewRewardWidget, ESeasonPassRewardType RewardType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassSingleRewardEntryWidget", "HandleRewardContentCreated");

	Params::SeasonPassSingleRewardEntryWidget_HandleRewardContentCreated Parms{};

	Parms.NewRewardWidget = NewRewardWidget;
	Parms.RewardType = RewardType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.SeasonPassSingleRewardEntryWidget.K2_HandleEmptyReward
// (Event, Public, BlueprintEvent)

void USeasonPassSingleRewardEntryWidget::K2_HandleEmptyReward()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassSingleRewardEntryWidget", "K2_HandleEmptyReward");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.LyraBrightnessEditor.HandleBackClicked
// (Final, Native, Private)

void ULyraBrightnessEditor::HandleBackClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBrightnessEditor", "HandleBackClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraBrightnessEditor.HandleDoneClicked
// (Final, Native, Private)

void ULyraBrightnessEditor::HandleDoneClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraBrightnessEditor", "HandleDoneClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_GetProfileXPWhenReady.GetProfileXPWhenReady
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_GetProfileXPWhenReady*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_GetProfileXPWhenReady* UAsyncAction_GetProfileXPWhenReady::GetProfileXPWhenReady(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_GetProfileXPWhenReady", "GetProfileXPWhenReady");

	Params::AsyncAction_GetProfileXPWhenReady_GetProfileXPWhenReady Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.SetAllowAudioInBackgroundSetting
// (Final, Native, Public)
// Parameters:
// ELyraAllowBackgroundAudioSetting        NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetAllowAudioInBackgroundSetting(ELyraAllowBackgroundAudioSetting NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetAllowAudioInBackgroundSetting");

	Params::LyraSettingsShared_SetAllowAudioInBackgroundSetting Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetColorBlindMode
// (Final, Native, Public)
// Parameters:
// EColorBlindMode                         InMode                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetColorBlindMode(EColorBlindMode InMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetColorBlindMode");

	Params::LyraSettingsShared_SetColorBlindMode Parms{};

	Parms.InMode = InMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetColorBlindStrength
// (Final, Native, Public)
// Parameters:
// int32                                   InColorBlindStrength                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetColorBlindStrength(int32 InColorBlindStrength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetColorBlindStrength");

	Params::LyraSettingsShared_SetColorBlindStrength Parms{};

	Parms.InColorBlindStrength = InColorBlindStrength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetForceFeedbackEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetForceFeedbackEnabled(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetForceFeedbackEnabled");

	Params::LyraSettingsShared_SetForceFeedbackEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetFOV
// (Final, Native, Public)
// Parameters:
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetFOV(float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetFOV");

	Params::LyraSettingsShared_SetFOV Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetGamepadLookStickDeadZone
// (Final, Native, Public)
// Parameters:
// float                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetGamepadLookStickDeadZone(const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetGamepadLookStickDeadZone");

	Params::LyraSettingsShared_SetGamepadLookStickDeadZone Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetGamepadMoveStickDeadZone
// (Final, Native, Public)
// Parameters:
// float                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetGamepadMoveStickDeadZone(const float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetGamepadMoveStickDeadZone");

	Params::LyraSettingsShared_SetGamepadMoveStickDeadZone Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetGamepadTargetingSensitivityPreset
// (Final, Native, Public)
// Parameters:
// ELyraGamepadSensitivity                 NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetGamepadTargetingSensitivityPreset(ELyraGamepadSensitivity NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetGamepadTargetingSensitivityPreset");

	Params::LyraSettingsShared_SetGamepadTargetingSensitivityPreset Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetInvertHorizontalAxis
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInvertHorizontalAxis(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInvertHorizontalAxis");

	Params::LyraSettingsShared_SetInvertHorizontalAxis Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetInvertHorizontalAxisMouse
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInvertHorizontalAxisMouse(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInvertHorizontalAxisMouse");

	Params::LyraSettingsShared_SetInvertHorizontalAxisMouse Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetInvertVerticalAxis
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInvertVerticalAxis(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInvertVerticalAxis");

	Params::LyraSettingsShared_SetInvertVerticalAxis Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetInvertVerticalAxisMouse
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetInvertVerticalAxisMouse(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetInvertVerticalAxisMouse");

	Params::LyraSettingsShared_SetInvertVerticalAxisMouse Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetLookSensitivityPreset
// (Final, Native, Public)
// Parameters:
// ELyraGamepadSensitivity                 NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetLookSensitivityPreset(ELyraGamepadSensitivity NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetLookSensitivityPreset");

	Params::LyraSettingsShared_SetLookSensitivityPreset Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetMouseSensitivityX
// (Final, Native, Public)
// Parameters:
// double                                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetMouseSensitivityX(double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetMouseSensitivityX");

	Params::LyraSettingsShared_SetMouseSensitivityX Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetMouseSensitivityY
// (Final, Native, Public)
// Parameters:
// double                                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetMouseSensitivityY(double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetMouseSensitivityY");

	Params::LyraSettingsShared_SetMouseSensitivityY Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetTargetingMultiplier
// (Final, Native, Public)
// Parameters:
// double                                  NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTargetingMultiplier(double NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTargetingMultiplier");

	Params::LyraSettingsShared_SetTargetingMultiplier Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetTriggerHapticsEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTriggerHapticsEnabled(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTriggerHapticsEnabled");

	Params::LyraSettingsShared_SetTriggerHapticsEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetTriggerHapticStartPosition
// (Final, Native, Public)
// Parameters:
// uint8                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTriggerHapticStartPosition(const uint8 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTriggerHapticStartPosition");

	Params::LyraSettingsShared_SetTriggerHapticStartPosition Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetTriggerHapticStrength
// (Final, Native, Public)
// Parameters:
// uint8                                   NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTriggerHapticStrength(const uint8 NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTriggerHapticStrength");

	Params::LyraSettingsShared_SetTriggerHapticStrength Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.SetTriggerPullUsesHapticThreshold
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsShared::SetTriggerPullUsesHapticThreshold(const bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "SetTriggerPullUsesHapticThreshold");

	Params::LyraSettingsShared_SetTriggerPullUsesHapticThreshold Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsShared.GetAllowAudioInBackgroundSetting
// (Final, Native, Public, Const)
// Parameters:
// ELyraAllowBackgroundAudioSetting        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraAllowBackgroundAudioSetting ULyraSettingsShared::GetAllowAudioInBackgroundSetting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetAllowAudioInBackgroundSetting");

	Params::LyraSettingsShared_GetAllowAudioInBackgroundSetting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetColorBlindMode
// (Final, Native, Public, Const)
// Parameters:
// EColorBlindMode                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EColorBlindMode ULyraSettingsShared::GetColorBlindMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetColorBlindMode");

	Params::LyraSettingsShared_GetColorBlindMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetColorBlindStrength
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsShared::GetColorBlindStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetColorBlindStrength");

	Params::LyraSettingsShared_GetColorBlindStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetForceFeedbackEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetForceFeedbackEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetForceFeedbackEnabled");

	Params::LyraSettingsShared_GetForceFeedbackEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetFOV
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsShared::GetFOV() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetFOV");

	Params::LyraSettingsShared_GetFOV Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetGamepadLookSensitivityPreset
// (Final, Native, Public, Const)
// Parameters:
// ELyraGamepadSensitivity                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraGamepadSensitivity ULyraSettingsShared::GetGamepadLookSensitivityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetGamepadLookSensitivityPreset");

	Params::LyraSettingsShared_GetGamepadLookSensitivityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetGamepadLookStickDeadZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsShared::GetGamepadLookStickDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetGamepadLookStickDeadZone");

	Params::LyraSettingsShared_GetGamepadLookStickDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetGamepadMoveStickDeadZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsShared::GetGamepadMoveStickDeadZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetGamepadMoveStickDeadZone");

	Params::LyraSettingsShared_GetGamepadMoveStickDeadZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetGamepadTargetingSensitivityPreset
// (Final, Native, Public, Const)
// Parameters:
// ELyraGamepadSensitivity                 ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraGamepadSensitivity ULyraSettingsShared::GetGamepadTargetingSensitivityPreset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetGamepadTargetingSensitivityPreset");

	Params::LyraSettingsShared_GetGamepadTargetingSensitivityPreset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetInvertHorizontalAxis
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetInvertHorizontalAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInvertHorizontalAxis");

	Params::LyraSettingsShared_GetInvertHorizontalAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetInvertHorizontalAxisMouse
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetInvertHorizontalAxisMouse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInvertHorizontalAxisMouse");

	Params::LyraSettingsShared_GetInvertHorizontalAxisMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetInvertVerticalAxis
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetInvertVerticalAxis() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInvertVerticalAxis");

	Params::LyraSettingsShared_GetInvertVerticalAxis Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetInvertVerticalAxisMouse
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetInvertVerticalAxisMouse() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetInvertVerticalAxisMouse");

	Params::LyraSettingsShared_GetInvertVerticalAxisMouse Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetMouseSensitivityX
// (Final, Native, Public, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraSettingsShared::GetMouseSensitivityX() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetMouseSensitivityX");

	Params::LyraSettingsShared_GetMouseSensitivityX Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetMouseSensitivityY
// (Final, Native, Public, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraSettingsShared::GetMouseSensitivityY() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetMouseSensitivityY");

	Params::LyraSettingsShared_GetMouseSensitivityY Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetTargetingMultiplier
// (Final, Native, Public, Const)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraSettingsShared::GetTargetingMultiplier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTargetingMultiplier");

	Params::LyraSettingsShared_GetTargetingMultiplier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetTriggerHapticsEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetTriggerHapticsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTriggerHapticsEnabled");

	Params::LyraSettingsShared_GetTriggerHapticsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetTriggerHapticStartPosition
// (Final, Native, Public, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ULyraSettingsShared::GetTriggerHapticStartPosition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTriggerHapticStartPosition");

	Params::LyraSettingsShared_GetTriggerHapticStartPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetTriggerHapticStrength
// (Final, Native, Public, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ULyraSettingsShared::GetTriggerHapticStrength() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTriggerHapticStrength");

	Params::LyraSettingsShared_GetTriggerHapticStrength Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsShared.GetTriggerPullUsesHapticThreshold
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsShared::GetTriggerPullUsesHapticThreshold() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsShared", "GetTriggerPullUsesHapticThreshold");

	Params::LyraSettingsShared_GetTriggerPullUsesHapticThreshold Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ArmorAttributeSet.OnRep_MeleeArmor
// (Native, Public)

void UArmorAttributeSet::OnRep_MeleeArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmorAttributeSet", "OnRep_MeleeArmor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ArmorAttributeSet.OnRep_ProjectileArmor
// (Native, Public)

void UArmorAttributeSet::OnRep_ProjectileArmor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ArmorAttributeSet", "OnRep_ProjectileArmor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AnimNotify_PlaySoundForPerspective.OnMontageEnded
// (Final, Native, Private, Const)
// Parameters:
// class UAnimMontage*                     Montage                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInterrupted                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAnimNotify_PlaySoundForPerspective::OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AnimNotify_PlaySoundForPerspective", "OnMontageEnded");

	Params::AnimNotify_PlaySoundForPerspective_OnMontageEnded Parms{};

	Parms.Montage = Montage;
	Parms.bInterrupted = bInterrupted;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SeasonPassRewardWidgetCatalogItemInterface.ApplyCatalogItemData
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSeasonPassCatalogItem           Item                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ISeasonPassRewardWidgetCatalogItemInterface::ApplyCatalogItemData(const struct FSeasonPassCatalogItem& Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassRewardWidgetCatalogItemInterface", "ApplyCatalogItemData");

	Params::SeasonPassRewardWidgetCatalogItemInterface_ApplyCatalogItemData Parms{};

	Parms.Item = std::move(Item);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AuthenticationInitializationStep_AccountData.HandleUserAvatarLoaded
// (Final, Native, Public)
// Parameters:
// bool                                    bInWasSuccessful                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture>          InResultTexture                                        (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthenticationInitializationStep_AccountData::HandleUserAvatarLoaded(bool bInWasSuccessful, TSoftObjectPtr<class UTexture> InResultTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthenticationInitializationStep_AccountData", "HandleUserAvatarLoaded");

	Params::AuthenticationInitializationStep_AccountData_HandleUserAvatarLoaded Parms{};

	Parms.bInWasSuccessful = bInWasSuccessful;
	Parms.InResultTexture = InResultTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EndCondition.EliminateTeam
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AEndCondition::EliminateTeam(uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndCondition", "EliminateTeam");

	Params::EndCondition_EliminateTeam Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EndCondition.GetEndConditionName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName AEndCondition::GetEndConditionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndCondition", "GetEndConditionName");

	Params::EndCondition_GetEndConditionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamColorFunctionLibrary.GetLocalPlayerTeamId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UTeamColorFunctionLibrary::GetLocalPlayerTeamId(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamColorFunctionLibrary", "GetLocalPlayerTeamId");

	Params::TeamColorFunctionLibrary_GetLocalPlayerTeamId Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamColorFunctionLibrary.GetTeamColorForTeamId
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UTeamColorFunctionLibrary::GetTeamColorForTeamId(class UObject* WorldContext, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamColorFunctionLibrary", "GetTeamColorForTeamId");

	Params::TeamColorFunctionLibrary_GetTeamColorForTeamId Parms{};

	Parms.WorldContext = WorldContext;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamColorFunctionLibrary.GetTeamColorForTeamType
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// ETeamType                               TeamType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FLinearColor UTeamColorFunctionLibrary::GetTeamColorForTeamType(ETeamType TeamType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamColorFunctionLibrary", "GetTeamColorForTeamType");

	Params::TeamColorFunctionLibrary_GetTeamColorForTeamType Parms{};

	Parms.TeamType = TeamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamColorFunctionLibrary.GetTeamIdFromTeamType
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamType                               TeamType                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UTeamColorFunctionLibrary::GetTeamIdFromTeamType(class UObject* WorldContext, ETeamType TeamType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamColorFunctionLibrary", "GetTeamIdFromTeamType");

	Params::TeamColorFunctionLibrary_GetTeamIdFromTeamType Parms{};

	Parms.WorldContext = WorldContext;
	Parms.TeamType = TeamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamColorFunctionLibrary.GetTeamIdFromTeamTypeFromSpecificPlayerPointOfView
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamType                               TeamTypeToConvert                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UTeamColorFunctionLibrary::GetTeamIdFromTeamTypeFromSpecificPlayerPointOfView(class APlayerController* PlayerController, ETeamType TeamTypeToConvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamColorFunctionLibrary", "GetTeamIdFromTeamTypeFromSpecificPlayerPointOfView");

	Params::TeamColorFunctionLibrary_GetTeamIdFromTeamTypeFromSpecificPlayerPointOfView Parms{};

	Parms.PlayerController = PlayerController;
	Parms.TeamTypeToConvert = TeamTypeToConvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamColorFunctionLibrary.GetTeamTypeFromTeamId
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamType UTeamColorFunctionLibrary::GetTeamTypeFromTeamId(class UObject* WorldContext, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamColorFunctionLibrary", "GetTeamTypeFromTeamId");

	Params::TeamColorFunctionLibrary_GetTeamTypeFromTeamId Parms{};

	Parms.WorldContext = WorldContext;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamColorFunctionLibrary.GetTeamTypeFromTeamIdFromSpecificPlayerPointOfView
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamIdToConvert                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ETeamType                               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ETeamType UTeamColorFunctionLibrary::GetTeamTypeFromTeamIdFromSpecificPlayerPointOfView(class APlayerController* PlayerController, uint8 TeamIdToConvert)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamColorFunctionLibrary", "GetTeamTypeFromTeamIdFromSpecificPlayerPointOfView");

	Params::TeamColorFunctionLibrary_GetTeamTypeFromTeamIdFromSpecificPlayerPointOfView Parms{};

	Parms.PlayerController = PlayerController;
	Parms.TeamIdToConvert = TeamIdToConvert;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AuthenticationInitializationStep_GameData.OnFinishedUpdatingGameData
// (Final, Native, Private)

void UAuthenticationInitializationStep_GameData::OnFinishedUpdatingGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthenticationInitializationStep_GameData", "OnFinishedUpdatingGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AuthenticationInitializationStep_GameData.OnLoggedIn
// (Final, Native, Private)

void UAuthenticationInitializationStep_GameData::OnLoggedIn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthenticationInitializationStep_GameData", "OnLoggedIn");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialListWidget.BlueprintApplyListStateNoAnimation
// (Event, Protected, BlueprintEvent)
// Parameters:
// ESocialListState                        InListState                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialListWidget::BlueprintApplyListStateNoAnimation(const ESocialListState InListState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialListWidget", "BlueprintApplyListStateNoAnimation");

	Params::SocialListWidget_BlueprintApplyListStateNoAnimation Parms{};

	Parms.InListState = InListState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.SocialListWidget.SetHeader
// (Event, Public, BlueprintEvent)
// Parameters:
// class FString                           StringToAppend                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialListWidget::SetHeader(const class FString& StringToAppend)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialListWidget", "SetHeader");

	Params::SocialListWidget_SetHeader Parms{};

	Parms.StringToAppend = std::move(StringToAppend);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.AchievementsGameInstanceSubsystem.ResetAchievements
// (Final, Native, Public, BlueprintCallable)

void UAchievementsGameInstanceSubsystem::ResetAchievements()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsGameInstanceSubsystem", "ResetAchievements");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AchievementsGameInstanceSubsystem.UnlockAchievement
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UAchievementMetaData>AchievementMetaData                                    (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsGameInstanceSubsystem::UnlockAchievement(const TSoftObjectPtr<class UAchievementMetaData> AchievementMetaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsGameInstanceSubsystem", "UnlockAchievement");

	Params::AchievementsGameInstanceSubsystem_UnlockAchievement Parms{};

	Parms.AchievementMetaData = AchievementMetaData;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AchievementsGameInstanceSubsystem.UpdateAchievementStatFloat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UAchievementStatMetaData>AchievementStatMetaData                                (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   StatValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsGameInstanceSubsystem::UpdateAchievementStatFloat(const TSoftObjectPtr<class UAchievementStatMetaData> AchievementStatMetaData, const float StatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsGameInstanceSubsystem", "UpdateAchievementStatFloat");

	Params::AchievementsGameInstanceSubsystem_UpdateAchievementStatFloat Parms{};

	Parms.AchievementStatMetaData = AchievementStatMetaData;
	Parms.StatValue = StatValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AchievementsGameInstanceSubsystem.UpdateAchievementStatInt
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UAchievementStatMetaData>AchievementStatMetaData                                (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   StatValue                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAchievementsGameInstanceSubsystem::UpdateAchievementStatInt(const TSoftObjectPtr<class UAchievementStatMetaData> AchievementStatMetaData, const int32 StatValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AchievementsGameInstanceSubsystem", "UpdateAchievementStatInt");

	Params::AchievementsGameInstanceSubsystem_UpdateAchievementStatInt Parms{};

	Parms.AchievementStatMetaData = AchievementStatMetaData;
	Parms.StatValue = StatValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamableInterface.GetTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FTeam                            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTeam ITeamableInterface::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamableInterface", "GetTeam");

	Params::TeamableInterface_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamableInterface.GetTeamID
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 ITeamableInterface::GetTeamID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamableInterface", "GetTeamID");

	Params::TeamableInterface_GetTeamID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamableInterface.HasTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITeamableInterface::HasTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamableInterface", "HasTeam");

	Params::TeamableInterface_HasTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamableInterface.TakeDamageFromAllTeams
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ITeamableInterface::TakeDamageFromAllTeams() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamableInterface", "TakeDamageFromAllTeams");

	Params::TeamableInterface_TakeDamageFromAllTeams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AmmoAttributeSet.OnRep_FireworkBoxAmmo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldFireworkBoxAmmo                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAmmoAttributeSet::OnRep_FireworkBoxAmmo(const struct FGameplayAttributeData& OldFireworkBoxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSet", "OnRep_FireworkBoxAmmo");

	Params::AmmoAttributeSet_OnRep_FireworkBoxAmmo Parms{};

	Parms.OldFireworkBoxAmmo = std::move(OldFireworkBoxAmmo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSet.OnRep_FireworkBoxMaxAmmo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldFireworkBoxAmmoMax                                  (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAmmoAttributeSet::OnRep_FireworkBoxMaxAmmo(const struct FGameplayAttributeData& OldFireworkBoxAmmoMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSet", "OnRep_FireworkBoxMaxAmmo");

	Params::AmmoAttributeSet_OnRep_FireworkBoxMaxAmmo Parms{};

	Parms.OldFireworkBoxAmmoMax = std::move(OldFireworkBoxAmmoMax);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSet.OnRep_OrangeCannonAmmo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldOrangeCannonAmmo                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAmmoAttributeSet::OnRep_OrangeCannonAmmo(const struct FGameplayAttributeData& OldOrangeCannonAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSet", "OnRep_OrangeCannonAmmo");

	Params::AmmoAttributeSet_OnRep_OrangeCannonAmmo Parms{};

	Parms.OldOrangeCannonAmmo = std::move(OldOrangeCannonAmmo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSet.OnRep_OrangeCannonMaxAmmo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldOrangeCannonAmmoMax                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAmmoAttributeSet::OnRep_OrangeCannonMaxAmmo(const struct FGameplayAttributeData& OldOrangeCannonAmmoMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSet", "OnRep_OrangeCannonMaxAmmo");

	Params::AmmoAttributeSet_OnRep_OrangeCannonMaxAmmo Parms{};

	Parms.OldOrangeCannonAmmoMax = std::move(OldOrangeCannonAmmoMax);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSet.OnRep_SlingshotAmmo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldSlingshotAmmo                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAmmoAttributeSet::OnRep_SlingshotAmmo(const struct FGameplayAttributeData& OldSlingshotAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSet", "OnRep_SlingshotAmmo");

	Params::AmmoAttributeSet_OnRep_SlingshotAmmo Parms{};

	Parms.OldSlingshotAmmo = std::move(OldSlingshotAmmo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSet.OnRep_SlingshotMaxAmmo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldSlingshotAmmoMax                                    (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAmmoAttributeSet::OnRep_SlingshotMaxAmmo(const struct FGameplayAttributeData& OldSlingshotAmmoMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSet", "OnRep_SlingshotMaxAmmo");

	Params::AmmoAttributeSet_OnRep_SlingshotMaxAmmo Parms{};

	Parms.OldSlingshotAmmoMax = std::move(OldSlingshotAmmoMax);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSet.OnRep_WrenchAmmo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldWrenchAmmo                                          (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAmmoAttributeSet::OnRep_WrenchAmmo(const struct FGameplayAttributeData& OldWrenchAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSet", "OnRep_WrenchAmmo");

	Params::AmmoAttributeSet_OnRep_WrenchAmmo Parms{};

	Parms.OldWrenchAmmo = std::move(OldWrenchAmmo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSet.OnRep_WrenchMaxAmmo
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayAttributeData           OldWrenchAmmoMax                                       (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAmmoAttributeSet::OnRep_WrenchMaxAmmo(const struct FGameplayAttributeData& OldWrenchAmmoMax)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSet", "OnRep_WrenchMaxAmmo");

	Params::AmmoAttributeSet_OnRep_WrenchMaxAmmo Parms{};

	Parms.OldWrenchAmmoMax = std::move(OldWrenchAmmoMax);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialFriendEntryWidget.GetLocalizedStatusInfo
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// EOnlineServicesFriendStatus             Status                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             StatusText                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialFriendEntryWidget::GetLocalizedStatusInfo(const EOnlineServicesFriendStatus Status, class FText* StatusText, struct FLinearColor* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialFriendEntryWidget", "GetLocalizedStatusInfo");

	Params::SocialFriendEntryWidget_GetLocalizedStatusInfo Parms{};

	Parms.Status = Status;

	UObject::ProcessEvent(Func, &Parms);

	if (StatusText != nullptr)
		*StatusText = std::move(Parms.StatusText);

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function JP.SocialFriendEntryWidget.SetIsInviteSent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsInviteSent                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialFriendEntryWidget::SetIsInviteSent(const bool bIsInviteSent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialFriendEntryWidget", "SetIsInviteSent");

	Params::SocialFriendEntryWidget_SetIsInviteSent Parms{};

	Parms.bIsInviteSent = bIsInviteSent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialFriendEntryWidget.SetStatus
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EOnlineServicesFriendStatus             Status                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialFriendEntryWidget::SetStatus(const EOnlineServicesFriendStatus Status)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialFriendEntryWidget", "SetStatus");

	Params::SocialFriendEntryWidget_SetStatus Parms{};

	Parms.Status = Status;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_WaitForClientAuthenticationInitialized.WaitForClientAuthenticationInitialized
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_WaitForClientAuthenticationInitialized*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_WaitForClientAuthenticationInitialized* UAsyncAction_WaitForClientAuthenticationInitialized::WaitForClientAuthenticationInitialized(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_WaitForClientAuthenticationInitialized", "WaitForClientAuthenticationInitialized");

	Params::AsyncAction_WaitForClientAuthenticationInitialized_WaitForClientAuthenticationInitialized Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP.GetGameModeJP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameModeJP*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameModeJP* AGameModeJP::GetGameModeJP(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameModeJP", "GetGameModeJP");

	Params::GameModeJP_GetGameModeJP Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP.GetEnemyHouseEssentialKills
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerStateJP*                   PlayerStateJP                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeJP::GetEnemyHouseEssentialKills(const class APlayerStateJP* PlayerStateJP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP", "GetEnemyHouseEssentialKills");

	Params::GameModeJP_GetEnemyHouseEssentialKills Parms{};

	Parms.PlayerStateJP = PlayerStateJP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP.GetTeamHouseEssentialLost
// (Native, Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerStateJP*                   PlayerStateJP                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 AGameModeJP::GetTeamHouseEssentialLost(const class APlayerStateJP* PlayerStateJP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP", "GetTeamHouseEssentialLost");

	Params::GameModeJP_GetTeamHouseEssentialLost Parms{};

	Parms.PlayerStateJP = PlayerStateJP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP.ServerTravel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UWorld>            TargetLevel                                            (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP::ServerTravel(TSoftObjectPtr<class UWorld> TargetLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP", "ServerTravel");

	Params::GameModeJP_ServerTravel Parms{};

	Parms.TargetLevel = TargetLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Match.EndConditionEnabled
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AEndCondition>        EndConditionType                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeJP_Match::EndConditionEnabled(class UObject* WorldContextObject, TSubclassOf<class AEndCondition> EndConditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameModeJP_Match", "EndConditionEnabled");

	Params::GameModeJP_Match_EndConditionEnabled Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EndConditionType = EndConditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP_Match.GetEndCondition
// (Final, Native, Static, Protected, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AEndCondition>        EndConditionType                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AEndCondition*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEndCondition* AGameModeJP_Match::GetEndCondition(class UObject* WorldContextObject, TSubclassOf<class AEndCondition> EndConditionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameModeJP_Match", "GetEndCondition");

	Params::GameModeJP_Match_GetEndCondition Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EndConditionType = EndConditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP_Match.CanShutdownGracefully
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeJP_Match::CanShutdownGracefully()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "CanShutdownGracefully");

	Params::GameModeJP_Match_CanShutdownGracefully Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP_Match.CanShutdownGracefully_Internal
// (Final, Native, Private)

void AGameModeJP_Match::CanShutdownGracefully_Internal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "CanShutdownGracefully_Internal");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Match.ChoosePlayerStart_Implementation
// (Native, Public, BlueprintCallable)
// Parameters:
// class AController*                      Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* AGameModeJP_Match::ChoosePlayerStart_Implementation(class AController* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "ChoosePlayerStart_Implementation");

	Params::GameModeJP_Match_ChoosePlayerStart_Implementation Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP_Match.GracefulShutdownBegin
// (Final, Native, Private)

void AGameModeJP_Match::GracefulShutdownBegin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "GracefulShutdownBegin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Match.HandlePlayerBlockedListInitialized
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_Match::HandlePlayerBlockedListInitialized(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "HandlePlayerBlockedListInitialized");

	Params::GameModeJP_Match_HandlePlayerBlockedListInitialized Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Match.OnKill
// (Native, Protected, HasOutParams)
// Parameters:
// struct FGameplayTag                     Channel                                                (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FKillGameplayMessage             MessagePayload                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void AGameModeJP_Match::OnKill(const struct FGameplayTag& Channel, const struct FKillGameplayMessage& MessagePayload)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "OnKill");

	Params::GameModeJP_Match_OnKill Parms{};

	Parms.Channel = std::move(Channel);
	Parms.MessagePayload = std::move(MessagePayload);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Match.RestartMatch
// (Native, Public, BlueprintCallable)

void AGameModeJP_Match::RestartMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "RestartMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Match.ServerDoneLoadingHouses
// (Native, Public, BlueprintCallable)

void AGameModeJP_Match::ServerDoneLoadingHouses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "ServerDoneLoadingHouses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Match.AddEndCondition
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, Const)
// Parameters:
// TSubclassOf<class AEndCondition>        EndConditionType                                       (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_Match::AddEndCondition(TSubclassOf<class AEndCondition> EndConditionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "AddEndCondition");

	Params::GameModeJP_Match_AddEndCondition Parms{};

	Parms.EndConditionType = EndConditionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Match.IsAllClientsHousesLoaded
// (Final, BlueprintAuthorityOnly, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeJP_Match::IsAllClientsHousesLoaded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Match", "IsAllClientsHousesLoaded");

	Params::GameModeJP_Match_IsAllClientsHousesLoaded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AbilityTask_WaitForActorOutOfFocus.WaitForActorOutOfFocus
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ActorToFind                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            TagsToLookFor                                          (Parm, NativeAccessSpecifierPublic)
// float                                   CheckInterval                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitForActorOutOfFocus*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitForActorOutOfFocus* UAbilityTask_WaitForActorOutOfFocus::WaitForActorOutOfFocus(class UGameplayAbility* OwningAbility, class AActor* ActorToFind, const struct FGameplayTagContainer& TagsToLookFor, float CheckInterval)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitForActorOutOfFocus", "WaitForActorOutOfFocus");

	Params::AbilityTask_WaitForActorOutOfFocus_WaitForActorOutOfFocus Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.ActorToFind = ActorToFind;
	Parms.TagsToLookFor = std::move(TagsToLookFor);
	Parms.CheckInterval = CheckInterval;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AbilityTask_WaitForActorOutOfFocus.CheckOnOutOfFocus
// (Final, Native, Public)

void UAbilityTask_WaitForActorOutOfFocus::CheckOnOutOfFocus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitForActorOutOfFocus", "CheckOnOutOfFocus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.WarmupActor.DisableWarmup
// (Event, Public, BlueprintEvent)

void AWarmupActor::DisableWarmup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupActor", "DisableWarmup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.WarmupActor.EnableWarmup
// (Event, Public, BlueprintEvent)

void AWarmupActor::EnableWarmup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupActor", "EnableWarmup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.LyraSettingValueDiscreteDynamic_AudioOutputDevice.DefaultDeviceChanged
// (Final, Native, Public)
// Parameters:
// EAudioDeviceChangedRole                 InRole                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioOutputDevice::DefaultDeviceChanged(EAudioDeviceChangedRole InRole, const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioOutputDevice", "DefaultDeviceChanged");

	Params::LyraSettingValueDiscreteDynamic_AudioOutputDevice_DefaultDeviceChanged Parms{};

	Parms.InRole = InRole;
	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingValueDiscreteDynamic_AudioOutputDevice.DeviceAddedOrRemoved
// (Final, Native, Public)
// Parameters:
// class FString                           DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioOutputDevice::DeviceAddedOrRemoved(const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioOutputDevice", "DeviceAddedOrRemoved");

	Params::LyraSettingValueDiscreteDynamic_AudioOutputDevice_DeviceAddedOrRemoved Parms{};

	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingValueDiscreteDynamic_AudioOutputDevice.OnAudioOutputDevicesObtained
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<struct FAudioOutputDeviceInfo>   AvailableDevices                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioOutputDevice::OnAudioOutputDevicesObtained(const TArray<struct FAudioOutputDeviceInfo>& AvailableDevices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioOutputDevice", "OnAudioOutputDevicesObtained");

	Params::LyraSettingValueDiscreteDynamic_AudioOutputDevice_OnAudioOutputDevicesObtained Parms{};

	Parms.AvailableDevices = std::move(AvailableDevices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingValueDiscreteDynamic_AudioOutputDevice.OnCompletedDeviceSwap
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FSwapAudioOutputResult           SwapResult                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioOutputDevice::OnCompletedDeviceSwap(const struct FSwapAudioOutputResult& SwapResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioOutputDevice", "OnCompletedDeviceSwap");

	Params::LyraSettingValueDiscreteDynamic_AudioOutputDevice_OnCompletedDeviceSwap Parms{};

	Parms.SwapResult = std::move(SwapResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialBlockedPlayerEntryWidget.GetLocalizedStatusInfo
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class FText                             StatusText                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialBlockedPlayerEntryWidget::GetLocalizedStatusInfo(class FText* StatusText, struct FLinearColor* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialBlockedPlayerEntryWidget", "GetLocalizedStatusInfo");

	Params::SocialBlockedPlayerEntryWidget_GetLocalizedStatusInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (StatusText != nullptr)
		*StatusText = std::move(Parms.StatusText);

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function JP.SocialBlockedPlayerEntryWidget.SetStatus
// (Final, Native, Public, BlueprintCallable)

void USocialBlockedPlayerEntryWidget::SetStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialBlockedPlayerEntryWidget", "SetStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AbilityTask_WaitInputReleaseOrTimer.WaitInputReleaseOrTimer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTestAlreadyReleased                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_WaitInputReleaseOrTimer*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_WaitInputReleaseOrTimer* UAbilityTask_WaitInputReleaseOrTimer::WaitInputReleaseOrTimer(class UGameplayAbility* OwningAbility, float Time, bool bTestAlreadyReleased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_WaitInputReleaseOrTimer", "WaitInputReleaseOrTimer");

	Params::AbilityTask_WaitInputReleaseOrTimer_WaitInputReleaseOrTimer Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Time = Time;
	Parms.bTestAlreadyReleased = bTestAlreadyReleased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AbilityTask_WaitInputReleaseOrTimer.OnReleaseCallback
// (Final, Native, Public)

void UAbilityTask_WaitInputReleaseOrTimer::OnReleaseCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_WaitInputReleaseOrTimer", "OnReleaseCallback");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncTaskEffectStackChanged.ListenForGameplayEffectStackChange
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          AbilitySystemComponent                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     EffectGameplayTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncTaskEffectStackChanged*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncTaskEffectStackChanged* UAsyncTaskEffectStackChanged::ListenForGameplayEffectStackChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncTaskEffectStackChanged", "ListenForGameplayEffectStackChange");

	Params::AsyncTaskEffectStackChanged_ListenForGameplayEffectStackChange Parms{};

	Parms.AbilitySystemComponent = AbilitySystemComponent;
	Parms.EffectGameplayTag = std::move(EffectGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncTaskEffectStackChanged.EndTask
// (Final, Native, Private, BlueprintCallable)

void UAsyncTaskEffectStackChanged::EndTask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncTaskEffectStackChanged", "EndTask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandShakePlayerStateComponent.OnRep_ElapsedTimeWhenJoinedMatch
// (Final, Native, Public)

void UPlayerJoinHandShakePlayerStateComponent::OnRep_ElapsedTimeWhenJoinedMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandShakePlayerStateComponent", "OnRep_ElapsedTimeWhenJoinedMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandShakePlayerStateComponent.OnRep_IsBlockedListInitialized
// (Native, Public)

void UPlayerJoinHandShakePlayerStateComponent::OnRep_IsBlockedListInitialized()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandShakePlayerStateComponent", "OnRep_IsBlockedListInitialized");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandShakePlayerStateComponent.OnRep_JoinStatus
// (Native, Public)

void UPlayerJoinHandShakePlayerStateComponent::OnRep_JoinStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandShakePlayerStateComponent", "OnRep_JoinStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandShakePlayerStateComponent.GetIsBlockedListInitialized
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerJoinHandShakePlayerStateComponent::GetIsBlockedListInitialized() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandShakePlayerStateComponent", "GetIsBlockedListInitialized");

	Params::PlayerJoinHandShakePlayerStateComponent_GetIsBlockedListInitialized Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerJoinHandShakePlayerStateComponent.GetJoinStatus
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPlayerStateJoinStatus                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPlayerStateJoinStatus UPlayerJoinHandShakePlayerStateComponent::GetJoinStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandShakePlayerStateComponent", "GetJoinStatus");

	Params::PlayerJoinHandShakePlayerStateComponent_GetJoinStatus Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_WaitForLoadingScreenToHide.WaitForLoadingScreenToHide
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_WaitForLoadingScreenToHide*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_WaitForLoadingScreenToHide* UAsyncAction_WaitForLoadingScreenToHide::WaitForLoadingScreenToHide(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_WaitForLoadingScreenToHide", "WaitForLoadingScreenToHide");

	Params::AsyncAction_WaitForLoadingScreenToHide_WaitForLoadingScreenToHide Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_WaitForLoadingScreenToHide.OnLoadingScreenStatusChanged
// (Final, Native, Private)
// Parameters:
// bool                                    LoadingScreenVisibilityChanged                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAction_WaitForLoadingScreenToHide::OnLoadingScreenStatusChanged(bool LoadingScreenVisibilityChanged)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_WaitForLoadingScreenToHide", "OnLoadingScreenStatusChanged");

	Params::AsyncAction_WaitForLoadingScreenToHide_OnLoadingScreenStatusChanged Parms{};

	Parms.LoadingScreenVisibilityChanged = LoadingScreenVisibilityChanged;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AuthenticationInitialization_RecoverMatch.AbortReconnect
// (Final, Native, Public, BlueprintCallable)

void UAuthenticationInitialization_RecoverMatch::AbortReconnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthenticationInitialization_RecoverMatch", "AbortReconnect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AuthenticationInitialization_RecoverMatch.Reconnect
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TDelegate<void(bool Success)>           OnComplete                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAuthenticationInitialization_RecoverMatch::Reconnect(const TDelegate<void(bool Success)> OnComplete)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AuthenticationInitialization_RecoverMatch", "Reconnect");

	Params::AuthenticationInitialization_RecoverMatch_Reconnect Parms{};

	Parms.OnComplete = OnComplete;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_WaitForCoordinatorActivation_UIDataIsReady.WaitForUIDataIsReadyCoordinator
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady* UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady::WaitForUIDataIsReadyCoordinator(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_WaitForCoordinatorActivation_UIDataIsReady", "WaitForUIDataIsReadyCoordinator");

	Params::AsyncAction_WaitForCoordinatorActivation_UIDataIsReady_WaitForUIDataIsReadyCoordinator Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_WaitForCoordinatorActivation_UIDataIsReady.HandleCoordinatorActivated
// (Final, Native, Private)
// Parameters:
// class UBaseCoordinator*                 Coordinator                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady::HandleCoordinatorActivated(class UBaseCoordinator* Coordinator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_WaitForCoordinatorActivation_UIDataIsReady", "HandleCoordinatorActivated");

	Params::AsyncAction_WaitForCoordinatorActivation_UIDataIsReady_HandleCoordinatorActivated Parms{};

	Parms.Coordinator = Coordinator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.ExecuteCheat
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::ExecuteCheat(const class FString& Command, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerControllerJP", "ExecuteCheat");

	Params::PlayerControllerJP_ExecuteCheat Parms{};

	Parms.Command = std::move(Command);
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.BlueprintLog
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewMinVerbosityLevel                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::BlueprintLog(const class FString& CategoryName, const class FString& NewMinVerbosityLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "BlueprintLog");

	Params::PlayerControllerJP_BlueprintLog Parms{};

	Parms.CategoryName = std::move(CategoryName);
	Parms.NewMinVerbosityLevel = std::move(NewMinVerbosityLevel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.BlueprintLogList
// (Final, Exec, Native, Public)

void APlayerControllerJP::BlueprintLogList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "BlueprintLogList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.BlueprintLogReset
// (Final, Exec, Native, Public)

void APlayerControllerJP::BlueprintLogReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "BlueprintLogReset");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.ChangeTeam
// (Final, Exec, Native, Public)
// Parameters:
// uint8                                   Team                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::ChangeTeam(uint8 Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "ChangeTeam");

	Params::PlayerControllerJP_ChangeTeam Parms{};

	Parms.Team = Team;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Client_ReceiveMessage
// (Net, Native, Event, Public, NetClient)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMessageType                            Type                                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Client_ReceiveMessage(const class FString& Message, const EMessageType& Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Client_ReceiveMessage");

	Params::PlayerControllerJP_Client_ReceiveMessage Parms{};

	Parms.Message = std::move(Message);
	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Client_UpdateLoadout
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerControllerJP::Client_UpdateLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Client_UpdateLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Client_UpdateOwnedHouses
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerControllerJP::Client_UpdateOwnedHouses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Client_UpdateOwnedHouses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Client_UpdateOwnedNeighbors
// (Net, NetReliable, Native, Event, Public, NetClient)

void APlayerControllerJP::Client_UpdateOwnedNeighbors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Client_UpdateOwnedNeighbors");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.HandlePartyChanged
// (Final, Native, Private)

void APlayerControllerJP::HandlePartyChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "HandlePartyChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.OnOwnedHousesUpdated
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FOnlineStoreItemData>     OwnedItems                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FOnlineStoreItemData>     UnownedItems                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerControllerJP::OnOwnedHousesUpdated(const TArray<struct FOnlineStoreItemData>& OwnedItems, const TArray<struct FOnlineStoreItemData>& UnownedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "OnOwnedHousesUpdated");

	Params::PlayerControllerJP_OnOwnedHousesUpdated Parms{};

	Parms.OwnedItems = std::move(OwnedItems);
	Parms.UnownedItems = std::move(UnownedItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.PlayerAcceptedToLeaveMatch
// (Final, Native, Public, BlueprintCallable)

void APlayerControllerJP::PlayerAcceptedToLeaveMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "PlayerAcceptedToLeaveMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.ReadFriendsList
// (Final, Exec, Native, Public)

void APlayerControllerJP::ReadFriendsList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "ReadFriendsList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_ChangeCharacterRole
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// struct FCharacterRoleData               NewCharacterRole                                       (Parm, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_ChangeCharacterRole(const struct FCharacterRoleData& NewCharacterRole)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_ChangeCharacterRole");

	Params::PlayerControllerJP_Server_ChangeCharacterRole Parms{};

	Parms.NewCharacterRole = std::move(NewCharacterRole);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_ChangeHouseIdentifierVote
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     HouseIdentifierVote                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_ChangeHouseIdentifierVote(const struct FGameplayTag& HouseIdentifierVote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_ChangeHouseIdentifierVote");

	Params::PlayerControllerJP_Server_ChangeHouseIdentifierVote Parms{};

	Parms.HouseIdentifierVote = std::move(HouseIdentifierVote);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_ChangeMatchConfiguration
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FMatchConfiguration              InNewConfig                                            (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_ChangeMatchConfiguration(const struct FMatchConfiguration& InNewConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_ChangeMatchConfiguration");

	Params::PlayerControllerJP_Server_ChangeMatchConfiguration Parms{};

	Parms.InNewConfig = std::move(InNewConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_ChangeOwnedHouses
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// TArray<struct FGameplayTag>             OwnedHouses                                            (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_ChangeOwnedHouses(const TArray<struct FGameplayTag>& OwnedHouses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_ChangeOwnedHouses");

	Params::PlayerControllerJP_Server_ChangeOwnedHouses Parms{};

	Parms.OwnedHouses = std::move(OwnedHouses);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_ChangeTeam
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_ChangeTeam(uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_ChangeTeam");

	Params::PlayerControllerJP_Server_ChangeTeam Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_ExecuteCheat
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// class FString                           Command                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_ExecuteCheat(const class FString& Command)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_ExecuteCheat");

	Params::PlayerControllerJP_Server_ExecuteCheat Parms{};

	Parms.Command = std::move(Command);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_PlayerAcceptedToLeaveMatch
// (Net, NetReliable, Native, Event, Public, NetServer)

void APlayerControllerJP::Server_PlayerAcceptedToLeaveMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_PlayerAcceptedToLeaveMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_SendMasterPlayerAccountId
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class FString                           MasterPlayerAccountId                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_SendMasterPlayerAccountId(const class FString& MasterPlayerAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_SendMasterPlayerAccountId");

	Params::PlayerControllerJP_Server_SendMasterPlayerAccountId Parms{};

	Parms.MasterPlayerAccountId = std::move(MasterPlayerAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_SendMessageToAll
// (Net, Native, Event, Public, NetServer)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_SendMessageToAll(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_SendMessageToAll");

	Params::PlayerControllerJP_Server_SendMessageToAll Parms{};

	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_SendTitlePlayerAccountId
// (Net, NetReliable, Native, Event, Protected, NetServer, BlueprintCallable)
// Parameters:
// class FString                           TitlePlayerAccountId                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_SendTitlePlayerAccountId(const class FString& TitlePlayerAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_SendTitlePlayerAccountId");

	Params::PlayerControllerJP_Server_SendTitlePlayerAccountId Parms{};

	Parms.TitlePlayerAccountId = std::move(TitlePlayerAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_SetOwnedNeighbors
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TArray<struct FGameplayTag>             InOwnedNeighbors                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_SetOwnedNeighbors(const TArray<struct FGameplayTag>& InOwnedNeighbors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_SetOwnedNeighbors");

	Params::PlayerControllerJP_Server_SetOwnedNeighbors Parms{};

	Parms.InOwnedNeighbors = std::move(InOwnedNeighbors);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_SetPartyIdString
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// class FString                           InPartyIdString                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_SetPartyIdString(const class FString& InPartyIdString)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_SetPartyIdString");

	Params::PlayerControllerJP_Server_SetPartyIdString Parms{};

	Parms.InPartyIdString = std::move(InPartyIdString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Server_SetUserOnlineID
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FUniqueNetIdRepl                 InID                                                   (ConstParm, Parm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::Server_SetUserOnlineID(const struct FUniqueNetIdRepl& InID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Server_SetUserOnlineID");

	Params::PlayerControllerJP_Server_SetUserOnlineID Parms{};

	Parms.InID = std::move(InID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.StartMatchmaking
// (Final, Exec, Native, Public)
// Parameters:
// class FString                           QueueName                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::StartMatchmaking(const class FString& QueueName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "StartMatchmaking");

	Params::PlayerControllerJP_StartMatchmaking Parms{};

	Parms.QueueName = std::move(QueueName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.Client_UpdateCachedCurrencies
// (Net, NetReliable, Native, Event, Public, NetClient, Const)

void APlayerControllerJP::Client_UpdateCachedCurrencies() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "Client_UpdateCachedCurrencies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.HasJoinedMatchInProgress
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerJP::HasJoinedMatchInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "HasJoinedMatchInProgress");

	Params::PlayerControllerJP_HasJoinedMatchInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerControllerJP.JoinSession
// (Final, Exec, Native, Public, Const)
// Parameters:
// class FString                           SessionId                                              (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::JoinSession(const class FString& SessionId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "JoinSession");

	Params::PlayerControllerJP_JoinSession Parms{};

	Parms.SessionId = std::move(SessionId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.PrintTeam
// (Final, Exec, Native, Public, Const)

void APlayerControllerJP::PrintTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "PrintTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP.UpdateSeasonPass
// (Final, Exec, Native, Public, Const)
// Parameters:
// class FString                           SeasonPassName                                         (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP::UpdateSeasonPass(const class FString& SeasonPassName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP", "UpdateSeasonPass");

	Params::PlayerControllerJP_UpdateSeasonPass Parms{};

	Parms.SeasonPassName = std::move(SeasonPassName);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.AddMoney
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::AddMoney(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "AddMoney");

	Params::PlayerControllerJP_Match_AddMoney Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.AddPassiveIncome
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::AddPassiveIncome(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "AddPassiveIncome");

	Params::PlayerControllerJP_Match_AddPassiveIncome Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.AddPerfectness
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::AddPerfectness(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "AddPerfectness");

	Params::PlayerControllerJP_Match_AddPerfectness Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.AddWood
// (Final, Exec, Native, Public)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::AddWood(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "AddWood");

	Params::PlayerControllerJP_Match_AddWood Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.CheatRemoveSpecialAbilityCooldown
// (Final, Exec, Native, Public)

void APlayerControllerJP_Match::CheatRemoveSpecialAbilityCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "CheatRemoveSpecialAbilityCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.CheatRespawnAsNeighbor
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             NeighborID                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::CheatRespawnAsNeighbor(class FName NeighborID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "CheatRespawnAsNeighbor");

	Params::PlayerControllerJP_Match_CheatRespawnAsNeighbor Parms{};

	Parms.NeighborID = NeighborID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.CheatSpawnActor
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             DataTableRowName                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::CheatSpawnActor(class FName DataTableRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "CheatSpawnActor");

	Params::PlayerControllerJP_Match_CheatSpawnActor Parms{};

	Parms.DataTableRowName = DataTableRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.Client_AssignMatchRewards
// (Net, Native, Event, Public, NetClient)
// Parameters:
// struct FMatchRewards                    Rewards                                                (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::Client_AssignMatchRewards(const struct FMatchRewards& Rewards)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "Client_AssignMatchRewards");

	Params::PlayerControllerJP_Match_Client_AssignMatchRewards Parms{};

	Parms.Rewards = std::move(Rewards);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.EndGame
// (Final, Exec, Native, Public)

void APlayerControllerJP_Match::EndGame()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "EndGame");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.EndWarmup
// (Final, Exec, Native, Public)

void APlayerControllerJP_Match::EndWarmup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "EndWarmup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.GetMatchRewards
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FMatchRewards                    ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchRewards APlayerControllerJP_Match::GetMatchRewards()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "GetMatchRewards");

	Params::PlayerControllerJP_Match_GetMatchRewards Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerControllerJP_Match.HandleHUDMatchWidgetAdded
// (Final, Native, Private)
// Parameters:
// class UJPHUDWidget_Match*               HUDWidget                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::HandleHUDMatchWidgetAdded(class UJPHUDWidget_Match* HUDWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "HandleHUDMatchWidgetAdded");

	Params::PlayerControllerJP_Match_HandleHUDMatchWidgetAdded Parms{};

	Parms.HUDWidget = HUDWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.K2_InitializePlayer
// (Event, Protected, BlueprintEvent)

void APlayerControllerJP_Match::K2_InitializePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "K2_InitializePlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PlayerControllerJP_Match.KillPlayer
// (Event, Protected, BlueprintEvent)

void APlayerControllerJP_Match::KillPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "KillPlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PlayerControllerJP_Match.LoginTwitch
// (Event, Public, BlueprintEvent)

void APlayerControllerJP_Match::LoginTwitch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "LoginTwitch");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PlayerControllerJP_Match.OnDefaultFOVChanged
// (Event, Public, BlueprintEvent)

void APlayerControllerJP_Match::OnDefaultFOVChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "OnDefaultFOVChanged");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PlayerControllerJP_Match.RestartMatch
// (Final, Exec, Native, Public)

void APlayerControllerJP_Match::RestartMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "RestartMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.Server_CheatCancelSpecialAbilityCooldown
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void APlayerControllerJP_Match::Server_CheatCancelSpecialAbilityCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "Server_CheatCancelSpecialAbilityCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.Server_CheatSpawnActor
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class FName                             DataTableRowName                                       (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::Server_CheatSpawnActor(const class FName& DataTableRowName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "Server_CheatSpawnActor");

	Params::PlayerControllerJP_Match_Server_CheatSpawnActor Parms{};

	Parms.DataTableRowName = DataTableRowName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.Server_RespawnAsNeighbor
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// struct FGameplayTag                     NewNeighbor                                            (ConstParm, Parm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::Server_RespawnAsNeighbor(const struct FGameplayTag& NewNeighbor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "Server_RespawnAsNeighbor");

	Params::PlayerControllerJP_Match_Server_RespawnAsNeighbor Parms{};

	Parms.NewNeighbor = std::move(NewNeighbor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.Server_SpawnItem
// (Final, Net, NetReliable, Native, Event, Private, NetServer, NetValidate)
// Parameters:
// class FName                             ItemName                                               (ConstParm, Parm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::Server_SpawnItem(const class FName& ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "Server_SpawnItem");

	Params::PlayerControllerJP_Match_Server_SpawnItem Parms{};

	Parms.ItemName = ItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.Server_TeleportToLocation
// (Final, Net, NetReliable, Native, Event, Private, NetServer)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::Server_TeleportToLocation(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "Server_TeleportToLocation");

	Params::PlayerControllerJP_Match_Server_TeleportToLocation Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.ServerNotifyLoadedHouses
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable, NetValidate)

void APlayerControllerJP_Match::ServerNotifyLoadedHouses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "ServerNotifyLoadedHouses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.SpawnItem
// (Final, Exec, Native, Public)
// Parameters:
// class FName                             ItemName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::SpawnItem(class FName ItemName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "SpawnItem");

	Params::PlayerControllerJP_Match_SpawnItem Parms{};

	Parms.ItemName = ItemName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.StartTwitchIntegration
// (Event, Public, BlueprintEvent)

void APlayerControllerJP_Match::StartTwitchIntegration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "StartTwitchIntegration");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PlayerControllerJP_Match.TeleportToLocation
// (Final, Exec, Native, Public)
// Parameters:
// float                                   X                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Y                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Z                                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Match::TeleportToLocation(float X, float Y, float Z)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "TeleportToLocation");

	Params::PlayerControllerJP_Match_TeleportToLocation Parms{};

	Parms.X = X;
	Parms.Y = Y;
	Parms.Z = Z;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.ToggleCheatWindow
// (Final, Native, Private)

void APlayerControllerJP_Match::ToggleCheatWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "ToggleCheatWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Match.GetMatchHUDWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UJPHUDWidget_Match*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJPHUDWidget_Match* APlayerControllerJP_Match::GetMatchHUDWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "GetMatchHUDWidget");

	Params::PlayerControllerJP_Match_GetMatchHUDWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerControllerJP_Match.HasMatchRewards
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerJP_Match::HasMatchRewards() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "HasMatchRewards");

	Params::PlayerControllerJP_Match_HasMatchRewards Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerControllerJP_Match.IsHousesLoadedOnClient
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerControllerJP_Match::IsHousesLoadedOnClient() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Match", "IsHousesLoadedOnClient");

	Params::PlayerControllerJP_Match_IsHousesLoadedOnClient Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPHUDWidget_Match.GetMatchHUDWidget
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJPHUDWidget_Match*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJPHUDWidget_Match* UJPHUDWidget_Match::GetMatchHUDWidget(class UObject* WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPHUDWidget_Match", "GetMatchHUDWidget");

	Params::JPHUDWidget_Match_GetMatchHUDWidget Parms{};

	Parms.WorldContext = WorldContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPHUDWidget_Match.AddRuntimeChildWidget
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJPHUDWidget_Match::AddRuntimeChildWidget(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPHUDWidget_Match", "AddRuntimeChildWidget");

	Params::JPHUDWidget_Match_AddRuntimeChildWidget Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPHUDWidget_Match.AddRuntimeChildWidgetAt
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJPHUDWidget_Match::AddRuntimeChildWidgetAt(class UUserWidget* Widget, int32 Index_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPHUDWidget_Match", "AddRuntimeChildWidgetAt");

	Params::JPHUDWidget_Match_AddRuntimeChildWidgetAt Parms{};

	Parms.Widget = Widget;
	Parms.Index_0 = Index_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPHUDWidget_Match.RemoveRuntimeChildWidget
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// class UUserWidget*                      Widget                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJPHUDWidget_Match::RemoveRuntimeChildWidget(class UUserWidget* Widget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPHUDWidget_Match", "RemoveRuntimeChildWidget");

	Params::JPHUDWidget_Match_RemoveRuntimeChildWidget Parms{};

	Parms.Widget = Widget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.WarmupComponent.CheckTimeLeftDelegates
// (Final, Native, Private)

void UWarmupComponent::CheckTimeLeftDelegates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "CheckTimeLeftDelegates");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.WarmupComponent.IsWarmupActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UWarmupComponent::IsWarmupActive()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "IsWarmupActive");

	Params::WarmupComponent_IsWarmupActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.WarmupComponent.K2_WarmupEnded
// (Event, Protected, BlueprintEvent)

void UWarmupComponent::K2_WarmupEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "K2_WarmupEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.WarmupComponent.ListenOnWarmupSecondsLeft
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   SecondsLeft                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void()>                       Delegate                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWarmupComponent::ListenOnWarmupSecondsLeft(float SecondsLeft, TDelegate<void()> Delegate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "ListenOnWarmupSecondsLeft");

	Params::WarmupComponent_ListenOnWarmupSecondsLeft Parms{};

	Parms.SecondsLeft = SecondsLeft;
	Parms.Delegate = Delegate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.WarmupComponent.OnExperienceLoaded
// (Final, Native, Private)
// Parameters:
// class UExperienceDefinition*            Definition                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UWarmupComponent::OnExperienceLoaded(const class UExperienceDefinition* Definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "OnExperienceLoaded");

	Params::WarmupComponent_OnExperienceLoaded Parms{};

	Parms.Definition = Definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.WarmupComponent.OnRep_HasEnded
// (Final, Native, Private)

void UWarmupComponent::OnRep_HasEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "OnRep_HasEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.WarmupComponent.OnTimerEnded
// (Final, Native, Private)

void UWarmupComponent::OnTimerEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "OnTimerEnded");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.WarmupComponent.GetEndTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWarmupComponent::GetEndTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "GetEndTime");

	Params::WarmupComponent_GetEndTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.WarmupComponent.GetTimeLeft
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UWarmupComponent::GetTimeLeft() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("WarmupComponent", "GetTimeLeft");

	Params::WarmupComponent_GetTimeLeft Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_AwaitPlayerStateJPLobbyReady.AwaitPlayerStateJPLobbyReady
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStateJP_Lobby*             PlayerState_0                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   TimeoutDuration_0                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_AwaitPlayerStateJPLobbyReady*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_AwaitPlayerStateJPLobbyReady* UAsyncAction_AwaitPlayerStateJPLobbyReady::AwaitPlayerStateJPLobbyReady(class UObject* WorldContextObject, class APlayerStateJP_Lobby* PlayerState_0, float TimeoutDuration_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_AwaitPlayerStateJPLobbyReady", "AwaitPlayerStateJPLobbyReady");

	Params::AsyncAction_AwaitPlayerStateJPLobbyReady_AwaitPlayerStateJPLobbyReady Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PlayerState_0 = PlayerState_0;
	Parms.TimeoutDuration_0 = TimeoutDuration_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_AwaitPlayerStateJPLobbyReady.OnPlayerStateReady
// (Final, Native, Private)

void UAsyncAction_AwaitPlayerStateJPLobbyReady::OnPlayerStateReady()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_AwaitPlayerStateJPLobbyReady", "OnPlayerStateReady");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_AwaitPlayerStateJPLobbyReady.OnPlayerXPChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   BroadcastPlayerState                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerXP                        PlayerXP                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UAsyncAction_AwaitPlayerStateJPLobbyReady::OnPlayerXPChanged(class APlayerStateJP* BroadcastPlayerState, const struct FPlayerXP& PlayerXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_AwaitPlayerStateJPLobbyReady", "OnPlayerXPChanged");

	Params::AsyncAction_AwaitPlayerStateJPLobbyReady_OnPlayerXPChanged Parms{};

	Parms.BroadcastPlayerState = BroadcastPlayerState;
	Parms.PlayerXP = std::move(PlayerXP);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_AwaitPlayerStateJPLobbyReady.OnTimerExpired
// (Final, Native, Private)

void UAsyncAction_AwaitPlayerStateJPLobbyReady::OnTimerExpired()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_AwaitPlayerStateJPLobbyReady", "OnTimerExpired");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_WaitForLocalPlayerStateSet.WaitForLocalPlayerStateSet
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_WaitForLocalPlayerStateSet*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_WaitForLocalPlayerStateSet* UAsyncAction_WaitForLocalPlayerStateSet::WaitForLocalPlayerStateSet(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_WaitForLocalPlayerStateSet", "WaitForLocalPlayerStateSet");

	Params::AsyncAction_WaitForLocalPlayerStateSet_WaitForLocalPlayerStateSet Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_WaitForLocalPlayerStateSet.HandlePlayerStateSet
// (Final, Native, Private)
// Parameters:
// class UCommonLocalPlayer*               CommonLocalPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAction_WaitForLocalPlayerStateSet::HandlePlayerStateSet(class UCommonLocalPlayer* CommonLocalPlayer, class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_WaitForLocalPlayerStateSet", "HandlePlayerStateSet");

	Params::AsyncAction_WaitForLocalPlayerStateSet_HandlePlayerStateSet Parms{};

	Parms.CommonLocalPlayer = CommonLocalPlayer;
	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.UpdateGameDataStep_ActiveNeighbors.GetActiveNeighbors
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FNeighborOnlineServicesContainerReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FNeighborOnlineServicesContainer UUpdateGameDataStep_ActiveNeighbors::GetActiveNeighbors(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UpdateGameDataStep_ActiveNeighbors", "GetActiveNeighbors");

	Params::UpdateGameDataStep_ActiveNeighbors_GetActiveNeighbors Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_StartMainMenuInitialization.StartMainMenuInitialization
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_StartMainMenuInitialization*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_StartMainMenuInitialization* UAsyncAction_StartMainMenuInitialization::StartMainMenuInitialization(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_StartMainMenuInitialization", "StartMainMenuInitialization");

	Params::AsyncAction_StartMainMenuInitialization_StartMainMenuInitialization Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.UpdateGameDataStep_ActiveHouses.GetActiveHouses
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FHouseOnlineServicesContainerReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FHouseOnlineServicesContainer UUpdateGameDataStep_ActiveHouses::GetActiveHouses(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UpdateGameDataStep_ActiveHouses", "GetActiveHouses");

	Params::UpdateGameDataStep_ActiveHouses_GetActiveHouses Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_SetDefaultCharacterSettings.SetDefaultCharacterSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDefaultCharacterSettings        DefaultCharacterSettings                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// class UAsyncAction_SetDefaultCharacterSettings*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_SetDefaultCharacterSettings* UAsyncAction_SetDefaultCharacterSettings::SetDefaultCharacterSettings(class UObject* WorldContextObject, const struct FDefaultCharacterSettings& DefaultCharacterSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_SetDefaultCharacterSettings", "SetDefaultCharacterSettings");

	Params::AsyncAction_SetDefaultCharacterSettings_SetDefaultCharacterSettings Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.DefaultCharacterSettings = std::move(DefaultCharacterSettings);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_SetDefaultCharacterSettings.HandleError
// (Final, Native, Public)
// Parameters:
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ErrorMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAction_SetDefaultCharacterSettings::HandleError(int32 ErrorCode, const class FString& ErrorMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_SetDefaultCharacterSettings", "HandleError");

	Params::AsyncAction_SetDefaultCharacterSettings_HandleError Parms{};

	Parms.ErrorCode = ErrorCode;
	Parms.ErrorMessage = std::move(ErrorMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_SetDefaultCharacterSettings.HandleSuccess
// (Final, Native, Public)

void UAsyncAction_SetDefaultCharacterSettings::HandleSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_SetDefaultCharacterSettings", "HandleSuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SessionSearchStatics.CloneSearchResults
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UCommonSession_SearchResult*>Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UCommonSession_SearchResult*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCommonSession_SearchResult*> USessionSearchStatics::CloneSearchResults(const TArray<class UCommonSession_SearchResult*>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SessionSearchStatics", "CloneSearchResults");

	Params::SessionSearchStatics_CloneSearchResults Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionSearchStatics.DebugDumpToString
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCommonSession_SearchResult*      Value                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeResultValues                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeSessionValues                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeBaseSettings                                    (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeMemberSettings                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeCustomSettings                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USessionSearchStatics::DebugDumpToString(const class UCommonSession_SearchResult* Value, const bool IncludeResultValues, const bool IncludeSessionValues, const bool IncludeBaseSettings, const bool IncludeMemberSettings, const bool IncludeCustomSettings)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SessionSearchStatics", "DebugDumpToString");

	Params::SessionSearchStatics_DebugDumpToString Parms{};

	Parms.Value = Value;
	Parms.IncludeResultValues = IncludeResultValues;
	Parms.IncludeSessionValues = IncludeSessionValues;
	Parms.IncludeBaseSettings = IncludeBaseSettings;
	Parms.IncludeMemberSettings = IncludeMemberSettings;
	Parms.IncludeCustomSettings = IncludeCustomSettings;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionSearchStatics.RemoveEmpty
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UCommonSession_SearchResult*>Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UCommonSession_SearchResult*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCommonSession_SearchResult*> USessionSearchStatics::RemoveEmpty(const TArray<class UCommonSession_SearchResult*>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SessionSearchStatics", "RemoveEmpty");

	Params::SessionSearchStatics_RemoveEmpty Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionSearchStatics.RemoveFull
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UCommonSession_SearchResult*>Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UCommonSession_SearchResult*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCommonSession_SearchResult*> USessionSearchStatics::RemoveFull(const TArray<class UCommonSession_SearchResult*>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SessionSearchStatics", "RemoveFull");

	Params::SessionSearchStatics_RemoveFull Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionSearchStatics.RemoveVersionMismatch
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UCommonSession_SearchResult*>Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// TArray<class UCommonSession_SearchResult*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCommonSession_SearchResult*> USessionSearchStatics::RemoveVersionMismatch(const TArray<class UCommonSession_SearchResult*>& Values)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SessionSearchStatics", "RemoveVersionMismatch");

	Params::SessionSearchStatics_RemoveVersionMismatch Parms{};

	Parms.Values = std::move(Values);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionSearchStatics.SortSearchResults
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<class UCommonSession_SearchResult*>Values                                                 (Parm, ZeroConstructor, NativeAccessSpecifierPublic)
// bool                                    Ascending                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SortByPing                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SortByCreatedTimestamp                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    SortByLobbyName                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UCommonSession_SearchResult*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UCommonSession_SearchResult*> USessionSearchStatics::SortSearchResults(const TArray<class UCommonSession_SearchResult*>& Values, const bool Ascending, const bool SortByPing, const bool SortByCreatedTimestamp, const bool SortByLobbyName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SessionSearchStatics", "SortSearchResults");

	Params::SessionSearchStatics_SortSearchResults Parms{};

	Parms.Values = std::move(Values);
	Parms.Ascending = Ascending;
	Parms.SortByPing = SortByPing;
	Parms.SortByCreatedTimestamp = SortByCreatedTimestamp;
	Parms.SortByLobbyName = SortByLobbyName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.UpdateGameDataStep_ActivePerks.GetActivePerks
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FPerkOnlineServicesContainerReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FPerkOnlineServicesContainer UUpdateGameDataStep_ActivePerks::GetActivePerks(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UpdateGameDataStep_ActivePerks", "GetActivePerks");

	Params::UpdateGameDataStep_ActivePerks_GetActivePerks Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameModeJP_Lobby.ForceTravel
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void AGameModeJP_Lobby::ForceTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Lobby", "ForceTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Lobby.HandlePlayerBlockedListInitialized
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_Lobby::HandlePlayerBlockedListInitialized(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Lobby", "HandlePlayerBlockedListInitialized");

	Params::GameModeJP_Lobby_HandlePlayerBlockedListInitialized Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Lobby.HandlePlayerControllerPartyIdChanged
// (Final, Native, Private)
// Parameters:
// class APlayerControllerJP*              PlayerControllerJP                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OldPartyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           NewPartyId                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_Lobby::HandlePlayerControllerPartyIdChanged(class APlayerControllerJP* PlayerControllerJP, const class FString& OldPartyId, const class FString& NewPartyId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Lobby", "HandlePlayerControllerPartyIdChanged");

	Params::GameModeJP_Lobby_HandlePlayerControllerPartyIdChanged Parms{};

	Parms.PlayerControllerJP = PlayerControllerJP;
	Parms.OldPartyId = std::move(OldPartyId);
	Parms.NewPartyId = std::move(NewPartyId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Lobby.HandlePlayerHouseVoteChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OldHouseIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NewHouseIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_Lobby::HandlePlayerHouseVoteChanged(class APlayerStateJP* PlayerState, const struct FGameplayTag& OldHouseIdentifier, const struct FGameplayTag& NewHouseIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Lobby", "HandlePlayerHouseVoteChanged");

	Params::GameModeJP_Lobby_HandlePlayerHouseVoteChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.OldHouseIdentifier = std::move(OldHouseIdentifier);
	Parms.NewHouseIdentifier = std::move(NewHouseIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Lobby.HandlePlayerTeamIdChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_Lobby::HandlePlayerTeamIdChanged(class APlayerStateJP* PlayerState, const uint8& TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Lobby", "HandlePlayerTeamIdChanged");

	Params::GameModeJP_Lobby_HandlePlayerTeamIdChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Lobby.HandleStartLobbyTravelCountdownBegun
// (Final, Native, Private)
// Parameters:
// float                                   InDesiredTravelTimestamp                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_Lobby::HandleStartLobbyTravelCountdownBegun(float InDesiredTravelTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Lobby", "HandleStartLobbyTravelCountdownBegun");

	Params::GameModeJP_Lobby_HandleStartLobbyTravelCountdownBegun Parms{};

	Parms.InDesiredTravelTimestamp = InDesiredTravelTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_Lobby.IsLobbyFull
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameModeJP_Lobby::IsLobbyFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Lobby", "IsLobbyFull");

	Params::GameModeJP_Lobby_IsLobbyFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.UpdateGameDataStep_ActiveRewards.GetActiveRewards
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FRewardOnlineServicesContainerReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FRewardOnlineServicesContainer UUpdateGameDataStep_ActiveRewards::GetActiveRewards(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UpdateGameDataStep_ActiveRewards", "GetActiveRewards");

	Params::UpdateGameDataStep_ActiveRewards_GetActiveRewards Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.UpdateGameDataStep_FirstTimeLoginRewards.GetFirstTimeLoginRewards
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FFirstTimeLoginRewardsData ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FFirstTimeLoginRewardsData UUpdateGameDataStep_FirstTimeLoginRewards::GetFirstTimeLoginRewards(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UpdateGameDataStep_FirstTimeLoginRewards", "GetFirstTimeLoginRewards");

	Params::UpdateGameDataStep_FirstTimeLoginRewards_GetFirstTimeLoginRewards Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.UpdateGameDataStep_QuickPlay.GetQuickPlayConfiguration
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FQuickPlaySettings         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FQuickPlaySettings UUpdateGameDataStep_QuickPlay::GetQuickPlayConfiguration(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("UpdateGameDataStep_QuickPlay", "GetQuickPlayConfiguration");

	Params::UpdateGameDataStep_QuickPlay_GetQuickPlayConfiguration Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassRewardWidget_CatalogItem.HideLoadGuard
// (Event, Protected, BlueprintEvent)

void USeasonPassRewardWidget_CatalogItem::HideLoadGuard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassRewardWidget_CatalogItem", "HideLoadGuard");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.SeasonPassRewardWidget_CatalogItem.ShowLoadGuard
// (Event, Protected, BlueprintEvent)

void USeasonPassRewardWidget_CatalogItem::ShowLoadGuard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassRewardWidget_CatalogItem", "ShowLoadGuard");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.AbilitySystemComponentJP.CopyComponent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UAbilitySystemComponent*          Target                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilitySystemComponentJP::CopyComponent(class UAbilitySystemComponent* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentJP", "CopyComponent");

	Params::AbilitySystemComponentJP_CopyComponent Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AbilitySystemComponentJP.HasAnyAbilityByClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UGameplayAbility>     AbilityClass                                           (ConstParm, Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilitySystemComponentJP::HasAnyAbilityByClass(const TSubclassOf<class UGameplayAbility> AbilityClass) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentJP", "HasAnyAbilityByClass");

	Params::AbilitySystemComponentJP_HasAnyAbilityByClass Parms{};

	Parms.AbilityClass = AbilityClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AbilitySystemComponentJP.HasAnyAbilityWithTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTagContainer            Tags                                                   (ConstParm, Parm, NativeAccessSpecifierPublic)
// bool                                    bExactMatch                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilitySystemComponentJP::HasAnyAbilityWithTag(const struct FGameplayTagContainer& Tags, const bool bExactMatch) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilitySystemComponentJP", "HasAnyAbilityWithTag");

	Params::AbilitySystemComponentJP_HasAnyAbilityWithTag Parms{};

	Parms.Tags = std::move(Tags);
	Parms.bExactMatch = bExactMatch;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AbilityTask_CreateChargeTimerWidget.CreateChargeTimerWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bTestAlreadyReleased                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilityTask_CreateChargeTimerWidget*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAbilityTask_CreateChargeTimerWidget* UAbilityTask_CreateChargeTimerWidget::CreateChargeTimerWidget(class UGameplayAbility* OwningAbility, TSubclassOf<class UUserWidget> Class_0, float Time, bool bTestAlreadyReleased)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AbilityTask_CreateChargeTimerWidget", "CreateChargeTimerWidget");

	Params::AbilityTask_CreateChargeTimerWidget_CreateChargeTimerWidget Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.Class_0 = Class_0;
	Parms.Time = Time;
	Parms.bTestAlreadyReleased = bTestAlreadyReleased;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AbilityTask_CreateChargeTimerWidget.BeginSpawningActor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           SpawnedActor                                           (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UAbilityTask_CreateChargeTimerWidget::BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class UUserWidget> Class_0, class AActor** SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_CreateChargeTimerWidget", "BeginSpawningActor");

	Params::AbilityTask_CreateChargeTimerWidget_BeginSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.Class_0 = Class_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (SpawnedActor != nullptr)
		*SpawnedActor = Parms.SpawnedActor;

	return Parms.ReturnValue;
}


// Function JP.AbilityTask_CreateChargeTimerWidget.FinishSpawningActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 OwningAbility                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayAbilityTargetDataHandle TargetData                                             (Parm, NativeAccessSpecifierPublic)
// class AActor*                           SpawnedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_CreateChargeTimerWidget::FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_CreateChargeTimerWidget", "FinishSpawningActor");

	Params::AbilityTask_CreateChargeTimerWidget_FinishSpawningActor Parms{};

	Parms.OwningAbility = OwningAbility;
	Parms.TargetData = std::move(TargetData);
	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AbilityTask_CreateChargeTimerWidget.OnReleaseCallback
// (Final, Native, Public)
// Parameters:
// float                                   ElapsedTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAbilityTask_CreateChargeTimerWidget::OnReleaseCallback(float ElapsedTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_CreateChargeTimerWidget", "OnReleaseCallback");

	Params::AbilityTask_CreateChargeTimerWidget_OnReleaseCallback Parms{};

	Parms.ElapsedTime = ElapsedTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AbilityTask_CreateChargeTimerWidget.OnTimeFinish
// (Final, Native, Protected)

void UAbilityTask_CreateChargeTimerWidget::OnTimeFinish()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AbilityTask_CreateChargeTimerWidget", "OnTimeFinish");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.TargetingFilterTask_BlueprintLogic.ShouldFilterTargetBP
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class AActor*                           HitActor                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Source                                                 (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTargetingFilterTask_BlueprintLogic::ShouldFilterTargetBP(const class AActor* HitActor, const class AActor* Source) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TargetingFilterTask_BlueprintLogic", "ShouldFilterTargetBP");

	Params::TargetingFilterTask_BlueprintLogic_ShouldFilterTargetBP Parms{};

	Parms.HitActor = HitActor;
	Parms.Source = Source;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionResultViewModel.CreateViewModel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCommonSession_SearchResult*      Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USessionResultViewModel*          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USessionResultViewModel* USessionResultViewModel::CreateViewModel(class UCommonSession_SearchResult* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SessionResultViewModel", "CreateViewModel");

	Params::SessionResultViewModel_CreateViewModel Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionResultViewModel.GetAvailablePlayerSlots
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USessionResultViewModel::GetAvailablePlayerSlots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SessionResultViewModel", "GetAvailablePlayerSlots");

	Params::SessionResultViewModel_GetAvailablePlayerSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionResultViewModel.GetIsReachable
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USessionResultViewModel::GetIsReachable() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SessionResultViewModel", "GetIsReachable");

	Params::SessionResultViewModel_GetIsReachable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionResultViewModel.GetMaxPlayerSlots
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USessionResultViewModel::GetMaxPlayerSlots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SessionResultViewModel", "GetMaxPlayerSlots");

	Params::SessionResultViewModel_GetMaxPlayerSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionResultViewModel.GetPingInMs
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USessionResultViewModel::GetPingInMs() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SessionResultViewModel", "GetPingInMs");

	Params::SessionResultViewModel_GetPingInMs Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionResultViewModel.GetSessionName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USessionResultViewModel::GetSessionName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SessionResultViewModel", "GetSessionName");

	Params::SessionResultViewModel_GetSessionName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionResultViewModel.GetSessionOwner
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USessionResultViewModel::GetSessionOwner() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SessionResultViewModel", "GetSessionOwner");

	Params::SessionResultViewModel_GetSessionOwner Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SessionResultViewModel.GetTakenPlayerSlots
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USessionResultViewModel::GetTakenPlayerSlots() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SessionResultViewModel", "GetTakenPlayerSlots");

	Params::SessionResultViewModel_GetTakenPlayerSlots Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AmmoAttributeSetListener.OnFireworkBoxAmmoChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Ammo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAmmoAttributeSetListener::OnFireworkBoxAmmoChanged(float Ammo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSetListener", "OnFireworkBoxAmmoChanged");

	Params::AmmoAttributeSetListener_OnFireworkBoxAmmoChanged Parms{};

	Parms.Ammo = Ammo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSetListener.OnFireworkBoxMaxAmmoChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   MaxAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAmmoAttributeSetListener::OnFireworkBoxMaxAmmoChanged(float MaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSetListener", "OnFireworkBoxMaxAmmoChanged");

	Params::AmmoAttributeSetListener_OnFireworkBoxMaxAmmoChanged Parms{};

	Parms.MaxAmmo = MaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSetListener.OnOrangeCannonAmmoChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Ammo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAmmoAttributeSetListener::OnOrangeCannonAmmoChanged(float Ammo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSetListener", "OnOrangeCannonAmmoChanged");

	Params::AmmoAttributeSetListener_OnOrangeCannonAmmoChanged Parms{};

	Parms.Ammo = Ammo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSetListener.OnOrangeCannonMaxAmmoChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   MaxAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAmmoAttributeSetListener::OnOrangeCannonMaxAmmoChanged(float MaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSetListener", "OnOrangeCannonMaxAmmoChanged");

	Params::AmmoAttributeSetListener_OnOrangeCannonMaxAmmoChanged Parms{};

	Parms.MaxAmmo = MaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSetListener.OnSlingshotAmmoChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Ammo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAmmoAttributeSetListener::OnSlingshotAmmoChanged(float Ammo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSetListener", "OnSlingshotAmmoChanged");

	Params::AmmoAttributeSetListener_OnSlingshotAmmoChanged Parms{};

	Parms.Ammo = Ammo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSetListener.OnSlingshotMaxAmmoChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   MaxAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAmmoAttributeSetListener::OnSlingshotMaxAmmoChanged(float MaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSetListener", "OnSlingshotMaxAmmoChanged");

	Params::AmmoAttributeSetListener_OnSlingshotMaxAmmoChanged Parms{};

	Parms.MaxAmmo = MaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSetListener.OnWrenchAmmoChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Ammo                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAmmoAttributeSetListener::OnWrenchAmmoChanged(float Ammo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSetListener", "OnWrenchAmmoChanged");

	Params::AmmoAttributeSetListener_OnWrenchAmmoChanged Parms{};

	Parms.Ammo = Ammo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AmmoAttributeSetListener.OnWrenchMaxAmmoChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   MaxAmmo                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IAmmoAttributeSetListener::OnWrenchMaxAmmoChanged(float MaxAmmo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AmmoAttributeSetListener", "OnWrenchMaxAmmoChanged");

	Params::AmmoAttributeSetListener_OnWrenchMaxAmmoChanged Parms{};

	Parms.MaxAmmo = MaxAmmo;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_GetDefaultCharacterSettings.GetDefaultCharacterSettings
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_GetDefaultCharacterSettings*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_GetDefaultCharacterSettings* UAsyncAction_GetDefaultCharacterSettings::GetDefaultCharacterSettings(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_GetDefaultCharacterSettings", "GetDefaultCharacterSettings");

	Params::AsyncAction_GetDefaultCharacterSettings_GetDefaultCharacterSettings Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_GetDefaultCharacterSettings.HandleError
// (Final, Native, Public)
// Parameters:
// int32                                   ErrorCode                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ErrorMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UAsyncAction_GetDefaultCharacterSettings::HandleError(int32 ErrorCode, const class FString& ErrorMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("AsyncAction_GetDefaultCharacterSettings", "HandleError");

	Params::AsyncAction_GetDefaultCharacterSettings_HandleError Parms{};

	Parms.ErrorCode = ErrorCode;
	Parms.ErrorMessage = std::move(ErrorMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopWidgetMain.SetupControllerNavigation
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UWrapBox*>                 WrapBoxes                                              (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UShopWidgetMain::SetupControllerNavigation(const TArray<class UWrapBox*>& WrapBoxes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopWidgetMain", "SetupControllerNavigation");

	Params::ShopWidgetMain_SetupControllerNavigation Parms{};

	Parms.WrapBoxes = std::move(WrapBoxes);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopWidgetMain.ShopItemUpdated
// (Final, Native, Public)
// Parameters:
// struct FShopItemViewModel               ShopItemViewModel                                      (ConstParm, Parm, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopWidgetMain::ShopItemUpdated(const struct FShopItemViewModel& ShopItemViewModel, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopWidgetMain", "ShopItemUpdated");

	Params::ShopWidgetMain_ShopItemUpdated Parms{};

	Parms.ShopItemViewModel = std::move(ShopItemViewModel);
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopWidgetMain.UpdateLastOpenedShopCategory
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShopItemCategory                       LastOpenShopCategory                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopWidgetMain::UpdateLastOpenedShopCategory(const EShopItemCategory LastOpenShopCategory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopWidgetMain", "UpdateLastOpenedShopCategory");

	Params::ShopWidgetMain_UpdateLastOpenedShopCategory Parms{};

	Parms.LastOpenShopCategory = LastOpenShopCategory;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.AsyncAction_ListenForOnJoinSessionComplete.ListenForOnJoinSessionComplete
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject_0                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_ListenForOnJoinSessionComplete*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_ListenForOnJoinSessionComplete* UAsyncAction_ListenForOnJoinSessionComplete::ListenForOnJoinSessionComplete(class UObject* WorldContextObject_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_ListenForOnJoinSessionComplete", "ListenForOnJoinSessionComplete");

	Params::AsyncAction_ListenForOnJoinSessionComplete_ListenForOnJoinSessionComplete Parms{};

	Parms.WorldContextObject_0 = WorldContextObject_0;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ServiceMessage.GetBackgroundUrl
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UServiceMessage::GetBackgroundUrl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServiceMessage", "GetBackgroundUrl");

	Params::ServiceMessage_GetBackgroundUrl Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ServiceMessage.GetId
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UServiceMessage::GetId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServiceMessage", "GetId");

	Params::ServiceMessage_GetId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ServiceMessage.GetMessage
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UServiceMessage::GetMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServiceMessage", "GetMessage");

	Params::ServiceMessage_GetMessage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ServiceMessage.GetMessageLink
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UServiceMessage::GetMessageLink()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServiceMessage", "GetMessageLink");

	Params::ServiceMessage_GetMessageLink Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_LoadPawnDefinitionFromOnlineServiceId.LoadPawnDefinitionFromOnlineServiceId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           OnlineServiceId                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_LoadPawnDefinitionFromOnlineServiceId*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_LoadPawnDefinitionFromOnlineServiceId* UAsyncAction_LoadPawnDefinitionFromOnlineServiceId::LoadPawnDefinitionFromOnlineServiceId(class UObject* WorldContextObject, const class FString& OnlineServiceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_LoadPawnDefinitionFromOnlineServiceId", "LoadPawnDefinitionFromOnlineServiceId");

	Params::AsyncAction_LoadPawnDefinitionFromOnlineServiceId_LoadPawnDefinitionFromOnlineServiceId Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.OnlineServiceId = std::move(OnlineServiceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_LoginWithInitialization.LoginWithInitialization
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_LoginWithInitialization*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_LoginWithInitialization* UAsyncAction_LoginWithInitialization::LoginWithInitialization(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_LoginWithInitialization", "LoginWithInitialization");

	Params::AsyncAction_LoginWithInitialization_LoginWithInitialization Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.AsyncAction_WaitForLoggedIn.WaitForLoggedIn
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAsyncAction_WaitForLoggedIn*     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UAsyncAction_WaitForLoggedIn* UAsyncAction_WaitForLoggedIn::WaitForLoggedIn(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AsyncAction_WaitForLoggedIn", "WaitForLoggedIn");

	Params::AsyncAction_WaitForLoggedIn_WaitForLoggedIn Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BasePlayerStateWatcher.HandlePlayerStateAddedToGameState
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     AddedPlayerState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasePlayerStateWatcher::HandlePlayerStateAddedToGameState(class APlayerState* AddedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlayerStateWatcher", "HandlePlayerStateAddedToGameState");

	Params::BasePlayerStateWatcher_HandlePlayerStateAddedToGameState Parms{};

	Parms.AddedPlayerState = AddedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BasePlayerStateWatcher.HandlePlayerStateRemovedFromGameState
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     RemovedPlayerState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBasePlayerStateWatcher::HandlePlayerStateRemovedFromGameState(class APlayerState* RemovedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BasePlayerStateWatcher", "HandlePlayerStateRemovedFromGameState");

	Params::BasePlayerStateWatcher_HandlePlayerStateRemovedFromGameState Parms{};

	Parms.RemovedPlayerState = RemovedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BattlePassConfigurationAsset.GetCurrentBattlePassConfiguration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UBattlePassConfigurationAsset*ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UBattlePassConfigurationAsset* UBattlePassConfigurationAsset::GetCurrentBattlePassConfiguration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattlePassConfigurationAsset", "GetCurrentBattlePassConfiguration");

	Params::BattlePassConfigurationAsset_GetCurrentBattlePassConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BattlePassConfigurationAsset.GetAllBattlePassRewardsBetweenLevels
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FromBattlePassLevelInclusive                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToBattlePassLevelInclusive                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FBattlePassLevelRewards>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FBattlePassLevelRewards> UBattlePassConfigurationAsset::GetAllBattlePassRewardsBetweenLevels(int32 FromBattlePassLevelInclusive, int32 ToBattlePassLevelInclusive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassConfigurationAsset", "GetAllBattlePassRewardsBetweenLevels");

	Params::BattlePassConfigurationAsset_GetAllBattlePassRewardsBetweenLevels Parms{};

	Parms.FromBattlePassLevelInclusive = FromBattlePassLevelInclusive;
	Parms.ToBattlePassLevelInclusive = ToBattlePassLevelInclusive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BattlePassConfigurationAsset.GetAllBattlePassRewardsBetweenLevelsFlattened
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   FromBattlePassLevelInclusive                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToBattlePassLevelInclusive                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludeFreeRewards                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IncludePremiumRewards                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> UBattlePassConfigurationAsset::GetAllBattlePassRewardsBetweenLevelsFlattened(int32 FromBattlePassLevelInclusive, int32 ToBattlePassLevelInclusive, bool IncludeFreeRewards, bool IncludePremiumRewards)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassConfigurationAsset", "GetAllBattlePassRewardsBetweenLevelsFlattened");

	Params::BattlePassConfigurationAsset_GetAllBattlePassRewardsBetweenLevelsFlattened Parms{};

	Parms.FromBattlePassLevelInclusive = FromBattlePassLevelInclusive;
	Parms.ToBattlePassLevelInclusive = ToBattlePassLevelInclusive;
	Parms.IncludeFreeRewards = IncludeFreeRewards;
	Parms.IncludePremiumRewards = IncludePremiumRewards;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BattlePassConfigurationAsset.TryGetBattlePassRewardsAtLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    Found                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   BattlePassLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FBattlePassLevelRewards          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FBattlePassLevelRewards UBattlePassConfigurationAsset::TryGetBattlePassRewardsAtLevel(bool* Found, int32 BattlePassLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassConfigurationAsset", "TryGetBattlePassRewardsAtLevel");

	Params::BattlePassConfigurationAsset_TryGetBattlePassRewardsAtLevel Parms{};

	Parms.BattlePassLevel = BattlePassLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Found != nullptr)
		*Found = Parms.Found;

	return Parms.ReturnValue;
}


// Function JP.BattlePassConfigurationAsset.ClampBattlePassIndexToValidRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   BattlePassIndex                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutValidRange                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassConfigurationAsset::ClampBattlePassIndexToValidRange(int32 BattlePassIndex, bool* OutValidRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassConfigurationAsset", "ClampBattlePassIndexToValidRange");

	Params::BattlePassConfigurationAsset_ClampBattlePassIndexToValidRange Parms{};

	Parms.BattlePassIndex = BattlePassIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValidRange != nullptr)
		*OutValidRange = Parms.OutValidRange;

	return Parms.ReturnValue;
}


// Function JP.BattlePassConfigurationAsset.ClampBattlePassLevelToValidRange
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   BattlePassLevel                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OutValidRange                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBattlePassConfigurationAsset::ClampBattlePassLevelToValidRange(int32 BattlePassLevel, bool* OutValidRange) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BattlePassConfigurationAsset", "ClampBattlePassLevelToValidRange");

	Params::BattlePassConfigurationAsset_ClampBattlePassLevelToValidRange Parms{};

	Parms.BattlePassLevel = BattlePassLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutValidRange != nullptr)
		*OutValidRange = Parms.OutValidRange;

	return Parms.ReturnValue;
}


// Function JP.PlayerStartQueryWorldSubsystem.Query
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// struct FPlayerStartQueryRequest         Request                                                (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FPlayerStartQueryResult          ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerStartQueryResult UPlayerStartQueryWorldSubsystem::Query(const struct FPlayerStartQueryRequest& Request)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStartQueryWorldSubsystem", "Query");

	Params::PlayerStartQueryWorldSubsystem_Query Parms{};

	Parms.Request = std::move(Request);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerRewardDataAsset.Sort
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<class UPlayerRewardDataAsset*>   PlayerRewardDataAssets                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerRewardDataAsset::Sort(TArray<class UPlayerRewardDataAsset*>& PlayerRewardDataAssets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerRewardDataAsset", "Sort");

	Params::PlayerRewardDataAsset_Sort Parms{};

	Parms.PlayerRewardDataAssets = std::move(PlayerRewardDataAssets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	PlayerRewardDataAssets = std::move(Parms.PlayerRewardDataAssets);
}


// Function JP.PlayerRewardDataAsset.TryGetPlayerRewardDataAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     PlayerRewardDataAssetID                                (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UPlayerRewardDataAsset>OutSoftPlayerRewardDataAsset                           (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerRewardDataAsset::TryGetPlayerRewardDataAsset(const struct FGameplayTag& PlayerRewardDataAssetID, TSoftObjectPtr<class UPlayerRewardDataAsset>* OutSoftPlayerRewardDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerRewardDataAsset", "TryGetPlayerRewardDataAsset");

	Params::PlayerRewardDataAsset_TryGetPlayerRewardDataAsset Parms{};

	Parms.PlayerRewardDataAssetID = std::move(PlayerRewardDataAssetID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftPlayerRewardDataAsset != nullptr)
		*OutSoftPlayerRewardDataAsset = Parms.OutSoftPlayerRewardDataAsset;

	return Parms.ReturnValue;
}


// Function JP.BattlePassCurrencyRewardDefinition.TryGetBattlePassCurrencyRewardDefinition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     BattlePassRewardCurrencyID                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UBattlePassCurrencyRewardDefinition>OutSoftBattlePassCurrencyRewardDefinition              (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattlePassCurrencyRewardDefinition::TryGetBattlePassCurrencyRewardDefinition(const struct FGameplayTag& BattlePassRewardCurrencyID, TSoftObjectPtr<class UBattlePassCurrencyRewardDefinition>* OutSoftBattlePassCurrencyRewardDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattlePassCurrencyRewardDefinition", "TryGetBattlePassCurrencyRewardDefinition");

	Params::BattlePassCurrencyRewardDefinition_TryGetBattlePassCurrencyRewardDefinition Parms{};

	Parms.BattlePassRewardCurrencyID = std::move(BattlePassRewardCurrencyID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftBattlePassCurrencyRewardDefinition != nullptr)
		*OutSoftBattlePassCurrencyRewardDefinition = Parms.OutSoftBattlePassCurrencyRewardDefinition;

	return Parms.ReturnValue;
}


// Function JP.BattlePassMetaData.TryGetBattlePassMetaData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     BattlePassID                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UBattlePassMetaData>OutSoftBattlePassMetaData                              (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBattlePassMetaData::TryGetBattlePassMetaData(const struct FGameplayTag& BattlePassID, TSoftObjectPtr<class UBattlePassMetaData>* OutSoftBattlePassMetaData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BattlePassMetaData", "TryGetBattlePassMetaData");

	Params::BattlePassMetaData_TryGetBattlePassMetaData Parms{};

	Parms.BattlePassID = std::move(BattlePassID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftBattlePassMetaData != nullptr)
		*OutSoftBattlePassMetaData = Parms.OutSoftBattlePassMetaData;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.BroadcastOnTeamChanged
// (Final, Native, Protected)

void APlayerStateJP::BroadcastOnTeamChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "BroadcastOnTeamChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.CompletedTooltip
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     TooltipTag                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerStateJP::CompletedTooltip(const struct FGameplayTag& TooltipTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "CompletedTooltip");

	Params::PlayerStateJP_CompletedTooltip Parms{};

	Parms.TooltipTag = std::move(TooltipTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.GetCompletedTooltips
// (Final, Native, Public)
// Parameters:
// struct FTooltipTagCollection            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FTooltipTagCollection APlayerStateJP::GetCompletedTooltips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetCompletedTooltips");

	Params::PlayerStateJP_GetCompletedTooltips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetCurrentlySelectedSkinDefinition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UNeighborSkinDefinition>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UNeighborSkinDefinition> APlayerStateJP::GetCurrentlySelectedSkinDefinition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetCurrentlySelectedSkinDefinition");

	Params::PlayerStateJP_GetCurrentlySelectedSkinDefinition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetCurrentlySelectedSkinIdentifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag APlayerStateJP::GetCurrentlySelectedSkinIdentifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetCurrentlySelectedSkinIdentifier");

	Params::PlayerStateJP_GetCurrentlySelectedSkinIdentifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetCurrentlySelectedUniqueItemSkinIdentifier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag APlayerStateJP::GetCurrentlySelectedUniqueItemSkinIdentifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetCurrentlySelectedUniqueItemSkinIdentifier");

	Params::PlayerStateJP_GetCurrentlySelectedUniqueItemSkinIdentifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetSelectedNeighborLoadout
// (Native, Public, BlueprintCallable)
// Parameters:
// struct FNeighborLoadout                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNeighborLoadout APlayerStateJP::GetSelectedNeighborLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetSelectedNeighborLoadout");

	Params::PlayerStateJP_GetSelectedNeighborLoadout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetShowTooltips
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerStateJP::GetShowTooltips()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetShowTooltips");

	Params::PlayerStateJP_GetShowTooltips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetUniqueItemSkinDefinitionForNeighbor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemSkinDefinition>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UItemSkinDefinition> APlayerStateJP::GetUniqueItemSkinDefinitionForNeighbor(const struct FGameplayTag& NeighborIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetUniqueItemSkinDefinitionForNeighbor");

	Params::PlayerStateJP_GetUniqueItemSkinDefinitionForNeighbor Parms{};

	Parms.NeighborIdentifier = std::move(NeighborIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.HandleUserAvatarLoaded
// (Final, Native, Private)
// Parameters:
// bool                                    bInWasSuccessful                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture>          InResultTexture                                        (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerStateJP::HandleUserAvatarLoaded(bool bInWasSuccessful, TSoftObjectPtr<class UTexture> InResultTexture)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "HandleUserAvatarLoaded");

	Params::PlayerStateJP_HandleUserAvatarLoaded Parms{};

	Parms.bInWasSuccessful = bInWasSuccessful;
	Parms.InResultTexture = InResultTexture;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.IncrementAssists
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void APlayerStateJP::IncrementAssists()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "IncrementAssists");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.IncrementDeaths
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void APlayerStateJP::IncrementDeaths()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "IncrementDeaths");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.IncrementKills
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void APlayerStateJP::IncrementKills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "IncrementKills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_Assists
// (Native, Public)

void APlayerStateJP::OnRep_Assists()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_Assists");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_CharacterRole
// (Native, Public)

void APlayerStateJP::OnRep_CharacterRole()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_CharacterRole");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_Deaths
// (Native, Public)

void APlayerStateJP::OnRep_Deaths()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_Deaths");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_EndOfMatchData
// (Native, Public)

void APlayerStateJP::OnRep_EndOfMatchData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_EndOfMatchData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_EOS_ID
// (Native, Public)

void APlayerStateJP::OnRep_EOS_ID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_EOS_ID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_HouseIdentifierVote
// (Native, Public, HasOutParams)
// Parameters:
// struct FGameplayTag                     OldValue                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerStateJP::OnRep_HouseIdentifierVote(const struct FGameplayTag& OldValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_HouseIdentifierVote");

	Params::PlayerStateJP_OnRep_HouseIdentifierVote Parms{};

	Parms.OldValue = std::move(OldValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_IsInParty
// (Native, Public)

void APlayerStateJP::OnRep_IsInParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_IsInParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_Kills
// (Native, Public)

void APlayerStateJP::OnRep_Kills()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_Kills");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_Loadout
// (Native, Public)

void APlayerStateJP::OnRep_Loadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_Loadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_MasterPlayerAccountId
// (Native, Public)

void APlayerStateJP::OnRep_MasterPlayerAccountId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_MasterPlayerAccountId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_NeighborIdentifier
// (Native, Public)

void APlayerStateJP::OnRep_NeighborIdentifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_NeighborIdentifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_OnlineUserID
// (Native, Public)

void APlayerStateJP::OnRep_OnlineUserID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_OnlineUserID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_OwnedHouses
// (Native, Public)

void APlayerStateJP::OnRep_OwnedHouses()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_OwnedHouses");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_PlayerAbandonedMatch
// (Native, Protected)

void APlayerStateJP::OnRep_PlayerAbandonedMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_PlayerAbandonedMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_PlayerXP
// (Native, Public)

void APlayerStateJP::OnRep_PlayerXP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_PlayerXP");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_TeamID
// (Native, Public)

void APlayerStateJP::OnRep_TeamID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_TeamID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.OnRep_TitlePlayerAccountId
// (Native, Public)

void APlayerStateJP::OnRep_TitlePlayerAccountId()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "OnRep_TitlePlayerAccountId");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.Server_SetShowTooltips
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    Show                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerStateJP::Server_SetShowTooltips(bool Show)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "Server_SetShowTooltips");

	Params::PlayerStateJP_Server_SetShowTooltips Parms{};

	Parms.Show = Show;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.SetAssists
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewAssists                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerStateJP::SetAssists(const int32 NewAssists)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "SetAssists");

	Params::PlayerStateJP_SetAssists Parms{};

	Parms.NewAssists = NewAssists;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.SetDeaths
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewDeaths                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerStateJP::SetDeaths(const int32 NewDeaths)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "SetDeaths");

	Params::PlayerStateJP_SetDeaths Parms{};

	Parms.NewDeaths = NewDeaths;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.SetKills
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   NewKills                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerStateJP::SetKills(const int32 NewKills)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "SetKills");

	Params::PlayerStateJP_SetKills Parms{};

	Parms.NewKills = NewKills;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP.TryGetItemSkinDefinition
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ItemId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NeighborIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemSkinDefinition>OutSkinDefinition                                      (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerStateJP::TryGetItemSkinDefinition(const struct FGameplayTag& ItemId, const struct FGameplayTag& NeighborIdentifier, TSoftObjectPtr<class UItemSkinDefinition>* OutSkinDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "TryGetItemSkinDefinition");

	Params::PlayerStateJP_TryGetItemSkinDefinition Parms{};

	Parms.ItemId = std::move(ItemId);
	Parms.NeighborIdentifier = std::move(NeighborIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSkinDefinition != nullptr)
		*OutSkinDefinition = Parms.OutSkinDefinition;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.TryGetItemSkinDefinitionForCurrentNeighbor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ItemId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemSkinDefinition>OutSkinDefinition                                      (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerStateJP::TryGetItemSkinDefinitionForCurrentNeighbor(const struct FGameplayTag& ItemId, TSoftObjectPtr<class UItemSkinDefinition>* OutSkinDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "TryGetItemSkinDefinitionForCurrentNeighbor");

	Params::PlayerStateJP_TryGetItemSkinDefinitionForCurrentNeighbor Parms{};

	Parms.ItemId = std::move(ItemId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSkinDefinition != nullptr)
		*OutSkinDefinition = Parms.OutSkinDefinition;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetAssists
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APlayerStateJP::GetAssists() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetAssists");

	Params::PlayerStateJP_GetAssists Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetCharacterRole
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FCharacterRoleData               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCharacterRoleData APlayerStateJP::GetCharacterRole() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetCharacterRole");

	Params::PlayerStateJP_GetCharacterRole Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetCharacterXP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     CharacterTag                                           (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APlayerStateJP::GetCharacterXP(const struct FGameplayTag& CharacterTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetCharacterXP");

	Params::PlayerStateJP_GetCharacterXP Parms{};

	Parms.CharacterTag = std::move(CharacterTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetDeaths
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APlayerStateJP::GetDeaths() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetDeaths");

	Params::PlayerStateJP_GetDeaths Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetEndOfMatchData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FEndOfMatchPlayerData            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FEndOfMatchPlayerData APlayerStateJP::GetEndOfMatchData() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetEndOfMatchData");

	Params::PlayerStateJP_GetEndOfMatchData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetHouseIdentifierVote
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag APlayerStateJP::GetHouseIdentifierVote() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetHouseIdentifierVote");

	Params::PlayerStateJP_GetHouseIdentifierVote Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetIsInParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerStateJP::GetIsInParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetIsInParty");

	Params::PlayerStateJP_GetIsInParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetKills
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APlayerStateJP::GetKills() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetKills");

	Params::PlayerStateJP_GetKills Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetLoadout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FPlayerLoadout             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FPlayerLoadout APlayerStateJP::GetLoadout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetLoadout");

	Params::PlayerStateJP_GetLoadout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetMasterPlayerAccountId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APlayerStateJP::GetMasterPlayerAccountId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetMasterPlayerAccountId");

	Params::PlayerStateJP_GetMasterPlayerAccountId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetNeighborDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UNeighborDefinition>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UNeighborDefinition> APlayerStateJP::GetNeighborDefinition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetNeighborDefinition");

	Params::PlayerStateJP_GetNeighborDefinition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetNeighborIdentifier
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag APlayerStateJP::GetNeighborIdentifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetNeighborIdentifier");

	Params::PlayerStateJP_GetNeighborIdentifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetOwnedHouses
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FGameplayTag>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FGameplayTag> APlayerStateJP::GetOwnedHouses() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetOwnedHouses");

	Params::PlayerStateJP_GetOwnedHouses Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetPerkManagerComponent
// (Native, Event, Protected, BlueprintEvent, Const)
// Parameters:
// class UPerkManagerComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkManagerComponent* APlayerStateJP::GetPerkManagerComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetPerkManagerComponent");

	Params::PlayerStateJP_GetPerkManagerComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetPlayerDisplayName
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APlayerStateJP::GetPlayerDisplayName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetPlayerDisplayName");

	Params::PlayerStateJP_GetPlayerDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetProfileXP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 APlayerStateJP::GetProfileXP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetProfileXP");

	Params::PlayerStateJP_GetProfileXP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetSkinDefinitionForNeighbor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NeighborIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UNeighborSkinDefinition>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UNeighborSkinDefinition> APlayerStateJP::GetSkinDefinitionForNeighbor(const struct FGameplayTag& NeighborIdentifier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetSkinDefinitionForNeighbor");

	Params::PlayerStateJP_GetSkinDefinitionForNeighbor Parms{};

	Parms.NeighborIdentifier = std::move(NeighborIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTeam                      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTeam APlayerStateJP::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetTeam");

	Params::PlayerStateJP_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetTeamID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 APlayerStateJP::GetTeamID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetTeamID");

	Params::PlayerStateJP_GetTeamID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetTitlePlayerAccountId
// (Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString APlayerStateJP::GetTitlePlayerAccountId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetTitlePlayerAccountId");

	Params::PlayerStateJP_GetTitlePlayerAccountId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.GetUserAvatar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> APlayerStateJP::GetUserAvatar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "GetUserAvatar");

	Params::PlayerStateJP_GetUserAvatar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.HasLoadout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerStateJP::HasLoadout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "HasLoadout");

	Params::PlayerStateJP_HasLoadout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP.IsLocalPlayerState
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerStateJP::IsLocalPlayerState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP", "IsLocalPlayerState");

	Params::PlayerStateJP_IsLocalPlayerState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP_Match.OnRep_DeathRespawnTimeWindow
// (Final, Native, Protected)

void APlayerStateJP_Match::OnRep_DeathRespawnTimeWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_Match", "OnRep_DeathRespawnTimeWindow");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP_Match.SetDeathRespawnTimeWindow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FDeathRespawnTimeWindow          NewDeathRespawnTimeWindow                              (ConstParm, Parm, NoDestructor, NativeAccessSpecifierPublic)

void APlayerStateJP_Match::SetDeathRespawnTimeWindow(const struct FDeathRespawnTimeWindow& NewDeathRespawnTimeWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_Match", "SetDeathRespawnTimeWindow");

	Params::PlayerStateJP_Match_SetDeathRespawnTimeWindow Parms{};

	Parms.NewDeathRespawnTimeWindow = std::move(NewDeathRespawnTimeWindow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP_Match.GetDeathRespawnTimeWindow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FDeathRespawnTimeWindow          ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FDeathRespawnTimeWindow APlayerStateJP_Match::GetDeathRespawnTimeWindow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_Match", "GetDeathRespawnTimeWindow");

	Params::PlayerStateJP_Match_GetDeathRespawnTimeWindow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.CanNeighborBePicked
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NeighborIDTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::CanNeighborBePicked(const class UObject* WorldContextObject, const struct FGameplayTag& NeighborIDTag, const uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "CanNeighborBePicked");

	Params::BlueprintFunctionLibraryJP_CanNeighborBePicked Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.NeighborIDTag = std::move(NeighborIDTag);
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.ContainsTagStack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagStackContainer       Container                                              (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::ContainsTagStack(struct FGameplayTagStackContainer& Container, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "ContainsTagStack");

	Params::BlueprintFunctionLibraryJP_ContainsTagStack Parms{};

	Parms.Container = std::move(Container);
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Container = std::move(Parms.Container);

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.CopyToClipboard
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           NewClipboard                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::CopyToClipboard(const class FString& NewClipboard)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "CopyToClipboard");

	Params::BlueprintFunctionLibraryJP_CopyToClipboard Parms{};

	Parms.NewClipboard = std::move(NewClipboard);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.CreateCombatParticipantFromPlayer
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerStateJP_Match*             Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombatParticipant               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCombatParticipant UBlueprintFunctionLibraryJP::CreateCombatParticipantFromPlayer(class APlayerStateJP_Match* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "CreateCombatParticipantFromPlayer");

	Params::BlueprintFunctionLibraryJP_CreateCombatParticipantFromPlayer Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.EffectContextAddCombatParticipant
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// struct FCombatParticipant               Data                                                   (Parm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::EffectContextAddCombatParticipant(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FCombatParticipant& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EffectContextAddCombatParticipant");

	Params::BlueprintFunctionLibraryJP_EffectContextAddCombatParticipant Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.EffectContextAddKillData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// struct FKillData                        Data                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::EffectContextAddKillData(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FKillData& Data)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EffectContextAddKillData");

	Params::BlueprintFunctionLibraryJP_EffectContextAddKillData Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);
	Parms.Data = std::move(Data);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.EffectContextAddKillMethod
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpecHandle        SpecHandle                                             (Parm, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemDefinition>   ItemDefinition                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftClassPtr<class UClass>             GameplayAbility                                        (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::EffectContextAddKillMethod(const struct FGameplayEffectSpecHandle& SpecHandle, TSoftObjectPtr<class UItemDefinition> ItemDefinition, TSoftClassPtr<class UClass> GameplayAbility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EffectContextAddKillMethod");

	Params::BlueprintFunctionLibraryJP_EffectContextAddKillMethod Parms{};

	Parms.SpecHandle = std::move(SpecHandle);
	Parms.ItemDefinition = ItemDefinition;
	Parms.GameplayAbility = GameplayAbility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.EffectContextGetCombatParticipant
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// struct FCombatParticipant               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCombatParticipant UBlueprintFunctionLibraryJP::EffectContextGetCombatParticipant(const struct FGameplayEffectContextHandle& EffectContextHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EffectContextGetCombatParticipant");

	Params::BlueprintFunctionLibraryJP_EffectContextGetCombatParticipant Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.EffectContextGetKillData
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectContextHandle     EffectContextHandle                                    (Parm, NativeAccessSpecifierPublic)
// struct FKillData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FKillData UBlueprintFunctionLibraryJP::EffectContextGetKillData(const struct FGameplayEffectContextHandle& EffectContextHandle)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EffectContextGetKillData");

	Params::BlueprintFunctionLibraryJP_EffectContextGetKillData Parms{};

	Parms.EffectContextHandle = std::move(EffectContextHandle);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.EvaluateFloatValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EArithmeticOperators                    Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintFunctionLibraryJP::EvaluateFloatValue(EArithmeticOperators Operator, float Value1, float Value2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EvaluateFloatValue");

	Params::BlueprintFunctionLibraryJP_EvaluateFloatValue Parms{};

	Parms.Operator = Operator;
	Parms.Value1 = Value1;
	Parms.Value2 = Value2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.EvaluateIntValue
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// EArithmeticOperators                    Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Value2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintFunctionLibraryJP::EvaluateIntValue(EArithmeticOperators Operator, int32 Value1, int32 Value2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EvaluateIntValue");

	Params::BlueprintFunctionLibraryJP_EvaluateIntValue Parms{};

	Parms.Operator = Operator;
	Parms.Value1 = Value1;
	Parms.Value2 = Value2;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.EvaluateRuntimeFloatCurve
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRuntimeFloatCurve               Curve                                                  (Parm, NativeAccessSpecifierPublic)
// float                                   Time                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintFunctionLibraryJP::EvaluateRuntimeFloatCurve(const class UObject* WorldContextObject, const struct FRuntimeFloatCurve& Curve, float Time)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EvaluateRuntimeFloatCurve");

	Params::BlueprintFunctionLibraryJP_EvaluateRuntimeFloatCurve Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Curve = std::move(Curve);
	Parms.Time = Time;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.EvaluateVectorValue
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// EArithmeticOperators                    Operator                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector3f                        Value1                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector3f                        Value2                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector3f                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector3f UBlueprintFunctionLibraryJP::EvaluateVectorValue(EArithmeticOperators Operator, const struct FVector3f& Value1, const struct FVector3f& Value2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "EvaluateVectorValue");

	Params::BlueprintFunctionLibraryJP_EvaluateVectorValue Parms{};

	Parms.Operator = Operator;
	Parms.Value1 = std::move(Value1);
	Parms.Value2 = std::move(Value2);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.FindComponents
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UGameplayEffectIW>    GameplayEffect                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayEffectComponent>ClassToFind                                            (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UGameplayEffectComponent*> ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UGameplayEffectComponent*> UBlueprintFunctionLibraryJP::FindComponents(TSubclassOf<class UGameplayEffectIW> GameplayEffect, TSubclassOf<class UGameplayEffectComponent> ClassToFind)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "FindComponents");

	Params::BlueprintFunctionLibraryJP_FindComponents Parms{};

	Parms.GameplayEffect = GameplayEffect;
	Parms.ClassToFind = ClassToFind;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.FindScreenEdgeLocationForWorldLocation
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocation                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   EdgePercent                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        ViewportCenterLoc                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector2D                        OutScreenPosition                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   OutRotationAngleDegrees                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOnScreen                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::FindScreenEdgeLocationForWorldLocation(class UObject* WorldContextObject, const struct FVector& InLocation, const float EdgePercent, const struct FVector2D& ViewportCenterLoc, struct FVector2D* OutScreenPosition, float* OutRotationAngleDegrees, bool* bIsOnScreen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "FindScreenEdgeLocationForWorldLocation");

	Params::BlueprintFunctionLibraryJP_FindScreenEdgeLocationForWorldLocation Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.InLocation = std::move(InLocation);
	Parms.EdgePercent = EdgePercent;
	Parms.ViewportCenterLoc = std::move(ViewportCenterLoc);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutScreenPosition != nullptr)
		*OutScreenPosition = std::move(Parms.OutScreenPosition);

	if (OutRotationAngleDegrees != nullptr)
		*OutRotationAngleDegrees = Parms.OutRotationAngleDegrees;

	if (bIsOnScreen != nullptr)
		*bIsOnScreen = Parms.bIsOnScreen;
}


// Function JP.BlueprintFunctionLibraryJP.FlushPlayerControllerInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::FlushPlayerControllerInput(class APlayerController* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "FlushPlayerControllerInput");

	Params::BlueprintFunctionLibraryJP_FlushPlayerControllerInput Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.GetAbilityTagsFromSpec
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectSpec              Spec                                                   (Parm, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UBlueprintFunctionLibraryJP::GetAbilityTagsFromSpec(const struct FGameplayEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetAbilityTagsFromSpec");

	Params::BlueprintFunctionLibraryJP_GetAbilityTagsFromSpec Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetAssistingCombatParticipantFromASC
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AssistType                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UAbilitySystemComponent*          ASC                                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPlayerMatchRecord*               PlayerToIgnore                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombatParticipant               ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FCombatParticipant UBlueprintFunctionLibraryJP::GetAssistingCombatParticipantFromASC(const struct FGameplayTag& AssistType, class UAbilitySystemComponent* ASC, class UPlayerMatchRecord* PlayerToIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetAssistingCombatParticipantFromASC");

	Params::BlueprintFunctionLibraryJP_GetAssistingCombatParticipantFromASC Parms{};

	Parms.AssistType = std::move(AssistType);
	Parms.ASC = ASC;
	Parms.PlayerToIgnore = PlayerToIgnore;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetDefaultPerkColor
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UBlueprintFunctionLibraryJP::GetDefaultPerkColor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetDefaultPerkColor");

	Params::BlueprintFunctionLibraryJP_GetDefaultPerkColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetDirectionAxisFromVector
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FVector                          Vector                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EDirectionAxis                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EDirectionAxis UBlueprintFunctionLibraryJP::GetDirectionAxisFromVector(const struct FVector& Vector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetDirectionAxisFromVector");

	Params::BlueprintFunctionLibraryJP_GetDirectionAxisFromVector Parms{};

	Parms.Vector = std::move(Vector);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetDisplayNameFromCombatParticipant
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombatParticipant               Participant                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UBlueprintFunctionLibraryJP::GetDisplayNameFromCombatParticipant(const class UObject* WorldContextObject, const struct FCombatParticipant& Participant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetDisplayNameFromCombatParticipant");

	Params::BlueprintFunctionLibraryJP_GetDisplayNameFromCombatParticipant Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Participant = std::move(Participant);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetEffectContextHandleFromGameplayEffectSpec
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayEffectSpec              Spec                                                   (Parm, NativeAccessSpecifierPublic)
// struct FGameplayEffectContextHandle     ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayEffectContextHandle UBlueprintFunctionLibraryJP::GetEffectContextHandleFromGameplayEffectSpec(const struct FGameplayEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetEffectContextHandleFromGameplayEffectSpec");

	Params::BlueprintFunctionLibraryJP_GetEffectContextHandleFromGameplayEffectSpec Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetExpectedDuration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class UGameplayEffectIW>    GameplayEffect                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UBlueprintFunctionLibraryJP::GetExpectedDuration(TSubclassOf<class UGameplayEffectIW> GameplayEffect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetExpectedDuration");

	Params::BlueprintFunctionLibraryJP_GetExpectedDuration Parms{};

	Parms.GameplayEffect = GameplayEffect;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetFirstPlayerControllerJP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerControllerJP*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerControllerJP* UBlueprintFunctionLibraryJP::GetFirstPlayerControllerJP(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetFirstPlayerControllerJP");

	Params::BlueprintFunctionLibraryJP_GetFirstPlayerControllerJP Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetFirstPlayerControllerJP_Lobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PrintError                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerControllerJP_Lobby*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerControllerJP_Lobby* UBlueprintFunctionLibraryJP::GetFirstPlayerControllerJP_Lobby(const class UObject* WorldContextObject, bool PrintError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetFirstPlayerControllerJP_Lobby");

	Params::BlueprintFunctionLibraryJP_GetFirstPlayerControllerJP_Lobby Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrintError = PrintError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetFirstPlayerControllerJP_Match
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PrintError                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerControllerJP_Match*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerControllerJP_Match* UBlueprintFunctionLibraryJP::GetFirstPlayerControllerJP_Match(const class UObject* WorldContextObject, bool PrintError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetFirstPlayerControllerJP_Match");

	Params::BlueprintFunctionLibraryJP_GetFirstPlayerControllerJP_Match Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrintError = PrintError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetFirstPlayerStateJP
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStateJP*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStateJP* UBlueprintFunctionLibraryJP::GetFirstPlayerStateJP(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetFirstPlayerStateJP");

	Params::BlueprintFunctionLibraryJP_GetFirstPlayerStateJP Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetFirstPlayerStateJP_Lobby
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStateJP_Lobby*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStateJP_Lobby* UBlueprintFunctionLibraryJP::GetFirstPlayerStateJP_Lobby(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetFirstPlayerStateJP_Lobby");

	Params::BlueprintFunctionLibraryJP_GetFirstPlayerStateJP_Lobby Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetFirstPlayerStateJP_Match
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerStateJP_Match*             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerStateJP_Match* UBlueprintFunctionLibraryJP::GetFirstPlayerStateJP_Match(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetFirstPlayerStateJP_Match");

	Params::BlueprintFunctionLibraryJP_GetFirstPlayerStateJP_Match Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetGameModeJP_Lobby
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameModeJP_Lobby*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameModeJP_Lobby* UBlueprintFunctionLibraryJP::GetGameModeJP_Lobby(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetGameModeJP_Lobby");

	Params::BlueprintFunctionLibraryJP_GetGameModeJP_Lobby Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetGameModeJP_Match
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameModeJP_Match*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameModeJP_Match* UBlueprintFunctionLibraryJP::GetGameModeJP_Match(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetGameModeJP_Match");

	Params::BlueprintFunctionLibraryJP_GetGameModeJP_Match Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetGameplayAbilityForInputTag
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UEquipmentInstance*               EquipmentInstance                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     GameplayTag                                            (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UGameplayAbility>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UGameplayAbility> UBlueprintFunctionLibraryJP::GetGameplayAbilityForInputTag(class UEquipmentInstance* EquipmentInstance, const struct FGameplayTag& GameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetGameplayAbilityForInputTag");

	Params::BlueprintFunctionLibraryJP_GetGameplayAbilityForInputTag Parms{};

	Parms.EquipmentInstance = EquipmentInstance;
	Parms.GameplayTag = std::move(GameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetGameplayTagChildren
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ParentGameplayTag                                      (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTagContainer            ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FGameplayTagContainer UBlueprintFunctionLibraryJP::GetGameplayTagChildren(const struct FGameplayTag& ParentGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetGameplayTagChildren");

	Params::BlueprintFunctionLibraryJP_GetGameplayTagChildren Parms{};

	Parms.ParentGameplayTag = std::move(ParentGameplayTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetGameplayTagRootName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     TagToSplit                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintFunctionLibraryJP::GetGameplayTagRootName(const struct FGameplayTag& TagToSplit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetGameplayTagRootName");

	Params::BlueprintFunctionLibraryJP_GetGameplayTagRootName Parms{};

	Parms.TagToSplit = std::move(TagToSplit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetGameStateJP
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameStateJP*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameStateJP* UBlueprintFunctionLibraryJP::GetGameStateJP(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetGameStateJP");

	Params::BlueprintFunctionLibraryJP_GetGameStateJP Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetGameStateJP_Lobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameStateJP_Lobby*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameStateJP_Lobby* UBlueprintFunctionLibraryJP::GetGameStateJP_Lobby(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetGameStateJP_Lobby");

	Params::BlueprintFunctionLibraryJP_GetGameStateJP_Lobby Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetGameStateJP_Match
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGameStateJP_Match*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGameStateJP_Match* UBlueprintFunctionLibraryJP::GetGameStateJP_Match(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetGameStateJP_Match");

	Params::BlueprintFunctionLibraryJP_GetGameStateJP_Match Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetIsPie
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::GetIsPie()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetIsPie");

	Params::BlueprintFunctionLibraryJP_GetIsPie Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetLocalPlayerControllerJP_Lobby
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PrintError                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerControllerJP_Lobby*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerControllerJP_Lobby* UBlueprintFunctionLibraryJP::GetLocalPlayerControllerJP_Lobby(const class UObject* WorldContextObject, bool PrintError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetLocalPlayerControllerJP_Lobby");

	Params::BlueprintFunctionLibraryJP_GetLocalPlayerControllerJP_Lobby Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrintError = PrintError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetLocalPlayerControllerJP_Match
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    PrintError                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerControllerJP_Match*        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APlayerControllerJP_Match* UBlueprintFunctionLibraryJP::GetLocalPlayerControllerJP_Match(const class UObject* WorldContextObject, bool PrintError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetLocalPlayerControllerJP_Match");

	Params::BlueprintFunctionLibraryJP_GetLocalPlayerControllerJP_Match Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.PrintError = PrintError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetOnlineServicesID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          Object                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintFunctionLibraryJP::GetOnlineServicesID(class UObject* Object)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetOnlineServicesID");

	Params::BlueprintFunctionLibraryJP_GetOnlineServicesID Parms{};

	Parms.Object = Object;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetStencilValueFromMask
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintFunctionLibraryJP::GetStencilValueFromMask(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetStencilValueFromMask");

	Params::BlueprintFunctionLibraryJP_GetStencilValueFromMask Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetTagStackAmount
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagStack                TagStack                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintFunctionLibraryJP::GetTagStackAmount(const struct FGameplayTagStack& TagStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetTagStackAmount");

	Params::BlueprintFunctionLibraryJP_GetTagStackAmount Parms{};

	Parms.TagStack = std::move(TagStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetTagStackCount
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagStackContainer       Container                                              (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBlueprintFunctionLibraryJP::GetTagStackCount(struct FGameplayTagStackContainer& Container, const struct FGameplayTag& Tag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetTagStackCount");

	Params::BlueprintFunctionLibraryJP_GetTagStackCount Parms{};

	Parms.Container = std::move(Container);
	Parms.Tag = std::move(Tag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Container = std::move(Parms.Container);

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetTagStackTag
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTagStack                TagStack                                               (Parm, NoDestructor, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UBlueprintFunctionLibraryJP::GetTagStackTag(const struct FGameplayTagStack& TagStack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetTagStackTag");

	Params::BlueprintFunctionLibraryJP_GetTagStackTag Parms{};

	Parms.TagStack = std::move(TagStack);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetTargetTagsFromSpec
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayEffectSpec              Spec                                                   (Parm, NativeAccessSpecifierPublic)
// const struct FGameplayTagContainer      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FGameplayTagContainer UBlueprintFunctionLibraryJP::GetTargetTagsFromSpec(const struct FGameplayEffectSpec& Spec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetTargetTagsFromSpec");

	Params::BlueprintFunctionLibraryJP_GetTargetTagsFromSpec Parms{};

	Parms.Spec = std::move(Spec);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetTutorialPromptDialogDescriptor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Body                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UCommonGameDialogDescriptor*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonGameDialogDescriptor* UBlueprintFunctionLibraryJP::GetTutorialPromptDialogDescriptor(const class FText& Body)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetTutorialPromptDialogDescriptor");

	Params::BlueprintFunctionLibraryJP_GetTutorialPromptDialogDescriptor Parms{};

	Parms.Body = std::move(Body);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.GetTweakableData
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// const class UTweakableData*             ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UTweakableData* UBlueprintFunctionLibraryJP::GetTweakableData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "GetTweakableData");

	Params::BlueprintFunctionLibraryJP_GetTweakableData Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.IsActorReplicatingMovement
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::IsActorReplicatingMovement(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "IsActorReplicatingMovement");

	Params::BlueprintFunctionLibraryJP_IsActorReplicatingMovement Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.IsKeyboardFocused
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::IsKeyboardFocused()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "IsKeyboardFocused");

	Params::BlueprintFunctionLibraryJP_IsKeyboardFocused Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.IsSceneComponentOnScreen
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  SceneComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::IsSceneComponentOnScreen(const class UObject* WorldContextObject, const class USceneComponent* SceneComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "IsSceneComponentOnScreen");

	Params::BlueprintFunctionLibraryJP_IsSceneComponentOnScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SceneComponent = SceneComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.IsSceneComponentOnScreenWithSlack
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USceneComponent*                  SceneComponent                                         (ConstParm, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          LocalSpaceExtraSize                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::IsSceneComponentOnScreenWithSlack(const class UObject* WorldContextObject, const class USceneComponent* SceneComponent, const struct FVector& LocalSpaceExtraSize)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "IsSceneComponentOnScreenWithSlack");

	Params::BlueprintFunctionLibraryJP_IsSceneComponentOnScreenWithSlack Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.SceneComponent = SceneComponent;
	Parms.LocalSpaceExtraSize = std::move(LocalSpaceExtraSize);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.IsWorldPositionOnScreen
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          WorldLocation                                          (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::IsWorldPositionOnScreen(const class UObject* WorldContextObject, const struct FVector& WorldLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "IsWorldPositionOnScreen");

	Params::BlueprintFunctionLibraryJP_IsWorldPositionOnScreen Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.WorldLocation = std::move(WorldLocation);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.LegalPlacement
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FDeployabeLegality               LegalityStruct                                         (Parm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UBlueprintFunctionLibraryJP::LegalPlacement(const struct FDeployabeLegality& LegalityStruct)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "LegalPlacement");

	Params::BlueprintFunctionLibraryJP_LegalPlacement Parms{};

	Parms.LegalityStruct = std::move(LegalityStruct);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.SendMessageToAll
// (Final, BlueprintCosmetic, Native, Static, Public, BlueprintCallable)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::SendMessageToAll(const class FString& Message, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "SendMessageToAll");

	Params::BlueprintFunctionLibraryJP_SendMessageToAll Parms{};

	Parms.Message = std::move(Message);
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.SetTagStack
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTagStackContainer       Container                                              (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     Tag                                                    (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewStacks                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::SetTagStack(struct FGameplayTagStackContainer& Container, const struct FGameplayTag& Tag, int32 NewStacks)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "SetTagStack");

	Params::BlueprintFunctionLibraryJP_SetTagStack Parms{};

	Parms.Container = std::move(Container);
	Parms.Tag = std::move(Tag);
	Parms.NewStacks = NewStacks;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	Container = std::move(Parms.Container);
}


// Function JP.BlueprintFunctionLibraryJP.SimulateMouseScrollInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::SimulateMouseScrollInput(const struct FKey& InKey, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "SimulateMouseScrollInput");

	Params::BlueprintFunctionLibraryJP_SimulateMouseScrollInput Parms{};

	Parms.InKey = std::move(InKey);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.SimulatePlayerAnalogInput
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::SimulatePlayerAnalogInput(const struct FKey& InKey, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "SimulatePlayerAnalogInput");

	Params::BlueprintFunctionLibraryJP_SimulatePlayerAnalogInput Parms{};

	Parms.InKey = std::move(InKey);
	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.SimulatePlayerInputKeyDown
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::SimulatePlayerInputKeyDown(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "SimulatePlayerInputKeyDown");

	Params::BlueprintFunctionLibraryJP_SimulatePlayerInputKeyDown Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.SimulatePlayerInputKeyUp
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FKey                             InKey                                                  (Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::SimulatePlayerInputKeyUp(const struct FKey& InKey)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "SimulatePlayerInputKeyUp");

	Params::BlueprintFunctionLibraryJP_SimulatePlayerInputKeyUp Parms{};

	Parms.InKey = std::move(InKey);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.SortRoomData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TArray<struct FRoomData>                RoomCollection                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::SortRoomData(TArray<struct FRoomData>& RoomCollection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "SortRoomData");

	Params::BlueprintFunctionLibraryJP_SortRoomData Parms{};

	Parms.RoomCollection = std::move(RoomCollection);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	RoomCollection = std::move(Parms.RoomCollection);
}


// Function JP.BlueprintFunctionLibraryJP.SplitGameplayTagName
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     TagToSplit                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FString> UBlueprintFunctionLibraryJP::SplitGameplayTagName(const struct FGameplayTag& TagToSplit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "SplitGameplayTagName");

	Params::BlueprintFunctionLibraryJP_SplitGameplayTagName Parms{};

	Parms.TagToSplit = std::move(TagToSplit);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BlueprintFunctionLibraryJP.TraceForHitsWithInterface
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Range                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Width                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  Height                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  TraceHeightOffset                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          TraceFromLocation                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         TraceRotation                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           Interface                                              (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Debug                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<EObjectTypeQuery>                ObjectTypes                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ActorsToIgnore                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FHitResult>               AcceptedHits                                           (Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    NoHits                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    OnlyHitWorldStatic                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::TraceForHitsWithInterface(class UObject* WorldContextObject, const double Range, const double Width, const double Height, const double TraceHeightOffset, const struct FVector& TraceFromLocation, const struct FRotator& TraceRotation, class AActor* Owner, TSubclassOf<class IInterface> Interface, bool Debug, const TArray<EObjectTypeQuery>& ObjectTypes, const TArray<class AActor*>& ActorsToIgnore, TArray<struct FHitResult>* AcceptedHits, bool* NoHits, bool* OnlyHitWorldStatic)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "TraceForHitsWithInterface");

	Params::BlueprintFunctionLibraryJP_TraceForHitsWithInterface Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Range = Range;
	Parms.Width = Width;
	Parms.Height = Height;
	Parms.TraceHeightOffset = TraceHeightOffset;
	Parms.TraceFromLocation = std::move(TraceFromLocation);
	Parms.TraceRotation = std::move(TraceRotation);
	Parms.Owner = Owner;
	Parms.Interface = Interface;
	Parms.Debug = Debug;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (AcceptedHits != nullptr)
		*AcceptedHits = std::move(Parms.AcceptedHits);

	if (NoHits != nullptr)
		*NoHits = Parms.NoHits;

	if (OnlyHitWorldStatic != nullptr)
		*OnlyHitWorldStatic = Parms.OnlyHitWorldStatic;
}


// Function JP.BlueprintFunctionLibraryJP.TryAddTagStacksToItemInInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemDefinition>   ItemDefinition                                         (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, int32>        TagStacksToAdd                                         (ConstParm, Parm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::TryAddTagStacksToItemInInventory(class UGameplayAbility* Ability, const TSoftObjectPtr<class UItemDefinition> ItemDefinition, const TMap<struct FGameplayTag, int32>& TagStacksToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "TryAddTagStacksToItemInInventory");

	Params::BlueprintFunctionLibraryJP_TryAddTagStacksToItemInInventory Parms{};

	Parms.Ability = Ability;
	Parms.ItemDefinition = ItemDefinition;
	Parms.TagStacksToAdd = std::move(TagStacksToAdd);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.TrySetTagStacksForItemInInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemDefinition>   ItemDefinition                                         (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, int32>        TagStacksToSet                                         (ConstParm, Parm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::TrySetTagStacksForItemInInventory(class UGameplayAbility* Ability, const TSoftObjectPtr<class UItemDefinition> ItemDefinition, const TMap<struct FGameplayTag, int32>& TagStacksToSet)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "TrySetTagStacksForItemInInventory");

	Params::BlueprintFunctionLibraryJP_TrySetTagStacksForItemInInventory Parms{};

	Parms.Ability = Ability;
	Parms.ItemDefinition = ItemDefinition;
	Parms.TagStacksToSet = std::move(TagStacksToSet);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintFunctionLibraryJP.TrySubtractTagStacksFromItemInInventory
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UGameplayAbility*                 Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemDefinition>   ItemDefinition                                         (ConstParm, Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<struct FGameplayTag, int32>        TagStacksToSubtract                                    (ConstParm, Parm, NativeAccessSpecifierPublic)

void UBlueprintFunctionLibraryJP::TrySubtractTagStacksFromItemInInventory(class UGameplayAbility* Ability, const TSoftObjectPtr<class UItemDefinition> ItemDefinition, const TMap<struct FGameplayTag, int32>& TagStacksToSubtract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintFunctionLibraryJP", "TrySubtractTagStacksFromItemInInventory");

	Params::BlueprintFunctionLibraryJP_TrySubtractTagStacksFromItemInInventory Parms{};

	Parms.Ability = Ability;
	Parms.ItemDefinition = ItemDefinition;
	Parms.TagStacksToSubtract = std::move(TagStacksToSubtract);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialRecentPlayerInteractionWidget.OnBlockButtonClicked
// (Final, Native, Private)

void USocialRecentPlayerInteractionWidget::OnBlockButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialRecentPlayerInteractionWidget", "OnBlockButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintLogging.Print
// (Final, Native, Static, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class FString                           CategoryName                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InString                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EVerbosity                              Verbosity                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLinearColor                     TextColor                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   Duration                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UBlueprintLogging::Print(const class FString& CategoryName, const class FString& InString, EVerbosity Verbosity, const struct FLinearColor& TextColor, float Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintLogging", "Print");

	Params::BlueprintLogging_Print Parms{};

	Parms.CategoryName = std::move(CategoryName);
	Parms.InString = std::move(InString);
	Parms.Verbosity = Verbosity;
	Parms.TextColor = std::move(TextColor);
	Parms.Duration = Duration;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.BlueprintStringLibraryJP.Conv_PlayerLoadoutToString
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FPlayerLoadout                   InLoadout                                              (Parm, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UBlueprintStringLibraryJP::Conv_PlayerLoadoutToString(const struct FPlayerLoadout& InLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BlueprintStringLibraryJP", "Conv_PlayerLoadoutToString");

	Params::BlueprintStringLibraryJP_Conv_PlayerLoadoutToString Parms{};

	Parms.InLoadout = std::move(InLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.BuyAmmoBehavior.GetAmmoToAdd
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemInstance*                    Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UBuyAmmoBehavior::GetAmmoToAdd(class UItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BuyAmmoBehavior", "GetAmmoToAdd");

	Params::BuyAmmoBehavior_GetAmmoToAdd Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialPartyFollowLeaderPasswordMenu.Canceled
// (Final, Native, Public, BlueprintCallable)

void USocialPartyFollowLeaderPasswordMenu::Canceled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyFollowLeaderPasswordMenu", "Canceled");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialPartyFollowLeaderPasswordMenu.EnteredPassword
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialPartyFollowLeaderPasswordMenu::EnteredPassword(const class FString& Password)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyFollowLeaderPasswordMenu", "EnteredPassword");

	Params::SocialPartyFollowLeaderPasswordMenu_EnteredPassword Parms{};

	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamAssignableManager.GatherReferences
// (Final, Native, Public, BlueprintCallable)

void ATeamAssignableManager::GatherReferences()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamAssignableManager", "GatherReferences");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamAssignableManager.FindOwningGroundsKeeper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGroundsKeeper*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGroundsKeeper* ATeamAssignableManager::FindOwningGroundsKeeper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamAssignableManager", "FindOwningGroundsKeeper");

	Params::TeamAssignableManager_FindOwningGroundsKeeper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.CharacterDeathComponent.BeginRespawn
// (Event, Protected, BlueprintEvent)

void UCharacterDeathComponent::BeginRespawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "BeginRespawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.CharacterDeathComponent.FinishRespawnCooldown
// (Final, Native, Public, BlueprintCallable)

void UCharacterDeathComponent::FinishRespawnCooldown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "FinishRespawnCooldown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.CharacterDeathComponent.GetOriginalController
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AController* UCharacterDeathComponent::GetOriginalController()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "GetOriginalController");

	Params::CharacterDeathComponent_GetOriginalController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.CharacterDeathComponent.GetOriginalPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UCharacterDeathComponent::GetOriginalPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "GetOriginalPawn");

	Params::CharacterDeathComponent_GetOriginalPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.CharacterDeathComponent.GetSpectatorPawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UCharacterDeathComponent::GetSpectatorPawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "GetSpectatorPawn");

	Params::CharacterDeathComponent_GetSpectatorPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.CharacterDeathComponent.KillCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   RespawnTime                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDeathComponent::KillCharacter(float RespawnTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "KillCharacter");

	Params::CharacterDeathComponent_KillCharacter Parms{};

	Parms.RespawnTime = RespawnTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.CharacterDeathComponent.RespawnCharacter
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           NewCharacter                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDeathComponent::RespawnCharacter(class AActor* NewCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "RespawnCharacter");

	Params::CharacterDeathComponent_RespawnCharacter Parms{};

	Parms.NewCharacter = NewCharacter;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.CharacterDeathComponent.SetWantsToRespawn
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InWantsToRespawn                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterDeathComponent::SetWantsToRespawn(bool InWantsToRespawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "SetWantsToRespawn");

	Params::CharacterDeathComponent_SetWantsToRespawn Parms{};

	Parms.InWantsToRespawn = InWantsToRespawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.CharacterDeathComponent.SpectatorPawnSpawned
// (Event, Protected, BlueprintEvent)

void UCharacterDeathComponent::SpectatorPawnSpawned()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "SpectatorPawnSpawned");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.CharacterDeathComponent.GetWantsToRespawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UCharacterDeathComponent::GetWantsToRespawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterDeathComponent", "GetWantsToRespawn");

	Params::CharacterDeathComponent_GetWantsToRespawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.StaticMeshActorJP.K2_FellOutOfWorld
// (Event, Public, BlueprintEvent)

void AStaticMeshActorJP::K2_FellOutOfWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaticMeshActorJP", "K2_FellOutOfWorld");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.CharacterJP.GetDefinition
// (Final, Native, Protected, BlueprintCallable, BlueprintPure)
// Parameters:
// class UNeighborDefinition*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNeighborDefinition* ACharacterJP::GetDefinition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "GetDefinition");

	Params::CharacterJP_GetDefinition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.CharacterJP.GetTransformOfThirdPersonBone
// (Event, Protected, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FName                             BoneName                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ACharacterJP::GetTransformOfThirdPersonBone(class FName BoneName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "GetTransformOfThirdPersonBone");

	Params::CharacterJP_GetTransformOfThirdPersonBone Parms{};

	Parms.BoneName = BoneName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.CharacterJP.K2_FellOutOfWorld
// (Event, Public, BlueprintEvent)

void ACharacterJP::K2_FellOutOfWorld()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "K2_FellOutOfWorld");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.CharacterJP.K2_HealthAttributeChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   OldValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterJP::K2_HealthAttributeChanged(float OldValue, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "K2_HealthAttributeChanged");

	Params::CharacterJP_K2_HealthAttributeChanged Parms{};

	Parms.OldValue = OldValue;
	Parms.NewValue = NewValue;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.CharacterJP.K2_InitializePlayer
// (Event, Protected, BlueprintEvent)

void ACharacterJP::K2_InitializePlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "K2_InitializePlayer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.CharacterJP.K2_OnRep_PlayerState
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerStateJP_Match*             PlayerStateJP_Match                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterJP::K2_OnRep_PlayerState(const class APlayerStateJP_Match* PlayerStateJP_Match)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "K2_OnRep_PlayerState");

	Params::CharacterJP_K2_OnRep_PlayerState Parms{};

	Parms.PlayerStateJP_Match = PlayerStateJP_Match;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.CharacterJP.KilledByNonPlayer
// (Final, BlueprintAuthorityOnly, Native, Private, BlueprintCallable)
// Parameters:
// class FString                           KillerObject                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterJP::KilledByNonPlayer(const class FString& KillerObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "KilledByNonPlayer");

	Params::CharacterJP_KilledByNonPlayer Parms{};

	Parms.KillerObject = std::move(KillerObject);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.CharacterJP.KilledByPlayer
// (Final, BlueprintAuthorityOnly, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     KillerPawnTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterJP::KilledByPlayer(const struct FGameplayTag& KillerPawnTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "KilledByPlayer");

	Params::CharacterJP_KilledByPlayer Parms{};

	Parms.KillerPawnTag = std::move(KillerPawnTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.CharacterJP.MovementInputPreProcess
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FVector                          WorldDirection                                         (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ScaleValue                                             (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bForce                                                 (Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ACharacterJP::MovementInputPreProcess(struct FVector& WorldDirection, float& ScaleValue, bool& bForce)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "MovementInputPreProcess");

	Params::CharacterJP_MovementInputPreProcess Parms{};

	Parms.WorldDirection = std::move(WorldDirection);
	Parms.ScaleValue = ScaleValue;
	Parms.bForce = bForce;

	UObject::ProcessEvent(Func, &Parms);

	WorldDirection = std::move(Parms.WorldDirection);
	ScaleValue = Parms.ScaleValue;
	bForce = Parms.bForce;
}


// Function JP.CharacterJP.GetCharacterIdTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ACharacterJP::GetCharacterIdTag() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "GetCharacterIdTag");

	Params::CharacterJP_GetCharacterIdTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.CharacterJP.GetTeamMaterial
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UMaterialInstance*                ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UMaterialInstance* ACharacterJP::GetTeamMaterial() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterJP", "GetTeamMaterial");

	Params::CharacterJP_GetTeamMaterial Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.CharacterMaskComponent.PopMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMaskComponent::PopMask(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMaskComponent", "PopMask");

	Params::CharacterMaskComponent_PopMask Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.CharacterMaskComponent.PushMask
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InTag                                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterMaskComponent::PushMask(const struct FGameplayTag& InTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMaskComponent", "PushMask");

	Params::CharacterMaskComponent_PushMask Parms{};

	Parms.InTag = std::move(InTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.CharacterMaskComponent.RefreshMask
// (Final, Native, Public, BlueprintCallable)

void UCharacterMaskComponent::RefreshMask()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterMaskComponent", "RefreshMask");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ChargeableWidget.OnCancelCharge
// (Native, Event, Public, BlueprintEvent)

void IChargeableWidget::OnCancelCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableWidget", "OnCancelCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ChargeableWidget.OnCompleteCharge
// (Native, Event, Public, BlueprintEvent)

void IChargeableWidget::OnCompleteCharge()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableWidget", "OnCompleteCharge");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ChargeableWidget.OnStartCharge
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   ChargeTime                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IChargeableWidget::OnStartCharge(float ChargeTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ChargeableWidget", "OnStartCharge");

	Params::ChargeableWidget_OnStartCharge Parms{};

	Parms.ChargeTime = ChargeTime;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ClientAuthenticationInitializationGameInstanceSubsystem.GetClientGameInitializationFailedDescriptor
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             Body                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UCommonGameDialogDescriptor*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonGameDialogDescriptor* UClientAuthenticationInitializationGameInstanceSubsystem::GetClientGameInitializationFailedDescriptor(const class FText& Body)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ClientAuthenticationInitializationGameInstanceSubsystem", "GetClientGameInitializationFailedDescriptor");

	Params::ClientAuthenticationInitializationGameInstanceSubsystem_GetClientGameInitializationFailedDescriptor Parms{};

	Parms.Body = std::move(Body);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ClientAuthenticationInitializationGameInstanceSubsystem.IsFinished
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UClientAuthenticationInitializationGameInstanceSubsystem::IsFinished() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ClientAuthenticationInitializationGameInstanceSubsystem", "IsFinished");

	Params::ClientAuthenticationInitializationGameInstanceSubsystem_IsFinished Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialUserEntryWidget.GetListItemPadding
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FMargin                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

struct FMargin USocialUserEntryWidget::GetListItemPadding()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialUserEntryWidget", "GetListItemPadding");

	Params::SocialUserEntryWidget_GetListItemPadding Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.SocialUserEntryWidget.SetAvatar
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UOnlineServicesUserBase*          User                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialUserEntryWidget::SetAvatar(class UOnlineServicesUserBase* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialUserEntryWidget", "SetAvatar");

	Params::SocialUserEntryWidget_SetAvatar Parms{};

	Parms.User = User;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.CurveInterpolationComponent.StartInterpolationEvent
// (Final, Native, Public, BlueprintCallable)

void UCurveInterpolationComponent::StartInterpolationEvent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CurveInterpolationComponent", "StartInterpolationEvent");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.DeathDurabilityChangeBehavior.GetNewDurability
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemInstance*                    Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDeathDurabilityChangeBehavior::GetNewDurability(class UItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DeathDurabilityChangeBehavior", "GetNewDurability");

	Params::DeathDurabilityChangeBehavior_GetNewDurability Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraConfirmationScreen.HandleTapToCloseZoneMouseButtonDown
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FGeometry                        MyGeometry                                             (Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// struct FPointerEvent                    MouseEvent                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FEventReply                      ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FEventReply ULyraConfirmationScreen::HandleTapToCloseZoneMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraConfirmationScreen", "HandleTapToCloseZoneMouseButtonDown");

	Params::LyraConfirmationScreen_HandleTapToCloseZoneMouseButtonDown Parms{};

	Parms.MyGeometry = std::move(MyGeometry);
	Parms.MouseEvent = std::move(MouseEvent);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraConfirmationScreen.GetEntryBoxButtonsWidget
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UDynamicEntryBox*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UDynamicEntryBox* ULyraConfirmationScreen::GetEntryBoxButtonsWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraConfirmationScreen", "GetEntryBoxButtonsWidget");

	Params::LyraConfirmationScreen_GetEntryBoxButtonsWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.DeathRespawnTimeWindowFunctionLibrary.GetTimeUntilEndOfTimeWindow
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDeathRespawnTimeWindow          DeathRespawnTimeWindow                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UDeathRespawnTimeWindowFunctionLibrary::GetTimeUntilEndOfTimeWindow(class UObject* WorldContext, const struct FDeathRespawnTimeWindow& DeathRespawnTimeWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DeathRespawnTimeWindowFunctionLibrary", "GetTimeUntilEndOfTimeWindow");

	Params::DeathRespawnTimeWindowFunctionLibrary_GetTimeUntilEndOfTimeWindow Parms{};

	Parms.WorldContext = WorldContext;
	Parms.DeathRespawnTimeWindow = std::move(DeathRespawnTimeWindow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.DeathRespawnTimeWindowFunctionLibrary.IsAfterTimeWindow
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDeathRespawnTimeWindow          DeathRespawnTimeWindow                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDeathRespawnTimeWindowFunctionLibrary::IsAfterTimeWindow(class UObject* WorldContext, const struct FDeathRespawnTimeWindow& DeathRespawnTimeWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DeathRespawnTimeWindowFunctionLibrary", "IsAfterTimeWindow");

	Params::DeathRespawnTimeWindowFunctionLibrary_IsAfterTimeWindow Parms{};

	Parms.WorldContext = WorldContext;
	Parms.DeathRespawnTimeWindow = std::move(DeathRespawnTimeWindow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.DeathRespawnTimeWindowFunctionLibrary.IsBeforeTimeWindow
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDeathRespawnTimeWindow          DeathRespawnTimeWindow                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDeathRespawnTimeWindowFunctionLibrary::IsBeforeTimeWindow(class UObject* WorldContext, const struct FDeathRespawnTimeWindow& DeathRespawnTimeWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DeathRespawnTimeWindowFunctionLibrary", "IsBeforeTimeWindow");

	Params::DeathRespawnTimeWindowFunctionLibrary_IsBeforeTimeWindow Parms{};

	Parms.WorldContext = WorldContext;
	Parms.DeathRespawnTimeWindow = std::move(DeathRespawnTimeWindow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.DeathRespawnTimeWindowFunctionLibrary.IsInTimeWindow
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContext                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDeathRespawnTimeWindow          DeathRespawnTimeWindow                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UDeathRespawnTimeWindowFunctionLibrary::IsInTimeWindow(class UObject* WorldContext, const struct FDeathRespawnTimeWindow& DeathRespawnTimeWindow)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("DeathRespawnTimeWindowFunctionLibrary", "IsInTimeWindow");

	Params::DeathRespawnTimeWindowFunctionLibrary_IsInTimeWindow Parms{};

	Parms.WorldContext = WorldContext;
	Parms.DeathRespawnTimeWindow = std::move(DeathRespawnTimeWindow);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraFrontendStateComponent.OnUserInitialized
// (Final, Native, Private)
// Parameters:
// class UCommonUserInfo*                  UserInfo                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Error                                                  (Parm, NativeAccessSpecifierPublic)
// ECommonUserPrivilege                    RequestedPrivilege                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommonUserOnlineContext                OnlineContext                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraFrontendStateComponent::OnUserInitialized(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestedPrivilege, ECommonUserOnlineContext OnlineContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraFrontendStateComponent", "OnUserInitialized");

	Params::LyraFrontendStateComponent_OnUserInitialized Parms{};

	Parms.UserInfo = UserInfo;
	Parms.bSuccess = bSuccess;
	Parms.Error = std::move(Error);
	Parms.RequestedPrivilege = RequestedPrivilege;
	Parms.OnlineContext = OnlineContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.DedicatedServerInitializationStep_GameData.OnFinishedUpdatingGameData
// (Final, Native, Private)

void UDedicatedServerInitializationStep_GameData::OnFinishedUpdatingGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DedicatedServerInitializationStep_GameData", "OnFinishedUpdatingGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamInitializationStepComponent.K2_AllTeamsCreated
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)

void UTeamInitializationStepComponent::K2_AllTeamsCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamInitializationStepComponent", "K2_AllTeamsCreated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.TeamInitializationStepComponent.K2_AllTeamsReplicated
// (BlueprintCosmetic, Event, Public, BlueprintEvent)

void UTeamInitializationStepComponent::K2_AllTeamsReplicated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamInitializationStepComponent", "K2_AllTeamsReplicated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.IndicatorLibrary.GetIndicatorManagerComponent
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class AController*                      Controller                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class ULyraIndicatorManagerComponent*   ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraIndicatorManagerComponent* UIndicatorLibrary::GetIndicatorManagerComponent(class AController* Controller)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("IndicatorLibrary", "GetIndicatorManagerComponent");

	Params::IndicatorLibrary_GetIndicatorManagerComponent Parms{};

	Parms.Controller = Controller;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.DistanceScalingWidgetComponent.OnPlayerEnterRadius
// (Final, Native, Protected, BlueprintCallable)

void UDistanceScalingWidgetComponent::OnPlayerEnterRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceScalingWidgetComponent", "OnPlayerEnterRadius");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.DistanceScalingWidgetComponent.OnPlayerExitRadius
// (Final, Native, Protected, BlueprintCallable)

void UDistanceScalingWidgetComponent::OnPlayerExitRadius()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DistanceScalingWidgetComponent", "OnPlayerExitRadius");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.DropBehavior.GetDroppedAmmoCount
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// class UItemInstance*                    Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UDropBehavior::GetDroppedAmmoCount(class UItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("DropBehavior", "GetDroppedAmmoCount");

	Params::DropBehavior_GetDroppedAmmoCount Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerEconomy.OnRep_Money
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FResourceData                    OldMoney                                               (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerEconomy::OnRep_Money(struct FResourceData* OldMoney)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEconomy", "OnRep_Money");

	Params::PlayerEconomy_OnRep_Money Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldMoney != nullptr)
		*OldMoney = std::move(Parms.OldMoney);
}


// Function JP.PlayerEconomy.OnRep_PassiveIncomeAmount
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FResourceData                    OldPassiveIncome                                       (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerEconomy::OnRep_PassiveIncomeAmount(struct FResourceData* OldPassiveIncome)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEconomy", "OnRep_PassiveIncomeAmount");

	Params::PlayerEconomy_OnRep_PassiveIncomeAmount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldPassiveIncome != nullptr)
		*OldPassiveIncome = std::move(Parms.OldPassiveIncome);
}


// Function JP.PlayerEconomy.OnRep_Perfectness
// (Final, Native, Private)

void UPlayerEconomy::OnRep_Perfectness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEconomy", "OnRep_Perfectness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerEconomy.OnRep_Wood
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FResourceData                    OldWood                                                (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UPlayerEconomy::OnRep_Wood(struct FResourceData* OldWood)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEconomy", "OnRep_Wood");

	Params::PlayerEconomy_OnRep_Wood Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OldWood != nullptr)
		*OldWood = std::move(Parms.OldWood);
}


// Function JP.EndTime_Timer.BroadcastTimerEndedGameplayMessage
// (Final, Native, Private)

void UEndTime_Timer::BroadcastTimerEndedGameplayMessage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EndTime_Timer", "BroadcastTimerEndedGameplayMessage");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveDefinition.FindActionByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UObjectiveAction>     ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObjectiveAction*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObjectiveAction* UObjectiveDefinition::FindActionByType(TSubclassOf<class UObjectiveAction> ActionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveDefinition", "FindActionByType");

	Params::ObjectiveDefinition_FindActionByType Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveDefinition.FindActionsByType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UObjectiveAction>     ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObjectiveAction*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UObjectiveAction*> UObjectiveDefinition::FindActionsByType(TSubclassOf<class UObjectiveAction> ActionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveDefinition", "FindActionsByType");

	Params::ObjectiveDefinition_FindActionsByType Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EnvironmentSelectionWidgetBase.SelectEnvironment
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FEnvironmentDefinition           Environment                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEnvironmentSelectionWidgetBase::SelectEnvironment(const struct FEnvironmentDefinition& Environment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EnvironmentSelectionWidgetBase", "SelectEnvironment");

	Params::EnvironmentSelectionWidgetBase_SelectEnvironment Parms{};

	Parms.Environment = std::move(Environment);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamSetterInterface.SetTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITeamSetterInterface::SetTeam(uint8 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamSetterInterface", "SetTeam");

	Params::TeamSetterInterface_SetTeam Parms{};

	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EULAWidget.OnAgreeButtonClicked
// (Final, Native, Public, BlueprintCallable)

void UEULAWidget::OnAgreeButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EULAWidget", "OnAgreeButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.EULAWidget.SetEulaText
// (Event, Public, BlueprintEvent)

void UEULAWidget::SetEulaText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EULAWidget", "SetEulaText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.EULAWidget.SetTitleText
// (Event, Public, BlueprintEvent)

void UEULAWidget::SetTitleText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EULAWidget", "SetTitleText");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.FinancesBundlePurchaseListWidget.BindBundleButtons
// (Final, Native, Protected, BlueprintCallable)

void UFinancesBundlePurchaseListWidget::BindBundleButtons()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesBundlePurchaseListWidget", "BindBundleButtons");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.FinancesBundlePurchaseListWidget.OnBundleClicked
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           PlatformID                                             (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFinancesBundlePurchaseListWidget::OnBundleClicked(const class FString& PlatformID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesBundlePurchaseListWidget", "OnBundleClicked");

	Params::FinancesBundlePurchaseListWidget_OnBundleClicked Parms{};

	Parms.PlatformID = std::move(PlatformID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.FinancesBundlePurchaseListWidget.SetStoreOffers
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FPlatformStoreOffer>      PlatformStoreOffers                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UFinancesBundlePurchaseListWidget::SetStoreOffers(const TArray<struct FPlatformStoreOffer>& PlatformStoreOffers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesBundlePurchaseListWidget", "SetStoreOffers");

	Params::FinancesBundlePurchaseListWidget_SetStoreOffers Parms{};

	Parms.PlatformStoreOffers = std::move(PlatformStoreOffers);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.FinancesWidget.ChangeThrobberMessage
// (Event, Protected, BlueprintEvent)
// Parameters:
// EPlatformStoreState                     StoreState                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFinancesWidget::ChangeThrobberMessage(const EPlatformStoreState StoreState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesWidget", "ChangeThrobberMessage");

	Params::FinancesWidget_ChangeThrobberMessage Parms{};

	Parms.StoreState = StoreState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.FinancesWidget.DismissThrobber
// (Event, Protected, BlueprintEvent)

void UFinancesWidget::DismissThrobber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesWidget", "DismissThrobber");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.FinancesWidget.LoadData
// (Final, Native, Public, BlueprintCallable)

void UFinancesWidget::LoadData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesWidget", "LoadData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.FinancesWidget.ShowPurchaseErrorModal
// (Event, Protected, BlueprintEvent)
// Parameters:
// EPlatformStoreState                     StoreState                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TransactionId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFinancesWidget::ShowPurchaseErrorModal(const EPlatformStoreState StoreState, const class FString& TransactionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesWidget", "ShowPurchaseErrorModal");

	Params::FinancesWidget_ShowPurchaseErrorModal Parms{};

	Parms.StoreState = StoreState;
	Parms.TransactionId = std::move(TransactionId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.FinancesWidget.ShowPurchaseSuccessModal
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// bool                                    bWalletUpdateSucceeded                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlatformStoreOffer              StoreOffer                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FString                           TransactionId                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UFinancesWidget::ShowPurchaseSuccessModal(const bool bWalletUpdateSucceeded, const struct FPlatformStoreOffer& StoreOffer, const class FString& TransactionId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesWidget", "ShowPurchaseSuccessModal");

	Params::FinancesWidget_ShowPurchaseSuccessModal Parms{};

	Parms.bWalletUpdateSucceeded = bWalletUpdateSucceeded;
	Parms.StoreOffer = std::move(StoreOffer);
	Parms.TransactionId = std::move(TransactionId);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.FinancesWidget.ShowThrobber
// (Event, Protected, BlueprintEvent)

void UFinancesWidget::ShowThrobber()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("FinancesWidget", "ShowThrobber");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.TraceFromPosition.GetTraceFromPosition
// (Native, Event, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void ITraceFromPosition::GetTraceFromPosition(struct FVector* Location, struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TraceFromPosition", "GetTraceFromPosition");

	Params::TraceFromPosition_GetTraceFromPosition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function JP.GameDataGameInstanceSubsystem.ForceFullUpdateGameData
// (Final, Native, Public, BlueprintCallable)

void UGameDataGameInstanceSubsystem::ForceFullUpdateGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGameInstanceSubsystem", "ForceFullUpdateGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameDataGameInstanceSubsystem.ForceUpdateGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            KeysToUpdate                                           (Parm, NativeAccessSpecifierPublic)

void UGameDataGameInstanceSubsystem::ForceUpdateGameData(const struct FGameplayTagContainer& KeysToUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGameInstanceSubsystem", "ForceUpdateGameData");

	Params::GameDataGameInstanceSubsystem_ForceUpdateGameData Parms{};

	Parms.KeysToUpdate = std::move(KeysToUpdate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameDataGameInstanceSubsystem.SoftFullUpdateGameData
// (Final, Native, Public, BlueprintCallable)

void UGameDataGameInstanceSubsystem::SoftFullUpdateGameData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGameInstanceSubsystem", "SoftFullUpdateGameData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameDataGameInstanceSubsystem.SoftUpdateGameData
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTagContainer            KeysToUpdate                                           (Parm, NativeAccessSpecifierPublic)

void UGameDataGameInstanceSubsystem::SoftUpdateGameData(const struct FGameplayTagContainer& KeysToUpdate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameDataGameInstanceSubsystem", "SoftUpdateGameData");

	Params::GameDataGameInstanceSubsystem_SoftUpdateGameData Parms{};

	Parms.KeysToUpdate = std::move(KeysToUpdate);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameInstanceJP.AcceptToAbandonMatch
// (Final, Native, Public, BlueprintCallable)

void UGameInstanceJP::AcceptToAbandonMatch()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "AcceptToAbandonMatch");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameInstanceJP.CacheNetworkError
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// ENetworkFailure                         FailureType                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstanceJP::CacheNetworkError(ENetworkFailure FailureType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "CacheNetworkError");

	Params::GameInstanceJP_CacheNetworkError Parms{};

	Parms.FailureType = FailureType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameInstanceJP.DisplayOkDialog
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             Header                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Body                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGameInstanceJP::DisplayOkDialog(const class FText& Header, const class FText& Body)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "DisplayOkDialog");

	Params::GameInstanceJP_DisplayOkDialog Parms{};

	Parms.Header = std::move(Header);
	Parms.Body = std::move(Body);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.GameInstanceJP.K2_ReconnectToGameSession
// (Event, Public, BlueprintEvent)
// Parameters:
// class UAuthenticationInitialization_RecoverMatch*RecoverMatch                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameInstanceJP::K2_ReconnectToGameSession(class UAuthenticationInitialization_RecoverMatch* RecoverMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "K2_ReconnectToGameSession");

	Params::GameInstanceJP_K2_ReconnectToGameSession Parms{};

	Parms.RecoverMatch = RecoverMatch;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.GameInstanceJP.OnHandleNetworkError
// (Final, Native, Public, BlueprintCallable)

void UGameInstanceJP::OnHandleNetworkError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "OnHandleNetworkError");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction JP.GameInstanceJP.OnReconnectAccept__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UGameInstanceJP::OnReconnectAccept__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "OnReconnectAccept__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.GameInstanceJP.ReconnectToGameSession
// (Final, Native, Public, BlueprintCallable)

void UGameInstanceJP::ReconnectToGameSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "ReconnectToGameSession");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameInstanceJP.ReturnToMainMenuAsHostOrClient
// (Final, Native, Public, BlueprintCallable)

void UGameInstanceJP::ReturnToMainMenuAsHostOrClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "ReturnToMainMenuAsHostOrClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameInstanceJP.ReturnToMainMenuClient
// (Final, Native, Public, BlueprintCallable)

void UGameInstanceJP::ReturnToMainMenuClient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "ReturnToMainMenuClient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameInstanceJP.GetOkDialogDescriptor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             Header                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             Body                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class UCommonGameDialogDescriptor*      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonGameDialogDescriptor* UGameInstanceJP::GetOkDialogDescriptor(const class FText& Header, const class FText& Body) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameInstanceJP", "GetOkDialogDescriptor");

	Params::GameInstanceJP_GetOkDialogDescriptor Parms{};

	Parms.Header = std::move(Header);
	Parms.Body = std::move(Body);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveTrackingManager.ChangeTrackedObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveTrackingManager::ChangeTrackedObjective(class APlayerStateJP* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveTrackingManager", "ChangeTrackedObjective");

	Params::ObjectiveTrackingManager_ChangeTrackedObjective Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveTrackingManager.IsTrackingObjective
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObjectiveDefinition*             ObjectiveDefinition                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectiveTrackingManager::IsTrackingObjective(class APlayerStateJP* PlayerState, class UObjectiveDefinition* ObjectiveDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveTrackingManager", "IsTrackingObjective");

	Params::ObjectiveTrackingManager_IsTrackingObjective Parms{};

	Parms.PlayerState = PlayerState;
	Parms.ObjectiveDefinition = ObjectiveDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction JP.ObjectiveTrackingManager.ObjectiveTrackingDelegate__DelegateSignature
// (BlueprintAuthorityOnly, MulticastDelegate, Public, Delegate, HasOutParams)
// Parameters:
// TArray<struct FObjectiveTracker>        ObjectiveTrackers_0                                    (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UObjectiveTrackingManager::ObjectiveTrackingDelegate__DelegateSignature(const TArray<struct FObjectiveTracker>& ObjectiveTrackers_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveTrackingManager", "ObjectiveTrackingDelegate__DelegateSignature");

	Params::ObjectiveTrackingManager_ObjectiveTrackingDelegate__DelegateSignature Parms{};

	Parms.ObjectiveTrackers_0 = std::move(ObjectiveTrackers_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectiveTrackingManager.OnRep_ObjectiveTrackers
// (Final, Native, Private)

void UObjectiveTrackingManager::OnRep_ObjectiveTrackers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveTrackingManager", "OnRep_ObjectiveTrackers");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveTrackingManager.RemoveTrackersForObjective
// (Final, Native, Public)
// Parameters:
// struct FObjectiveAndOwningPlayer        ObjectiveDefinition                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UObjectiveTrackingManager::RemoveTrackersForObjective(const struct FObjectiveAndOwningPlayer& ObjectiveDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveTrackingManager", "RemoveTrackersForObjective");

	Params::ObjectiveTrackingManager_RemoveTrackersForObjective Parms{};

	Parms.ObjectiveDefinition = std::move(ObjectiveDefinition);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_MainMenu.OnExperienceLoaded
// (Final, Native, Protected)
// Parameters:
// class UExperienceDefinition*            Definition                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_MainMenu::OnExperienceLoaded(const class UExperienceDefinition* Definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_MainMenu", "OnExperienceLoaded");

	Params::GameModeJP_MainMenu_OnExperienceLoaded Parms{};

	Parms.Definition = Definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameModeJP_MainMenu.ShowUserWasBannedDialog
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UCommonGameDialogDescriptor*      Descriptor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_MainMenu::ShowUserWasBannedDialog(class UCommonGameDialogDescriptor* Descriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_MainMenu", "ShowUserWasBannedDialog");

	Params::GameModeJP_MainMenu_ShowUserWasBannedDialog Parms{};

	Parms.Descriptor = Descriptor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.GameModeJP_Tutorial.K2_ExperienceLoaded
// (Event, Protected, BlueprintEvent)

void AGameModeJP_Tutorial::K2_ExperienceLoaded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Tutorial", "K2_ExperienceLoaded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.GameModeJP_Tutorial.OnExperienceLoaded
// (Final, Native, Protected)
// Parameters:
// class UExperienceDefinition*            Definition                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameModeJP_Tutorial::OnExperienceLoaded(const class UExperienceDefinition* Definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameModeJP_Tutorial", "OnExperienceLoaded");

	Params::GameModeJP_Tutorial_OnExperienceLoaded Parms{};

	Parms.Definition = Definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameplayAbilityJP.OnInputReleased
// (Final, Native, Private)
// Parameters:
// float                                   TimeHeld                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGameplayAbilityJP::OnInputReleased(float TimeHeld)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbilityJP", "OnInputReleased");

	Params::GameplayAbilityJP_OnInputReleased Parms{};

	Parms.TimeHeld = TimeHeld;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameplayAbility_NeighborSpecialAbilityBase.GetDefinitionFromSourceObject
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UNeighborSpecialAbilityDefinition>DefinitionType                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNeighborSpecialAbilityDefinition*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNeighborSpecialAbilityDefinition* UGameplayAbility_NeighborSpecialAbilityBase::GetDefinitionFromSourceObject(TSubclassOf<class UNeighborSpecialAbilityDefinition> DefinitionType) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameplayAbility_NeighborSpecialAbilityBase", "GetDefinitionFromSourceObject");

	Params::GameplayAbility_NeighborSpecialAbilityBase_GetDefinitionFromSourceObject Parms{};

	Parms.DefinitionType = DefinitionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP.SendTeamMessage
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InMessage                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameStateJP::SendTeamMessage(uint8 TeamId, const class FName InMessage, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GameStateJP", "SendTeamMessage");

	Params::GameStateJP_SendTeamMessage Parms{};

	Parms.TeamId = TeamId;
	Parms.InMessage = InMessage;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.DisplayMessageToLocalPlayer
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FName                             Message                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameStateJP::DisplayMessageToLocalPlayer(class FName Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "DisplayMessageToLocalPlayer");

	Params::GameStateJP_DisplayMessageToLocalPlayer Parms{};

	Parms.Message = Message;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.GameStateJP.DoSendTeamMessage
// (Final, Net, Native, Event, NetMulticast, Private)
// Parameters:
// uint8                                   InTeamID                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FName                             InMessage                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameStateJP::DoSendTeamMessage(const uint8 InTeamID, const class FName InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "DoSendTeamMessage");

	Params::GameStateJP_DoSendTeamMessage Parms{};

	Parms.InTeamID = InTeamID;
	Parms.InMessage = InMessage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.GameEnded
// (Event, Protected, BlueprintEvent)

void AGameStateJP::GameEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "GameEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.GameStateJP.GetAliveTeams
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> AGameStateJP::GetAliveTeams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "GetAliveTeams");

	Params::GameStateJP_GetAliveTeams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP.GetEliminatedTeams
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> AGameStateJP::GetEliminatedTeams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "GetEliminatedTeams");

	Params::GameStateJP_GetEliminatedTeams Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTeam                      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTeam AGameStateJP::GetTeam(uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "GetTeam");

	Params::GameStateJP_GetTeam Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP.GetWinningTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 AGameStateJP::GetWinningTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "GetWinningTeam");

	Params::GameStateJP_GetWinningTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP.HandleOwnedHousesChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             NewOwnedHouses                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void AGameStateJP::HandleOwnedHousesChanged(class APlayerStateJP* PlayerState, const TArray<struct FGameplayTag>& NewOwnedHouses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "HandleOwnedHousesChanged");

	Params::GameStateJP_HandleOwnedHousesChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NewOwnedHouses = std::move(NewOwnedHouses);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.HandlePlayerStateAdded
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameStateJP::HandlePlayerStateAdded(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "HandlePlayerStateAdded");

	Params::GameStateJP_HandlePlayerStateAdded Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.HandlePlayerStateRemoved
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameStateJP::HandlePlayerStateRemoved(class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "HandlePlayerStateRemoved");

	Params::GameStateJP_HandlePlayerStateRemoved Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.OnRep_MatchConfiguration
// (Final, Native, Private)

void AGameStateJP::OnRep_MatchConfiguration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "OnRep_MatchConfiguration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.OnRep_ServerDebugInformation
// (Final, Native, Private)

void AGameStateJP::OnRep_ServerDebugInformation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "OnRep_ServerDebugInformation");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.OnRep_Teams
// (Final, Native, Private)

void AGameStateJP::OnRep_Teams()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "OnRep_Teams");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.QueryBroadcastTeamChange
// (Final, Native, Private)

void AGameStateJP::QueryBroadcastTeamChange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "QueryBroadcastTeamChange");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP.SendMessageToPlayerController
// (Final, Native, Private, HasOutParams)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EMessageType                            Type                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerControllerJP*              PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameStateJP::SendMessageToPlayerController(const class FString& Message, const EMessageType& Type, class APlayerControllerJP* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP", "SendMessageToPlayerController");

	Params::GameStateJP_SendMessageToPlayerController Parms{};

	Parms.Message = std::move(Message);
	Parms.Type = Type;
	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP_Lobby.HandleBackfillError
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCommonGameDialogDescriptor*      Descriptor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameStateJP_Lobby::HandleBackfillError(class UCommonGameDialogDescriptor* Descriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Lobby", "HandleBackfillError");

	Params::GameStateJP_Lobby_HandleBackfillError Parms{};

	Parms.Descriptor = Descriptor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.GameStateJP_Lobby.GetLobbyPlayerStatesArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class APlayerStateJP_Lobby*>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerStateJP_Lobby*> AGameStateJP_Lobby::GetLobbyPlayerStatesArray() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Lobby", "GetLobbyPlayerStatesArray");

	Params::GameStateJP_Lobby_GetLobbyPlayerStatesArray Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP_Lobby.GetLobbyPlayerStatesArrayGroupedByTeamId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IncludeInvalidTeamID                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<uint8, struct FLobbyPlayerStateGroup>ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<uint8, struct FLobbyPlayerStateGroup> AGameStateJP_Lobby::GetLobbyPlayerStatesArrayGroupedByTeamId(const bool IncludeInvalidTeamID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Lobby", "GetLobbyPlayerStatesArrayGroupedByTeamId");

	Params::GameStateJP_Lobby_GetLobbyPlayerStatesArrayGroupedByTeamId Parms{};

	Parms.IncludeInvalidTeamID = IncludeInvalidTeamID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP_Lobby.GetLobbyPlayerStatesArrayGroupedByTeamIdAsArray
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    IncludeInvalidTeamID                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FLobbyPlayerStateGroup>   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FLobbyPlayerStateGroup> AGameStateJP_Lobby::GetLobbyPlayerStatesArrayGroupedByTeamIdAsArray(const bool IncludeInvalidTeamID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Lobby", "GetLobbyPlayerStatesArrayGroupedByTeamIdAsArray");

	Params::GameStateJP_Lobby_GetLobbyPlayerStatesArrayGroupedByTeamIdAsArray Parms{};

	Parms.IncludeInvalidTeamID = IncludeInvalidTeamID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP_Lobby.GetLobbyPlayerStatesByTeamId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   TeamId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLobbyPlayerStateGroup           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FLobbyPlayerStateGroup AGameStateJP_Lobby::GetLobbyPlayerStatesByTeamId(const uint8 TeamId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Lobby", "GetLobbyPlayerStatesByTeamId");

	Params::GameStateJP_Lobby_GetLobbyPlayerStatesByTeamId Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP_Lobby.ReturnToMainMenu
// (Final, Native, Public, BlueprintCallable, Const)

void AGameStateJP_Lobby::ReturnToMainMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Lobby", "ReturnToMainMenu");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP_Match.FinalEndConditionSet
// (Event, Protected, BlueprintEvent)
// Parameters:
// class AEndCondition*                    EndCondition                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AGameStateJP_Match::FinalEndConditionSet(class AEndCondition* EndCondition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Match", "FinalEndConditionSet");

	Params::GameStateJP_Match_FinalEndConditionSet Parms{};

	Parms.EndCondition = EndCondition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.GameStateJP_Match.OnMatchEnded
// (Event, Protected, BlueprintEvent)

void AGameStateJP_Match::OnMatchEnded()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Match", "OnMatchEnded");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.GameStateJP_Match.OnRep_FinalEndCondition
// (Final, Native, Protected)

void AGameStateJP_Match::OnRep_FinalEndCondition()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Match", "OnRep_FinalEndCondition");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GameStateJP_Match.AreAllRoomManagersFound
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameStateJP_Match::AreAllRoomManagersFound() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Match", "AreAllRoomManagersFound");

	Params::GameStateJP_Match_AreAllRoomManagersFound Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP_Match.GetFinalEndCondition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AEndCondition*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AEndCondition* AGameStateJP_Match::GetFinalEndCondition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Match", "GetFinalEndCondition");

	Params::GameStateJP_Match_GetFinalEndCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP_Match.GetFoundRoomManagers
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const TArray<class ARoomManager*>       ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<class ARoomManager*> AGameStateJP_Match::GetFoundRoomManagers() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Match", "GetFoundRoomManagers");

	Params::GameStateJP_Match_GetFoundRoomManagers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP_Match.GetMatchPlayerStatesByTeamId
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   TeamId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FMatchPlayerStateGroup           ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FMatchPlayerStateGroup AGameStateJP_Match::GetMatchPlayerStatesByTeamId(const uint8 TeamId) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Match", "GetMatchPlayerStatesByTeamId");

	Params::GameStateJP_Match_GetMatchPlayerStatesByTeamId Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GameStateJP_Match.HasFinalEndCondition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AGameStateJP_Match::HasFinalEndCondition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GameStateJP_Match", "HasFinalEndCondition");

	Params::GameStateJP_Match_HasFinalEndCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GA_ContinuousTrace.PerformTrace
// (Final, Native, Private)
// Parameters:
// int32                                   ActionNumber                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGA_ContinuousTrace::PerformTrace(int32 ActionNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GA_ContinuousTrace", "PerformTrace");

	Params::GA_ContinuousTrace_PerformTrace Parms{};

	Parms.ActionNumber = ActionNumber;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialBlockedPlayersListWidget.BlueprintOnUnblockPlayerFailed
// (Event, Protected, BlueprintEvent)

void USocialBlockedPlayersListWidget::BlueprintOnUnblockPlayerFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialBlockedPlayersListWidget", "BlueprintOnUnblockPlayerFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.SocialBlockedPlayersListWidget.UpdateBlockedPlayersList
// (Final, Native, Private)

void USocialBlockedPlayersListWidget::UpdateBlockedPlayersList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialBlockedPlayersListWidget", "UpdateBlockedPlayersList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PerkSelectPopupWidgetBase.DismissPopup
// (Final, Native, Public, BlueprintCallable)

void UPerkSelectPopupWidgetBase::DismissPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkSelectPopupWidgetBase", "DismissPopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PerkSelectPopupWidgetBase.SelectEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPerkSelectEntry*                 EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkSelectPopupWidgetBase::SelectEntry(class UPerkSelectEntry* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkSelectPopupWidgetBase", "SelectEntry");

	Params::PerkSelectPopupWidgetBase_SelectEntry Parms{};

	Parms.EntryWidget = EntryWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GeneralPerkSelectPopupWidget.BlueprintHandleEntryWidgetCreated
// (Event, Public, BlueprintEvent)
// Parameters:
// class UPerkSelectEntry*                 EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGeneralPerkSelectPopupWidget::BlueprintHandleEntryWidgetCreated(class UPerkSelectEntry* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GeneralPerkSelectPopupWidget", "BlueprintHandleEntryWidgetCreated");

	Params::GeneralPerkSelectPopupWidget_BlueprintHandleEntryWidgetCreated Parms{};

	Parms.EntryWidget = EntryWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.GetServerDebugInformationAsyncAction.GetServerDebugInformation
// (Final, Native, Static, Private, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGetServerDebugInformationAsyncAction*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UGetServerDebugInformationAsyncAction* UGetServerDebugInformationAsyncAction::GetServerDebugInformation(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("GetServerDebugInformationAsyncAction", "GetServerDebugInformation");

	Params::GetServerDebugInformationAsyncAction_GetServerDebugInformation Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GetServerDebugInformationAsyncAction.OnServerDebugInformationReady
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FServerDebugInformation          Information                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UGetServerDebugInformationAsyncAction::OnServerDebugInformationReady(const struct FServerDebugInformation& Information)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GetServerDebugInformationAsyncAction", "OnServerDebugInformationReady");

	Params::GetServerDebugInformationAsyncAction_OnServerDebugInformationReady Parms{};

	Parms.Information = std::move(Information);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialFriendsListWidget.OnPartyChanged
// (Final, Native, Private)

void USocialFriendsListWidget::OnPartyChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialFriendsListWidget", "OnPartyChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialFriendsListWidget.UpdateFriendsList
// (Final, Native, Private)

void USocialFriendsListWidget::UpdateFriendsList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialFriendsListWidget", "UpdateFriendsList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GroundsKeeper.OnRep_TeamID
// (Final, Native, Private)

void AGroundsKeeper::OnRep_TeamID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundsKeeper", "OnRep_TeamID");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GroundsKeeper.SubscribeToTeamEvents
// (Final, Native, Public)

void AGroundsKeeper::SubscribeToTeamEvents()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundsKeeper", "SubscribeToTeamEvents");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GroundsKeeper.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTeam                            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTeam AGroundsKeeper::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundsKeeper", "GetTeam");

	Params::GroundsKeeper_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GroundsKeeper.GetTeamID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 AGroundsKeeper::GetTeamID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundsKeeper", "GetTeamID");

	Params::GroundsKeeper_GetTeamID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GroundskeeperReference.ClearGroundsKeeperOwner
// (Final, Native, Public, BlueprintCallable)

void UGroundskeeperReference::ClearGroundsKeeperOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundskeeperReference", "ClearGroundsKeeperOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GroundskeeperReference.RecalculateGroundsKeeperOwner
// (Final, Native, Public, BlueprintCallable)

void UGroundskeeperReference::RecalculateGroundsKeeperOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundskeeperReference", "RecalculateGroundsKeeperOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.GroundskeeperReference.SetGroundskeeperOverride
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AGroundsKeeper*                   NewGroundskeeper                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UGroundskeeperReference::SetGroundskeeperOverride(class AGroundsKeeper* NewGroundskeeper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundskeeperReference", "SetGroundskeeperOverride");

	Params::GroundskeeperReference_SetGroundskeeperOverride Parms{};

	Parms.NewGroundskeeper = NewGroundskeeper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GroundskeeperReference.GetGroundsKeeper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGroundsKeeper*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGroundsKeeper* UGroundskeeperReference::GetGroundsKeeper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundskeeperReference", "GetGroundsKeeper");

	Params::GroundskeeperReference_GetGroundsKeeper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GroundskeeperReference.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTeam                      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTeam UGroundskeeperReference::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundskeeperReference", "GetTeam");

	Params::GroundskeeperReference_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GroundskeeperReference.HasReference
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UGroundskeeperReference::HasReference() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GroundskeeperReference", "HasReference");

	Params::GroundskeeperReference_HasReference Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GSInteractable.CancelInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGSInteractable::CancelInteraction(class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "CancelInteraction");

	Params::GSInteractable_CancelInteraction Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GSInteractable.InteractableCancelInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGSInteractable::InteractableCancelInteraction(class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "InteractableCancelInteraction");

	Params::GSInteractable_InteractableCancelInteraction Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GSInteractable.PostInteract
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGSInteractable::PostInteract(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "PostInteract");

	Params::GSInteractable_PostInteract Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GSInteractable.PreInteract
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGSInteractable::PreInteract(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "PreInteract");

	Params::GSInteractable_PreInteract Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GSInteractable.RegisterInteracter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGSInteractable::RegisterInteracter(class UPrimitiveComponent* InteractionComponent, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "RegisterInteracter");

	Params::GSInteractable_RegisterInteracter Parms{};

	Parms.InteractionComponent = InteractionComponent;
	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GSInteractable.UnregisterInteracter
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGSInteractable::UnregisterInteracter(class UPrimitiveComponent* InteractionComponent, class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "UnregisterInteracter");

	Params::GSInteractable_UnregisterInteracter Parms{};

	Parms.InteractionComponent = InteractionComponent;
	Parms.InteractingActor = InteractingActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.GSInteractable.GetInteractionDuration
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float IGSInteractable::GetInteractionDuration(class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "GetInteractionDuration");

	Params::GSInteractable_GetInteractionDuration Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GSInteractable.GetPostInteractSyncType
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bShouldSync                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAbilityTaskNetSyncType                 Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGSInteractable::GetPostInteractSyncType(bool* bShouldSync, EAbilityTaskNetSyncType* Type, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "GetPostInteractSyncType");

	Params::GSInteractable_GetPostInteractSyncType Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bShouldSync != nullptr)
		*bShouldSync = Parms.bShouldSync;

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function JP.GSInteractable.GetPreInteractSyncType
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    bShouldSync                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EAbilityTaskNetSyncType                 Type                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IGSInteractable::GetPreInteractSyncType(bool* bShouldSync, EAbilityTaskNetSyncType* Type, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "GetPreInteractSyncType");

	Params::GSInteractable_GetPreInteractSyncType Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bShouldSync != nullptr)
		*bShouldSync = Parms.bShouldSync;

	if (Type != nullptr)
		*Type = Parms.Type;
}


// Function JP.GSInteractable.IsAvailableForEnemyTeam
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IGSInteractable::IsAvailableForEnemyTeam(class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "IsAvailableForEnemyTeam");

	Params::GSInteractable_IsAvailableForEnemyTeam Parms{};

	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.GSInteractable.IsAvailableForInteraction
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class AActor*                           InteractingActor                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimitiveComponent*              InteractionComponent                                   (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IGSInteractable::IsAvailableForInteraction(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("GSInteractable", "IsAvailableForInteraction");

	Params::GSInteractable_IsAvailableForInteraction Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.InteractionComponent = InteractionComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.HealthAttributeSetListener.OnDamaged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Delta                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Causer                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FCombatParticipant               CombatParticipant                                      (ConstParm, Parm, NativeAccessSpecifierPublic)
// struct FKillMethod                      KillMethod                                             (ConstParm, Parm, NativeAccessSpecifierPublic)
// struct FVector_NetQuantize              Location                                               (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHealthAttributeSetListener::OnDamaged(float Delta, class AActor* Causer, const struct FCombatParticipant& CombatParticipant, const struct FKillMethod& KillMethod, const struct FVector_NetQuantize& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthAttributeSetListener", "OnDamaged");

	Params::HealthAttributeSetListener_OnDamaged Parms{};

	Parms.Delta = Delta;
	Parms.Causer = Causer;
	Parms.CombatParticipant = std::move(CombatParticipant);
	Parms.KillMethod = std::move(KillMethod);
	Parms.Location = std::move(Location);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HealthAttributeSetListener.OnHealthChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxHealth                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IHealthAttributeSetListener::OnHealthChanged(float Health, float MaxHealth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthAttributeSetListener", "OnHealthChanged");

	Params::HealthAttributeSetListener_OnHealthChanged Parms{};

	Parms.Health = Health;
	Parms.MaxHealth = MaxHealth;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HealthAttributeSet.OnRep_Health
// (Final, Native, Private)

void UHealthAttributeSet::OnRep_Health()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthAttributeSet", "OnRep_Health");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.HealthAttributeSet.OnRep_MaxHealth
// (Final, Native, Private)

void UHealthAttributeSet::OnRep_MaxHealth()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthAttributeSet", "OnRep_MaxHealth");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.HealthComponent.HealDamage
// (Native, Protected, BlueprintCallable)
// Parameters:
// float                                   FHealAmount                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::HealDamage(float FHealAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "HealDamage");

	Params::HealthComponent_HealDamage Parms{};

	Parms.FHealAmount = FHealAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HealthComponent.IsDead
// (Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHealthComponent::IsDead()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "IsDead");

	Params::HealthComponent_IsDead Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.HealthComponent.TakeDamage
// (Native, Protected, BlueprintCallable)
// Parameters:
// float                                   FDamageAmount                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHealthComponent::TakeDamage(float FDamageAmount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HealthComponent", "TakeDamage");

	Params::HealthComponent_TakeDamage Parms{};

	Parms.FDamageAmount = FDamageAmount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HitResultFunctionLibrary.GetClosestHitResultByDistance
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FHitResult>               HitResults                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UHitResultFunctionLibrary::GetClosestHitResultByDistance(const TArray<struct FHitResult>& HitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HitResultFunctionLibrary", "GetClosestHitResultByDistance");

	Params::HitResultFunctionLibrary_GetClosestHitResultByDistance Parms{};

	Parms.HitResults = std::move(HitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.HitResultFunctionLibrary.GetFurthestHitResultByDistance
// (Final, Native, Static, Private, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FHitResult>               HitResults                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// struct FHitResult                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

struct FHitResult UHitResultFunctionLibrary::GetFurthestHitResultByDistance(const TArray<struct FHitResult>& HitResults)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HitResultFunctionLibrary", "GetFurthestHitResultByDistance");

	Params::HitResultFunctionLibrary_GetFurthestHitResultByDistance Parms{};

	Parms.HitResults = std::move(HitResults);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraPerformanceStatSubsystem.GetCachedStat
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELyraDisplayablePerformanceStat         Stat                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraPerformanceStatSubsystem::GetCachedStat(ELyraDisplayablePerformanceStat Stat) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPerformanceStatSubsystem", "GetCachedStat");

	Params::LyraPerformanceStatSubsystem_GetCachedStat Parms{};

	Parms.Stat = Stat;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.HotjoinMatchComponent.OnEssentialDestroyed
// (Final, Native, Public)

void UHotjoinMatchComponent::OnEssentialDestroyed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HotjoinMatchComponent", "OnEssentialDestroyed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.HotjoinMatchComponent.OnTimerElapsed
// (Final, Native, Public)

void UHotjoinMatchComponent::OnTimerElapsed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HotjoinMatchComponent", "OnTimerElapsed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseDefinition.TryGetHouseDefinition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     HouseID                                                (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UHouseDefinition>  OutSoftHouseDefinition                                 (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UHouseDefinition::TryGetHouseDefinition(const struct FGameplayTag& HouseID, TSoftObjectPtr<class UHouseDefinition>* OutSoftHouseDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("HouseDefinition", "TryGetHouseDefinition");

	Params::HouseDefinition_TryGetHouseDefinition Parms{};

	Parms.HouseID = std::move(HouseID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftHouseDefinition != nullptr)
		*OutSoftHouseDefinition = Parms.OutSoftHouseDefinition;

	return Parms.ReturnValue;
}


// Function JP.HouseVotePopupEntryWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FHouseVotePopupEntryViewModel    ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UHouseVotePopupEntryWidget::ApplyViewModel(const struct FHouseVotePopupEntryViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupEntryWidget", "ApplyViewModel");

	Params::HouseVotePopupEntryWidget_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.HouseVotePopupEntryWidget.Clicked
// (Final, Native, Public, BlueprintCallable)

void UHouseVotePopupEntryWidget::Clicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupEntryWidget", "Clicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseVotePopupEntryWidget.SetNoVote
// (Event, Public, BlueprintEvent)

void UHouseVotePopupEntryWidget::SetNoVote()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupEntryWidget", "SetNoVote");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.TeamVolume.GetGroundsKeeper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGroundsKeeper*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGroundsKeeper* ATeamVolume::GetGroundsKeeper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamVolume", "GetGroundsKeeper");

	Params::TeamVolume_GetGroundsKeeper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamVolume.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FTeam                      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTeam ATeamVolume::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamVolume", "GetTeam");

	Params::TeamVolume_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.HouseVotePopupWidget.DismissPopup
// (Final, Native, Public, BlueprintCallable)

void UHouseVotePopupWidget::DismissPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "DismissPopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseVotePopupWidget.HandleEntryWidgetCreated
// (Event, Public, BlueprintEvent)
// Parameters:
// class UHouseVotePopupEntryWidget*       EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHouseVotePopupWidget::HandleEntryWidgetCreated(class UHouseVotePopupEntryWidget* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "HandleEntryWidgetCreated");

	Params::HouseVotePopupWidget_HandleEntryWidgetCreated Parms{};

	Parms.EntryWidget = EntryWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.HouseVotePopupWidget.HandlePlayerStateHouseIdentifierVoteChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OldHouseIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NewHouseIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHouseVotePopupWidget::HandlePlayerStateHouseIdentifierVoteChanged(class APlayerStateJP_Lobby* PlayerState, const struct FGameplayTag& OldHouseIdentifier, const struct FGameplayTag& NewHouseIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "HandlePlayerStateHouseIdentifierVoteChanged");

	Params::HouseVotePopupWidget_HandlePlayerStateHouseIdentifierVoteChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.OldHouseIdentifier = std::move(OldHouseIdentifier);
	Parms.NewHouseIdentifier = std::move(NewHouseIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseVotePopupWidget.HandlePlayerStateOwnedHousesChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             NewOwnedHouses                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UHouseVotePopupWidget::HandlePlayerStateOwnedHousesChanged(class APlayerStateJP_Lobby* PlayerState, const TArray<struct FGameplayTag>& NewOwnedHouses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "HandlePlayerStateOwnedHousesChanged");

	Params::HouseVotePopupWidget_HandlePlayerStateOwnedHousesChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NewOwnedHouses = std::move(NewOwnedHouses);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseVotePopupWidget.HandlePlayerStateTeamHousePoolChanged
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHouseVotePopupWidget::HandlePlayerStateTeamHousePoolChanged(class APlayerStateJP_Lobby* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "HandlePlayerStateTeamHousePoolChanged");

	Params::HouseVotePopupWidget_HandlePlayerStateTeamHousePoolChanged Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseVotePopupWidget.HandlePlayerStateTeamIdChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OldTeamID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewTeamID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHouseVotePopupWidget::HandlePlayerStateTeamIdChanged(class APlayerStateJP_Lobby* PlayerState, const uint8& OldTeamID, const uint8& NewTeamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "HandlePlayerStateTeamIdChanged");

	Params::HouseVotePopupWidget_HandlePlayerStateTeamIdChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.OldTeamID = OldTeamID;
	Parms.NewTeamID = NewTeamID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseVotePopupWidget.HandlePlayerStateTracked
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     TrackedPlayerState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Initial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHouseVotePopupWidget::HandlePlayerStateTracked(class APlayerState* TrackedPlayerState, bool Initial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "HandlePlayerStateTracked");

	Params::HouseVotePopupWidget_HandlePlayerStateTracked Parms{};

	Parms.TrackedPlayerState = TrackedPlayerState;
	Parms.Initial = Initial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseVotePopupWidget.HandlePlayerStateUntracked
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     UntrackedPlayerState                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHouseVotePopupWidget::HandlePlayerStateUntracked(class APlayerState* UntrackedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "HandlePlayerStateUntracked");

	Params::HouseVotePopupWidget_HandlePlayerStateUntracked Parms{};

	Parms.UntrackedPlayerState = UntrackedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.HouseVotePopupWidget.SelectEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UHouseVotePopupEntryWidget*       EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UHouseVotePopupWidget::SelectEntry(class UHouseVotePopupEntryWidget* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("HouseVotePopupWidget", "SelectEntry");

	Params::HouseVotePopupWidget_SelectEntry Parms{};

	Parms.EntryWidget = EntryWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorWidgetInterface.BindIndicator
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UIndicatorDescriptor*             Indicator                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIndicatorWidgetInterface::BindIndicator(class UIndicatorDescriptor* Indicator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorWidgetInterface", "BindIndicator");

	Params::IndicatorWidgetInterface_BindIndicator Parms{};

	Parms.Indicator = Indicator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorWidgetInterface.UnbindIndicator
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UIndicatorDescriptor*             Indicator                                              (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IIndicatorWidgetInterface::UnbindIndicator(const class UIndicatorDescriptor* Indicator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorWidgetInterface", "UnbindIndicator");

	Params::IndicatorWidgetInterface_UnbindIndicator Parms{};

	Parms.Indicator = Indicator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraButtonBase.SetButtonText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraButtonBase::SetButtonText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraButtonBase", "SetButtonText");

	Params::LyraButtonBase_SetButtonText Parms{};

	Parms.InText = std::move(InText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraButtonBase.UpdateButtonStyle
// (Event, Protected, BlueprintEvent)

void ULyraButtonBase::UpdateButtonStyle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraButtonBase", "UpdateButtonStyle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.LyraButtonBase.UpdateButtonText
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// class FText                             InText                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraButtonBase::UpdateButtonText(const class FText& InText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraButtonBase", "UpdateButtonText");

	Params::LyraButtonBase_UpdateButtonText Parms{};

	Parms.InText = std::move(InText);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LyraTabButtonBase.SetTabLabelInfo_Implementation
// (Native, Protected, HasOutParams)
// Parameters:
// struct FLyraTabDescriptor               TabLabelInfo                                           (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ULyraTabButtonBase::SetTabLabelInfo_Implementation(const struct FLyraTabDescriptor& TabLabelInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabButtonBase", "SetTabLabelInfo_Implementation");

	Params::LyraTabButtonBase_SetTabLabelInfo_Implementation Parms{};

	Parms.TabLabelInfo = std::move(TabLabelInfo);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IncomeNotification.Activate
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AIncomeNotification::Activate(float Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IncomeNotification", "Activate");

	Params::IncomeNotification_Activate Parms{};

	Parms.Score = Score;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.NeighborSelectEntry.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FNeighborSelectEntryViewModel    ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNeighborSelectEntry::ApplyViewModel(const struct FNeighborSelectEntryViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSelectEntry", "ApplyViewModel");

	Params::NeighborSelectEntry_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.NeighborSelectEntry.Clicked
// (Final, Native, Public, BlueprintCallable)

void UNeighborSelectEntry::Clicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSelectEntry", "Clicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborSelectEntry.SetRandomNeighbor
// (Event, Public, BlueprintEvent)

void UNeighborSelectEntry::SetRandomNeighbor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSelectEntry", "SetRandomNeighbor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.MovementSpeedAttribute.OnRep_AimSpeedCoefficient
// (Native, Protected)

void UMovementSpeedAttribute::OnRep_AimSpeedCoefficient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttribute", "OnRep_AimSpeedCoefficient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttribute.OnRep_AirControl
// (Native, Protected)

void UMovementSpeedAttribute::OnRep_AirControl()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttribute", "OnRep_AirControl");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttribute.OnRep_CrouchJumpVelocityCoefficient
// (Native, Protected)

void UMovementSpeedAttribute::OnRep_CrouchJumpVelocityCoefficient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttribute", "OnRep_CrouchJumpVelocityCoefficient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttribute.OnRep_CrouchSpeedCoefficient
// (Native, Protected)

void UMovementSpeedAttribute::OnRep_CrouchSpeedCoefficient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttribute", "OnRep_CrouchSpeedCoefficient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttribute.OnRep_JumpVelocity
// (Native, Protected)

void UMovementSpeedAttribute::OnRep_JumpVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttribute", "OnRep_JumpVelocity");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttribute.OnRep_MovementSpeed
// (Native, Protected)

void UMovementSpeedAttribute::OnRep_MovementSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttribute", "OnRep_MovementSpeed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttribute.OnRep_SprintSpeedCoefficient
// (Native, Protected)

void UMovementSpeedAttribute::OnRep_SprintSpeedCoefficient()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttribute", "OnRep_SprintSpeedCoefficient");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborSpecialAbilitiesComponent.GrantAbility
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UNeighborSpecialAbilityDefinition*Definition                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNeighborSpecialAbilityInstance*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNeighborSpecialAbilityInstance* UNeighborSpecialAbilitiesComponent::GrantAbility(class UNeighborSpecialAbilityDefinition* Definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSpecialAbilitiesComponent", "GrantAbility");

	Params::NeighborSpecialAbilitiesComponent_GrantAbility Parms{};

	Parms.Definition = Definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.NeighborSpecialAbilitiesComponent.ReplaceSpecialAbility
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UNeighborSpecialAbilityDefinition*NewDefinition                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UNeighborSpecialAbilityInstance*  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UNeighborSpecialAbilityInstance* UNeighborSpecialAbilitiesComponent::ReplaceSpecialAbility(class UNeighborSpecialAbilityDefinition* NewDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSpecialAbilitiesComponent", "ReplaceSpecialAbility");

	Params::NeighborSpecialAbilitiesComponent_ReplaceSpecialAbility Parms{};

	Parms.NewDefinition = NewDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ItemAction_ItemWheel.ConstructItemWheelInfo
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UItemInstance*                    Item                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FItemWheelInfo                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FItemWheelInfo UItemAction_ItemWheel::ConstructItemWheelInfo(class UItemInstance* Item)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemAction_ItemWheel", "ConstructItemWheelInfo");

	Params::ItemAction_ItemWheel_ConstructItemWheelInfo Parms{};

	Parms.Item = Item;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ItemSkinDefinition.GetDefaultItemSkinID
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UItemSkinDefinition::GetDefaultItemSkinID(const class UItemDefinition* ItemDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemSkinDefinition", "GetDefaultItemSkinID");

	Params::ItemSkinDefinition_GetDefaultItemSkinID Parms{};

	Parms.ItemDefinition = ItemDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ItemSkinDefinition.TryGetItemSkinDefinition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ItemSkinID                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UItemSkinDefinition>OutSoftItemSkinDefinition                              (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UItemSkinDefinition::TryGetItemSkinDefinition(const struct FGameplayTag& ItemSkinID, TSoftObjectPtr<class UItemSkinDefinition>* OutSoftItemSkinDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ItemSkinDefinition", "TryGetItemSkinDefinition");

	Params::ItemSkinDefinition_TryGetItemSkinDefinition Parms{};

	Parms.ItemSkinID = std::move(ItemSkinID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftItemSkinDefinition != nullptr)
		*OutSoftItemSkinDefinition = Parms.OutSoftItemSkinDefinition;

	return Parms.ReturnValue;
}


// Function JP.NeighborPerkSelectPopupWidget.BlueprintHandleEntryWidgetCreated
// (Event, Public, BlueprintEvent)
// Parameters:
// class UPerkSelectEntry*                 EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNeighborPerkSelectPopupWidget::BlueprintHandleEntryWidgetCreated(class UPerkSelectEntry* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborPerkSelectPopupWidget", "BlueprintHandleEntryWidgetCreated");

	Params::NeighborPerkSelectPopupWidget_BlueprintHandleEntryWidgetCreated Parms{};

	Parms.EntryWidget = EntryWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.JPActionWidget.TryGetActionIcon
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UInputAction*                     Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSlateBrush                      IconSlateBrush                                         (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJPActionWidget::TryGetActionIcon(class UInputAction* Action, struct FSlateBrush* IconSlateBrush)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPActionWidget", "TryGetActionIcon");

	Params::JPActionWidget_TryGetActionIcon Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (IconSlateBrush != nullptr)
		*IconSlateBrush = std::move(Parms.IconSlateBrush);

	return Parms.ReturnValue;
}


// Function JP.JPActionWidget.TryGetActionKeyForFirstBoundKey
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UInputAction*                     Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ActionKeyText                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJPActionWidget::TryGetActionKeyForFirstBoundKey(class UInputAction* Action, class FText* ActionKeyText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPActionWidget", "TryGetActionKeyForFirstBoundKey");

	Params::JPActionWidget_TryGetActionKeyForFirstBoundKey Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionKeyText != nullptr)
		*ActionKeyText = std::move(Parms.ActionKeyText);

	return Parms.ReturnValue;
}


// Function JP.JPActionWidget.TryGetActionTextForFirstBoundKey
// (Final, Native, Private, HasOutParams, BlueprintCallable)
// Parameters:
// class UInputAction*                     Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ActionKeyText                                          (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJPActionWidget::TryGetActionTextForFirstBoundKey(class UInputAction* Action, class FText* ActionKeyText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPActionWidget", "TryGetActionTextForFirstBoundKey");

	Params::JPActionWidget_TryGetActionTextForFirstBoundKey Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (ActionKeyText != nullptr)
		*ActionKeyText = std::move(Parms.ActionKeyText);

	return Parms.ReturnValue;
}


// Function JP.JPActionWidget.GetCurrentInputType
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ECommonInputType                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ECommonInputType UJPActionWidget::GetCurrentInputType() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPActionWidget", "GetCurrentInputType");

	Params::JPActionWidget_GetCurrentInputType Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPActionWidget.GetKeysMappedToAction
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UInputAction*                     Action                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FKey>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FKey> UJPActionWidget::GetKeysMappedToAction(class UInputAction* Action) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPActionWidget", "GetKeysMappedToAction");

	Params::JPActionWidget_GetKeysMappedToAction Parms{};

	Parms.Action = Action;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PreLobbyServerBrowserList.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPreLobbyServerBrowserListViewModelViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserList::ApplyViewModel(const struct FPreLobbyServerBrowserListViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "ApplyViewModel");

	Params::PreLobbyServerBrowserList_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.PreLobbyServerBrowserList.DisplayPasswordPrompt
// (Event, Public, BlueprintEvent)

void UPreLobbyServerBrowserList::DisplayPasswordPrompt()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "DisplayPasswordPrompt");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PreLobbyServerBrowserList.HandleEntrySelected
// (Final, Native, Protected)
// Parameters:
// class UPreLobbyServerBrowserEntry*      InEntry                                                (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InJoin                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserList::HandleEntrySelected(class UPreLobbyServerBrowserEntry* InEntry, bool InJoin)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "HandleEntrySelected");

	Params::PreLobbyServerBrowserList_HandleEntrySelected Parms{};

	Parms.InEntry = InEntry;
	Parms.InJoin = InJoin;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserList.OnHandleJoinSelectedLobbyRequest
// (Event, Public, BlueprintEvent)

void UPreLobbyServerBrowserList::OnHandleJoinSelectedLobbyRequest()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "OnHandleJoinSelectedLobbyRequest");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PreLobbyServerBrowserList.OnPlayerInputPassword
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class FString                           Password                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserList::OnPlayerInputPassword(const class FString& Password)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "OnPlayerInputPassword");

	Params::PreLobbyServerBrowserList_OnPlayerInputPassword Parms{};

	Parms.Password = std::move(Password);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserList.PopulateWithTestData
// (Final, Native, Public, BlueprintCallable)

void UPreLobbyServerBrowserList::PopulateWithTestData()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "PopulateWithTestData");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserList.SetPageIndex
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPageIndex                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserList::SetPageIndex(int32 InPageIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "SetPageIndex");

	Params::PreLobbyServerBrowserList_SetPageIndex Parms{};

	Parms.InPageIndex = InPageIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserList.SetShowFullServers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInShowFullServers                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserList::SetShowFullServers(bool bInShowFullServers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "SetShowFullServers");

	Params::PreLobbyServerBrowserList_SetShowFullServers Parms{};

	Parms.bInShowFullServers = bInShowFullServers;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserList.SetSortMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EPreLobbyServerBrowserListSortMode      InSortMode                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserList::SetSortMode(EPreLobbyServerBrowserListSortMode InSortMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "SetSortMode");

	Params::PreLobbyServerBrowserList_SetSortMode Parms{};

	Parms.InSortMode = InSortMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserList.TryJoinSelectedLobby
// (Final, Native, Public, BlueprintCallable)

void UPreLobbyServerBrowserList::TryJoinSelectedLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "TryJoinSelectedLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserList.GetSelectedEntry
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPreLobbyServerBrowserEntry*      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPreLobbyServerBrowserEntry* UPreLobbyServerBrowserList::GetSelectedEntry() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserList", "GetSelectedEntry");

	Params::PreLobbyServerBrowserList_GetSelectedEntry Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.NeighborDefinition.GetStartingItemID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNeighborDefinition::GetStartingItemID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborDefinition", "GetStartingItemID");

	Params::NeighborDefinition_GetStartingItemID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.NeighborDefinition.TryGetStartingItemSkinID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNeighborDefinition::TryGetStartingItemSkinID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborDefinition", "TryGetStartingItemSkinID");

	Params::NeighborDefinition_TryGetStartingItemSkinID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.RepairnessAttributeSetListener.OnRepairnessChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Repairness                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxRepairness                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IRepairnessAttributeSetListener::OnRepairnessChanged(float Repairness, float MaxRepairness)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RepairnessAttributeSetListener", "OnRepairnessChanged");

	Params::RepairnessAttributeSetListener_OnRepairnessChanged Parms{};

	Parms.Repairness = Repairness;
	Parms.MaxRepairness = MaxRepairness;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborSelectPopupWidget.DismissPopup
// (Native, Public, BlueprintCallable)

void UNeighborSelectPopupWidget::DismissPopup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSelectPopupWidget", "DismissPopup");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborSelectPopupWidget.HandleEntryWidgetCreated
// (Event, Public, BlueprintEvent)
// Parameters:
// class UNeighborSelectEntry*             EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNeighborSelectPopupWidget::HandleEntryWidgetCreated(class UNeighborSelectEntry* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSelectPopupWidget", "HandleEntryWidgetCreated");

	Params::NeighborSelectPopupWidget_HandleEntryWidgetCreated Parms{};

	Parms.EntryWidget = EntryWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.NeighborSelectPopupWidget.SelectEntry
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UNeighborSelectEntry*             EntryWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag UNeighborSelectPopupWidget::SelectEntry(class UNeighborSelectEntry* EntryWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSelectPopupWidget", "SelectEntry");

	Params::NeighborSelectPopupWidget_SelectEntry Parms{};

	Parms.EntryWidget = EntryWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPGameSettingWithOddEvenInterface.GetIsEven
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IJPGameSettingWithOddEvenInterface::GetIsEven()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPGameSettingWithOddEvenInterface", "GetIsEven");

	Params::JPGameSettingWithOddEvenInterface_GetIsEven Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPGameSettingWithOddEvenInterface.SetIsEven
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEven                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IJPGameSettingWithOddEvenInterface::SetIsEven(bool IsEven)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPGameSettingWithOddEvenInterface", "SetIsEven");

	Params::JPGameSettingWithOddEvenInterface_SetIsEven Parms{};

	Parms.IsEven = IsEven;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveManagerComponent.CreateObjectiveInstance
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObjectiveDefinition*             ObjectiveDefinition                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveManagerComponent::CreateObjectiveInstance(class UObject* WorldContextObject, class UObjectiveDefinition* ObjectiveDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ObjectiveManagerComponent", "CreateObjectiveInstance");

	Params::ObjectiveManagerComponent_CreateObjectiveInstance Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ObjectiveDefinition = ObjectiveDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveManagerComponent.CreateObjectiveInstanceForThisObjectiveComponent
// (BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObjectiveDefinition*             ObjectiveDefinition                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    UseTooltipShowSetting                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveManagerComponent::CreateObjectiveInstanceForThisObjectiveComponent(class UObjectiveDefinition* ObjectiveDefinition, bool UseTooltipShowSetting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveManagerComponent", "CreateObjectiveInstanceForThisObjectiveComponent");

	Params::ObjectiveManagerComponent_CreateObjectiveInstanceForThisObjectiveComponent Parms{};

	Parms.ObjectiveDefinition = ObjectiveDefinition;
	Parms.UseTooltipShowSetting = UseTooltipShowSetting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPSessionManagerSubsystem.GetBuildConfigurationFromSession
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCommonSession_SearchResult*      SessionSearchResult                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJPSessionManagerSubsystem::GetBuildConfigurationFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPSessionManagerSubsystem", "GetBuildConfigurationFromSession");

	Params::JPSessionManagerSubsystem_GetBuildConfigurationFromSession Parms{};

	Parms.SessionSearchResult = SessionSearchResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JP.JPSessionManagerSubsystem.GetCreatedTimestampFromSession
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCommonSession_SearchResult*      SessionSearchResult                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FDateTime                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FDateTime UJPSessionManagerSubsystem::GetCreatedTimestampFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPSessionManagerSubsystem", "GetCreatedTimestampFromSession");

	Params::JPSessionManagerSubsystem_GetCreatedTimestampFromSession Parms{};

	Parms.SessionSearchResult = SessionSearchResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JP.JPSessionManagerSubsystem.GetCurrentLobbyName
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJPSessionManagerSubsystem::GetCurrentLobbyName(bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPSessionManagerSubsystem", "GetCurrentLobbyName");

	Params::JPSessionManagerSubsystem_GetCurrentLobbyName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JP.JPSessionManagerSubsystem.GetIsInLobbyFromSession
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCommonSession_SearchResult*      SessionSearchResult                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJPSessionManagerSubsystem::GetIsInLobbyFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPSessionManagerSubsystem", "GetIsInLobbyFromSession");

	Params::JPSessionManagerSubsystem_GetIsInLobbyFromSession Parms{};

	Parms.SessionSearchResult = SessionSearchResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JP.JPSessionManagerSubsystem.GetIsInNeighbourhoodFromSession
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCommonSession_SearchResult*      SessionSearchResult                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UJPSessionManagerSubsystem::GetIsInNeighbourhoodFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPSessionManagerSubsystem", "GetIsInNeighbourhoodFromSession");

	Params::JPSessionManagerSubsystem_GetIsInNeighbourhoodFromSession Parms{};

	Parms.SessionSearchResult = SessionSearchResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JP.JPSessionManagerSubsystem.GetLobbyNameFromSession
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCommonSession_SearchResult*      SessionSearchResult                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJPSessionManagerSubsystem::GetLobbyNameFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPSessionManagerSubsystem", "GetLobbyNameFromSession");

	Params::JPSessionManagerSubsystem_GetLobbyNameFromSession Parms{};

	Parms.SessionSearchResult = SessionSearchResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JP.JPSessionManagerSubsystem.GetProjectVersionFromSession
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class UCommonSession_SearchResult*      SessionSearchResult                                    (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJPSessionManagerSubsystem::GetProjectVersionFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPSessionManagerSubsystem", "GetProjectVersionFromSession");

	Params::JPSessionManagerSubsystem_GetProjectVersionFromSession Parms{};

	Parms.SessionSearchResult = SessionSearchResult;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Success != nullptr)
		*Success = Parms.Success;

	return Parms.ReturnValue;
}


// Function JP.OnlineServicesPartyMember.IsLeader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineServicesPartyMember::IsLeader() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineServicesPartyMember", "IsLeader");

	Params::OnlineServicesPartyMember_IsLeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPSettingPanel.AddSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPSettingPanel::AddSetting(class UJPSettingWidget* InWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPSettingPanel", "AddSetting");

	Params::JPSettingPanel_AddSetting Parms{};

	Parms.InWidget = InWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPSettingPanel.ClearHighlight
// (Final, Native, Public, BlueprintCallable)

void UJPSettingPanel::ClearHighlight()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPSettingPanel", "ClearHighlight");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPSettingPanel.HighlightSetting
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InSettingIdentifier                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPSettingPanel::HighlightSetting(const class FString& InSettingIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPSettingPanel", "HighlightSetting");

	Params::JPSettingPanel_HighlightSetting Parms{};

	Parms.InSettingIdentifier = std::move(InSettingIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPSettingPanel.GetAllSettings
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<class UJPSettingWidget*>         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UJPSettingWidget*> UJPSettingPanel::GetAllSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPSettingPanel", "GetAllSettings");

	Params::JPSettingPanel_GetAllSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPSettingPanel.GetSetting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           InSettingIdentifier                                    (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UJPSettingWidget*                 ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJPSettingWidget* UJPSettingPanel::GetSetting(const class FString& InSettingIdentifier) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPSettingPanel", "GetSetting");

	Params::JPSettingPanel_GetSetting Parms{};

	Parms.InSettingIdentifier = std::move(InSettingIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveWorldSubsystem.DestroySubObjective
// (Final, Native, Public)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveWorldSubsystem::DestroySubObjective(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWorldSubsystem", "DestroySubObjective");

	Params::ObjectiveWorldSubsystem_DestroySubObjective Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveWorldSubsystem.GetObjectives
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<struct FObjectiveAndOwningPlayer>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FObjectiveAndOwningPlayer> UObjectiveWorldSubsystem::GetObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWorldSubsystem", "GetObjectives");

	Params::ObjectiveWorldSubsystem_GetObjectives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction JP.ObjectiveWorldSubsystem.ObjectiveDelegate__DelegateSignature
// (BlueprintAuthorityOnly, MulticastDelegate, Public, Delegate)
// Parameters:
// struct FObjectiveAndOwningPlayer        ObjectiveDefinition                                    (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UObjectiveWorldSubsystem::ObjectiveDelegate__DelegateSignature(const struct FObjectiveAndOwningPlayer& ObjectiveDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWorldSubsystem", "ObjectiveDelegate__DelegateSignature");

	Params::ObjectiveWorldSubsystem_ObjectiveDelegate__DelegateSignature Parms{};

	Parms.ObjectiveDefinition = std::move(ObjectiveDefinition);

	UObject::ProcessEvent(Func, &Parms);
}


// DelegateFunction JP.ObjectiveWorldSubsystem.SubObjectiveDelegate__DelegateSignature
// (BlueprintAuthorityOnly, MulticastDelegate, Public, Delegate)
// Parameters:
// class ASubObjective*                    SubObjective                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveWorldSubsystem::SubObjectiveDelegate__DelegateSignature(class ASubObjective* SubObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWorldSubsystem", "SubObjectiveDelegate__DelegateSignature");

	Params::ObjectiveWorldSubsystem_SubObjectiveDelegate__DelegateSignature Parms{};

	Parms.SubObjective = SubObjective;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.JPSettingWidget.SetHighlighted
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InHovered                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPSettingWidget::SetHighlighted(bool InHovered)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPSettingWidget", "SetHighlighted");

	Params::JPSettingWidget_SetHighlighted Parms{};

	Parms.InHovered = InHovered;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.JPSettingWidget.GetSettingPanel
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UJPSettingPanel*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UJPSettingPanel* UJPSettingWidget::GetSettingPanel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPSettingWidget", "GetSettingPanel");

	Params::JPSettingWidget_GetSettingPanel Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPTabDescriptorProviderInterface.GetTabDescriptors
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// TArray<struct FLyraTabDescriptor>       ExistingTabDescriptors                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// TArray<struct FLyraTabDescriptor>       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<struct FLyraTabDescriptor> IJPTabDescriptorProviderInterface::GetTabDescriptors(const TArray<struct FLyraTabDescriptor>& ExistingTabDescriptors) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabDescriptorProviderInterface", "GetTabDescriptors");

	Params::JPTabDescriptorProviderInterface_GetTabDescriptors Parms{};

	Parms.ExistingTabDescriptors = std::move(ExistingTabDescriptors);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.JPTabDescriptorProviderInterface.IsTabDisabled
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// class FName                             TabName                                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool IJPTabDescriptorProviderInterface::IsTabDisabled(const class FName TabName) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabDescriptorProviderInterface", "IsTabDisabled");

	Params::JPTabDescriptorProviderInterface_IsTabDisabled Parms{};

	Parms.TabName = TabName;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.LyraTabListWidgetBase.GetPreregisteredTabInfo
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TabNameID                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FLyraTabDescriptor               OutTabInfo                                             (Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::GetPreregisteredTabInfo(const class FName TabNameID, struct FLyraTabDescriptor* OutTabInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "GetPreregisteredTabInfo");

	Params::LyraTabListWidgetBase_GetPreregisteredTabInfo Parms{};

	Parms.TabNameID = TabNameID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTabInfo != nullptr)
		*OutTabInfo = std::move(Parms.OutTabInfo);

	return Parms.ReturnValue;
}


// Function JP.LyraTabListWidgetBase.GetVisibleTabCount
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraTabListWidgetBase::GetVisibleTabCount()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "GetVisibleTabCount");

	Params::LyraTabListWidgetBase_GetVisibleTabCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraTabListWidgetBase.IsTabVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FName                             TabId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::IsTabVisible(class FName TabId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "IsTabVisible");

	Params::LyraTabListWidgetBase_IsTabVisible Parms{};

	Parms.TabId = TabId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// DelegateFunction JP.LyraTabListWidgetBase.OnTabContentCreated__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// class FName                             TabId                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonUserWidget*                TabWidget                                              (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTabListWidgetBase::OnTabContentCreated__DelegateSignature(class FName TabId, class UCommonUserWidget* TabWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "OnTabContentCreated__DelegateSignature");

	Params::LyraTabListWidgetBase_OnTabContentCreated__DelegateSignature Parms{};

	Parms.TabId = TabId;
	Parms.TabWidget = TabWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LyraTabListWidgetBase.RegisterDynamicTab
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLyraTabDescriptor               TabDescriptor                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::RegisterDynamicTab(const struct FLyraTabDescriptor& TabDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "RegisterDynamicTab");

	Params::LyraTabListWidgetBase_RegisterDynamicTab Parms{};

	Parms.TabDescriptor = std::move(TabDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraTabListWidgetBase.SetTabHiddenState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TabNameID                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bHidden                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraTabListWidgetBase::SetTabHiddenState(class FName TabNameID, bool bHidden)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "SetTabHiddenState");

	Params::LyraTabListWidgetBase_SetTabHiddenState Parms{};

	Parms.TabNameID = TabNameID;
	Parms.bHidden = bHidden;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraTabListWidgetBase.IsFirstTabActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::IsFirstTabActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "IsFirstTabActive");

	Params::LyraTabListWidgetBase_IsFirstTabActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraTabListWidgetBase.IsLastTabActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTabListWidgetBase::IsLastTabActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabListWidgetBase", "IsLastTabActive");

	Params::LyraTabListWidgetBase_IsLastTabActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreBlueprintFunctionLibrary.GetTitlePlayerAccountIdFromPlayerController
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerControllerJP*              PlayerController                                       (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOnlineStoreBlueprintFunctionLibrary::GetTitlePlayerAccountIdFromPlayerController(const class APlayerControllerJP* PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreBlueprintFunctionLibrary", "GetTitlePlayerAccountIdFromPlayerController");

	Params::OnlineStoreBlueprintFunctionLibrary_GetTitlePlayerAccountIdFromPlayerController Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreBlueprintFunctionLibrary.GetTitlePlayerAccountIdFromPlayerState
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOnlineStoreBlueprintFunctionLibrary::GetTitlePlayerAccountIdFromPlayerState(const class APlayerStateJP* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreBlueprintFunctionLibrary", "GetTitlePlayerAccountIdFromPlayerState");

	Params::OnlineStoreBlueprintFunctionLibrary_GetTitlePlayerAccountIdFromPlayerState Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreBlueprintFunctionLibrary.TryGetCurrencyBundleDataAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPlatformStoreOffer              PlatformStoreOffer                                     (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UOnlineCurrencyBundleDataAsset>CurrencyBundleDataAsset                                (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineStoreBlueprintFunctionLibrary::TryGetCurrencyBundleDataAsset(const struct FPlatformStoreOffer& PlatformStoreOffer, TSoftObjectPtr<class UOnlineCurrencyBundleDataAsset>* CurrencyBundleDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreBlueprintFunctionLibrary", "TryGetCurrencyBundleDataAsset");

	Params::OnlineStoreBlueprintFunctionLibrary_TryGetCurrencyBundleDataAsset Parms{};

	Parms.PlatformStoreOffer = std::move(PlatformStoreOffer);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (CurrencyBundleDataAsset != nullptr)
		*CurrencyBundleDataAsset = Parms.CurrencyBundleDataAsset;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreBlueprintFunctionLibrary.TryGetCurrencyFromTagIdentifier
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CurrencyIdentifier                                     (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UOnlineCurrency>   OutCurrency                                            (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineStoreBlueprintFunctionLibrary::TryGetCurrencyFromTagIdentifier(const struct FGameplayTag& CurrencyIdentifier, TSoftObjectPtr<class UOnlineCurrency>* OutCurrency)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreBlueprintFunctionLibrary", "TryGetCurrencyFromTagIdentifier");

	Params::OnlineStoreBlueprintFunctionLibrary_TryGetCurrencyFromTagIdentifier Parms{};

	Parms.CurrencyIdentifier = std::move(CurrencyIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutCurrency != nullptr)
		*OutCurrency = Parms.OutCurrency;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreBlueprintFunctionLibrary.TryGetLoadoutStartingItemSkinID
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FNeighborLoadout                 NeighborLoadout                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OutTag                                                 (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineStoreBlueprintFunctionLibrary::TryGetLoadoutStartingItemSkinID(const struct FNeighborLoadout& NeighborLoadout, struct FGameplayTag* OutTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreBlueprintFunctionLibrary", "TryGetLoadoutStartingItemSkinID");

	Params::OnlineStoreBlueprintFunctionLibrary_TryGetLoadoutStartingItemSkinID Parms{};

	Parms.NeighborLoadout = std::move(NeighborLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutTag != nullptr)
		*OutTag = std::move(Parms.OutTag);

	return Parms.ReturnValue;
}


// Function JP.EconomyDefinition.GetMoneyDisplayNameText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UEconomyDefinition::GetMoneyDisplayNameText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomyDefinition", "GetMoneyDisplayNameText");

	Params::EconomyDefinition_GetMoneyDisplayNameText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomyDefinition.GetPerfectnessDisplayNameText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UEconomyDefinition::GetPerfectnessDisplayNameText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomyDefinition", "GetPerfectnessDisplayNameText");

	Params::EconomyDefinition_GetPerfectnessDisplayNameText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomyDefinition.GetWoodDisplayNameText
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UEconomyDefinition::GetWoodDisplayNameText() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomyDefinition", "GetWoodDisplayNameText");

	Params::EconomyDefinition_GetWoodDisplayNameText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomyDefinition.IsValid
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEconomyDefinition::IsValid() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomyDefinition", "IsValid");

	Params::EconomyDefinition_IsValid Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.FlushNetDormancy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void UObjectiveBase::FlushNetDormancy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "FlushNetDormancy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveBase.GetObjectivesComponent
// (Final, Native, Public)
// Parameters:
// class UObjectivesComponent*             ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObjectivesComponent* UObjectiveBase::GetObjectivesComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetObjectivesComponent");

	Params::ObjectiveBase_GetObjectivesComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.HasAuthority
// (Final, Native, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectiveBase::HasAuthority()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "HasAuthority");

	Params::ObjectiveBase_HasAuthority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.InitializeTeamDependencies
// (Final, Native, Private)

void UObjectiveBase::InitializeTeamDependencies()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "InitializeTeamDependencies");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveBase.OnCreated
// (Event, Protected, BlueprintEvent)

void UObjectiveBase::OnCreated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "OnCreated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.ObjectiveBase.OnRep_GroundsKeeper
// (Final, Native, Private)

void UObjectiveBase::OnRep_GroundsKeeper()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "OnRep_GroundsKeeper");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveBase.OnRep_ManagedTasks
// (Final, Native, Private)

void UObjectiveBase::OnRep_ManagedTasks()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "OnRep_ManagedTasks");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveBase.SpawnTasks
// (Final, BlueprintAuthorityOnly, Native, Private, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               TaskType                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   AmountToSpawn                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UObjectiveBase::SpawnTasks(TSubclassOf<class AActor> TaskType, uint8 AmountToSpawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "SpawnTasks");

	Params::ObjectiveBase_SpawnTasks Parms{};

	Parms.TaskType = TaskType;
	Parms.AmountToSpawn = AmountToSpawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.GetGroundsKeeper
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGroundsKeeper*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGroundsKeeper* UObjectiveBase::GetGroundsKeeper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetGroundsKeeper");

	Params::ObjectiveBase_GetGroundsKeeper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.GetIsWinningCondition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectiveBase::GetIsWinningCondition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetIsWinningCondition");

	Params::ObjectiveBase_GetIsWinningCondition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.GetMatchConfiguration
// (Final, Native, Private, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FMatchConfiguration        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMatchConfiguration UObjectiveBase::GetMatchConfiguration() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetMatchConfiguration");

	Params::ObjectiveBase_GetMatchConfiguration Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.GetProgressionText
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class FText                             RowData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UObjectiveBase::GetProgressionText(const class FText& RowData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetProgressionText");

	Params::ObjectiveBase_GetProgressionText Parms{};

	Parms.RowData = std::move(RowData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.GetState
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// EObjectiveState                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EObjectiveState UObjectiveBase::GetState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetState");

	Params::ObjectiveBase_GetState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.GetTeam
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FTeam                            ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FTeam UObjectiveBase::GetTeam() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetTeam");

	Params::ObjectiveBase_GetTeam Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.GetTeamID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UObjectiveBase::GetTeamID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetTeamID");

	Params::ObjectiveBase_GetTeamID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.GetTitle
// (Native, Event, Public, HasOutParams, BlueprintEvent, Const)
// Parameters:
// class FText                             RowData                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UObjectiveBase::GetTitle(const class FText& RowData) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "GetTitle");

	Params::ObjectiveBase_GetTitle Parms{};

	Parms.RowData = std::move(RowData);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveBase.IsLocalPlayerRelated
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UObjectiveBase::IsLocalPlayerRelated() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveBase", "IsLocalPlayerRelated");

	Params::ObjectiveBase_IsLocalPlayerRelated Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPTabPanelContent.SetTabVisibility
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InDirection                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPTabPanelContent::SetTabVisibility(bool InVisible, int32 InDirection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabPanelContent", "SetTabVisibility");

	Params::JPTabPanelContent_SetTabVisibility Parms{};

	Parms.InVisible = InVisible;
	Parms.InDirection = InDirection;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.JPTabPanelContent.GetIdentifier
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJPTabPanelContent::GetIdentifier() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabPanelContent", "GetIdentifier");

	Params::JPTabPanelContent_GetIdentifier Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPTabPanelContent.GetTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UJPTabPanelContent::GetTitle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabPanelContent", "GetTitle");

	Params::JPTabPanelContent_GetTitle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPTabPanel.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FJPTabPanelViewModel             InViewModel                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UJPTabPanel::ApplyViewModel(const struct FJPTabPanelViewModel& InViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabPanel", "ApplyViewModel");

	Params::JPTabPanel_ApplyViewModel Parms{};

	Parms.InViewModel = std::move(InViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.JPTabPanel.SelectDefaultTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InPlayAnimation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPTabPanel::SelectDefaultTab(bool InPlayAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabPanel", "SelectDefaultTab");

	Params::JPTabPanel_SelectDefaultTab Parms{};

	Parms.InPlayAnimation = InPlayAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPTabPanel.SelectNextTab
// (Final, Native, Public, BlueprintCallable)

void UJPTabPanel::SelectNextTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabPanel", "SelectNextTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPTabPanel.SelectPreviousTab
// (Final, Native, Public, BlueprintCallable)

void UJPTabPanel::SelectPreviousTab()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabPanel", "SelectPreviousTab");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPTabPanel.SelectTab
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FString                           InIdentifier                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InPlayAnimation                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPTabPanel::SelectTab(const class FString& InIdentifier, bool InPlayAnimation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPTabPanel", "SelectTab");

	Params::JPTabPanel_SelectTab Parms{};

	Parms.InIdentifier = std::move(InIdentifier);
	Parms.InPlayAnimation = InPlayAnimation;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPTimeFunctionLibrary.TimeSecondsToMinuteSeconds
// (Final, Native, Static, Private, BlueprintCallable, BlueprintPure)
// Parameters:
// float                                   Seconds                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UJPTimeFunctionLibrary::TimeSecondsToMinuteSeconds(float Seconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPTimeFunctionLibrary", "TimeSecondsToMinuteSeconds");

	Params::JPTimeFunctionLibrary_TimeSecondsToMinuteSeconds Parms{};

	Parms.Seconds = Seconds;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPUIBlueprintFunctionLibrary.InsertPanelChildWidgetAt
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPanelWidget*                     PanelWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewChildWidget                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPUIBlueprintFunctionLibrary::InsertPanelChildWidgetAt(class UPanelWidget* PanelWidget, int32 Index_0, class UWidget* NewChildWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPUIBlueprintFunctionLibrary", "InsertPanelChildWidgetAt");

	Params::JPUIBlueprintFunctionLibrary_InsertPanelChildWidgetAt Parms{};

	Parms.PanelWidget = PanelWidget;
	Parms.Index_0 = Index_0;
	Parms.NewChildWidget = NewChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPUIBlueprintFunctionLibrary.ReplaceAllChildWidgetsWithArrayOfWidgets
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPanelWidget*                     PanelWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UWidget*>                  NewChildWidgets                                        (Parm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UJPUIBlueprintFunctionLibrary::ReplaceAllChildWidgetsWithArrayOfWidgets(class UPanelWidget* PanelWidget, const TArray<class UWidget*>& NewChildWidgets)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPUIBlueprintFunctionLibrary", "ReplaceAllChildWidgetsWithArrayOfWidgets");

	Params::JPUIBlueprintFunctionLibrary_ReplaceAllChildWidgetsWithArrayOfWidgets Parms{};

	Parms.PanelWidget = PanelWidget;
	Parms.NewChildWidgets = std::move(NewChildWidgets);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPUIBlueprintFunctionLibrary.ShiftPanelChildWidget
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPanelWidget*                     PanelWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Index_0                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewChildWidget                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPUIBlueprintFunctionLibrary::ShiftPanelChildWidget(class UPanelWidget* PanelWidget, int32 Index_0, class UWidget* NewChildWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPUIBlueprintFunctionLibrary", "ShiftPanelChildWidget");

	Params::JPUIBlueprintFunctionLibrary_ShiftPanelChildWidget Parms{};

	Parms.PanelWidget = PanelWidget;
	Parms.Index_0 = Index_0;
	Parms.NewChildWidget = NewChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPUIBlueprintFunctionLibrary.ShiftPanelChildWidgetRelative
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPanelWidget*                     PanelWidget                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   RelativeIndex                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UWidget*                          NewChildWidget                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UJPUIBlueprintFunctionLibrary::ShiftPanelChildWidgetRelative(class UPanelWidget* PanelWidget, int32 RelativeIndex, class UWidget* NewChildWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("JPUIBlueprintFunctionLibrary", "ShiftPanelChildWidgetRelative");

	Params::JPUIBlueprintFunctionLibrary_ShiftPanelChildWidgetRelative Parms{};

	Parms.PanelWidget = PanelWidget;
	Parms.RelativeIndex = RelativeIndex;
	Parms.NewChildWidget = NewChildWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineServicesLobbySubsystem.BeginQuickPlay
// (Final, Native, Public, BlueprintCallable)

void UOnlineServicesLobbySubsystem::BeginQuickPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineServicesLobbySubsystem", "BeginQuickPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineServicesLobbySubsystem.CancelQuickPlay
// (Final, Native, Public, BlueprintCallable)

void UOnlineServicesLobbySubsystem::CancelQuickPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineServicesLobbySubsystem", "CancelQuickPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineServicesLobbySubsystem.CreateLobby
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FLobbyConfiguration              InConfig                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineServicesLobbySubsystem::CreateLobby(const struct FLobbyConfiguration& InConfig)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineServicesLobbySubsystem", "CreateLobby");

	Params::OnlineServicesLobbySubsystem_CreateLobby Parms{};

	Parms.InConfig = std::move(InConfig);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineServicesLobbySubsystem.OnPartyChanged
// (Final, Native, Private)

void UOnlineServicesLobbySubsystem::OnPartyChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineServicesLobbySubsystem", "OnPartyChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineServicesLobbySubsystem.IsEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineServicesLobbySubsystem::IsEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineServicesLobbySubsystem", "IsEnabled");

	Params::OnlineServicesLobbySubsystem_IsEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineServicesLobbySubsystem.IsQuickPlayMatchmakingInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineServicesLobbySubsystem::IsQuickPlayMatchmakingInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineServicesLobbySubsystem", "IsQuickPlayMatchmakingInProgress");

	Params::OnlineServicesLobbySubsystem_IsQuickPlayMatchmakingInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.JPUIControllerBase.DoEULACheck
// (Final, Native, Protected, BlueprintCallable)

void AJPUIControllerBase::DoEULACheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "DoEULACheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPUIControllerBase.OnEulaAccepted
// (Event, Protected, BlueprintEvent)

void AJPUIControllerBase::OnEulaAccepted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "OnEulaAccepted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.JPUIControllerBase.OnEulaError
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJPUIControllerBase::OnEulaError(const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "OnEulaError");

	Params::JPUIControllerBase_OnEulaError Parms{};

	Parms.Message = std::move(Message);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.JPUIControllerBase.OnEULAWidgetShown
// (Event, Protected, BlueprintEvent)
// Parameters:
// class UEULAWidget*                      EULAWidget                                             (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJPUIControllerBase::OnEULAWidgetShown(class UEULAWidget* EULAWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "OnEULAWidgetShown");

	Params::JPUIControllerBase_OnEULAWidgetShown Parms{};

	Parms.EULAWidget = EULAWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.JPUIControllerBase.OnPrivacyPolicyAccepted
// (Event, Protected, BlueprintEvent)

void AJPUIControllerBase::OnPrivacyPolicyAccepted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "OnPrivacyPolicyAccepted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.JPUIControllerBase.PrivacyPolicyCheck
// (Final, Native, Protected, BlueprintCallable)

void AJPUIControllerBase::PrivacyPolicyCheck()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "PrivacyPolicyCheck");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPUIControllerBase.ResetUserAndSessionStateIfHardDisconnect
// (Final, Native, Protected, BlueprintCallable)

void AJPUIControllerBase::ResetUserAndSessionStateIfHardDisconnect()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "ResetUserAndSessionStateIfHardDisconnect");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPUIControllerBase.SetShouldApplyMenuFrameRateLimit
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    InApplyLimit                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJPUIControllerBase::SetShouldApplyMenuFrameRateLimit(bool InApplyLimit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "SetShouldApplyMenuFrameRateLimit");

	Params::JPUIControllerBase_SetShouldApplyMenuFrameRateLimit Parms{};

	Parms.InApplyLimit = InApplyLimit;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPUIControllerBase.SetShouldShowLoadingScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InShouldShowLoadingScreen                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InReason                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void AJPUIControllerBase::SetShouldShowLoadingScreen(bool InShouldShowLoadingScreen, const class FString& InReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "SetShouldShowLoadingScreen");

	Params::JPUIControllerBase_SetShouldShowLoadingScreen Parms{};

	Parms.InShouldShowLoadingScreen = InShouldShowLoadingScreen;
	Parms.InReason = std::move(InReason);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.JPUIControllerBase.TryJoinRequestedSession
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool AJPUIControllerBase::TryJoinRequestedSession()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("JPUIControllerBase", "TryJoinRequestedSession");

	Params::JPUIControllerBase_TryJoinRequestedSession Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LevelVoteComponent.GetVotingLevelFromIndex
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// uint8                                   LevelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FLevelVoteData             ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FLevelVoteData ULevelVoteComponent::GetVotingLevelFromIndex(uint8 LevelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LevelVoteComponent", "GetVotingLevelFromIndex");

	Params::LevelVoteComponent_GetVotingLevelFromIndex Parms{};

	Parms.LevelIndex = LevelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LevelVoteComponent.FinishVotingProcess
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ULevelVoteComponent::FinishVotingProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "FinishVotingProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LevelVoteComponent.OnRep_TotalVoted
// (Final, Native, Private)

void ULevelVoteComponent::OnRep_TotalVoted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "OnRep_TotalVoted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LevelVoteComponent.StartVotingProcess
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ULevelVoteComponent::StartVotingProcess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "StartVotingProcess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LevelVoteComponent.VoteOnLevel
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   LevelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULevelVoteComponent::VoteOnLevel(uint8 LevelIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "VoteOnLevel");

	Params::LevelVoteComponent_VoteOnLevel Parms{};

	Parms.LevelIndex = LevelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LevelVoteComponent.GetVoteState
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVoteState                              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVoteState ULevelVoteComponent::GetVoteState() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "GetVoteState");

	Params::LevelVoteComponent_GetVoteState Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LevelVoteComponent.OnRep_SelectedLevel
// (Final, Native, Private, Const)

void ULevelVoteComponent::OnRep_SelectedLevel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "OnRep_SelectedLevel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LevelVoteComponent.OnRep_VoteOptions
// (Final, Native, Private, Const)

void ULevelVoteComponent::OnRep_VoteOptions() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LevelVoteComponent", "OnRep_VoteOptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ListenServerBackfillWorldSubsystem.OnAllPlayersReadyAndWaitingUpdated
// (Final, Native, Private)
// Parameters:
// bool                                    AllPlayersReadyAndWaiting                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UListenServerBackfillWorldSubsystem::OnAllPlayersReadyAndWaitingUpdated(const bool AllPlayersReadyAndWaiting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ListenServerBackfillWorldSubsystem", "OnAllPlayersReadyAndWaitingUpdated");

	Params::ListenServerBackfillWorldSubsystem_OnAllPlayersReadyAndWaitingUpdated Parms{};

	Parms.AllPlayersReadyAndWaiting = AllPlayersReadyAndWaiting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LoadGuardButton.EnableLoadGuard
// (Final, Native, Public, BlueprintCallable)

void ULoadGuardButton::EnableLoadGuard()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGuardButton", "EnableLoadGuard");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LoadGuardButton.RestoreButton
// (Final, Native, Public, BlueprintCallable)

void ULoadGuardButton::RestoreButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGuardButton", "RestoreButton");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LoadGuardButton.SetButtonText
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// class FText                             InButtonText                                           (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULoadGuardButton::SetButtonText(const class FText& InButtonText)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadGuardButton", "SetButtonText");

	Params::LoadGuardButton_SetButtonText Parms{};

	Parms.InButtonText = std::move(InButtonText);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LoadoutVerificationServerComponent.OnInventoryIdsChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             InventoryIds                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULoadoutVerificationServerComponent::OnInventoryIdsChanged(class APlayerStateJP* PlayerState, const TArray<struct FGameplayTag>& InventoryIds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadoutVerificationServerComponent", "OnInventoryIdsChanged");

	Params::LoadoutVerificationServerComponent_OnInventoryIdsChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.InventoryIds = std::move(InventoryIds);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LoadoutVerificationServerComponent.OnMasterIdAcquired
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           MasterPlayerAccountId                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadoutVerificationServerComponent::OnMasterIdAcquired(class APlayerStateJP* PlayerState, const class FString& MasterPlayerAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadoutVerificationServerComponent", "OnMasterIdAcquired");

	Params::LoadoutVerificationServerComponent_OnMasterIdAcquired Parms{};

	Parms.PlayerState = PlayerState;
	Parms.MasterPlayerAccountId = std::move(MasterPlayerAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LoadoutVerificationServerComponent.OnPlayerXPChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerXP                        PlayerXP                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULoadoutVerificationServerComponent::OnPlayerXPChanged(class APlayerStateJP* PlayerState, const struct FPlayerXP& PlayerXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadoutVerificationServerComponent", "OnPlayerXPChanged");

	Params::LoadoutVerificationServerComponent_OnPlayerXPChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.PlayerXP = std::move(PlayerXP);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LoadoutVerificationServerComponent.OnTitleIdAcquired
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           TitlePlayerAccountId                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULoadoutVerificationServerComponent::OnTitleIdAcquired(class APlayerStateJP* PlayerState, const class FString& TitlePlayerAccountId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LoadoutVerificationServerComponent", "OnTitleIdAcquired");

	Params::LoadoutVerificationServerComponent_OnTitleIdAcquired Parms{};

	Parms.PlayerState = PlayerState;
	Parms.TitlePlayerAccountId = std::move(TitlePlayerAccountId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreItemDataFunctionLibrary.MakeOnlineStoreItemBattlePassRequirementStruct
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     BattlePassTag                                          (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   LevelRequirement                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPremium                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemBattlePassRequirementReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOnlineStoreItemBattlePassRequirement UOnlineStoreItemDataFunctionLibrary::MakeOnlineStoreItemBattlePassRequirementStruct(const struct FGameplayTag& BattlePassTag, const int32 LevelRequirement, const bool bIsPremium)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreItemDataFunctionLibrary", "MakeOnlineStoreItemBattlePassRequirementStruct");

	Params::OnlineStoreItemDataFunctionLibrary_MakeOnlineStoreItemBattlePassRequirementStruct Parms{};

	Parms.BattlePassTag = std::move(BattlePassTag);
	Parms.LevelRequirement = LevelRequirement;
	Parms.bIsPremium = bIsPremium;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreItemDataFunctionLibrary.MakeOnlineStoreItemCostStruct
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     CurrencyTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemCost             ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)

struct FOnlineStoreItemCost UOnlineStoreItemDataFunctionLibrary::MakeOnlineStoreItemCostStruct(const struct FGameplayTag& CurrencyTag, const int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreItemDataFunctionLibrary", "MakeOnlineStoreItemCostStruct");

	Params::OnlineStoreItemDataFunctionLibrary_MakeOnlineStoreItemCostStruct Parms{};

	Parms.CurrencyTag = std::move(CurrencyTag);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreItemDataFunctionLibrary.MakeOnlineStoreItemData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           OnlineServicesID                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AssetID                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EOnlineItemUnlockRequirement            UnlockRequirement                                      (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOwned                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemCost             Cost                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemBattlePassRequirementBattlePassRequirement                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   Tags                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemData             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOnlineStoreItemData UOnlineStoreItemDataFunctionLibrary::MakeOnlineStoreItemData(const class FString& OnlineServicesID, const struct FGameplayTag& AssetID, const EOnlineItemUnlockRequirement UnlockRequirement, const bool bIsOwned, const struct FOnlineStoreItemCost& Cost, const struct FOnlineStoreItemBattlePassRequirement& BattlePassRequirement, const TArray<class FString>& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreItemDataFunctionLibrary", "MakeOnlineStoreItemData");

	Params::OnlineStoreItemDataFunctionLibrary_MakeOnlineStoreItemData Parms{};

	Parms.OnlineServicesID = std::move(OnlineServicesID);
	Parms.AssetID = std::move(AssetID);
	Parms.UnlockRequirement = UnlockRequirement;
	Parms.bIsOwned = bIsOwned;
	Parms.Cost = std::move(Cost);
	Parms.BattlePassRequirement = std::move(BattlePassRequirement);
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreItemDataFunctionLibrary.MakeOnlineStoreItemDataBattlePassUnlock
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           OnlineServicesID                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AssetID                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOwned                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemBattlePassRequirementBattlePassRequirement                                  (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   Tags                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemData             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOnlineStoreItemData UOnlineStoreItemDataFunctionLibrary::MakeOnlineStoreItemDataBattlePassUnlock(const class FString& OnlineServicesID, const struct FGameplayTag& AssetID, const bool bIsOwned, const struct FOnlineStoreItemBattlePassRequirement& BattlePassRequirement, const TArray<class FString>& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreItemDataFunctionLibrary", "MakeOnlineStoreItemDataBattlePassUnlock");

	Params::OnlineStoreItemDataFunctionLibrary_MakeOnlineStoreItemDataBattlePassUnlock Parms{};

	Parms.OnlineServicesID = std::move(OnlineServicesID);
	Parms.AssetID = std::move(AssetID);
	Parms.bIsOwned = bIsOwned;
	Parms.BattlePassRequirement = std::move(BattlePassRequirement);
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreItemDataFunctionLibrary.MakeOnlineStoreItemDataNoUnlock
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           OnlineServicesID                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AssetID                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOwned                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class FString>                   Tags                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemData             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOnlineStoreItemData UOnlineStoreItemDataFunctionLibrary::MakeOnlineStoreItemDataNoUnlock(const class FString& OnlineServicesID, const struct FGameplayTag& AssetID, const bool bIsOwned, const TArray<class FString>& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreItemDataFunctionLibrary", "MakeOnlineStoreItemDataNoUnlock");

	Params::OnlineStoreItemDataFunctionLibrary_MakeOnlineStoreItemDataNoUnlock Parms{};

	Parms.OnlineServicesID = std::move(OnlineServicesID);
	Parms.AssetID = std::move(AssetID);
	Parms.bIsOwned = bIsOwned;
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreItemDataFunctionLibrary.MakeOnlineStoreItemDataVirtualCurrencyUnlock
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           OnlineServicesID                                       (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AssetID                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsOwned                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemCost             Cost                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// TArray<class FString>                   Tags                                                   (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemData             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FOnlineStoreItemData UOnlineStoreItemDataFunctionLibrary::MakeOnlineStoreItemDataVirtualCurrencyUnlock(const class FString& OnlineServicesID, const struct FGameplayTag& AssetID, const bool bIsOwned, const struct FOnlineStoreItemCost& Cost, const TArray<class FString>& Tags)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineStoreItemDataFunctionLibrary", "MakeOnlineStoreItemDataVirtualCurrencyUnlock");

	Params::OnlineStoreItemDataFunctionLibrary_MakeOnlineStoreItemDataVirtualCurrencyUnlock Parms{};

	Parms.OnlineServicesID = std::move(OnlineServicesID);
	Parms.AssetID = std::move(AssetID);
	Parms.bIsOwned = bIsOwned;
	Parms.Cost = std::move(Cost);
	Parms.Tags = std::move(Tags);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LobbyConfigurationWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyConfigurationViewModel     InModel                                                (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyConfigurationWidget::ApplyViewModel(const struct FLobbyConfigurationViewModel& InModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationWidget", "ApplyViewModel");

	Params::LobbyConfigurationWidget_ApplyViewModel Parms{};

	Parms.InModel = std::move(InModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyConfigurationWidget.OnLobbyCreationFailed
// (Final, Native, Protected)

void ULobbyConfigurationWidget::OnLobbyCreationFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationWidget", "OnLobbyCreationFailed");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyConfigurationWidget.OpenLobby
// (Final, Native, Protected, BlueprintCallable)

void ULobbyConfigurationWidget::OpenLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationWidget", "OpenLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyConfigurationWidget.SetBoolValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyConfigurationWidget::SetBoolValue(class UJPSettingWidget* InWidget, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationWidget", "SetBoolValue");

	Params::LobbyConfigurationWidget_SetBoolValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyConfigurationWidget.SetIntegerValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyConfigurationWidget::SetIntegerValue(class UJPSettingWidget* InWidget, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationWidget", "SetIntegerValue");

	Params::LobbyConfigurationWidget_SetIntegerValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyConfigurationWidget.SetStringValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InValue                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyConfigurationWidget::SetStringValue(class UJPSettingWidget* InWidget, const class FString& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationWidget", "SetStringValue");

	Params::LobbyConfigurationWidget_SetStringValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyConfigurationWidget.ShowCreateLobbyError
// (Event, Protected, BlueprintEvent)

void ULobbyConfigurationWidget::ShowCreateLobbyError()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationWidget", "ShowCreateLobbyError");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.LobbyConfigurationWidget.ShowCreateLobbyLoading
// (Event, Protected, BlueprintEvent)

void ULobbyConfigurationWidget::ShowCreateLobbyLoading()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyConfigurationWidget", "ShowCreateLobbyLoading");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.LobbyEventsReceiverInterface.PlayerJoinedLobby
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ILobbyEventsReceiverInterface::PlayerJoinedLobby(class APlayerStateJP_Lobby* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyEventsReceiverInterface", "PlayerJoinedLobby");

	Params::LobbyEventsReceiverInterface_PlayerJoinedLobby Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyEventsReceiverInterface.PlayerLeftLobby
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ILobbyEventsReceiverInterface::PlayerLeftLobby(class APlayerStateJP_Lobby* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyEventsReceiverInterface", "PlayerLeftLobby");

	Params::LobbyEventsReceiverInterface_PlayerLeftLobby Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyEventsWorldSubsystem.AddEventReceiver
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ILobbyEventsReceiverInterface>EventReceiver                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    AllowCatchUp                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULobbyEventsWorldSubsystem::AddEventReceiver(TScriptInterface<class ILobbyEventsReceiverInterface> EventReceiver, bool AllowCatchUp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyEventsWorldSubsystem", "AddEventReceiver");

	Params::LobbyEventsWorldSubsystem_AddEventReceiver Parms{};

	Parms.EventReceiver = EventReceiver;
	Parms.AllowCatchUp = AllowCatchUp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LobbyEventsWorldSubsystem.HandlePlayerStateAdded
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     AddedPlayerState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyEventsWorldSubsystem::HandlePlayerStateAdded(class APlayerState* AddedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyEventsWorldSubsystem", "HandlePlayerStateAdded");

	Params::LobbyEventsWorldSubsystem_HandlePlayerStateAdded Parms{};

	Parms.AddedPlayerState = AddedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyEventsWorldSubsystem.HandlePlayerStateRemoved
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     RemovedPlayerState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyEventsWorldSubsystem::HandlePlayerStateRemoved(class APlayerState* RemovedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyEventsWorldSubsystem", "HandlePlayerStateRemoved");

	Params::LobbyEventsWorldSubsystem_HandlePlayerStateRemoved Parms{};

	Parms.RemovedPlayerState = RemovedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyEventsWorldSubsystem.RemoveEventReceiver
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TScriptInterface<class ILobbyEventsReceiverInterface>EventReceiver                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULobbyEventsWorldSubsystem::RemoveEventReceiver(TScriptInterface<class ILobbyEventsReceiverInterface> EventReceiver)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyEventsWorldSubsystem", "RemoveEventReceiver");

	Params::LobbyEventsWorldSubsystem_RemoveEventReceiver Parms{};

	Parms.EventReceiver = EventReceiver;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LobbyFlowControllerStateComponent.OnExperienceLoaded
// (Final, Native, Private)
// Parameters:
// class UExperienceDefinition*            Experience                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyFlowControllerStateComponent::OnExperienceLoaded(const class UExperienceDefinition* Experience)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyFlowControllerStateComponent", "OnExperienceLoaded");

	Params::LobbyFlowControllerStateComponent_OnExperienceLoaded Parms{};

	Parms.Experience = Experience;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseSelectorWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyHouseSelectorViewModel     ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULobbyHouseSelectorWidget::ApplyViewModel(const struct FLobbyHouseSelectorViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseSelectorWidget", "ApplyViewModel");

	Params::LobbyHouseSelectorWidget_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyHouseSelectorWidget.HandlePlayerStateHouseIdentifierVoteChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OldHouseIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NewHouseIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseSelectorWidget::HandlePlayerStateHouseIdentifierVoteChanged(class APlayerStateJP_Lobby* PlayerState, const struct FGameplayTag& OldHouseIdentifier, const struct FGameplayTag& NewHouseIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseSelectorWidget", "HandlePlayerStateHouseIdentifierVoteChanged");

	Params::LobbyHouseSelectorWidget_HandlePlayerStateHouseIdentifierVoteChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.OldHouseIdentifier = std::move(OldHouseIdentifier);
	Parms.NewHouseIdentifier = std::move(NewHouseIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseSelectorWidget.HandlePlayerStateTeamHousePoolChanged
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseSelectorWidget::HandlePlayerStateTeamHousePoolChanged(class APlayerStateJP_Lobby* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseSelectorWidget", "HandlePlayerStateTeamHousePoolChanged");

	Params::LobbyHouseSelectorWidget_HandlePlayerStateTeamHousePoolChanged Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseSelectorWidget.HandlePlayerStateTeamIdChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   OldTeamID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewTeamID                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseSelectorWidget::HandlePlayerStateTeamIdChanged(class APlayerStateJP_Lobby* PlayerState, const uint8& OldTeamID, const uint8& NewTeamID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseSelectorWidget", "HandlePlayerStateTeamIdChanged");

	Params::LobbyHouseSelectorWidget_HandlePlayerStateTeamIdChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.OldTeamID = OldTeamID;
	Parms.NewTeamID = NewTeamID;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseSelectorWidget.HandlePlayerStateTracked
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     TrackedPlayerState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Initial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseSelectorWidget::HandlePlayerStateTracked(class APlayerState* TrackedPlayerState, bool Initial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseSelectorWidget", "HandlePlayerStateTracked");

	Params::LobbyHouseSelectorWidget_HandlePlayerStateTracked Parms{};

	Parms.TrackedPlayerState = TrackedPlayerState;
	Parms.Initial = Initial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseSelectorWidget.HandlePlayerStateUntracked
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     UntrackedPlayerState                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseSelectorWidget::HandlePlayerStateUntracked(class APlayerState* UntrackedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseSelectorWidget", "HandlePlayerStateUntracked");

	Params::LobbyHouseSelectorWidget_HandlePlayerStateUntracked Parms{};

	Parms.UntrackedPlayerState = UntrackedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseVotePlayerStateWatcher.HandlePlayerStateHouseIdentifierVoteChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     OldHouseIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NewHouseIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseVotePlayerStateWatcher::HandlePlayerStateHouseIdentifierVoteChanged(class APlayerStateJP* PlayerState, const struct FGameplayTag& OldHouseIdentifier, const struct FGameplayTag& NewHouseIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseVotePlayerStateWatcher", "HandlePlayerStateHouseIdentifierVoteChanged");

	Params::LobbyHouseVotePlayerStateWatcher_HandlePlayerStateHouseIdentifierVoteChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.OldHouseIdentifier = std::move(OldHouseIdentifier);
	Parms.NewHouseIdentifier = std::move(NewHouseIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseVotePlayerStateWatcher.HandlePlayerStateOwnedHouseChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FGameplayTag>             NewOwnedHouses                                         (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyHouseVotePlayerStateWatcher::HandlePlayerStateOwnedHouseChanged(class APlayerStateJP* PlayerState, const TArray<struct FGameplayTag>& NewOwnedHouses)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseVotePlayerStateWatcher", "HandlePlayerStateOwnedHouseChanged");

	Params::LobbyHouseVotePlayerStateWatcher_HandlePlayerStateOwnedHouseChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NewOwnedHouses = std::move(NewOwnedHouses);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseVotePlayerStateWatcher.HandlePlayerStateTeamHousePoolChanged
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseVotePlayerStateWatcher::HandlePlayerStateTeamHousePoolChanged(class APlayerStateJP* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseVotePlayerStateWatcher", "HandlePlayerStateTeamHousePoolChanged");

	Params::LobbyHouseVotePlayerStateWatcher_HandlePlayerStateTeamHousePoolChanged Parms{};

	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseVotePlayerStateWatcher.HandlePlayerStateTeamIdChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseVotePlayerStateWatcher::HandlePlayerStateTeamIdChanged(class APlayerStateJP* PlayerState, const uint8& TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseVotePlayerStateWatcher", "HandlePlayerStateTeamIdChanged");

	Params::LobbyHouseVotePlayerStateWatcher_HandlePlayerStateTeamIdChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseVotePlayerStateWatcher.HandlePlayerStateTracked
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     TrackedPlayerState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Initial                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseVotePlayerStateWatcher::HandlePlayerStateTracked(class APlayerState* TrackedPlayerState, bool Initial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseVotePlayerStateWatcher", "HandlePlayerStateTracked");

	Params::LobbyHouseVotePlayerStateWatcher_HandlePlayerStateTracked Parms{};

	Parms.TrackedPlayerState = TrackedPlayerState;
	Parms.Initial = Initial;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyHouseVotePlayerStateWatcher.HandlePlayerStateUntracked
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     UntrackedPlayerState                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyHouseVotePlayerStateWatcher::HandlePlayerStateUntracked(class APlayerState* UntrackedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyHouseVotePlayerStateWatcher", "HandlePlayerStateUntracked");

	Params::LobbyHouseVotePlayerStateWatcher_HandlePlayerStateUntracked Parms{};

	Parms.UntrackedPlayerState = UntrackedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PerkSelectEntry.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPerkSelectEntryViewModel        ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UPerkSelectEntry::ApplyViewModel(const struct FPerkSelectEntryViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkSelectEntry", "ApplyViewModel");

	Params::PerkSelectEntry_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.PerkSelectEntry.Clicked
// (Final, Native, Public, BlueprintCallable)

void UPerkSelectEntry::Clicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkSelectEntry", "Clicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyKickPlayerEntryWidget.AddPlayerState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class APlayerStateJP_Lobby*             InPlayerState                                          (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyKickPlayerEntryWidget::AddPlayerState(const class APlayerStateJP_Lobby* InPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyKickPlayerEntryWidget", "AddPlayerState");

	Params::LobbyKickPlayerEntryWidget_AddPlayerState Parms{};

	Parms.InPlayerState = InPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyKickPlayerEntryWidget.GetPlayerKickedBanReasonText
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULobbyKickPlayerEntryWidget::GetPlayerKickedBanReasonText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyKickPlayerEntryWidget", "GetPlayerKickedBanReasonText");

	Params::LobbyKickPlayerEntryWidget_GetPlayerKickedBanReasonText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.LobbyKickPlayerEntryWidget.OnKickButtonClicked
// (Final, Native, Private)

void ULobbyKickPlayerEntryWidget::OnKickButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyKickPlayerEntryWidget", "OnKickButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLevelVoteEntryWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyLevelVoteEntryViewModel    ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyLevelVoteEntryWidget::ApplyViewModel(const struct FLobbyLevelVoteEntryViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteEntryWidget", "ApplyViewModel");

	Params::LobbyLevelVoteEntryWidget_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyLevelVoteEntryWidget.DisableInteractivity
// (Event, Public, BlueprintEvent)

void ULobbyLevelVoteEntryWidget::DisableInteractivity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteEntryWidget", "DisableInteractivity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.LobbyLevelVoteEntryWidget.UpdateVoteCount
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8                                   NewVoteCount                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyLevelVoteEntryWidget::UpdateVoteCount(uint8 NewVoteCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteEntryWidget", "UpdateVoteCount");

	Params::LobbyLevelVoteEntryWidget_UpdateVoteCount Parms{};

	Parms.NewVoteCount = NewVoteCount;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyLevelVoteEntryWidget.VoteOnEntry
// (Final, Native, Protected, BlueprintCallable)

void ULobbyLevelVoteEntryWidget::VoteOnEntry()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteEntryWidget", "VoteOnEntry");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLevelVoteSelectedLevelWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyLevelVoteSelectedLevelViewModelViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyLevelVoteSelectedLevelWidget::ApplyViewModel(const struct FLobbyLevelVoteSelectedLevelViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteSelectedLevelWidget", "ApplyViewModel");

	Params::LobbyLevelVoteSelectedLevelWidget_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyLevelVoteWidget.DisableAllEntries
// (Final, Native, Private)

void ULobbyLevelVoteWidget::DisableAllEntries()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteWidget", "DisableAllEntries");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLevelVoteWidget.OnLevelVotesUpdated
// (Final, Native, Private)
// Parameters:
// uint8                                   UpdatedLevel                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   NewVoteCount                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyLevelVoteWidget::OnLevelVotesUpdated(const uint8 UpdatedLevel, const uint8 NewVoteCount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteWidget", "OnLevelVotesUpdated");

	Params::LobbyLevelVoteWidget_OnLevelVotesUpdated Parms{};

	Parms.UpdatedLevel = UpdatedLevel;
	Parms.NewVoteCount = NewVoteCount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLevelVoteWidget.OnVotingFinished
// (Final, Native, Private, HasOutParams)
// Parameters:
// struct FLevelVoteData                   ChosenLevel                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyLevelVoteWidget::OnVotingFinished(const struct FLevelVoteData& ChosenLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteWidget", "OnVotingFinished");

	Params::LobbyLevelVoteWidget_OnVotingFinished Parms{};

	Parms.ChosenLevel = std::move(ChosenLevel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLevelVoteWidget.PopulateOptions
// (Final, Native, Private)

void ULobbyLevelVoteWidget::PopulateOptions()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteWidget", "PopulateOptions");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLevelVoteWidget.VoteUpdated
// (Event, Public, BlueprintEvent)

void ULobbyLevelVoteWidget::VoteUpdated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteWidget", "VoteUpdated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.LobbyLevelVoteWidget.GetTotalVotes
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<uint8>                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<uint8> ULobbyLevelVoteWidget::GetTotalVotes() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLevelVoteWidget", "GetTotalVotes");

	Params::LobbyLevelVoteWidget_GetTotalVotes Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassRewardContent_CurrencyInterface.ApplyCurrencyViewModel
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSeasonPassRewardContent_CurrencyViewModelViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ISeasonPassRewardContent_CurrencyInterface::ApplyCurrencyViewModel(const struct FSeasonPassRewardContent_CurrencyViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassRewardContent_CurrencyInterface", "ApplyCurrencyViewModel");

	Params::SeasonPassRewardContent_CurrencyInterface_ApplyCurrencyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLocalPlayerSwitchTeamWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyLocalPlayerSwitchTeamViewModelViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULobbyLocalPlayerSwitchTeamWidget::ApplyViewModel(const struct FLobbyLocalPlayerSwitchTeamViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLocalPlayerSwitchTeamWidget", "ApplyViewModel");

	Params::LobbyLocalPlayerSwitchTeamWidget_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyLocalPlayerSwitchTeamWidget.HandleLocalPlayerStateSet
// (Final, Native, Protected)
// Parameters:
// class UCommonLocalPlayer*               CommonLocalPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyLocalPlayerSwitchTeamWidget::HandleLocalPlayerStateSet(class UCommonLocalPlayer* CommonLocalPlayer, class APlayerState* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLocalPlayerSwitchTeamWidget", "HandleLocalPlayerStateSet");

	Params::LobbyLocalPlayerSwitchTeamWidget_HandleLocalPlayerStateSet Parms{};

	Parms.CommonLocalPlayer = CommonLocalPlayer;
	Parms.PlayerState = PlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLocalPlayerSwitchTeamWidget.HandleTeamIdChanged
// (Final, Native, Protected, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyLocalPlayerSwitchTeamWidget::HandleTeamIdChanged(class APlayerStateJP* PlayerState, const uint8& TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLocalPlayerSwitchTeamWidget", "HandleTeamIdChanged");

	Params::LobbyLocalPlayerSwitchTeamWidget_HandleTeamIdChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyLocalPlayerSwitchTeamWidget.SwitchTeam
// (Final, Native, Public, BlueprintCallable)

void ULobbyLocalPlayerSwitchTeamWidget::SwitchTeam()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyLocalPlayerSwitchTeamWidget", "SwitchTeam");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyNeighborSelectorWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyNeighborSelectorViewModel  ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyNeighborSelectorWidget::ApplyViewModel(const struct FLobbyNeighborSelectorViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyNeighborSelectorWidget", "ApplyViewModel");

	Params::LobbyNeighborSelectorWidget_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyNeighborSelectorWidget.HandleNeighborIdChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NeighborIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyNeighborSelectorWidget::HandleNeighborIdChanged(class APlayerStateJP* PlayerState, const struct FGameplayTag& NeighborIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyNeighborSelectorWidget", "HandleNeighborIdChanged");

	Params::LobbyNeighborSelectorWidget_HandleNeighborIdChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NeighborIdentifier = std::move(NeighborIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyPlayerWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyPlayerAvatarViewModel      ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyPlayerWidget::ApplyViewModel(const struct FLobbyPlayerAvatarViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyPlayerWidget", "ApplyViewModel");

	Params::LobbyPlayerWidget_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyPlayerWidget.GetPlayerKickedBanReasonText
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ULobbyPlayerWidget::GetPlayerKickedBanReasonText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyPlayerWidget", "GetPlayerKickedBanReasonText");

	Params::LobbyPlayerWidget_GetPlayerKickedBanReasonText Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.LobbyPlayerWidget.OnKickButtonClicked
// (Final, Native, Private)

void ULobbyPlayerWidget::OnKickButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyPlayerWidget", "OnKickButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_MatchComponent.K2_OnPossessedPawnChanged
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerControllerJP_MatchComponent::K2_OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_MatchComponent", "K2_OnPossessedPawnChanged");

	Params::PlayerControllerJP_MatchComponent_K2_OnPossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.PlayerControllerJP_MatchComponent.OnPossessedPawnChanged
// (Final, Native, Protected)
// Parameters:
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerControllerJP_MatchComponent::OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_MatchComponent", "OnPossessedPawnChanged");

	Params::PlayerControllerJP_MatchComponent_OnPossessedPawnChanged Parms{};

	Parms.OldPawn = OldPawn;
	Parms.NewPawn = NewPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_MatchComponent.GetControlledPawn
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APawn*                            ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APawn* UPlayerControllerJP_MatchComponent::GetControlledPawn() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_MatchComponent", "GetControlledPawn");

	Params::PlayerControllerJP_MatchComponent_GetControlledPawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LobbyReadyComponent.OnRep_bAllPlayersReadyAndWaiting
// (Native, Protected)

void ULobbyReadyComponent::OnRep_bAllPlayersReadyAndWaiting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyReadyComponent", "OnRep_bAllPlayersReadyAndWaiting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyReadyStateWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyReadyStateViewModel        InViewModel                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULobbyReadyStateWidget::ApplyViewModel(const struct FLobbyReadyStateViewModel& InViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyReadyStateWidget", "ApplyViewModel");

	Params::LobbyReadyStateWidget_ApplyViewModel Parms{};

	Parms.InViewModel = std::move(InViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyReadyStateWidget.ForceTravel
// (Final, Native, Protected, BlueprintCallable)

void ULobbyReadyStateWidget::ForceTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyReadyStateWidget", "ForceTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyReadyStateWidget.HandleAbortCountdown
// (Final, Native, Protected)

void ULobbyReadyStateWidget::HandleAbortCountdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyReadyStateWidget", "HandleAbortCountdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyReadyStateWidget.HandleStartCountdown
// (Final, Native, Protected)
// Parameters:
// float                                   InDesiredTravelTimestamp                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyReadyStateWidget::HandleStartCountdown(float InDesiredTravelTimestamp)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyReadyStateWidget", "HandleStartCountdown");

	Params::LobbyReadyStateWidget_HandleStartCountdown Parms{};

	Parms.InDesiredTravelTimestamp = InDesiredTravelTimestamp;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyReadyStateWidget.OnReadyChanged
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP_Lobby*             InPS                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InReady                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyReadyStateWidget::OnReadyChanged(class APlayerStateJP_Lobby* InPS, bool InReady)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyReadyStateWidget", "OnReadyChanged");

	Params::LobbyReadyStateWidget_OnReadyChanged Parms{};

	Parms.InPS = InPS;
	Parms.InReady = InReady;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyReadyStateWidget.ReadyUp
// (Final, Native, Protected, BlueprintCallable)

void ULobbyReadyStateWidget::ReadyUp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyReadyStateWidget", "ReadyUp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.DisconnectLocalPlayer
// (Final, Native, Protected, BlueprintCallable)

void ULobbyTeamManagerWidget::DisconnectLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "DisconnectLocalPlayer");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandleIsInPartyChanged
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsInParty                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandleIsInPartyChanged(class APlayerStateJP* PlayerState, bool bIsInParty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandleIsInPartyChanged");

	Params::LobbyTeamManagerWidget_HandleIsInPartyChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.bIsInParty = bIsInParty;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandleJoinStatusChanged
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EPlayerStateJoinStatus                  JoinStatus                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandleJoinStatusChanged(class APlayerState* PlayerState, const EPlayerStateJoinStatus JoinStatus)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandleJoinStatusChanged");

	Params::LobbyTeamManagerWidget_HandleJoinStatusChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.JoinStatus = JoinStatus;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandleNeighborIdChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     NeighborIdentifier                                     (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandleNeighborIdChanged(class APlayerStateJP* PlayerState, const struct FGameplayTag& NeighborIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandleNeighborIdChanged");

	Params::LobbyTeamManagerWidget_HandleNeighborIdChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NeighborIdentifier = std::move(NeighborIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandlePlayerLoadoutChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPlayerLoadout                   NewLoadout                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandlePlayerLoadoutChanged(class APlayerStateJP* PlayerState, const struct FPlayerLoadout& NewLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandlePlayerLoadoutChanged");

	Params::LobbyTeamManagerWidget_HandlePlayerLoadoutChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NewLoadout = std::move(NewLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandlePlayerNameChanged
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Name_0                                                 (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandlePlayerNameChanged(class APlayerStateJP* PlayerState, const class FString& Name_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandlePlayerNameChanged");

	Params::LobbyTeamManagerWidget_HandlePlayerNameChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.Name_0 = std::move(Name_0);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandlePlayerStateAdded
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     AddedPlayerState                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandlePlayerStateAdded(class APlayerState* AddedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandlePlayerStateAdded");

	Params::LobbyTeamManagerWidget_HandlePlayerStateAdded Parms{};

	Parms.AddedPlayerState = AddedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandlePlayerStateRemoved
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     RemovedPlayerState                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandlePlayerStateRemoved(class APlayerState* RemovedPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandlePlayerStateRemoved");

	Params::LobbyTeamManagerWidget_HandlePlayerStateRemoved Parms{};

	Parms.RemovedPlayerState = RemovedPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandleReadyAndWaitingChanged
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bReadyAndWaiting                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandleReadyAndWaitingChanged(class APlayerStateJP_Lobby* PlayerState, const bool bReadyAndWaiting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandleReadyAndWaitingChanged");

	Params::LobbyTeamManagerWidget_HandleReadyAndWaitingChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.bReadyAndWaiting = bReadyAndWaiting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandleSlotRelocation
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP_Lobby*             InPlayerState                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandleSlotRelocation(class APlayerStateJP_Lobby* InPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandleSlotRelocation");

	Params::LobbyTeamManagerWidget_HandleSlotRelocation Parms{};

	Parms.InPlayerState = InPlayerState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandleTeamIdChanged
// (Final, Native, Private, HasOutParams)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandleTeamIdChanged(class APlayerStateJP* PlayerState, const uint8& TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandleTeamIdChanged");

	Params::LobbyTeamManagerWidget_HandleTeamIdChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.HandleUserAvatarChanged
// (Final, Native, Private)
// Parameters:
// class APlayerStateJP*                   PlayerState                                            (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UTexture2D>        NewAvatar                                              (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::HandleUserAvatarChanged(class APlayerStateJP* PlayerState, TSoftObjectPtr<class UTexture2D> NewAvatar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "HandleUserAvatarChanged");

	Params::LobbyTeamManagerWidget_HandleUserAvatarChanged Parms{};

	Parms.PlayerState = PlayerState;
	Parms.NewAvatar = NewAvatar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamManagerWidget.PushConfirmPlayWithBlockedPlayerPrompt
// (Event, Protected, BlueprintEvent)
// Parameters:
// class APlayerStateJP_Lobby*             PlayerState                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::PushConfirmPlayWithBlockedPlayerPrompt(const class APlayerStateJP_Lobby* PlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "PushConfirmPlayWithBlockedPlayerPrompt");

	Params::LobbyTeamManagerWidget_PushConfirmPlayWithBlockedPlayerPrompt Parms{};

	Parms.PlayerState = PlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyTeamManagerWidget.SetAllSlotsVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InVisibility                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTeamManagerWidget::SetAllSlotsVisibility(bool InVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamManagerWidget", "SetAllSlotsVisibility");

	Params::LobbyTeamManagerWidget_SetAllSlotsVisibility Parms{};

	Parms.InVisibility = InVisibility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP_ReplicationMonitorComponent.HandlePawnSet
// (Final, Native, Private)
// Parameters:
// class APlayerState*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            NewPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            OldPawn                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerStateJP_ReplicationMonitorComponent::HandlePawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_ReplicationMonitorComponent", "HandlePawnSet");

	Params::PlayerStateJP_ReplicationMonitorComponent_HandlePawnSet Parms{};

	Parms.Player = Player;
	Parms.NewPawn = NewPawn;
	Parms.OldPawn = OldPawn;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP_ReplicationMonitorComponent.IsFullyReplicatedForHUD
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPlayerStateJP_ReplicationMonitorComponent::IsFullyReplicatedForHUD() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_ReplicationMonitorComponent", "IsFullyReplicatedForHUD");

	Params::PlayerStateJP_ReplicationMonitorComponent_IsFullyReplicatedForHUD Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP_ReplicationMonitorComponent.LogReplicationStatus
// (Final, Native, Public, BlueprintCallable, Const)

void UPlayerStateJP_ReplicationMonitorComponent::LogReplicationStatus() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_ReplicationMonitorComponent", "LogReplicationStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamPlayerWorldSlotActor.HandlePreviewClassLoaded
// (Final, Native, Private)
// Parameters:
// TSoftClassPtr<class UClass>             InPreviewClass                                         (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALobbyTeamPlayerWorldSlotActor::HandlePreviewClassLoaded(TSoftClassPtr<class UClass> InPreviewClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamPlayerWorldSlotActor", "HandlePreviewClassLoaded");

	Params::LobbyTeamPlayerWorldSlotActor_HandlePreviewClassLoaded Parms{};

	Parms.InPreviewClass = InPreviewClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTeamPlayerWorldSlotActor.HandleSkinLoaded
// (Final, Native, Private)
// Parameters:
// TSoftObjectPtr<class UNeighborSkinDefinition>InNeighborSkinDefinition                               (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ALobbyTeamPlayerWorldSlotActor::HandleSkinLoaded(TSoftObjectPtr<class UNeighborSkinDefinition> InNeighborSkinDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTeamPlayerWorldSlotActor", "HandleSkinLoaded");

	Params::LobbyTeamPlayerWorldSlotActor_HandleSkinLoaded Parms{};

	Parms.InNeighborSkinDefinition = InNeighborSkinDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PerkAction.GetDefinition
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UPerkDefinition*                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkDefinition* UPerkAction::GetDefinition() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkAction", "GetDefinition");

	Params::PerkAction_GetDefinition Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkAction_AbilityActivatedBase.OnAbilityActivated
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FGameplayAbilitySpecHandle       Handle                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UGameplayAbility*                 Ability                                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPerkAction_AbilityActivatedBase::OnAbilityActivated(const struct FGameplayAbilitySpecHandle& Handle, class UGameplayAbility* Ability)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkAction_AbilityActivatedBase", "OnAbilityActivated");

	Params::PerkAction_AbilityActivatedBase_OnAbilityActivated Parms{};

	Parms.Handle = std::move(Handle);
	Parms.Ability = Ability;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LobbyTravelComponent.HandleAllPlayersReadyAndWaiting
// (Final, Native, Private)
// Parameters:
// bool                                    bInReadyAndWaitingState                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTravelComponent::HandleAllPlayersReadyAndWaiting(bool bInReadyAndWaitingState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTravelComponent", "HandleAllPlayersReadyAndWaiting");

	Params::LobbyTravelComponent_HandleAllPlayersReadyAndWaiting Parms{};

	Parms.bInReadyAndWaitingState = bInReadyAndWaitingState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTravelComponent.OnRep_ServerTravelTimestamp
// (Final, Native, Private)

void ULobbyTravelComponent::OnRep_ServerTravelTimestamp()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTravelComponent", "OnRep_ServerTravelTimestamp");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTravelComponent.Server_AbortTravel
// (Net, NetReliable, Native, Event, Public, NetServer)

void ULobbyTravelComponent::Server_AbortTravel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTravelComponent", "Server_AbortTravel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTravelComponent.Server_QueueTravel
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// bool                                    bInDoCountdown                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInAllowAbort                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULobbyTravelComponent::Server_QueueTravel(bool bInDoCountdown, bool bInAllowAbort)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTravelComponent", "Server_QueueTravel");

	Params::LobbyTravelComponent_Server_QueueTravel Parms{};

	Parms.bInDoCountdown = bInDoCountdown;
	Parms.bInAllowAbort = bInAllowAbort;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTravelComponent.Travel
// (Final, Native, Private)

void ULobbyTravelComponent::Travel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTravelComponent", "Travel");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LobbyTravelCountdownWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FLobbyCountdownViewModel         InModel                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ULobbyTravelCountdownWidget::ApplyViewModel(const struct FLobbyCountdownViewModel& InModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LobbyTravelCountdownWidget", "ApplyViewModel");

	Params::LobbyTravelCountdownWidget_ApplyViewModel Parms{};

	Parms.InModel = std::move(InModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.SocialPartyInvitesListWidget.UpdatePartyInvitesList
// (Final, Native, Private)

void USocialPartyInvitesListWidget::UpdatePartyInvitesList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyInvitesListWidget", "UpdatePartyInvitesList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalRotationRateMeasurer.SetSceneComponentToMeasure
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class USceneComponent*                  SceneComponent                                         (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalRotationRateMeasurer::SetSceneComponentToMeasure(class USceneComponent* SceneComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalRotationRateMeasurer", "SetSceneComponentToMeasure");

	Params::LocalRotationRateMeasurer_SetSceneComponentToMeasure Parms{};

	Parms.SceneComponent = SceneComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerProgressionFunctionLibrary.GetProfileLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ProfileXP                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerProgressionFunctionLibrary::GetProfileLevel(const int32 ProfileXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerProgressionFunctionLibrary", "GetProfileLevel");

	Params::PlayerProgressionFunctionLibrary_GetProfileLevel Parms{};

	Parms.ProfileXP = ProfileXP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerProgressionFunctionLibrary.GetProgressBetweenProfileLevels
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ProfileXP                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   FromProfileLevelInclusive                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ToProfileLevelInclusive                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerProgressionFunctionLibrary::GetProgressBetweenProfileLevels(const int32 ProfileXP, const int32 FromProfileLevelInclusive, const int32 ToProfileLevelInclusive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerProgressionFunctionLibrary", "GetProgressBetweenProfileLevels");

	Params::PlayerProgressionFunctionLibrary_GetProgressBetweenProfileLevels Parms{};

	Parms.ProfileXP = ProfileXP;
	Parms.FromProfileLevelInclusive = FromProfileLevelInclusive;
	Parms.ToProfileLevelInclusive = ToProfileLevelInclusive;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerProgressionFunctionLibrary.GetProgressTowardNextProfileLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   ProfileXP                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UPlayerProgressionFunctionLibrary::GetProgressTowardNextProfileLevel(const int32 ProfileXP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerProgressionFunctionLibrary", "GetProgressTowardNextProfileLevel");

	Params::PlayerProgressionFunctionLibrary_GetProgressTowardNextProfileLevel Parms{};

	Parms.ProfileXP = ProfileXP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerProgressionFunctionLibrary.GetTotalXPRequirementForProfileLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   Level                                                  (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerProgressionFunctionLibrary::GetTotalXPRequirementForProfileLevel(const int32 Level)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerProgressionFunctionLibrary", "GetTotalXPRequirementForProfileLevel");

	Params::PlayerProgressionFunctionLibrary_GetTotalXPRequirementForProfileLevel Parms{};

	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerProgressionFunctionLibrary.GetXPRequirementForNextProfileLevel
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// int32                                   CurrentLevel                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UPlayerProgressionFunctionLibrary::GetXPRequirementForNextProfileLevel(const int32 CurrentLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PlayerProgressionFunctionLibrary", "GetXPRequirementForNextProfileLevel");

	Params::PlayerProgressionFunctionLibrary_GetXPRequirementForNextProfileLevel Parms{};

	Parms.CurrentLevel = CurrentLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetDisplayName
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULocalUserOnlineServicesGameInstanceSubsystem::GetDisplayName()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetDisplayName");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetDisplayName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.HandleShutdown
// (Final, Native, Public, BlueprintCallable)

void ULocalUserOnlineServicesGameInstanceSubsystem::HandleShutdown()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "HandleShutdown");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.PushEndOfPlaytestWidget
// (Final, Native, Public, BlueprintCallable)

void ULocalUserOnlineServicesGameInstanceSubsystem::PushEndOfPlaytestWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "PushEndOfPlaytestWidget");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.SavePlayerLoadout
// (Final, Native, Public, BlueprintCallable)

void ULocalUserOnlineServicesGameInstanceSubsystem::SavePlayerLoadout()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "SavePlayerLoadout");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.SetDefaultNeighborID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalUserOnlineServicesGameInstanceSubsystem::SetDefaultNeighborID(const struct FGameplayTag& NeighborID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "SetDefaultNeighborID");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_SetDefaultNeighborID Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.SetHouseID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     HouseID                                                (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalUserOnlineServicesGameInstanceSubsystem::SetHouseID(const struct FGameplayTag& HouseID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "SetHouseID");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_SetHouseID Parms{};

	Parms.HouseID = std::move(HouseID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.SetItemSkin
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ItemId                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     SkinID                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalUserOnlineServicesGameInstanceSubsystem::SetItemSkin(const struct FGameplayTag& NeighborID, const struct FGameplayTag& ItemId, const struct FGameplayTag& SkinID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "SetItemSkin");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_SetItemSkin Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.ItemId = std::move(ItemId);
	Parms.SkinID = std::move(SkinID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.SetNeighborLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNeighborLoadout                 NeighborLoadout                                        (Parm, NativeAccessSpecifierPublic)

void ULocalUserOnlineServicesGameInstanceSubsystem::SetNeighborLoadout(const struct FGameplayTag& NeighborID, const struct FNeighborLoadout& NeighborLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "SetNeighborLoadout");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_SetNeighborLoadout Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.NeighborLoadout = std::move(NeighborLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.SetNeighborSkin
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     SkinID                                                 (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalUserOnlineServicesGameInstanceSubsystem::SetNeighborSkin(const struct FGameplayTag& NeighborID, const struct FGameplayTag& SkinID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "SetNeighborSkin");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_SetNeighborSkin Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.SkinID = std::move(SkinID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetCharacterXP
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULocalUserOnlineServicesGameInstanceSubsystem::GetCharacterXP(const struct FGameplayTag& NeighborID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetCharacterXP");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetCharacterXP Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetDefaultNeighborID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ULocalUserOnlineServicesGameInstanceSubsystem::GetDefaultNeighborID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetDefaultNeighborID");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetDefaultNeighborID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetHouseID
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ULocalUserOnlineServicesGameInstanceSubsystem::GetHouseID() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetHouseID");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetHouseID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetNeighborLoadout
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FNeighborLoadout                 ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FNeighborLoadout ULocalUserOnlineServicesGameInstanceSubsystem::GetNeighborLoadout(const struct FGameplayTag& NeighborID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetNeighborLoadout");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetNeighborLoadout Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetPlayerLoadout
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FPlayerLoadout                   ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPlayerLoadout ULocalUserOnlineServicesGameInstanceSubsystem::GetPlayerLoadout() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetPlayerLoadout");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetPlayerLoadout Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetPlaytestTimeLeftString
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   DaysLeft                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   HoursLeft                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   MinutesLeft                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   SecondsLeft                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULocalUserOnlineServicesGameInstanceSubsystem::GetPlaytestTimeLeftString(int32* DaysLeft, int32* HoursLeft, int32* MinutesLeft, int32* SecondsLeft) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetPlaytestTimeLeftString");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetPlaytestTimeLeftString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (DaysLeft != nullptr)
		*DaysLeft = Parms.DaysLeft;

	if (HoursLeft != nullptr)
		*HoursLeft = Parms.HoursLeft;

	if (MinutesLeft != nullptr)
		*MinutesLeft = Parms.MinutesLeft;

	if (SecondsLeft != nullptr)
		*SecondsLeft = Parms.SecondsLeft;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetProfileXP
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULocalUserOnlineServicesGameInstanceSubsystem::GetProfileXP() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetProfileXP");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetProfileXP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.GetUserAvatar
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UTexture2D*                       ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UTexture2D* ULocalUserOnlineServicesGameInstanceSubsystem::GetUserAvatar() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "GetUserAvatar");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_GetUserAvatar Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.HasPlaytestEnded
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocalUserOnlineServicesGameInstanceSubsystem::HasPlaytestEnded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "HasPlaytestEnded");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_HasPlaytestEnded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LocalUserOnlineServicesGameInstanceSubsystem.IsPlaytestInProgress
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULocalUserOnlineServicesGameInstanceSubsystem::IsPlaytestInProgress() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LocalUserOnlineServicesGameInstanceSubsystem", "IsPlaytestInProgress");

	Params::LocalUserOnlineServicesGameInstanceSubsystem_IsPlaytestInProgress Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialPartyMemberEntryWidget.GetLocalizedStatusInfo
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// class FText                             StatusText                                             (Parm, OutParm, NativeAccessSpecifierPublic)
// struct FLinearColor                     Color                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialPartyMemberEntryWidget::GetLocalizedStatusInfo(class FText* StatusText, struct FLinearColor* Color)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyMemberEntryWidget", "GetLocalizedStatusInfo");

	Params::SocialPartyMemberEntryWidget_GetLocalizedStatusInfo Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (StatusText != nullptr)
		*StatusText = std::move(Parms.StatusText);

	if (Color != nullptr)
		*Color = std::move(Parms.Color);
}


// Function JP.SocialPartyMemberEntryWidget.SetStatus
// (Final, Native, Public, BlueprintCallable)

void USocialPartyMemberEntryWidget::SetStatus()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyMemberEntryWidget", "SetStatus");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialRecentPlayerEntryWidget.GetFormattedLastSeenTimeSpan
// (Event, Protected, HasOutParams, HasDefaults, BlueprintEvent)
// Parameters:
// struct FTimespan                        LastSeenTimespan                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText USocialRecentPlayerEntryWidget::GetFormattedLastSeenTimeSpan(const struct FTimespan& LastSeenTimespan)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialRecentPlayerEntryWidget", "GetFormattedLastSeenTimeSpan");

	Params::SocialRecentPlayerEntryWidget_GetFormattedLastSeenTimeSpan Parms{};

	Parms.LastSeenTimespan = std::move(LastSeenTimespan);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.SocialRecentPlayerEntryWidget.SetLastSeen
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FDateTime                        LastSeen                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialRecentPlayerEntryWidget::SetLastSeen(const struct FDateTime& LastSeen)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialRecentPlayerEntryWidget", "SetLastSeen");

	Params::SocialRecentPlayerEntryWidget_SetLastSeen Parms{};

	Parms.LastSeen = std::move(LastSeen);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialWidget.HandleOnHostGoToNewLobbyPrompted
// (Event, Protected, BlueprintEvent)

void USocialWidget::HandleOnHostGoToNewLobbyPrompted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialWidget", "HandleOnHostGoToNewLobbyPrompted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.SocialWidget.OnFailedToJoinPartyCallback
// (Event, Protected, BlueprintEvent)

void USocialWidget::OnFailedToJoinPartyCallback()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialWidget", "OnFailedToJoinPartyCallback");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.SocialWidget.ToggleHidableWidgets
// (Final, Native, Public, BlueprintCallable)

void USocialWidget::ToggleHidableWidgets()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialWidget", "ToggleHidableWidgets");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialWidget.ToggleSocialListState
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UUserWidget*                      ToggledWidget                                          (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialWidget::ToggleSocialListState(class UUserWidget* ToggledWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialWidget", "ToggleSocialListState");

	Params::SocialWidget_ToggleSocialListState Parms{};

	Parms.ToggledWidget = ToggledWidget;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialWidget.OnHostAcceptLeaveLobbyPrompt
// (Final, Native, Protected, BlueprintCallable, Const)

void USocialWidget::OnHostAcceptLeaveLobbyPrompt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialWidget", "OnHostAcceptLeaveLobbyPrompt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialWidget.OnHostDeclineLeaveLobbyPrompt
// (Final, Native, Protected, BlueprintCallable, Const)

void USocialWidget::OnHostDeclineLeaveLobbyPrompt() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialWidget", "OnHostDeclineLeaveLobbyPrompt");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandshakePlayerControllerComponent.Server_ChangeSelectedNeighborIdentifier
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FGameplayTag                     NewNeighborIdentifier                                  (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerJoinHandshakePlayerControllerComponent::Server_ChangeSelectedNeighborIdentifier(const struct FGameplayTag& NewNeighborIdentifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandshakePlayerControllerComponent", "Server_ChangeSelectedNeighborIdentifier");

	Params::PlayerJoinHandshakePlayerControllerComponent_Server_ChangeSelectedNeighborIdentifier Parms{};

	Parms.NewNeighborIdentifier = std::move(NewNeighborIdentifier);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandshakePlayerControllerComponent.Server_ResolveRandomNeighborSelection
// (Final, Net, NetReliable, Native, Event, Private, NetServer)

void UPlayerJoinHandshakePlayerControllerComponent::Server_ResolveRandomNeighborSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandshakePlayerControllerComponent", "Server_ResolveRandomNeighborSelection");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandshakePlayerControllerComponent.Server_SetBlockedList
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// TArray<class FString>                   SerializedBlockedIDs                                   (ConstParm, Parm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerJoinHandshakePlayerControllerComponent::Server_SetBlockedList(const TArray<class FString>& SerializedBlockedIDs)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandshakePlayerControllerComponent", "Server_SetBlockedList");

	Params::PlayerJoinHandshakePlayerControllerComponent_Server_SetBlockedList Parms{};

	Parms.SerializedBlockedIDs = std::move(SerializedBlockedIDs);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandshakePlayerControllerComponent.Server_SetConfirmedJoin
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void UPlayerJoinHandshakePlayerControllerComponent::Server_SetConfirmedJoin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandshakePlayerControllerComponent", "Server_SetConfirmedJoin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerJoinHandshakePlayerControllerComponent.Server_SetPlayerLoadout
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// struct FPlayerLoadout                   NewLoadout                                             (ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)

void UPlayerJoinHandshakePlayerControllerComponent::Server_SetPlayerLoadout(const struct FPlayerLoadout& NewLoadout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerJoinHandshakePlayerControllerComponent", "Server_SetPlayerLoadout");

	Params::PlayerJoinHandshakePlayerControllerComponent_Server_SetPlayerLoadout Parms{};

	Parms.NewLoadout = std::move(NewLoadout);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.RoomControllerComponent.ServerUpgradeRoom
// (Net, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// class ARoomManager*                     RoomManager                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void URoomControllerComponent::ServerUpgradeRoom(const class ARoomManager* RoomManager)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomControllerComponent", "ServerUpgradeRoom");

	Params::RoomControllerComponent_ServerUpgradeRoom Parms{};

	Parms.RoomManager = RoomManager;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraPlatformEmulationSettings.GetKnownDeviceProfiles
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULyraPlatformEmulationSettings::GetKnownDeviceProfiles() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlatformEmulationSettings", "GetKnownDeviceProfiles");

	Params::LyraPlatformEmulationSettings_GetKnownDeviceProfiles Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraPlatformEmulationSettings.GetKnownPlatformIds
// (Final, Native, Private, Const)
// Parameters:
// TArray<class FName>                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class FName> ULyraPlatformEmulationSettings::GetKnownPlatformIds() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPlatformEmulationSettings", "GetKnownPlatformIds");

	Params::LyraPlatformEmulationSettings_GetKnownPlatformIds Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ProjectSettingsJP.GetProjectSettings
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UProjectSettingsJP*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UProjectSettingsJP* UProjectSettingsJP::GetProjectSettings()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ProjectSettingsJP", "GetProjectSettings");

	Params::ProjectSettingsJP_GetProjectSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSafeZoneEditor.HandleBackClicked
// (Final, Native, Private)

void ULyraSafeZoneEditor::HandleBackClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSafeZoneEditor", "HandleBackClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSafeZoneEditor.HandleDoneClicked
// (Final, Native, Private)

void ULyraSafeZoneEditor::HandleDoneClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSafeZoneEditor", "HandleDoneClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SeasonPassContainerWidgetBase.ApplyViewModel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSeasonPassContainerViewModel    ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void USeasonPassContainerWidgetBase::ApplyViewModel(const struct FSeasonPassContainerViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassContainerWidgetBase", "ApplyViewModel");

	Params::SeasonPassContainerWidgetBase_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.SeasonPassContainerWidgetBase.SeasonPassIsAvailable
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USeasonPassContainerWidgetBase::SeasonPassIsAvailable()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassContainerWidgetBase", "SeasonPassIsAvailable");

	Params::SeasonPassContainerWidgetBase_SeasonPassIsAvailable Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.NeighborSpecialAbilityWidgetProvider.GetWidgetTypes
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<TSubclassOf<class UUserWidget>>  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, UObjectWrapper, NativeAccessSpecifierPublic)

TArray<TSubclassOf<class UUserWidget>> INeighborSpecialAbilityWidgetProvider::GetWidgetTypes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSpecialAbilityWidgetProvider", "GetWidgetTypes");

	Params::NeighborSpecialAbilityWidgetProvider_GetWidgetTypes Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// DelegateFunction JP.LyraSettingsLocal.BoolSettingChanged__DelegateSignature
// (MulticastDelegate, Public, Delegate)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::BoolSettingChanged__DelegateSignature(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "BoolSettingChanged__DelegateSignature");

	Params::LyraSettingsLocal_BoolSettingChanged__DelegateSignature Parms{};

	Parms.IsEnabled = IsEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.LyraSettingsLocal.IsHighContrastEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsHighContrastEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsHighContrastEnabled");

	Params::LyraSettingsLocal_IsHighContrastEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.IsMotionBlurEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsMotionBlurEnabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsMotionBlurEnabled");

	Params::LyraSettingsLocal_IsMotionBlurEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.RunAutoBenchmark
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bSaveImmediately                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::RunAutoBenchmark(bool bSaveImmediately)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "RunAutoBenchmark");

	Params::LyraSettingsLocal_RunAutoBenchmark Parms{};

	Parms.bSaveImmediately = bSaveImmediately;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetActivateVoiceChatUponDeathEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetActivateVoiceChatUponDeathEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetActivateVoiceChatUponDeathEnabled");

	Params::LyraSettingsLocal_SetActivateVoiceChatUponDeathEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetAimAssist
// (Final, Native, Public)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetAimAssist(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetAimAssist");

	Params::LyraSettingsLocal_SetAimAssist Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetAudioInputDeviceId
// (Final, Native, Public)
// Parameters:
// class FString                           InAudioInputDeviceId                                   (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetAudioInputDeviceId(const class FString& InAudioInputDeviceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetAudioInputDeviceId");

	Params::LyraSettingsLocal_SetAudioInputDeviceId Parms{};

	Parms.InAudioInputDeviceId = std::move(InAudioInputDeviceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetAudioOutputDeviceId
// (Final, Native, Public)
// Parameters:
// class FString                           InAudioOutputDeviceId                                  (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetAudioOutputDeviceId(const class FString& InAudioOutputDeviceId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetAudioOutputDeviceId");

	Params::LyraSettingsLocal_SetAudioOutputDeviceId Parms{};

	Parms.InAudioOutputDeviceId = std::move(InAudioOutputDeviceId);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetCommunicationEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetCommunicationEnabled(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetCommunicationEnabled");

	Params::LyraSettingsLocal_SetCommunicationEnabled Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetControllerPlatform
// (Final, Native, Public)
// Parameters:
// class FName                             InControllerPlatform                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetControllerPlatform(const class FName InControllerPlatform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetControllerPlatform");

	Params::LyraSettingsLocal_SetControllerPlatform Parms{};

	Parms.InControllerPlatform = InControllerPlatform;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetCrouchToggle
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetCrouchToggle(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetCrouchToggle");

	Params::LyraSettingsLocal_SetCrouchToggle Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetDesiredDeviceProfileQualitySuffix
// (Final, Native, Public)
// Parameters:
// class FString                           InDesiredSuffix                                        (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetDesiredDeviceProfileQualitySuffix(const class FString& InDesiredSuffix)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetDesiredDeviceProfileQualitySuffix");

	Params::LyraSettingsLocal_SetDesiredDeviceProfileQualitySuffix Parms{};

	Parms.InDesiredSuffix = std::move(InDesiredSuffix);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetDialogueVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetDialogueVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetDialogueVolume");

	Params::LyraSettingsLocal_SetDialogueVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetDisplayGamma
// (Final, Native, Public)
// Parameters:
// float                                   InGamma                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetDisplayGamma(float InGamma)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetDisplayGamma");

	Params::LyraSettingsLocal_SetDisplayGamma Parms{};

	Parms.InGamma = InGamma;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetFrameRateLimit_Always
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimit_Always(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimit_Always");

	Params::LyraSettingsLocal_SetFrameRateLimit_Always Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetFrameRateLimit_InMenu
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimit_InMenu(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimit_InMenu");

	Params::LyraSettingsLocal_SetFrameRateLimit_InMenu Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetFrameRateLimit_OnBattery
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimit_OnBattery(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimit_OnBattery");

	Params::LyraSettingsLocal_SetFrameRateLimit_OnBattery Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetFrameRateLimit_WhenBackgrounded
// (Final, Native, Public)
// Parameters:
// float                                   NewLimitFPS                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFrameRateLimit_WhenBackgrounded(float NewLimitFPS)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFrameRateLimit_WhenBackgrounded");

	Params::LyraSettingsLocal_SetFrameRateLimit_WhenBackgrounded Parms{};

	Parms.NewLimitFPS = NewLimitFPS;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetFXAAQuality
// (Final, Native, Public)
// Parameters:
// int32                                   Quality                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetFXAAQuality(int32 Quality)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetFXAAQuality");

	Params::LyraSettingsLocal_SetFXAAQuality Parms{};

	Parms.Quality = Quality;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetHDRAudioModeEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetHDRAudioModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetHDRAudioModeEnabled");

	Params::LyraSettingsLocal_SetHDRAudioModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetHeadphoneModeEnabled
// (Final, Native, Public)
// Parameters:
// bool                                    bEnabled                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetHeadphoneModeEnabled(bool bEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetHeadphoneModeEnabled");

	Params::LyraSettingsLocal_SetHeadphoneModeEnabled Parms{};

	Parms.bEnabled = bEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetHidePlayerNames
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetHidePlayerNames(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetHidePlayerNames");

	Params::LyraSettingsLocal_SetHidePlayerNames Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetHighContrast
// (Final, Native, Public)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetHighContrast(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetHighContrast");

	Params::LyraSettingsLocal_SetHighContrast Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetIsTestingMicrophone
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetIsTestingMicrophone(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetIsTestingMicrophone");

	Params::LyraSettingsLocal_SetIsTestingMicrophone Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetMicrophoneVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetMicrophoneVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetMicrophoneVolume");

	Params::LyraSettingsLocal_SetMicrophoneVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetMotionBlur
// (Final, Native, Public)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetMotionBlur(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetMotionBlur");

	Params::LyraSettingsLocal_SetMotionBlur Parms{};

	Parms.IsEnabled = IsEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetMSAASampleCount
// (Final, Native, Public)
// Parameters:
// int32                                   Samples                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetMSAASampleCount(int32 Samples)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetMSAASampleCount");

	Params::LyraSettingsLocal_SetMSAASampleCount Parms{};

	Parms.Samples = Samples;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetMusicVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetMusicVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetMusicVolume");

	Params::LyraSettingsLocal_SetMusicVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetOverallVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetOverallVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetOverallVolume");

	Params::LyraSettingsLocal_SetOverallVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetRegionOverride
// (Final, Native, Public)
// Parameters:
// ERegionOverride                         NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetRegionOverride(ERegionOverride NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetRegionOverride");

	Params::LyraSettingsLocal_SetRegionOverride Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetSafeZone
// (Final, Native, Public)
// Parameters:
// float                                   Value                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSafeZone(float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSafeZone");

	Params::LyraSettingsLocal_SetSafeZone Parms{};

	Parms.Value = Value;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetScreenPercentage
// (Final, Native, Public)
// Parameters:
// int32                                   Percentage                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetScreenPercentage(int32 Percentage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetScreenPercentage");

	Params::LyraSettingsLocal_SetScreenPercentage Parms{};

	Parms.Percentage = Percentage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetShowTooltips
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetShowTooltips(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetShowTooltips");

	Params::LyraSettingsLocal_SetShowTooltips Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetSoundFXVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSoundFXVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSoundFXVolume");

	Params::LyraSettingsLocal_SetSoundFXVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetSprintToggle
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSprintToggle(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSprintToggle");

	Params::LyraSettingsLocal_SetSprintToggle Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetSprintToggleController
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSprintToggleController(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSprintToggleController");

	Params::LyraSettingsLocal_SetSprintToggleController Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetSuperResolutionMode
// (Final, Native, Public)
// Parameters:
// int32                                   SuperSamplingMode                                      (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSuperResolutionMode(int32 SuperSamplingMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSuperResolutionMode");

	Params::LyraSettingsLocal_SetSuperResolutionMode Parms{};

	Parms.SuperSamplingMode = SuperSamplingMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetSuperResolutionQualityMode
// (Final, Native, Public)
// Parameters:
// int32                                   QualityMode                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetSuperResolutionQualityMode(int32 QualityMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetSuperResolutionQualityMode");

	Params::LyraSettingsLocal_SetSuperResolutionQualityMode Parms{};

	Parms.QualityMode = QualityMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetVoiceChatToggle
// (Final, Native, Public)
// Parameters:
// bool                                    NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetVoiceChatToggle(bool NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetVoiceChatToggle");

	Params::LyraSettingsLocal_SetVoiceChatToggle Parms{};

	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.SetVoiceChatVolume
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   InVolume                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingsLocal::SetVoiceChatVolume(float InVolume)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "SetVoiceChatVolume");

	Params::LyraSettingsLocal_SetVoiceChatVolume Parms{};

	Parms.InVolume = InVolume;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingsLocal.CanModifyHeadphoneModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::CanModifyHeadphoneModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "CanModifyHeadphoneModeEnabled");

	Params::LyraSettingsLocal_CanModifyHeadphoneModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.CanRunAutoBenchmark
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::CanRunAutoBenchmark() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "CanRunAutoBenchmark");

	Params::LyraSettingsLocal_CanRunAutoBenchmark Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetAudioInputDeviceId
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULyraSettingsLocal::GetAudioInputDeviceId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetAudioInputDeviceId");

	Params::LyraSettingsLocal_GetAudioInputDeviceId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetAudioOutputDeviceId
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULyraSettingsLocal::GetAudioOutputDeviceId() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetAudioOutputDeviceId");

	Params::LyraSettingsLocal_GetAudioOutputDeviceId Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetCommunicationEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetCommunicationEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetCommunicationEnabled");

	Params::LyraSettingsLocal_GetCommunicationEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetControllerPlatform
// (Final, Native, Public, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName ULyraSettingsLocal::GetControllerPlatform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetControllerPlatform");

	Params::LyraSettingsLocal_GetControllerPlatform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetCrouchToggle
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetCrouchToggle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetCrouchToggle");

	Params::LyraSettingsLocal_GetCrouchToggle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetDesiredDeviceProfileQualitySuffix
// (Final, Native, Public, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString ULyraSettingsLocal::GetDesiredDeviceProfileQualitySuffix() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDesiredDeviceProfileQualitySuffix");

	Params::LyraSettingsLocal_GetDesiredDeviceProfileQualitySuffix Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetDialogueVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetDialogueVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDialogueVolume");

	Params::LyraSettingsLocal_GetDialogueVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetDisplayGamma
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetDisplayGamma() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetDisplayGamma");

	Params::LyraSettingsLocal_GetDisplayGamma Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetFrameRateLimit_Always
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFrameRateLimit_Always() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimit_Always");

	Params::LyraSettingsLocal_GetFrameRateLimit_Always Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetFrameRateLimit_InMenu
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFrameRateLimit_InMenu() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimit_InMenu");

	Params::LyraSettingsLocal_GetFrameRateLimit_InMenu Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetFrameRateLimit_OnBattery
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFrameRateLimit_OnBattery() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimit_OnBattery");

	Params::LyraSettingsLocal_GetFrameRateLimit_OnBattery Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetFrameRateLimit_WhenBackgrounded
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetFrameRateLimit_WhenBackgrounded() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFrameRateLimit_WhenBackgrounded");

	Params::LyraSettingsLocal_GetFrameRateLimit_WhenBackgrounded Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetFXAAQuality
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetFXAAQuality() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetFXAAQuality");

	Params::LyraSettingsLocal_GetFXAAQuality Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetHidePlayerNames
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetHidePlayerNames() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetHidePlayerNames");

	Params::LyraSettingsLocal_GetHidePlayerNames Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetIsTestingMicrophone
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetIsTestingMicrophone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetIsTestingMicrophone");

	Params::LyraSettingsLocal_GetIsTestingMicrophone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetMicrophoneVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetMicrophoneVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetMicrophoneVolume");

	Params::LyraSettingsLocal_GetMicrophoneVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetMSAASampleCount
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetMSAASampleCount() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetMSAASampleCount");

	Params::LyraSettingsLocal_GetMSAASampleCount Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetMusicVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetMusicVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetMusicVolume");

	Params::LyraSettingsLocal_GetMusicVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetOverallVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetOverallVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetOverallVolume");

	Params::LyraSettingsLocal_GetOverallVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetRegionOverride
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ERegionOverride                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ERegionOverride ULyraSettingsLocal::GetRegionOverride() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetRegionOverride");

	Params::LyraSettingsLocal_GetRegionOverride Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetSafeZone
// (Final, Native, Public, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetSafeZone() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSafeZone");

	Params::LyraSettingsLocal_GetSafeZone Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetScreenPercentage
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetScreenPercentage() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetScreenPercentage");

	Params::LyraSettingsLocal_GetScreenPercentage Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetShowTooltips
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetShowTooltips() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetShowTooltips");

	Params::LyraSettingsLocal_GetShowTooltips Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetSoundFXVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetSoundFXVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSoundFXVolume");

	Params::LyraSettingsLocal_GetSoundFXVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetSprintToggle
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetSprintToggle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSprintToggle");

	Params::LyraSettingsLocal_GetSprintToggle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetSprintToggleController
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetSprintToggleController() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSprintToggleController");

	Params::LyraSettingsLocal_GetSprintToggleController Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetSuperResolutionMode
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetSuperResolutionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSuperResolutionMode");

	Params::LyraSettingsLocal_GetSuperResolutionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetSuperResolutionQualityMode
// (Final, Native, Public, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 ULyraSettingsLocal::GetSuperResolutionQualityMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetSuperResolutionQualityMode");

	Params::LyraSettingsLocal_GetSuperResolutionQualityMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetVoiceChatToggle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::GetVoiceChatToggle() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetVoiceChatToggle");

	Params::LyraSettingsLocal_GetVoiceChatToggle Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.GetVoiceChatVolume
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float ULyraSettingsLocal::GetVoiceChatVolume() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "GetVoiceChatVolume");

	Params::LyraSettingsLocal_GetVoiceChatVolume Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.IsActivateVoiceChatUponDeathEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsActivateVoiceChatUponDeathEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsActivateVoiceChatUponDeathEnabled");

	Params::LyraSettingsLocal_IsActivateVoiceChatUponDeathEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.IsAimAssistEnabled
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsAimAssistEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsAimAssistEnabled");

	Params::LyraSettingsLocal_IsAimAssistEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.IsHDRAudioModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsHDRAudioModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsHDRAudioModeEnabled");

	Params::LyraSettingsLocal_IsHDRAudioModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.IsHeadphoneModeEnabled
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsHeadphoneModeEnabled() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsHeadphoneModeEnabled");

	Params::LyraSettingsLocal_IsHeadphoneModeEnabled Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.IsSafeZoneSet
// (Final, Native, Public, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::IsSafeZoneSet() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "IsSafeZoneSet");

	Params::LyraSettingsLocal_IsSafeZoneSet Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingsLocal.ShouldRunAutoBenchmarkAtStartup
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraSettingsLocal::ShouldRunAutoBenchmarkAtStartup() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingsLocal", "ShouldRunAutoBenchmarkAtStartup");

	Params::LyraSettingsLocal_ShouldRunAutoBenchmarkAtStartup Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSettingValueDiscreteDynamic_AudioInputDevice.DeviceAddedOrRemoved
// (Final, Native, Public)
// Parameters:
// class FString                           DeviceID                                               (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioInputDevice::DeviceAddedOrRemoved(const class FString& DeviceID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioInputDevice", "DeviceAddedOrRemoved");

	Params::LyraSettingValueDiscreteDynamic_AudioInputDevice_DeviceAddedOrRemoved Parms{};

	Parms.DeviceID = std::move(DeviceID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSettingValueDiscreteDynamic_AudioInputDevice.OnAudioInputDevicesObtained
// (Final, Native, Public, HasOutParams)
// Parameters:
// TArray<struct FAudioInputDeviceInfo>    AvailableDevices                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraSettingValueDiscreteDynamic_AudioInputDevice::OnAudioInputDevicesObtained(const TArray<struct FAudioInputDeviceInfo>& AvailableDevices)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSettingValueDiscreteDynamic_AudioInputDevice", "OnAudioInputDevicesObtained");

	Params::LyraSettingValueDiscreteDynamic_AudioInputDevice_OnAudioInputDevicesObtained Parms{};

	Parms.AvailableDevices = std::move(AvailableDevices);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SeasonPassGameInstanceSubsystem.GetProgressTowardNextNeighborLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USeasonPassGameInstanceSubsystem::GetProgressTowardNextNeighborLevel(const struct FGameplayTag& NeighborID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassGameInstanceSubsystem", "GetProgressTowardNextNeighborLevel");

	Params::SeasonPassGameInstanceSubsystem_GetProgressTowardNextNeighborLevel Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassGameInstanceSubsystem.GetNeighborLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USeasonPassGameInstanceSubsystem::GetNeighborLevel(const struct FGameplayTag& NeighborID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassGameInstanceSubsystem", "GetNeighborLevel");

	Params::SeasonPassGameInstanceSubsystem_GetNeighborLevel Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassGameInstanceSubsystem.GetNeighborLevelForXP
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NeighborXP                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USeasonPassGameInstanceSubsystem::GetNeighborLevelForXP(const struct FGameplayTag& NeighborID, const int32 NeighborXP) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassGameInstanceSubsystem", "GetNeighborLevelForXP");

	Params::SeasonPassGameInstanceSubsystem_GetNeighborLevelForXP Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.NeighborXP = NeighborXP;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassGameInstanceSubsystem.GetNeighborPerkRewardsByLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TMap<int32, struct FGameplayTag>        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

TMap<int32, struct FGameplayTag> USeasonPassGameInstanceSubsystem::GetNeighborPerkRewardsByLevel(const struct FGameplayTag& NeighborID) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassGameInstanceSubsystem", "GetNeighborPerkRewardsByLevel");

	Params::SeasonPassGameInstanceSubsystem_GetNeighborPerkRewardsByLevel Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassGameInstanceSubsystem.GetTotalXPRequirementForNeighborLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Level                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USeasonPassGameInstanceSubsystem::GetTotalXPRequirementForNeighborLevel(const struct FGameplayTag& NeighborID, int32 Level) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassGameInstanceSubsystem", "GetTotalXPRequirementForNeighborLevel");

	Params::SeasonPassGameInstanceSubsystem_GetTotalXPRequirementForNeighborLevel Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.Level = Level;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassGameInstanceSubsystem.GetXPRequirementForNextNeighborLevel
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   CurrentLevel                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USeasonPassGameInstanceSubsystem::GetXPRequirementForNextNeighborLevel(const struct FGameplayTag& NeighborID, int32 CurrentLevel) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassGameInstanceSubsystem", "GetXPRequirementForNextNeighborLevel");

	Params::SeasonPassGameInstanceSubsystem_GetXPRequirementForNextNeighborLevel Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.CurrentLevel = CurrentLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassRewardContent_NeighborSkinInterface.ApplyNeighborSkinViewModel
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSeasonPassRewardContent_NeighborSkinViewModelViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ISeasonPassRewardContent_NeighborSkinInterface::ApplyNeighborSkinViewModel(const struct FSeasonPassRewardContent_NeighborSkinViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassRewardContent_NeighborSkinInterface", "ApplyNeighborSkinViewModel");

	Params::SeasonPassRewardContent_NeighborSkinInterface_ApplyNeighborSkinViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraUIBlueprintFunctionLibrary.FindAndRemoveWidgetFromAllLayers
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonActivatableWidget*         ActivatableWidget                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimaryGameLayout*               PrimaryGameLayout                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraUIBlueprintFunctionLibrary::FindAndRemoveWidgetFromAllLayers(const class UObject* WorldContextObject, class UCommonActivatableWidget* ActivatableWidget, class UPrimaryGameLayout* PrimaryGameLayout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraUIBlueprintFunctionLibrary", "FindAndRemoveWidgetFromAllLayers");

	Params::LyraUIBlueprintFunctionLibrary_FindAndRemoveWidgetFromAllLayers Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ActivatableWidget = ActivatableWidget;
	Parms.PrimaryGameLayout = PrimaryGameLayout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraUIBlueprintFunctionLibrary.GetLayerWidget
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     LayerName                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimaryGameLayout*               PrimaryGameLayout                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonActivatableWidgetContainerBase*ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonActivatableWidgetContainerBase* ULyraUIBlueprintFunctionLibrary::GetLayerWidget(const class UObject* WorldContextObject, const struct FGameplayTag& LayerName, class UPrimaryGameLayout* PrimaryGameLayout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraUIBlueprintFunctionLibrary", "GetLayerWidget");

	Params::LyraUIBlueprintFunctionLibrary_GetLayerWidget Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LayerName = std::move(LayerName);
	Parms.PrimaryGameLayout = PrimaryGameLayout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraUIBlueprintFunctionLibrary.GetPrimaryGameLayoutForPrimaryPlayer
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimaryGameLayout*               ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPrimaryGameLayout* ULyraUIBlueprintFunctionLibrary::GetPrimaryGameLayoutForPrimaryPlayer(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraUIBlueprintFunctionLibrary", "GetPrimaryGameLayoutForPrimaryPlayer");

	Params::LyraUIBlueprintFunctionLibrary_GetPrimaryGameLayoutForPrimaryPlayer Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraUIBlueprintFunctionLibrary.PushNonPooledWidgetToLayerStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     LayerName                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCommonActivatableWidget>ActivatableWidgetClass                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimaryGameLayout*               PrimaryGameLayout                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonActivatableWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonActivatableWidget* ULyraUIBlueprintFunctionLibrary::PushNonPooledWidgetToLayerStack(const class UObject* WorldContextObject, const struct FGameplayTag& LayerName, TSubclassOf<class UCommonActivatableWidget> ActivatableWidgetClass, class UPrimaryGameLayout* PrimaryGameLayout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraUIBlueprintFunctionLibrary", "PushNonPooledWidgetToLayerStack");

	Params::LyraUIBlueprintFunctionLibrary_PushNonPooledWidgetToLayerStack Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LayerName = std::move(LayerName);
	Parms.ActivatableWidgetClass = ActivatableWidgetClass;
	Parms.PrimaryGameLayout = PrimaryGameLayout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraUIBlueprintFunctionLibrary.PushWidgetToLayerStack
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     LayerName                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UCommonActivatableWidget>ActivatableWidgetClass                                 (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPrimaryGameLayout*               PrimaryGameLayout                                      (Parm, ZeroConstructor, InstancedReference, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonActivatableWidget*         ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UCommonActivatableWidget* ULyraUIBlueprintFunctionLibrary::PushWidgetToLayerStack(const class UObject* WorldContextObject, const struct FGameplayTag& LayerName, TSubclassOf<class UCommonActivatableWidget> ActivatableWidgetClass, class UPrimaryGameLayout* PrimaryGameLayout)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraUIBlueprintFunctionLibrary", "PushWidgetToLayerStack");

	Params::LyraUIBlueprintFunctionLibrary_PushWidgetToLayerStack Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.LayerName = std::move(LayerName);
	Parms.ActivatableWidgetClass = ActivatableWidgetClass;
	Parms.PrimaryGameLayout = PrimaryGameLayout;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraUIBlueprintFunctionLibrary.RemoveAllWidgetsOutsideRootLayout
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraUIBlueprintFunctionLibrary::RemoveAllWidgetsOutsideRootLayout(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("LyraUIBlueprintFunctionLibrary", "RemoveAllWidgetsOutsideRootLayout");

	Params::LyraUIBlueprintFunctionLibrary_RemoveAllWidgetsOutsideRootLayout Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SeasonPassPreviewContainerWidget.CreateTierWidget
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSeasonPassTierViewModel         ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USeasonPassPreviewContainerWidget::CreateTierWidget(const struct FSeasonPassTierViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassPreviewContainerWidget", "CreateTierWidget");

	Params::SeasonPassPreviewContainerWidget_CreateTierWidget Parms{};

	Parms.ViewModel = std::move(ViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PerkDefinition.TryGetPerkDefinition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     PerkID                                                 (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UPerkDefinition>   OutSoftPerkDefinition                                  (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UPerkDefinition::TryGetPerkDefinition(const struct FGameplayTag& PerkID, TSoftObjectPtr<class UPerkDefinition>* OutSoftPerkDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerkDefinition", "TryGetPerkDefinition");

	Params::PerkDefinition_TryGetPerkDefinition Parms{};

	Parms.PerkID = std::move(PerkID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftPerkDefinition != nullptr)
		*OutSoftPerkDefinition = Parms.OutSoftPerkDefinition;

	return Parms.ReturnValue;
}


// Function JP.PerkDefinition.GetBuffDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPerkDefinition::GetBuffDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkDefinition", "GetBuffDescription");

	Params::PerkDefinition_GetBuffDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkDefinition.GetCategory
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EPerkCategories                         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EPerkCategories UPerkDefinition::GetCategory() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkDefinition", "GetCategory");

	Params::PerkDefinition_GetCategory Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkDefinition.GetColor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FColor                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FColor UPerkDefinition::GetColor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkDefinition", "GetColor");

	Params::PerkDefinition_GetColor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkDefinition.GetDebuffDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPerkDefinition::GetDebuffDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkDefinition", "GetDebuffDescription");

	Params::PerkDefinition_GetDebuffDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkDefinition.GetDescription
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPerkDefinition::GetDescription() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkDefinition", "GetDescription");

	Params::PerkDefinition_GetDescription Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkDefinition.GetIcon
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftObjectPtr<class UTexture2D>        ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UTexture2D> UPerkDefinition::GetIcon() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkDefinition", "GetIcon");

	Params::PerkDefinition_GetIcon Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkDefinition.GetPerkName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UPerkDefinition::GetPerkName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkDefinition", "GetPerkName");

	Params::PerkDefinition_GetPerkName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PingControllerComponent.GetGloballyPingableObjects
// (Event, Public, BlueprintEvent)
// Parameters:
// TArray<class UPingableComponent*>       ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPingableComponent*> UPingControllerComponent::GetGloballyPingableObjects()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingControllerComponent", "GetGloballyPingableObjects");

	Params::PingControllerComponent_GetGloballyPingableObjects Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.PingControllerComponent.Server_RequestPing
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// struct FVector                          InViewLocation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FRotator                         InViewRotation                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
// class APlayerControllerJP_Match*        InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPingControllerComponent::Server_RequestPing(const struct FVector& InViewLocation, const struct FRotator& InViewRotation, class APlayerControllerJP_Match* InPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingControllerComponent", "Server_RequestPing");

	Params::PingControllerComponent_Server_RequestPing Parms{};

	Parms.InViewLocation = std::move(InViewLocation);
	Parms.InViewRotation = std::move(InViewRotation);
	Parms.InPC = InPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PingControllerComponent.Server_RequestPingComponent
// (Final, Net, NetReliable, Native, Event, Private, NetServer, HasDefaults)
// Parameters:
// class UPingableComponent*               InPingableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocationOverride                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APlayerControllerJP_Match*        InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPingControllerComponent::Server_RequestPingComponent(class UPingableComponent* InPingableComponent, const struct FVector& InLocationOverride, class APlayerControllerJP_Match* InPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingControllerComponent", "Server_RequestPingComponent");

	Params::PingControllerComponent_Server_RequestPingComponent Parms{};

	Parms.InPingableComponent = InPingableComponent;
	Parms.InLocationOverride = std::move(InLocationOverride);
	Parms.InPC = InPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PingControllerComponent.TryPing
// (Final, Native, Public, BlueprintCallable)

void UPingControllerComponent::TryPing()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingControllerComponent", "TryPing");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PingControllerComponent.TryPingComponent
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// class UPingableComponent*               InPingableComponent                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          InLocationOverride                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPingControllerComponent::TryPingComponent(class UPingableComponent* InPingableComponent, const struct FVector& InLocationOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingControllerComponent", "TryPingComponent");

	Params::PingControllerComponent_TryPingComponent Parms{};

	Parms.InPingableComponent = InPingableComponent;
	Parms.InLocationOverride = std::move(InLocationOverride);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MainMenuInitializationStep_SoftUpdateGameData.OnUpdateFinished
// (Final, Native, Private)

void UMainMenuInitializationStep_SoftUpdateGameData::OnUpdateFinished()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuInitializationStep_SoftUpdateGameData", "OnUpdateFinished");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.MatchConfigurationSubsystem.GetMatchConfiguration
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FMatchConfiguration        ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FMatchConfiguration UMatchConfigurationSubsystem::GetMatchConfiguration(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("MatchConfigurationSubsystem", "GetMatchConfiguration");

	Params::MatchConfigurationSubsystem_GetMatchConfiguration Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerControllerJP_Lobby.OnGetDefaultCharacterSettingsError
// (Final, Native, Private)
// Parameters:
// int32                                   Code                                                   (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           Message                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Lobby::OnGetDefaultCharacterSettingsError(const int32 Code, const class FString& Message)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Lobby", "OnGetDefaultCharacterSettingsError");

	Params::PlayerControllerJP_Lobby_OnGetDefaultCharacterSettingsError Parms{};

	Parms.Code = Code;
	Parms.Message = std::move(Message);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Lobby.Server_SetConfirmedJoin
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)

void APlayerControllerJP_Lobby::Server_SetConfirmedJoin()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Lobby", "Server_SetConfirmedJoin");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Lobby.Server_SetReadyAndWaiting
// (Net, NetReliable, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// bool                                    ReadyAndWaiting                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Lobby::Server_SetReadyAndWaiting(const bool ReadyAndWaiting)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Lobby", "Server_SetReadyAndWaiting");

	Params::PlayerControllerJP_Lobby_Server_SetReadyAndWaiting Parms{};

	Parms.ReadyAndWaiting = ReadyAndWaiting;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerControllerJP_Lobby.Server_VoteOnLevel
// (Net, NetReliable, Native, Event, Public, NetServer, Const)
// Parameters:
// int32                                   LevelIndex                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void APlayerControllerJP_Lobby::Server_VoteOnLevel(int32 LevelIndex) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerControllerJP_Lobby", "Server_VoteOnLevel");

	Params::PlayerControllerJP_Lobby_Server_VoteOnLevel Parms{};

	Parms.LevelIndex = LevelIndex;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MatchConfigurationWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FMatchConfigurationViewModel     InViewModel                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UMatchConfigurationWidget::ApplyViewModel(const struct FMatchConfigurationViewModel& InViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchConfigurationWidget", "ApplyViewModel");

	Params::MatchConfigurationWidget_ApplyViewModel Parms{};

	Parms.InViewModel = std::move(InViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.MatchConfigurationWidget.HandleConfigurationChanged
// (Final, Native, Private)

void UMatchConfigurationWidget::HandleConfigurationChanged()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchConfigurationWidget", "HandleConfigurationChanged");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.MatchConfigurationWidget.SetBoolValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchConfigurationWidget::SetBoolValue(class UJPSettingWidget* InWidget, bool InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchConfigurationWidget", "SetBoolValue");

	Params::MatchConfigurationWidget_SetBoolValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MatchConfigurationWidget.SetFloatValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchConfigurationWidget::SetFloatValue(class UJPSettingWidget* InWidget, float InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchConfigurationWidget", "SetFloatValue");

	Params::MatchConfigurationWidget_SetFloatValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MatchConfigurationWidget.SetIntegerValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchConfigurationWidget::SetIntegerValue(class UJPSettingWidget* InWidget, int32 InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchConfigurationWidget", "SetIntegerValue");

	Params::MatchConfigurationWidget_SetIntegerValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = InValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MatchConfigurationWidget.SetItemEnabled
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     InItemTag                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchConfigurationWidget::SetItemEnabled(const struct FGameplayTag& InItemTag, bool InEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchConfigurationWidget", "SetItemEnabled");

	Params::MatchConfigurationWidget_SetItemEnabled Parms{};

	Parms.InItemTag = std::move(InItemTag);
	Parms.InEnabled = InEnabled;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MatchConfigurationWidget.SetStringValue
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InValue                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMatchConfigurationWidget::SetStringValue(class UJPSettingWidget* InWidget, const class FString& InValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchConfigurationWidget", "SetStringValue");

	Params::MatchConfigurationWidget_SetStringValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = std::move(InValue);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MatchConfigurationWidget.TryResetConfiguration
// (Final, Native, Protected, BlueprintCallable)

void UMatchConfigurationWidget::TryResetConfiguration()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MatchConfigurationWidget", "TryResetConfiguration");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamableActor.RecalculateGroundsKeeperOwner
// (Final, Native, Private)

void ATeamableActor::RecalculateGroundsKeeperOwner()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamableActor", "RecalculateGroundsKeeperOwner");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamableActor.GetCachedGroundsKeeper
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class AGroundsKeeper*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGroundsKeeper* ATeamableActor::GetCachedGroundsKeeper() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamableActor", "GetCachedGroundsKeeper");

	Params::TeamableActor_GetCachedGroundsKeeper Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.RoomManager.HandleRoomUpgradeApproved
// (Final, Native, Protected)
// Parameters:
// class APlayerState*                     Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARoomManager::HandleRoomUpgradeApproved(class APlayerState* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomManager", "HandleRoomUpgradeApproved");

	Params::RoomManager_HandleRoomUpgradeApproved Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.RoomManager.K2_RoomUpgradeApproved
// (BlueprintAuthorityOnly, Event, Public, BlueprintEvent)
// Parameters:
// class APlayerState*                     InstigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARoomManager::K2_RoomUpgradeApproved(class APlayerState* InstigatingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomManager", "K2_RoomUpgradeApproved");

	Params::RoomManager_K2_RoomUpgradeApproved Parms{};

	Parms.InstigatingPlayer = InstigatingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.RoomManager.CanUpgradeRoom
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class APlayerState*                     InstigatingPlayer                                      (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ARoomManager::CanUpgradeRoom(class APlayerState* InstigatingPlayer) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomManager", "CanUpgradeRoom");

	Params::RoomManager_CanUpgradeRoom Parms{};

	Parms.InstigatingPlayer = InstigatingPlayer;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.MovementSpeedAttributeSetListener.OnAimSpeedCoefficientChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   SprintSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMovementSpeedAttributeSetListener::OnAimSpeedCoefficientChanged(float SprintSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttributeSetListener", "OnAimSpeedCoefficientChanged");

	Params::MovementSpeedAttributeSetListener_OnAimSpeedCoefficientChanged Parms{};

	Parms.SprintSpeed = SprintSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttributeSetListener.OnAirControlChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   AirControl                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMovementSpeedAttributeSetListener::OnAirControlChanged(float AirControl)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttributeSetListener", "OnAirControlChanged");

	Params::MovementSpeedAttributeSetListener_OnAirControlChanged Parms{};

	Parms.AirControl = AirControl;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttributeSetListener.OnCrouchJumpVelocityCoefficientChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   CrouchJumpVelocityCoefficient                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMovementSpeedAttributeSetListener::OnCrouchJumpVelocityCoefficientChanged(float CrouchJumpVelocityCoefficient)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttributeSetListener", "OnCrouchJumpVelocityCoefficientChanged");

	Params::MovementSpeedAttributeSetListener_OnCrouchJumpVelocityCoefficientChanged Parms{};

	Parms.CrouchJumpVelocityCoefficient = CrouchJumpVelocityCoefficient;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttributeSetListener.OnCrouchSpeedCoefficientChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   CrouchSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMovementSpeedAttributeSetListener::OnCrouchSpeedCoefficientChanged(float CrouchSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttributeSetListener", "OnCrouchSpeedCoefficientChanged");

	Params::MovementSpeedAttributeSetListener_OnCrouchSpeedCoefficientChanged Parms{};

	Parms.CrouchSpeed = CrouchSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttributeSetListener.OnJumpVelocityChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   JumpVelocity                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMovementSpeedAttributeSetListener::OnJumpVelocityChanged(float JumpVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttributeSetListener", "OnJumpVelocityChanged");

	Params::MovementSpeedAttributeSetListener_OnJumpVelocityChanged Parms{};

	Parms.JumpVelocity = JumpVelocity;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttributeSetListener.OnMovementSpeedChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   MovementSpeed                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMovementSpeedAttributeSetListener::OnMovementSpeedChanged(float MovementSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttributeSetListener", "OnMovementSpeedChanged");

	Params::MovementSpeedAttributeSetListener_OnMovementSpeedChanged Parms{};

	Parms.MovementSpeed = MovementSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MovementSpeedAttributeSetListener.OnSprintSpeedCoefficientChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   SprintSpeed                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IMovementSpeedAttributeSetListener::OnSprintSpeedCoefficientChanged(float SprintSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MovementSpeedAttributeSetListener", "OnSprintSpeedCoefficientChanged");

	Params::MovementSpeedAttributeSetListener_OnSprintSpeedCoefficientChanged Parms{};

	Parms.SprintSpeed = SprintSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MusicManagerComponent.OnMusicStateChanged
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// EMusicStates                            NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicManagerComponent::OnMusicStateChanged(EMusicStates NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicManagerComponent", "OnMusicStateChanged");

	Params::MusicManagerComponent_OnMusicStateChanged Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MusicManagerComponent.SetMusicState
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EMusicStates                            NewState                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMusicManagerComponent::SetMusicState(EMusicStates NewState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MusicManagerComponent", "SetMusicState");

	Params::MusicManagerComponent_SetMusicState Parms{};

	Parms.NewState = NewState;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborDataGameInstanceSubsystem.TryGetNeighborDefinition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Succeeded                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UNeighborDefinition>ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UNeighborDefinition> UNeighborDataGameInstanceSubsystem::TryGetNeighborDefinition(const struct FGameplayTag& NeighborID, bool* Succeeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NeighborDataGameInstanceSubsystem", "TryGetNeighborDefinition");

	Params::NeighborDataGameInstanceSubsystem_TryGetNeighborDefinition Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Succeeded != nullptr)
		*Succeeded = Parms.Succeeded;

	return Parms.ReturnValue;
}


// Function JP.NeighborDataGameInstanceSubsystem.TryGetNeighborMetaData
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    Succeeded                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UNeighborMetaData> ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftObjectPtr<class UNeighborMetaData> UNeighborDataGameInstanceSubsystem::TryGetNeighborMetaData(const struct FGameplayTag& NeighborID, bool* Succeeded)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NeighborDataGameInstanceSubsystem", "TryGetNeighborMetaData");

	Params::NeighborDataGameInstanceSubsystem_TryGetNeighborMetaData Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Succeeded != nullptr)
		*Succeeded = Parms.Succeeded;

	return Parms.ReturnValue;
}


// Function JP.NeighborFavoriteOrUnlockWidget.ApplyViewModel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOnlineStoreItemData             OnlineStoreItem                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UNeighborFavoriteOrUnlockWidget::ApplyViewModel(const struct FOnlineStoreItemData& OnlineStoreItem)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "ApplyViewModel");

	Params::NeighborFavoriteOrUnlockWidget_ApplyViewModel Parms{};

	Parms.OnlineStoreItem = std::move(OnlineStoreItem);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborFavoriteOrUnlockWidget.ApplyViewModelEditorPreview
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOnlineStoreItemData             OnlineStoreItem                                        (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     DefaultNeighborID                                      (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNeighborFavoriteOrUnlockWidget::ApplyViewModelEditorPreview(const struct FOnlineStoreItemData& OnlineStoreItem, const struct FGameplayTag& DefaultNeighborID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "ApplyViewModelEditorPreview");

	Params::NeighborFavoriteOrUnlockWidget_ApplyViewModelEditorPreview Parms{};

	Parms.OnlineStoreItem = std::move(OnlineStoreItem);
	Parms.DefaultNeighborID = std::move(DefaultNeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborFavoriteOrUnlockWidget.HandleInsufficientFunds
// (Event, Protected, BlueprintEvent)

void UNeighborFavoriteOrUnlockWidget::HandleInsufficientFunds()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "HandleInsufficientFunds");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.NeighborFavoriteOrUnlockWidget.HandleUnlockCancel
// (Event, Protected, BlueprintCallable, BlueprintEvent)

void UNeighborFavoriteOrUnlockWidget::HandleUnlockCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "HandleUnlockCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.NeighborFavoriteOrUnlockWidget.HandleUnlockError
// (Event, Protected, BlueprintEvent)
// Parameters:
// class FString                           ErrorMessage                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UNeighborFavoriteOrUnlockWidget::HandleUnlockError(const class FString& ErrorMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "HandleUnlockError");

	Params::NeighborFavoriteOrUnlockWidget_HandleUnlockError Parms{};

	Parms.ErrorMessage = std::move(ErrorMessage);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.NeighborFavoriteOrUnlockWidget.HandleUnlockSuccess
// (Event, Protected, BlueprintEvent)

void UNeighborFavoriteOrUnlockWidget::HandleUnlockSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "HandleUnlockSuccess");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.NeighborFavoriteOrUnlockWidget.OnUnlockConfirm
// (Final, Native, Protected, BlueprintCallable)

void UNeighborFavoriteOrUnlockWidget::OnUnlockConfirm()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "OnUnlockConfirm");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborFavoriteOrUnlockWidget.OnUnlockSuccess
// (Final, Native, Private)

void UNeighborFavoriteOrUnlockWidget::OnUnlockSuccess()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "OnUnlockSuccess");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborFavoriteOrUnlockWidget.PushSpinnerModal
// (Event, Protected, BlueprintEvent)

void UNeighborFavoriteOrUnlockWidget::PushSpinnerModal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "PushSpinnerModal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.NeighborFavoriteOrUnlockWidget.PushUnlockConfirmationModal
// (Event, Protected, BlueprintEvent)

void UNeighborFavoriteOrUnlockWidget::PushUnlockConfirmationModal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "PushUnlockConfirmationModal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.NeighborFavoriteOrUnlockWidget.SetBattlePassInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FOnlineStoreItemBattlePassRequirementBattlePassInfo                                         (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNeighborFavoriteOrUnlockWidget::SetBattlePassInfo(const struct FOnlineStoreItemBattlePassRequirement& BattlePassInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "SetBattlePassInfo");

	Params::NeighborFavoriteOrUnlockWidget_SetBattlePassInfo Parms{};

	Parms.BattlePassInfo = std::move(BattlePassInfo);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.NeighborFavoriteOrUnlockWidget.SetVirtualCurrencyInfo
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FOnlineStoreItemCost             ItemCost                                               (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UNeighborFavoriteOrUnlockWidget::SetVirtualCurrencyInfo(const struct FOnlineStoreItemCost& ItemCost)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "SetVirtualCurrencyInfo");

	Params::NeighborFavoriteOrUnlockWidget_SetVirtualCurrencyInfo Parms{};

	Parms.ItemCost = std::move(ItemCost);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.NeighborFavoriteOrUnlockWidget.GetCurrentNeighborAsStoreItem
// (Final, Native, Protected, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const struct FOnlineStoreItemData       ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const struct FOnlineStoreItemData UNeighborFavoriteOrUnlockWidget::GetCurrentNeighborAsStoreItem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborFavoriteOrUnlockWidget", "GetCurrentNeighborAsStoreItem");

	Params::NeighborFavoriteOrUnlockWidget_GetCurrentNeighborAsStoreItem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.NeighborPreviewActor.InitializeItem
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TSoftObjectPtr<class UItemSkinDefinition>InDefinition                                           (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANeighborPreviewActor::InitializeItem(const TSoftObjectPtr<class UItemSkinDefinition>& InDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborPreviewActor", "InitializeItem");

	Params::NeighborPreviewActor_InitializeItem Parms{};

	Parms.InDefinition = InDefinition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.NeighborPreviewActor.PlayAnimationFromContext
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     SkinID                                                 (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AnimationContext                                       (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ANeighborPreviewActor::PlayAnimationFromContext(const struct FGameplayTag& NeighborID, const struct FGameplayTag& SkinID, const struct FGameplayTag& AnimationContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborPreviewActor", "PlayAnimationFromContext");

	Params::NeighborPreviewActor_PlayAnimationFromContext Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.SkinID = std::move(SkinID);
	Parms.AnimationContext = std::move(AnimationContext);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.NeighborSkinDefinition.TryGetNeighborSkinDefinition
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborSkinID                                         (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UNeighborSkinDefinition>OutSoftNeighborSkinDefinition                          (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UNeighborSkinDefinition::TryGetNeighborSkinDefinition(const struct FGameplayTag& NeighborSkinID, TSoftObjectPtr<class UNeighborSkinDefinition>* OutSoftNeighborSkinDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("NeighborSkinDefinition", "TryGetNeighborSkinDefinition");

	Params::NeighborSkinDefinition_TryGetNeighborSkinDefinition Parms{};

	Parms.NeighborSkinID = std::move(NeighborSkinID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftNeighborSkinDefinition != nullptr)
		*OutSoftNeighborSkinDefinition = Parms.OutSoftNeighborSkinDefinition;

	return Parms.ReturnValue;
}


// Function JP.NeighborSpecialAbilityInterface.OnSpecialAbilityGranted
// (Event, Public, BlueprintEvent)

void INeighborSpecialAbilityInterface::OnSpecialAbilityGranted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSpecialAbilityInterface", "OnSpecialAbilityGranted");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.NeighborSpecialAbilityWidget.SetSourceAbility
// (Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UGameplayAbilityIW*               Source                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void INeighborSpecialAbilityWidget::SetSourceAbility(class UGameplayAbilityIW* Source)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("NeighborSpecialAbilityWidget", "SetSourceAbility");

	Params::NeighborSpecialAbilityWidget_SetSourceAbility Parms{};

	Parms.Source = Source;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectiveCollection.GetObjectives
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TArray<class UObjectiveDefinition*>     ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UObjectiveDefinition*> UObjectiveCollection::GetObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveCollection", "GetObjectives");

	Params::ObjectiveCollection_GetObjectives Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveCollection.GetObjectivesPerSpawn
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UObjectiveCollection::GetObjectivesPerSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveCollection", "GetObjectivesPerSpawn");

	Params::ObjectiveCollection_GetObjectivesPerSpawn Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectiveInstance.ReceiveObjectiveEndMessageGameplayEvent
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChannel                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FObjectiveGameplayMessage        InMessage                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

void UObjectiveInstance::ReceiveObjectiveEndMessageGameplayEvent(const struct FGameplayTag& InChannel, const struct FObjectiveGameplayMessage& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveInstance", "ReceiveObjectiveEndMessageGameplayEvent");

	Params::ObjectiveInstance_ReceiveObjectiveEndMessageGameplayEvent Parms{};

	Parms.InChannel = std::move(InChannel);
	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveInstance.ReceiveObjectiveEndMessageTimer
// (Final, Native, Public, HasOutParams)
// Parameters:
// struct FGameplayTag                     InChannel                                              (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FObjectiveEndMessage             InMessage                                              (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void UObjectiveInstance::ReceiveObjectiveEndMessageTimer(const struct FGameplayTag& InChannel, const struct FObjectiveEndMessage& InMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveInstance", "ReceiveObjectiveEndMessageTimer");

	Params::ObjectiveInstance_ReceiveObjectiveEndMessageTimer Parms{};

	Parms.InChannel = std::move(InChannel);
	Parms.InMessage = std::move(InMessage);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveInstance.ReceiveSubObjectiveCompleted
// (Final, Native, Public)
// Parameters:
// class ASubObjective*                    SubObjective                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveInstance::ReceiveSubObjectiveCompleted(class ASubObjective* SubObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveInstance", "ReceiveSubObjectiveCompleted");

	Params::ObjectiveInstance_ReceiveSubObjectiveCompleted Parms{};

	Parms.SubObjective = SubObjective;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveInstance.RegisterEndTimes
// (Final, Native, Public)

void UObjectiveInstance::RegisterEndTimes()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveInstance", "RegisterEndTimes");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveInstance.SubObjectiveCompleted
// (Final, Native, Public)
// Parameters:
// class APlayerStateJP*                   Player                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveInstance::SubObjectiveCompleted(class APlayerStateJP* Player)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveInstance", "SubObjectiveCompleted");

	Params::ObjectiveInstance_SubObjectiveCompleted Parms{};

	Parms.Player = Player;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveManagerTutorialComponent.CreateTutorialObjectiveInstanceForThisObjectiveComponent
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObjectiveDefinition*             ObjectiveDefinition                                    (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveManagerTutorialComponent::CreateTutorialObjectiveInstanceForThisObjectiveComponent(class UObjectiveDefinition* ObjectiveDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveManagerTutorialComponent", "CreateTutorialObjectiveInstanceForThisObjectiveComponent");

	Params::ObjectiveManagerTutorialComponent_CreateTutorialObjectiveInstanceForThisObjectiveComponent Parms{};

	Parms.ObjectiveDefinition = ObjectiveDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectivesComponent.CreateObjective
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObjectiveBase*                   ObjectiveTemplate                                      (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UObjectiveBase*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UObjectiveBase*> UObjectivesComponent::CreateObjective(class UObject* WorldContextObject, const class UObjectiveBase* ObjectiveTemplate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("ObjectivesComponent", "CreateObjective");

	Params::ObjectivesComponent_CreateObjective Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.ObjectiveTemplate = ObjectiveTemplate;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectivesComponent.OnRep_ActiveObjectives
// (Final, Native, Private)

void UObjectivesComponent::OnRep_ActiveObjectives()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectivesComponent", "OnRep_ActiveObjectives");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.ObjectiveWidget.CreateObjectiveWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FObjectiveAndOwningPlayer        Objective                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UObjectiveWidget::CreateObjectiveWidget(const struct FObjectiveAndOwningPlayer& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "CreateObjectiveWidget");

	Params::ObjectiveWidget_CreateObjectiveWidget Parms{};

	Parms.Objective = std::move(Objective);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectiveWidget.CreateSubObjectiveWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASubObjective*                    SubObjective                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveWidget::CreateSubObjectiveWidget(class ASubObjective* SubObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "CreateSubObjectiveWidget");

	Params::ObjectiveWidget_CreateSubObjectiveWidget Parms{};

	Parms.SubObjective = SubObjective;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectiveWidget.ObjectiveFinished
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FObjectiveAndOwningPlayer        Objective                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UObjectiveWidget::ObjectiveFinished(const struct FObjectiveAndOwningPlayer& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "ObjectiveFinished");

	Params::ObjectiveWidget_ObjectiveFinished Parms{};

	Parms.Objective = std::move(Objective);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectiveWidget.RegenerateObjectiveTrackerWidgets
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TArray<struct FObjectiveTracker>        ObjectiveTrackers                                      (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UObjectiveWidget::RegenerateObjectiveTrackerWidgets(const TArray<struct FObjectiveTracker>& ObjectiveTrackers)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "RegenerateObjectiveTrackerWidgets");

	Params::ObjectiveWidget_RegenerateObjectiveTrackerWidgets Parms{};

	Parms.ObjectiveTrackers = std::move(ObjectiveTrackers);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectiveWidget.RemoveObjectiveWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// struct FObjectiveAndOwningPlayer        Objective                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void UObjectiveWidget::RemoveObjectiveWidget(const struct FObjectiveAndOwningPlayer& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "RemoveObjectiveWidget");

	Params::ObjectiveWidget_RemoveObjectiveWidget Parms{};

	Parms.Objective = std::move(Objective);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectiveWidget.RemoveSubObjectiveWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASubObjective*                    SubObjective                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveWidget::RemoveSubObjectiveWidget(class ASubObjective* SubObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "RemoveSubObjectiveWidget");

	Params::ObjectiveWidget_RemoveSubObjectiveWidget Parms{};

	Parms.SubObjective = SubObjective;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectiveWidget.UpdateSubObjectiveWidget
// (Event, Public, BlueprintEvent)
// Parameters:
// class ASubObjective*                    SubObjective                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectiveWidget::UpdateSubObjectiveWidget(class ASubObjective* SubObjective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectiveWidget", "UpdateSubObjectiveWidget");

	Params::ObjectiveWidget_UpdateSubObjectiveWidget Parms{};

	Parms.SubObjective = SubObjective;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ObjectPoolingSubsystem.GetInactiveObjectOfClass
// (Final, Native, Private, BlueprintCallable)
// Parameters:
// TSubclassOf<class APooledActor>         Class_0                                                (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APawn*                            Instigator                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class APooledActor*                     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class APooledActor* UObjectPoolingSubsystem::GetInactiveObjectOfClass(TSubclassOf<class APooledActor> Class_0, class APawn* Instigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPoolingSubsystem", "GetInactiveObjectOfClass");

	Params::ObjectPoolingSubsystem_GetInactiveObjectOfClass Parms{};

	Parms.Class_0 = Class_0;
	Parms.Instigator = Instigator;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ObjectPoolingSubsystem.PooledObjectDestroyed
// (Final, Native, Private)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UObjectPoolingSubsystem::PooledObjectDestroyed(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ObjectPoolingSubsystem", "PooledObjectDestroyed");

	Params::ObjectPoolingSubsystem_PooledObjectDestroyed Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineCurrencyBundleDataAsset.TryGetCurrencyBundleDataAsset
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CurrencyBundleDataAssetID                              (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSoftObjectPtr<class UOnlineCurrencyBundleDataAsset>OutSoftCurrencyBundleDataAsset                         (Parm, OutParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineCurrencyBundleDataAsset::TryGetCurrencyBundleDataAsset(const struct FGameplayTag& CurrencyBundleDataAssetID, TSoftObjectPtr<class UOnlineCurrencyBundleDataAsset>* OutSoftCurrencyBundleDataAsset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineCurrencyBundleDataAsset", "TryGetCurrencyBundleDataAsset");

	Params::OnlineCurrencyBundleDataAsset_TryGetCurrencyBundleDataAsset Parms{};

	Parms.CurrencyBundleDataAssetID = std::move(CurrencyBundleDataAssetID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutSoftCurrencyBundleDataAsset != nullptr)
		*OutSoftCurrencyBundleDataAsset = Parms.OutSoftCurrencyBundleDataAsset;

	return Parms.ReturnValue;
}


// Function JP.OnlineCurrencyBundleDataAsset.GetDiscountDescription
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             Format                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// int32                                   OwnPrice                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OwnAmount                                              (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   PriceToCompare                                         (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmountToCompare                                        (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOnlineCurrencyBundleDataAsset::GetDiscountDescription(const class FText& Format, const int32 OwnPrice, const int32 OwnAmount, const int32 PriceToCompare, const int32 AmountToCompare) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCurrencyBundleDataAsset", "GetDiscountDescription");

	Params::OnlineCurrencyBundleDataAsset_GetDiscountDescription Parms{};

	Parms.Format = std::move(Format);
	Parms.OwnPrice = OwnPrice;
	Parms.OwnAmount = OwnAmount;
	Parms.PriceToCompare = PriceToCompare;
	Parms.AmountToCompare = AmountToCompare;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineCurrencyBundleDataAsset.GetPriceTag
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Price                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           CurrencyCode                                           (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText UOnlineCurrencyBundleDataAsset::GetPriceTag(int32 Price, const class FString& CurrencyCode) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCurrencyBundleDataAsset", "GetPriceTag");

	Params::OnlineCurrencyBundleDataAsset_GetPriceTag Parms{};

	Parms.Price = Price;
	Parms.CurrencyCode = std::move(CurrencyCode);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineCurrencyBundleDataAsset.GetTitle
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   Amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString UOnlineCurrencyBundleDataAsset::GetTitle(const int32 Amount) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineCurrencyBundleDataAsset", "GetTitle");

	Params::OnlineCurrencyBundleDataAsset_GetTitle Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineServicesFriend.GetFriends
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Page                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   EntriesPerPage                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UOnlineServicesFriend*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UOnlineServicesFriend*> UOnlineServicesFriend::GetFriends(class UObject* WorldContextObject, int32 Page, int32 EntriesPerPage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineServicesFriend", "GetFriends");

	Params::OnlineServicesFriend_GetFriends Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Page = Page;
	Parms.EntriesPerPage = EntriesPerPage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineServicesFriend.GetNumFriendsPlayingJP
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineServicesFriend::GetNumFriendsPlayingJP(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineServicesFriend", "GetNumFriendsPlayingJP");

	Params::OnlineServicesFriend_GetNumFriendsPlayingJP Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineServicesFriend.GetNumOnlineFriends
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineServicesFriend::GetNumOnlineFriends(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineServicesFriend", "GetNumOnlineFriends");

	Params::OnlineServicesFriend_GetNumOnlineFriends Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineServicesFriend.GetTotalFriends
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineServicesFriend::GetTotalFriends(class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("OnlineServicesFriend", "GetTotalFriends");

	Params::OnlineServicesFriend_GetTotalFriends Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreGameInstanceSubsystem.AddCurrencyAmount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CurrencyTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmountToAdd                                            (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::AddCurrencyAmount(const struct FGameplayTag& CurrencyTag, const int32 AmountToAdd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "AddCurrencyAmount");

	Params::OnlineStoreGameInstanceSubsystem_AddCurrencyAmount Parms{};

	Parms.CurrencyTag = std::move(CurrencyTag);
	Parms.AmountToAdd = AmountToAdd;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.GetCurrencyAmount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CurrencyTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UOnlineStoreGameInstanceSubsystem::GetCurrencyAmount(const struct FGameplayTag& CurrencyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "GetCurrencyAmount");

	Params::OnlineStoreGameInstanceSubsystem_GetCurrencyAmount Parms{};

	Parms.CurrencyTag = std::move(CurrencyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreGameInstanceSubsystem.GetHouses
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(TArray<struct FOnlineStoreItemData>& OwnedItems, TArray<struct FOnlineStoreItemData>& UnownedItems)>OnGetPlayerItems                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::GetHouses(const TDelegate<void(TArray<struct FOnlineStoreItemData>& OwnedItems, TArray<struct FOnlineStoreItemData>& UnownedItems)>& OnGetPlayerItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "GetHouses");

	Params::OnlineStoreGameInstanceSubsystem_GetHouses Parms{};

	Parms.OnGetPlayerItems = OnGetPlayerItems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.GetNeighborItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(struct FGameplayTag& NeighborID, struct FCosmeticsOnlineServicesDataContainer& RewardsContainer)>OnGetNeighborItems                                     (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::GetNeighborItems(const struct FGameplayTag& NeighborID, const TDelegate<void(struct FGameplayTag& NeighborID, struct FCosmeticsOnlineServicesDataContainer& RewardsContainer)>& OnGetNeighborItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "GetNeighborItems");

	Params::OnlineStoreGameInstanceSubsystem_GetNeighborItems Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.OnGetNeighborItems = OnGetNeighborItems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.GetNeighbors
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TDelegate<void(TArray<struct FOnlineStoreItemData>& OwnedItems, TArray<struct FOnlineStoreItemData>& UnownedItems)>OnGetPlayerItems                                       (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::GetNeighbors(const TDelegate<void(TArray<struct FOnlineStoreItemData>& OwnedItems, TArray<struct FOnlineStoreItemData>& UnownedItems)>& OnGetPlayerItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "GetNeighbors");

	Params::OnlineStoreGameInstanceSubsystem_GetNeighbors Parms{};

	Parms.OnGetPlayerItems = OnGetPlayerItems;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.IsCurrencySupported
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CurrencyTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineStoreGameInstanceSubsystem::IsCurrencySupported(const struct FGameplayTag& CurrencyTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "IsCurrencySupported");

	Params::OnlineStoreGameInstanceSubsystem_IsCurrencySupported Parms{};

	Parms.CurrencyTag = std::move(CurrencyTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreGameInstanceSubsystem.OnNeighborsInitialized
// (Final, Native, Private, HasOutParams)
// Parameters:
// TArray<struct FOnlineStoreItemData>     OwnedItems                                             (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
// TArray<struct FOnlineStoreItemData>     UnownedItems                                           (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::OnNeighborsInitialized(const TArray<struct FOnlineStoreItemData>& OwnedItems, const TArray<struct FOnlineStoreItemData>& UnownedItems)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "OnNeighborsInitialized");

	Params::OnlineStoreGameInstanceSubsystem_OnNeighborsInitialized Parms{};

	Parms.OwnedItems = std::move(OwnedItems);
	Parms.UnownedItems = std::move(UnownedItems);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.RequestNeighborItems
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::RequestNeighborItems(const struct FGameplayTag& NeighborID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "RequestNeighborItems");

	Params::OnlineStoreGameInstanceSubsystem_RequestNeighborItems Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.SetCurrencyAmount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CurrencyTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   Amount                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::SetCurrencyAmount(const struct FGameplayTag& CurrencyTag, const int32 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "SetCurrencyAmount");

	Params::OnlineStoreGameInstanceSubsystem_SetCurrencyAmount Parms{};

	Parms.CurrencyTag = std::move(CurrencyTag);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.SubtractCurrencyAmount
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     CurrencyTag                                            (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   AmountToSubtract                                       (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::SubtractCurrencyAmount(const struct FGameplayTag& CurrencyTag, const int32 AmountToSubtract)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "SubtractCurrencyAmount");

	Params::OnlineStoreGameInstanceSubsystem_SubtractCurrencyAmount Parms{};

	Parms.CurrencyTag = std::move(CurrencyTag);
	Parms.AmountToSubtract = AmountToSubtract;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.TryGetStoreItemDataForNeighborID
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemData             OutStoreItemData                                       (Parm, OutParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineStoreGameInstanceSubsystem::TryGetStoreItemDataForNeighborID(const struct FGameplayTag& NeighborID, struct FOnlineStoreItemData* OutStoreItemData)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "TryGetStoreItemDataForNeighborID");

	Params::OnlineStoreGameInstanceSubsystem_TryGetStoreItemDataForNeighborID Parms{};

	Parms.NeighborID = std::move(NeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (OutStoreItemData != nullptr)
		*OutStoreItemData = std::move(Parms.OutStoreItemData);

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreGameInstanceSubsystem.TryUnlockLocalBattlePassItem
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     AssetID                                                (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     AssociatedNeighborID                                   (ConstParm, Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UOnlineStoreGameInstanceSubsystem::TryUnlockLocalBattlePassItem(const struct FGameplayTag& AssetID, const struct FGameplayTag& AssociatedNeighborID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "TryUnlockLocalBattlePassItem");

	Params::OnlineStoreGameInstanceSubsystem_TryUnlockLocalBattlePassItem Parms{};

	Parms.AssetID = std::move(AssetID);
	Parms.AssociatedNeighborID = std::move(AssociatedNeighborID);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.OnlineStoreGameInstanceSubsystem.UnlockHouse
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOnlineStoreItemData             ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnSuccess                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& ErrorMessage)>OnError                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::UnlockHouse(const struct FOnlineStoreItemData& ItemData, const TDelegate<void()>& OnSuccess, const TDelegate<void(const class FString& ErrorMessage)>& OnError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "UnlockHouse");

	Params::OnlineStoreGameInstanceSubsystem_UnlockHouse Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.OnSuccess = OnSuccess;
	Parms.OnError = OnError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.UnlockNeighbor
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FOnlineStoreItemData             ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnSuccess                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& ErrorMessage)>OnError                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::UnlockNeighbor(const struct FOnlineStoreItemData& ItemData, const TDelegate<void()>& OnSuccess, const TDelegate<void(const class FString& ErrorMessage)>& OnError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "UnlockNeighbor");

	Params::OnlineStoreGameInstanceSubsystem_UnlockNeighbor Parms{};

	Parms.ItemData = std::move(ItemData);
	Parms.OnSuccess = OnSuccess;
	Parms.OnError = OnError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.UnlockNeighborItem
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     NeighborID                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FOnlineStoreItemData             ItemData                                               (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void()>                       OnSuccess                                              (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(const class FString& ErrorMessage)>OnError                                                (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UOnlineStoreGameInstanceSubsystem::UnlockNeighborItem(const struct FGameplayTag& NeighborID, const struct FOnlineStoreItemData& ItemData, const TDelegate<void()>& OnSuccess, const TDelegate<void(const class FString& ErrorMessage)>& OnError)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "UnlockNeighborItem");

	Params::OnlineStoreGameInstanceSubsystem_UnlockNeighborItem Parms{};

	Parms.NeighborID = std::move(NeighborID);
	Parms.ItemData = std::move(ItemData);
	Parms.OnSuccess = OnSuccess;
	Parms.OnError = OnError;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.OnlineStoreGameInstanceSubsystem.GetNeighborsFilteredByActive
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FOnlineStoreItemData>     ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FOnlineStoreItemData> UOnlineStoreGameInstanceSubsystem::GetNeighborsFilteredByActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("OnlineStoreGameInstanceSubsystem", "GetNeighborsFilteredByActive");

	Params::OnlineStoreGameInstanceSubsystem_GetNeighborsFilteredByActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkManagerComponent.GetPerkManagerComponentFromController
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class AController*                      Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPerkManagerComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkManagerComponent* UPerkManagerComponent::GetPerkManagerComponentFromController(class AController* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerkManagerComponent", "GetPerkManagerComponentFromController");

	Params::PerkManagerComponent_GetPerkManagerComponentFromController Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkManagerComponent.GetPerkManagerComponentFromPawn
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APawn*                            Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPerkManagerComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkManagerComponent* UPerkManagerComponent::GetPerkManagerComponentFromPawn(class APawn* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerkManagerComponent", "GetPerkManagerComponentFromPawn");

	Params::PerkManagerComponent_GetPerkManagerComponentFromPawn Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkManagerComponent.GetPerkManagerComponentFromPlayerState
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class APlayerState*                     Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPerkManagerComponent*            ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkManagerComponent* UPerkManagerComponent::GetPerkManagerComponentFromPlayerState(class APlayerState* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("PerkManagerComponent", "GetPerkManagerComponentFromPlayerState");

	Params::PerkManagerComponent_GetPerkManagerComponentFromPlayerState Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkManagerComponent.K2_GetAllActionsOfType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UPerkAction>          ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class UPerkAction*>              ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

TArray<class UPerkAction*> UPerkManagerComponent::K2_GetAllActionsOfType(TSubclassOf<class UPerkAction> ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManagerComponent", "K2_GetAllActionsOfType");

	Params::PerkManagerComponent_K2_GetAllActionsOfType Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PerkManagerComponent.K2_GetFirstActionOfType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UPerkAction>          ActionType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UPerkAction*                      ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UPerkAction* UPerkManagerComponent::K2_GetFirstActionOfType(TSubclassOf<class UPerkAction> ActionType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PerkManagerComponent", "K2_GetFirstActionOfType");

	Params::PerkManagerComponent_K2_GetFirstActionOfType Parms{};

	Parms.ActionType = ActionType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PingableComponent.GetPingDataBP
// (Event, Public, BlueprintEvent)
// Parameters:
// class APlayerControllerJP_Match*        InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPingData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPingData UPingableComponent::GetPingDataBP(class APlayerControllerJP_Match* InPC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingableComponent", "GetPingDataBP");

	Params::PingableComponent_GetPingDataBP Parms{};

	Parms.InPC = InPC;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.PingableComponent.GetPingData
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerControllerJP_Match*        InPC                                                   (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FPingData                        ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPingData UPingableComponent::GetPingData(class APlayerControllerJP_Match* InPC) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PingableComponent", "GetPingData");

	Params::PingableComponent_GetPingData Parms{};

	Parms.InPC = InPC;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP_Lobby.OnRep_IsHost
// (Native, Public)

void APlayerStateJP_Lobby::OnRep_IsHost()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_Lobby", "OnRep_IsHost");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP_Lobby.OnRep_ReadyAndWaiting
// (Native, Public)

void APlayerStateJP_Lobby::OnRep_ReadyAndWaiting()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_Lobby", "OnRep_ReadyAndWaiting");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerStateJP_Lobby.GetIsHost
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerStateJP_Lobby::GetIsHost() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_Lobby", "GetIsHost");

	Params::PlayerStateJP_Lobby_GetIsHost Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP_Lobby.GetReadyAndWaiting
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APlayerStateJP_Lobby::GetReadyAndWaiting() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_Lobby", "GetReadyAndWaiting");

	Params::PlayerStateJP_Lobby_GetReadyAndWaiting Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PlayerStateJP_Tutorial.SetNeighborLoadoutOverride
// (Final, Native, Protected, BlueprintCallable)
// Parameters:
// struct FNeighborLoadout                 LoadoutOverride                                        (ConstParm, Parm, NativeAccessSpecifierPublic)

void APlayerStateJP_Tutorial::SetNeighborLoadoutOverride(const struct FNeighborLoadout& LoadoutOverride)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerStateJP_Tutorial", "SetNeighborLoadoutOverride");

	Params::PlayerStateJP_Tutorial_SetNeighborLoadoutOverride Parms{};

	Parms.LoadoutOverride = std::move(LoadoutOverride);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PooledActor.CallPooledBeginPlay
// (Final, Native, Public, BlueprintCallable)

void APooledActor::CallPooledBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PooledActor", "CallPooledBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PooledActor.DeactivatePooledActor
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)

void APooledActor::DeactivatePooledActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PooledActor", "DeactivatePooledActor");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PooledActor.PooledBeginPlay
// (Native, Event, Public, BlueprintEvent)

void APooledActor::PooledBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PooledActor", "PooledBeginPlay");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PooledActor.IsActive
// (Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool APooledActor::IsActive() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PooledActor", "IsActive");

	Params::PooledActor_IsActive Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.PreLobbyServerBrowserEntry.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPreLobbyServerBrowserEntryViewModelInViewModel                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserEntry::ApplyViewModel(const struct FPreLobbyServerBrowserEntryViewModel& InViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserEntry", "ApplyViewModel");

	Params::PreLobbyServerBrowserEntry_ApplyViewModel Parms{};

	Parms.InViewModel = std::move(InViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.PreLobbyServerBrowserEntry.OnDeselected
// (Event, Public, BlueprintEvent)

void UPreLobbyServerBrowserEntry::OnDeselected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserEntry", "OnDeselected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PreLobbyServerBrowserEntry.OnSelected
// (Event, Public, BlueprintEvent)

void UPreLobbyServerBrowserEntry::OnSelected()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserEntry", "OnSelected");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.PreLobbyServerBrowserEntry.GetViewModel
// (Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// struct FPreLobbyServerBrowserEntryViewModelReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

struct FPreLobbyServerBrowserEntryViewModel UPreLobbyServerBrowserEntry::GetViewModel() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserEntry", "GetViewModel");

	Params::PreLobbyServerBrowserEntry_GetViewModel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.PreLobbyServerBrowserWidget.ApplyViewModel
// (Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FPreLobbyServerBrowserViewModel  InViewModel                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserWidget::ApplyViewModel(const struct FPreLobbyServerBrowserViewModel& InViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserWidget", "ApplyViewModel");

	Params::PreLobbyServerBrowserWidget_ApplyViewModel Parms{};

	Parms.InViewModel = std::move(InViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.PreLobbyServerBrowserWidget.RequestLobbies
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bInDoBackendRequest                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserWidget::RequestLobbies(bool bInDoBackendRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserWidget", "RequestLobbies");

	Params::PreLobbyServerBrowserWidget_RequestLobbies Parms{};

	Parms.bInDoBackendRequest = bInDoBackendRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserWidget.SetBoolValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInDoBackendRequest                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserWidget::SetBoolValue(class UJPSettingWidget* InWidget, bool InValue, bool bInDoBackendRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserWidget", "SetBoolValue");

	Params::PreLobbyServerBrowserWidget_SetBoolValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = InValue;
	Parms.bInDoBackendRequest = bInDoBackendRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserWidget.SetIntegerValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInDoBackendRequest                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserWidget::SetIntegerValue(class UJPSettingWidget* InWidget, int32 InValue, bool bInDoBackendRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserWidget", "SetIntegerValue");

	Params::PreLobbyServerBrowserWidget_SetIntegerValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = InValue;
	Parms.bInDoBackendRequest = bInDoBackendRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserWidget.SetMultiChoiceValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSet<int32>                             InValue                                                (Parm, NativeAccessSpecifierPublic)
// bool                                    bInDoBackendRequest                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserWidget::SetMultiChoiceValue(class UJPSettingWidget* InWidget, const TSet<int32>& InValue, bool bInDoBackendRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserWidget", "SetMultiChoiceValue");

	Params::PreLobbyServerBrowserWidget_SetMultiChoiceValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = std::move(InValue);
	Parms.bInDoBackendRequest = bInDoBackendRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserWidget.SetScalarValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   InValue                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInDoBackendRequest                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserWidget::SetScalarValue(class UJPSettingWidget* InWidget, float InValue, bool bInDoBackendRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserWidget", "SetScalarValue");

	Params::PreLobbyServerBrowserWidget_SetScalarValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = InValue;
	Parms.bInDoBackendRequest = bInDoBackendRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserWidget.SetStringValue
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UJPSettingWidget*                 InWidget                                               (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FString                           InValue                                                (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bInDoBackendRequest                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPreLobbyServerBrowserWidget::SetStringValue(class UJPSettingWidget* InWidget, const class FString& InValue, bool bInDoBackendRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserWidget", "SetStringValue");

	Params::PreLobbyServerBrowserWidget_SetStringValue Parms{};

	Parms.InWidget = InWidget;
	Parms.InValue = std::move(InValue);
	Parms.bInDoBackendRequest = bInDoBackendRequest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PreLobbyServerBrowserWidget.TryJoinLobby
// (Final, Native, Public, BlueprintCallable)

void UPreLobbyServerBrowserWidget::TryJoinLobby()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PreLobbyServerBrowserWidget", "TryJoinLobby");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.RandomLootSpawner.GetRandomLootTagBasedOnProbability
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// TMap<struct FGameplayTag, float>        LootProbabilities                                      (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ARandomLootSpawner::GetRandomLootTagBasedOnProbability(TMap<struct FGameplayTag, float>& LootProbabilities)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RandomLootSpawner", "GetRandomLootTagBasedOnProbability");

	Params::RandomLootSpawner_GetRandomLootTagBasedOnProbability Parms{};

	Parms.LootProbabilities = std::move(LootProbabilities);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	LootProbabilities = std::move(Parms.LootProbabilities);

	return Parms.ReturnValue;
}


// Function JP.RandomLootSpawner.SetNewLootDefinition
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class URandomLootDefinition*            Definition                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARandomLootSpawner::SetNewLootDefinition(class URandomLootDefinition* Definition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RandomLootSpawner", "SetNewLootDefinition");

	Params::RandomLootSpawner_SetNewLootDefinition Parms{};

	Parms.Definition = Definition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.RandomLootSpawner.TriggerLootSelection
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ReturnValue                                            (Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FGameplayTag ARandomLootSpawner::TriggerLootSelection()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RandomLootSpawner", "TriggerLootSelection");

	Params::RandomLootSpawner_TriggerLootSelection Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.RepairnessAttributeSet.OnRep_MaxRepairness
// (Final, Native, Private)

void URepairnessAttributeSet::OnRep_MaxRepairness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RepairnessAttributeSet", "OnRep_MaxRepairness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.RepairnessAttributeSet.OnRep_Repairness
// (Final, Native, Private)

void URepairnessAttributeSet::OnRep_Repairness()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RepairnessAttributeSet", "OnRep_Repairness");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.RichTextBlockInputImageDecorator.HasImageBrushForTag
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             TagOrId                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool URichTextBlockInputImageDecorator::HasImageBrushForTag(class FName TagOrId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RichTextBlockInputImageDecorator", "HasImageBrushForTag");

	Params::RichTextBlockInputImageDecorator_HasImageBrushForTag Parms{};

	Parms.TagOrId = TagOrId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.RoomVolume.GetAllTrackedActors
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARoomVolume::GetAllTrackedActors()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "GetAllTrackedActors");

	Params::RoomVolume_GetAllTrackedActors Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.RoomVolume.GetAllTrackedActorsOfType
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class AActor>               Type                                                   (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ARoomVolume::GetAllTrackedActorsOfType(TSubclassOf<class AActor> Type)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "GetAllTrackedActorsOfType");

	Params::RoomVolume_GetAllTrackedActorsOfType Parms{};

	Parms.Type = Type;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.RoomVolume.TrackActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARoomVolume::TrackActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "TrackActor");

	Params::RoomVolume_TrackActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.RoomVolume.UntrackActor
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           Actor                                                  (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ARoomVolume::UntrackActor(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RoomVolume", "UntrackActor");

	Params::RoomVolume_UntrackActor Parms{};

	Parms.Actor = Actor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SeasonPassContainerWidgetFull.CreateTierWidget
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSeasonPassTierViewModel         ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USeasonPassContainerWidgetFull::CreateTierWidget(const struct FSeasonPassTierViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassContainerWidgetFull", "CreateTierWidget");

	Params::SeasonPassContainerWidgetFull_CreateTierWidget Parms{};

	Parms.ViewModel = std::move(ViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SeasonPassRewardContent_NeighborInterface.ApplyNeighborViewModel
// (Native, Event, Public, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSeasonPassRewardContent_NeighborViewModelViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ISeasonPassRewardContent_NeighborInterface::ApplyNeighborViewModel(const struct FSeasonPassRewardContent_NeighborViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassRewardContent_NeighborInterface", "ApplyNeighborViewModel");

	Params::SeasonPassRewardContent_NeighborInterface_ApplyNeighborViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.RewardContentFactory.GetContentFromRewardType
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// ESeasonPassRewardType                   RewardType                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidget> URewardContentFactory::GetContentFromRewardType(ESeasonPassRewardType RewardType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("RewardContentFactory", "GetContentFromRewardType");

	Params::RewardContentFactory_GetContentFromRewardType Parms{};

	Parms.RewardType = RewardType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SeasonPassTierWidget.ApplyViewModel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FSeasonPassTierViewModel         InViewModel                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USeasonPassTierWidget::ApplyViewModel(const struct FSeasonPassTierViewModel& InViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassTierWidget", "ApplyViewModel");

	Params::SeasonPassTierWidget_ApplyViewModel Parms{};

	Parms.InViewModel = std::move(InViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SeasonPassTierWidget.CreateSingleRewardWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UPanelWidget*                     Parent                                                 (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsPremium                                             (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class USeasonPassRewardEntryWidgetBase>WidgetType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USeasonPassTierWidget::CreateSingleRewardWidget(class UPanelWidget* Parent, const bool bIsPremium, TSubclassOf<class USeasonPassRewardEntryWidgetBase> WidgetType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassTierWidget", "CreateSingleRewardWidget");

	Params::SeasonPassTierWidget_CreateSingleRewardWidget Parms{};

	Parms.Parent = Parent;
	Parms.bIsPremium = bIsPremium;
	Parms.WidgetType = WidgetType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SeasonPassTierWidget.K2_ApplyViewModel
// (Event, Protected, HasOutParams, BlueprintEvent)
// Parameters:
// struct FSeasonPassTierViewModel         ViewModel                                              (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USeasonPassTierWidget::K2_ApplyViewModel(const struct FSeasonPassTierViewModel& ViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassTierWidget", "K2_ApplyViewModel");

	Params::SeasonPassTierWidget_K2_ApplyViewModel Parms{};

	Parms.ViewModel = std::move(ViewModel);

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.SeasonPassTierWidget.TryGetFirstReward
// (Final, Native, Protected, HasOutParams, BlueprintCallable)
// Parameters:
// bool                                    bIsPremium                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FSeasonPassReward                OutReward                                              (Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USeasonPassTierWidget::TryGetFirstReward(bool bIsPremium, struct FSeasonPassReward& OutReward)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SeasonPassTierWidget", "TryGetFirstReward");

	Params::SeasonPassTierWidget_TryGetFirstReward Parms{};

	Parms.bIsPremium = bIsPremium;
	Parms.OutReward = std::move(OutReward);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	OutReward = std::move(Parms.OutReward);

	return Parms.ReturnValue;
}


// Function JP.ServiceMessageHandler.GetAllServiceMessages
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UServiceMessage*>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UServiceMessage*> UServiceMessageHandler::GetAllServiceMessages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServiceMessageHandler", "GetAllServiceMessages");

	Params::ServiceMessageHandler_GetAllServiceMessages Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ServiceMessageHandler.LoadAllServiceMessages
// (Final, Native, Public, BlueprintCallable)

void UServiceMessageHandler::LoadAllServiceMessages()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ServiceMessageHandler", "LoadAllServiceMessages");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SessionSearchResultViewModel.CreateViewModel
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UCommonSession_SearchSessionRequest*Target                                                 (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class USessionSearchResultViewModel*    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USessionSearchResultViewModel* USessionSearchResultViewModel::CreateViewModel(class UCommonSession_SearchSessionRequest* Target)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("SessionSearchResultViewModel", "CreateViewModel");

	Params::SessionSearchResultViewModel_CreateViewModel Parms{};

	Parms.Target = Target;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopInteractionComponent.AddAmmo
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShopItemViewModel               ShopItemViewModel                                      (Parm, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopInteractionComponent::AddAmmo(class UItemDefinition* ItemDefinition, const struct FShopItemViewModel& ShopItemViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "AddAmmo");

	Params::ShopInteractionComponent_AddAmmo Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.ShopItemViewModel = std::move(ShopItemViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopInteractionComponent.AttemptItemPurchase
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemInstance*                    OptionalItemToDropFromInventory                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DeliveryOrderConfirmed                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopInteractionComponent::AttemptItemPurchase(class UItemDefinition* ItemDefinition, class UItemInstance* OptionalItemToDropFromInventory, bool DeliveryOrderConfirmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "AttemptItemPurchase");

	Params::ShopInteractionComponent_AttemptItemPurchase Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.OptionalItemToDropFromInventory = OptionalItemToDropFromInventory;
	Parms.DeliveryOrderConfirmed = DeliveryOrderConfirmed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopInteractionComponent.CanAddAmmo
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopInteractionComponent::CanAddAmmo(class UItemDefinition* ItemDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "CanAddAmmo");

	Params::ShopInteractionComponent_CanAddAmmo Parms{};

	Parms.ItemDefinition = ItemDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopInteractionComponent.CanPurchaseItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopInteractionComponent::CanPurchaseItem(class UItemDefinition* ItemDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "CanPurchaseItem");

	Params::ShopInteractionComponent_CanPurchaseItem Parms{};

	Parms.ItemDefinition = ItemDefinition;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopInteractionComponent.DropItem
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemInstance*                    ItemToDropFromInventory                                (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopInteractionComponent::DropItem(class UItemInstance* ItemToDropFromInventory)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "DropItem");

	Params::ShopInteractionComponent_DropItem Parms{};

	Parms.ItemToDropFromInventory = ItemToDropFromInventory;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ShopInteractionComponent.ModifyItemAmountFromPerks
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UShopInteractionComponent::ModifyItemAmountFromPerks(class UItemDefinition* ItemDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "ModifyItemAmountFromPerks");

	Params::ShopInteractionComponent_ModifyItemAmountFromPerks Parms{};

	Parms.ItemDefinition = ItemDefinition;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.ShopInteractionComponent.OrderDelivery
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class AActor>               Actor                                                  (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShopItemViewModel               ShopItemViewModel                                      (Parm, NativeAccessSpecifierPublic)

void UShopInteractionComponent::OrderDelivery(TSubclassOf<class AActor> Actor, const struct FShopItemViewModel& ShopItemViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "OrderDelivery");

	Params::ShopInteractionComponent_OrderDelivery Parms{};

	Parms.Actor = Actor;
	Parms.ShopItemViewModel = std::move(ShopItemViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopInteractionComponent.PurchaseItem
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FShopItemViewModel               ShopItemViewModel                                      (Parm, NativeAccessSpecifierPublic)
// uint8                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemInstance*                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UItemInstance* UShopInteractionComponent::PurchaseItem(class UItemDefinition* ItemDefinition, const struct FShopItemViewModel& ShopItemViewModel, uint8 Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "PurchaseItem");

	Params::ShopInteractionComponent_PurchaseItem Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.ShopItemViewModel = std::move(ShopItemViewModel);
	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopInteractionComponent.Server_RequestPurchase
// (Net, Native, Event, Public, NetServer, BlueprintCallable)
// Parameters:
// struct FGameplayTag                     ItemDefinitionTag                                      (Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UItemInstance*                    OptionalItemToDropFromInventory                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    DeliveryOrderConfirmed                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopInteractionComponent::Server_RequestPurchase(const struct FGameplayTag& ItemDefinitionTag, class UItemInstance* OptionalItemToDropFromInventory, bool DeliveryOrderConfirmed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "Server_RequestPurchase");

	Params::ShopInteractionComponent_Server_RequestPurchase Parms{};

	Parms.ItemDefinitionTag = std::move(ItemDefinitionTag);
	Parms.OptionalItemToDropFromInventory = OptionalItemToDropFromInventory;
	Parms.DeliveryOrderConfirmed = DeliveryOrderConfirmed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopInteractionComponent.SetInventory
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UShopInteractionComponent::SetInventory()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "SetInventory");

	Params::ShopInteractionComponent_SetInventory Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function JP.ShopInteractionComponent.ShowDeliveryConfirmationPrompt
// (Event, Public, BlueprintEvent)
// Parameters:
// class UItemDefinition*                  ItemDefinition                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopInteractionComponent::ShowDeliveryConfirmationPrompt(class UItemDefinition* ItemDefinition)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopInteractionComponent", "ShowDeliveryConfirmationPrompt");

	Params::ShopInteractionComponent_ShowDeliveryConfirmationPrompt Parms{};

	Parms.ItemDefinition = ItemDefinition;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.ShopManagerComponent.GetShopItemViewModel
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UItemDefinition>   ItemDefinition                                         (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FShopItemViewModel         ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

const struct FShopItemViewModel UShopManagerComponent::GetShopItemViewModel(const TSoftObjectPtr<class UItemDefinition>& ItemDefinition, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "GetShopItemViewModel");

	Params::ShopManagerComponent_GetShopItemViewModel Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopManagerComponent.GetTeamShopItems
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const TArray<struct FShopItemViewModel> ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, ReferenceParm, NativeAccessSpecifierPublic)

const TArray<struct FShopItemViewModel> UShopManagerComponent::GetTeamShopItems(uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "GetTeamShopItems");

	Params::ShopManagerComponent_GetTeamShopItems Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopManagerComponent.ReactToShopItemChangeTeam1
// (Final, Native, Private)
// Parameters:
// struct FShopItemViewModel               ShopItemViewModel                                      (Parm, NativeAccessSpecifierPublic)

void UShopManagerComponent::ReactToShopItemChangeTeam1(const struct FShopItemViewModel& ShopItemViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "ReactToShopItemChangeTeam1");

	Params::ShopManagerComponent_ReactToShopItemChangeTeam1 Parms{};

	Parms.ShopItemViewModel = std::move(ShopItemViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopManagerComponent.ReactToShopItemChangeTeam2
// (Final, Native, Private)
// Parameters:
// struct FShopItemViewModel               ShopItemViewModel                                      (Parm, NativeAccessSpecifierPublic)

void UShopManagerComponent::ReactToShopItemChangeTeam2(const struct FShopItemViewModel& ShopItemViewModel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "ReactToShopItemChangeTeam2");

	Params::ShopManagerComponent_ReactToShopItemChangeTeam2 Parms{};

	Parms.ShopItemViewModel = std::move(ShopItemViewModel);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopManagerComponent.TutorialChangeAllItemsEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManagerComponent::TutorialChangeAllItemsEnabled(bool IsEnabled, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "TutorialChangeAllItemsEnabled");

	Params::ShopManagerComponent_TutorialChangeAllItemsEnabled Parms{};

	Parms.IsEnabled = IsEnabled;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopManagerComponent.TutorialChangeItemEnabled
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// TSoftObjectPtr<class UItemDefinition>   ItemDefinition                                         (ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManagerComponent::TutorialChangeItemEnabled(const TSoftObjectPtr<class UItemDefinition>& ItemDefinition, bool IsEnabled, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "TutorialChangeItemEnabled");

	Params::ShopManagerComponent_TutorialChangeItemEnabled Parms{};

	Parms.ItemDefinition = ItemDefinition;
	Parms.IsEnabled = IsEnabled;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopManagerComponent.TutorialChangeUpgradeEnabled
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    IsEnabled                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// EShopItemCategory                       Category                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManagerComponent::TutorialChangeUpgradeEnabled(bool IsEnabled, EShopItemCategory Category)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "TutorialChangeUpgradeEnabled");

	Params::ShopManagerComponent_TutorialChangeUpgradeEnabled Parms{};

	Parms.IsEnabled = IsEnabled;
	Parms.Category = Category;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopManagerComponent.UpdateShopViewModelGarageTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   GarageTier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManagerComponent::UpdateShopViewModelGarageTier(uint8 GarageTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "UpdateShopViewModelGarageTier");

	Params::ShopManagerComponent_UpdateShopViewModelGarageTier Parms{};

	Parms.GarageTier = GarageTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopManagerComponent.UpdateShopViewModelHouseLevel
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   HouseLevel                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManagerComponent::UpdateShopViewModelHouseLevel(uint8 HouseLevel)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "UpdateShopViewModelHouseLevel");

	Params::ShopManagerComponent_UpdateShopViewModelHouseLevel Parms{};

	Parms.HouseLevel = HouseLevel;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopManagerComponent.UpdateShopViewModelKitchenTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   KitchenTier                                            (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManagerComponent::UpdateShopViewModelKitchenTier(uint8 KitchenTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "UpdateShopViewModelKitchenTier");

	Params::ShopManagerComponent_UpdateShopViewModelKitchenTier Parms{};

	Parms.KitchenTier = KitchenTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopManagerComponent.UpdateShopViewModelPottingBenchTier
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// uint8                                   PottingBenchTier                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopManagerComponent::UpdateShopViewModelPottingBenchTier(uint8 PottingBenchTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopManagerComponent", "UpdateShopViewModelPottingBenchTier");

	Params::ShopManagerComponent_UpdateShopViewModelPottingBenchTier Parms{};

	Parms.PottingBenchTier = PottingBenchTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.ShopWidgetItemEntry.GetButton
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// class UButton*                          ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UButton* UShopWidgetItemEntry::GetButton()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopWidgetItemEntry", "GetButton");

	Params::ShopWidgetItemEntry_GetButton Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.ShopWidgetItemEntry.OnShopItemUpdate
// (Event, Public, BlueprintEvent)

void UShopWidgetItemEntry::OnShopItemUpdate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopWidgetItemEntry", "OnShopItemUpdate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.ShopWidgetTier.InitializeWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EShopItemCategory                       InCategory                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   InShopTier                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UShopWidgetTier::InitializeWidget(EShopItemCategory InCategory, uint8 InShopTier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("ShopWidgetTier", "InitializeWidget");

	Params::ShopWidgetTier_InitializeWidget Parms{};

	Parms.InCategory = InCategory;
	Parms.InShopTier = InShopTier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialBlockedPlayerInteractionWidget.OnUnblockButtonClicked
// (Final, Native, Private)

void USocialBlockedPlayerInteractionWidget::OnUnblockButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialBlockedPlayerInteractionWidget", "OnUnblockButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialFriendInteractionWidget.OnInviteButtonClicked
// (Final, Native, Private)

void USocialFriendInteractionWidget::OnInviteButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialFriendInteractionWidget", "OnInviteButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.AcceptPartyInvite
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPartyInvite                     InviteToAccept                                         (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::AcceptPartyInvite(const struct FPartyInvite& InviteToAccept)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "AcceptPartyInvite");

	Params::SocialGameInstanceSubsystem_AcceptPartyInvite Parms{};

	Parms.InviteToAccept = std::move(InviteToAccept);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.BlockPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOnlineServicesUserBase*          User                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::BlockPlayer(const class UOnlineServicesUserBase* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "BlockPlayer");

	Params::SocialGameInstanceSubsystem_BlockPlayer Parms{};

	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.CanUseSocials
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::CanUseSocials()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "CanUseSocials");

	Params::SocialGameInstanceSubsystem_CanUseSocials Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.ClearCachedNetworkFailure
// (Final, Native, Public, BlueprintCallable)

void USocialGameInstanceSubsystem::ClearCachedNetworkFailure()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "ClearCachedNetworkFailure");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.DeclinePartyInvite
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPartyInvite                     Invite                                                 (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::DeclinePartyInvite(const struct FPartyInvite& Invite)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "DeclinePartyInvite");

	Params::SocialGameInstanceSubsystem_DeclinePartyInvite Parms{};

	Parms.Invite = std::move(Invite);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.GetBlockedPlayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UOnlineServicesBlockedPlayer*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UOnlineServicesBlockedPlayer*> USocialGameInstanceSubsystem::GetBlockedPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetBlockedPlayers");

	Params::SocialGameInstanceSubsystem_GetBlockedPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetFriends
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UOnlineServicesFriend*>    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UOnlineServicesFriend*> USocialGameInstanceSubsystem::GetFriends()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetFriends");

	Params::SocialGameInstanceSubsystem_GetFriends Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetMaxNumPartyMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USocialGameInstanceSubsystem::GetMaxNumPartyMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetMaxNumPartyMembers");

	Params::SocialGameInstanceSubsystem_GetMaxNumPartyMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetNumFriendsPlayingJP
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USocialGameInstanceSubsystem::GetNumFriendsPlayingJP()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetNumFriendsPlayingJP");

	Params::SocialGameInstanceSubsystem_GetNumFriendsPlayingJP Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetNumOnlineFriends
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 USocialGameInstanceSubsystem::GetNumOnlineFriends()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetNumOnlineFriends");

	Params::SocialGameInstanceSubsystem_GetNumOnlineFriends Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetPartyMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UOnlineServicesPartyMember*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UOnlineServicesPartyMember*> USocialGameInstanceSubsystem::GetPartyMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetPartyMembers");

	Params::SocialGameInstanceSubsystem_GetPartyMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetRecentPlayers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TArray<class UOnlineServicesRecentPlayer*>ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class UOnlineServicesRecentPlayer*> USocialGameInstanceSubsystem::GetRecentPlayers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetRecentPlayers");

	Params::SocialGameInstanceSubsystem_GetRecentPlayers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetSourceUserAvatar
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FPartyInvite                     PartyInvite                                            (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
// TDelegate<void(TSoftObjectPtr<class UTexture> Avatar)>Callback                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::GetSourceUserAvatar(const struct FPartyInvite& PartyInvite, TDelegate<void(TSoftObjectPtr<class UTexture> Avatar)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetSourceUserAvatar");

	Params::SocialGameInstanceSubsystem_GetSourceUserAvatar Parms{};

	Parms.PartyInvite = std::move(PartyInvite);
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.GetUserAvatar
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOnlineServicesUserBase*          User                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TDelegate<void(TSoftObjectPtr<class UTexture> Avatar)>Callback                                               (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::GetUserAvatar(const class UOnlineServicesUserBase* User, TDelegate<void(TSoftObjectPtr<class UTexture> Avatar)> Callback)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetUserAvatar");

	Params::SocialGameInstanceSubsystem_GetUserAvatar Parms{};

	Parms.User = User;
	Parms.Callback = Callback;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.HasPostMatchLeaderLeftCountdownStarted
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::HasPostMatchLeaderLeftCountdownStarted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "HasPostMatchLeaderLeftCountdownStarted");

	Params::SocialGameInstanceSubsystem_HasPostMatchLeaderLeftCountdownStarted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.InviteToParty
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOnlineServicesUserBase*          User                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::InviteToParty(const class UOnlineServicesUserBase* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "InviteToParty");

	Params::SocialGameInstanceSubsystem_InviteToParty Parms{};

	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.IsPartyFull
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::IsPartyFull()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "IsPartyFull");

	Params::SocialGameInstanceSubsystem_IsPartyFull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.IsPartyLeaderWithMembers
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::IsPartyLeaderWithMembers()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "IsPartyLeaderWithMembers");

	Params::SocialGameInstanceSubsystem_IsPartyLeaderWithMembers Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.KickPartyMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOnlineServicesPartyMember*       PartyMember                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::KickPartyMember(const class UOnlineServicesPartyMember* PartyMember)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "KickPartyMember");

	Params::SocialGameInstanceSubsystem_KickPartyMember Parms{};

	Parms.PartyMember = PartyMember;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.LeaveParty
// (Final, Native, Public, BlueprintCallable)

void USocialGameInstanceSubsystem::LeaveParty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "LeaveParty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.PromotePartyMember
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOnlineServicesPartyMember*       PartyMember                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::PromotePartyMember(const class UOnlineServicesPartyMember* PartyMember)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "PromotePartyMember");

	Params::SocialGameInstanceSubsystem_PromotePartyMember Parms{};

	Parms.PartyMember = PartyMember;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.UnblockPlayer
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UOnlineServicesUserBase*          User                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialGameInstanceSubsystem::UnblockPlayer(const class UOnlineServicesUserBase* User)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "UnblockPlayer");

	Params::SocialGameInstanceSubsystem_UnblockPlayer Parms{};

	Parms.User = User;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialGameInstanceSubsystem.GetCachedNetworkFailureAsString
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FString USocialGameInstanceSubsystem::GetCachedNetworkFailureAsString() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetCachedNetworkFailureAsString");

	Params::SocialGameInstanceSubsystem_GetCachedNetworkFailureAsString Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetExistingPartyInvites
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TArray<struct FPartyInvite>             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FPartyInvite> USocialGameInstanceSubsystem::GetExistingPartyInvites() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetExistingPartyInvites");

	Params::SocialGameInstanceSubsystem_GetExistingPartyInvites Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.GetPostMatchLeaderLeftLeaveTime
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float USocialGameInstanceSubsystem::GetPostMatchLeaderLeftLeaveTime() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "GetPostMatchLeaderLeftLeaveTime");

	Params::SocialGameInstanceSubsystem_GetPostMatchLeaderLeftLeaveTime Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.HasCachedNetworkFailure
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::HasCachedNetworkFailure() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "HasCachedNetworkFailure");

	Params::SocialGameInstanceSubsystem_HasCachedNetworkFailure Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.IsInParty
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::IsInParty() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "IsInParty");

	Params::SocialGameInstanceSubsystem_IsInParty Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.IsLocalUserPartyLeader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::IsLocalUserPartyLeader() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "IsLocalUserPartyLeader");

	Params::SocialGameInstanceSubsystem_IsLocalUserPartyLeader Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.IsPartyMemberLeader
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UOnlineServicesPartyMember*       PartyMember                                            (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::IsPartyMemberLeader(const class UOnlineServicesPartyMember* PartyMember) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "IsPartyMemberLeader");

	Params::SocialGameInstanceSubsystem_IsPartyMemberLeader Parms{};

	Parms.PartyMember = PartyMember;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.TryGetCachedNetworkFailureAsTag
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     NetworkFailureTag                                      (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::TryGetCachedNetworkFailureAsTag(struct FGameplayTag* NetworkFailureTag) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "TryGetCachedNetworkFailureAsTag");

	Params::SocialGameInstanceSubsystem_TryGetCachedNetworkFailureAsTag Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (NetworkFailureTag != nullptr)
		*NetworkFailureTag = std::move(Parms.NetworkFailureTag);

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.TryGetFollowLeaderNetworkFailureDescriptor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FString                           FailureString                                          (Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonGameDialogDescriptor*      Descriptor                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::TryGetFollowLeaderNetworkFailureDescriptor(const class FString& FailureString, class UCommonGameDialogDescriptor** Descriptor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "TryGetFollowLeaderNetworkFailureDescriptor");

	Params::SocialGameInstanceSubsystem_TryGetFollowLeaderNetworkFailureDescriptor Parms{};

	Parms.FailureString = std::move(FailureString);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Descriptor != nullptr)
		*Descriptor = Parms.Descriptor;

	return Parms.ReturnValue;
}


// Function JP.SocialGameInstanceSubsystem.TryGetNetworkFailureTagDescriptor
// (Final, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FGameplayTag                     FailureTag                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UCommonGameDialogDescriptor*      Descriptor                                             (Parm, OutParm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool USocialGameInstanceSubsystem::TryGetNetworkFailureTagDescriptor(const struct FGameplayTag& FailureTag, class UCommonGameDialogDescriptor** Descriptor) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialGameInstanceSubsystem", "TryGetNetworkFailureTagDescriptor");

	Params::SocialGameInstanceSubsystem_TryGetNetworkFailureTagDescriptor Parms{};

	Parms.FailureTag = std::move(FailureTag);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Descriptor != nullptr)
		*Descriptor = Parms.Descriptor;

	return Parms.ReturnValue;
}


// Function JP.SocialPartyInviteWidget.ApplyAvatar
// (Event, Protected, BlueprintEvent)

void USocialPartyInviteWidget::ApplyAvatar()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyInviteWidget", "ApplyAvatar");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.SocialPartyInviteWidget.OnAcceptButtonClicked
// (Final, Native, Private)

void USocialPartyInviteWidget::OnAcceptButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyInviteWidget", "OnAcceptButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialPartyInviteWidget.OnDeclineButtonClicked
// (Final, Native, Private)

void USocialPartyInviteWidget::OnDeclineButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyInviteWidget", "OnDeclineButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialPartyInviteWidget.SetAvatar
// (Final, Native, Private)
// Parameters:
// TSoftObjectPtr<class UTexture>          InAvatar                                               (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialPartyInviteWidget::SetAvatar(TSoftObjectPtr<class UTexture> InAvatar)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyInviteWidget", "SetAvatar");

	Params::SocialPartyInviteWidget_SetAvatar Parms{};

	Parms.InAvatar = InAvatar;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialPartyMemberInteractionWidget.OnKickButtonClicked
// (Final, Native, Private)

void USocialPartyMemberInteractionWidget::OnKickButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyMemberInteractionWidget", "OnKickButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialPartyMemberInteractionWidget.OnLeavePartyButtonClicked
// (Final, Native, Private)

void USocialPartyMemberInteractionWidget::OnLeavePartyButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyMemberInteractionWidget", "OnLeavePartyButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialPartyMemberInteractionWidget.OnPromoteButtonClicked
// (Final, Native, Private)

void USocialPartyMemberInteractionWidget::OnPromoteButtonClicked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyMemberInteractionWidget", "OnPromoteButtonClicked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialPartyMemberInteractionWidget.SetPartyInfo
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bIsPartyOfOne                                          (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLocalUser                                           (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bIsLocalUserPartyLeader                                (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void USocialPartyMemberInteractionWidget::SetPartyInfo(const bool bIsPartyOfOne, const bool bIsLocalUser, const bool bIsLocalUserPartyLeader)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyMemberInteractionWidget", "SetPartyInfo");

	Params::SocialPartyMemberInteractionWidget_SetPartyInfo Parms{};

	Parms.bIsPartyOfOne = bIsPartyOfOne;
	Parms.bIsLocalUser = bIsLocalUser;
	Parms.bIsLocalUserPartyLeader = bIsLocalUserPartyLeader;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialPartyMembersListWidget.UpdatePartyMembersList
// (Final, Native, Private)

void USocialPartyMembersListWidget::UpdatePartyMembersList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialPartyMembersListWidget", "UpdatePartyMembersList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SocialRecentPlayersListWidget.BlueprintOnBlockPlayerFailed
// (Event, Protected, BlueprintEvent)

void USocialRecentPlayersListWidget::BlueprintOnBlockPlayerFailed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialRecentPlayersListWidget", "BlueprintOnBlockPlayerFailed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.SocialRecentPlayersListWidget.UpdateRecentPlayersList
// (Final, Native, Private)

void USocialRecentPlayersListWidget::UpdateRecentPlayersList()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SocialRecentPlayersListWidget", "UpdateRecentPlayersList");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SprintGA.OnStaminaEmpty
// (Final, Native, Private)

void USprintGA::OnStaminaEmpty()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SprintGA", "OnStaminaEmpty");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StaminaAttributeSetListener.OnStaminaChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Stamina                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   MaxStamina                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStaminaAttributeSetListener::OnStaminaChanged(float Stamina, float MaxStamina)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaAttributeSetListener", "OnStaminaChanged");

	Params::StaminaAttributeSetListener_OnStaminaChanged Parms{};

	Parms.Stamina = Stamina;
	Parms.MaxStamina = MaxStamina;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StaminaAttributeSet.OnRep_MaxStamina
// (Final, Native, Private)

void UStaminaAttributeSet::OnRep_MaxStamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaAttributeSet", "OnRep_MaxStamina");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StaminaAttributeSet.OnRep_Stamina
// (Final, Native, Private)

void UStaminaAttributeSet::OnRep_Stamina()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StaminaAttributeSet", "OnRep_Stamina");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnAgilityChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Agility                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnAgilityChanged(float Agility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnAgilityChanged");

	Params::StatsAttributeSetListener_OnAgilityChanged Parms{};

	Parms.Agility = Agility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnAgilityModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Agility                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnAgilityModifierChanged(float Agility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnAgilityModifierChanged");

	Params::StatsAttributeSetListener_OnAgilityModifierChanged Parms{};

	Parms.Agility = Agility;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnArmorModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Armor                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnArmorModifierChanged(float Armor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnArmorModifierChanged");

	Params::StatsAttributeSetListener_OnArmorModifierChanged Parms{};

	Parms.Armor = Armor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnCritChanceChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   CritChance                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnCritChanceChanged(float CritChance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnCritChanceChanged");

	Params::StatsAttributeSetListener_OnCritChanceChanged Parms{};

	Parms.CritChance = CritChance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnCritMultiplierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   CritMultiplier                                         (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnCritMultiplierChanged(float CritMultiplier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnCritMultiplierChanged");

	Params::StatsAttributeSetListener_OnCritMultiplierChanged Parms{};

	Parms.CritMultiplier = CritMultiplier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnEnduranceChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Endurance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnEnduranceChanged(float Endurance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnEnduranceChanged");

	Params::StatsAttributeSetListener_OnEnduranceChanged Parms{};

	Parms.Endurance = Endurance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnEnduranceModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Endurance                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnEnduranceModifierChanged(float Endurance)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnEnduranceModifierChanged");

	Params::StatsAttributeSetListener_OnEnduranceModifierChanged Parms{};

	Parms.Endurance = Endurance;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnHealthChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnHealthChanged(float Health)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnHealthChanged");

	Params::StatsAttributeSetListener_OnHealthChanged Parms{};

	Parms.Health = Health;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnHealthModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Health                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnHealthModifierChanged(float Health)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnHealthModifierChanged");

	Params::StatsAttributeSetListener_OnHealthModifierChanged Parms{};

	Parms.Health = Health;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnLevelDamageModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   LevelDamageModifier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnLevelDamageModifierChanged(float LevelDamageModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnLevelDamageModifierChanged");

	Params::StatsAttributeSetListener_OnLevelDamageModifierChanged Parms{};

	Parms.LevelDamageModifier = LevelDamageModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnMeleeDamageModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   MeleeDamageModifier                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnMeleeDamageModifierChanged(float MeleeDamageModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnMeleeDamageModifierChanged");

	Params::StatsAttributeSetListener_OnMeleeDamageModifierChanged Parms{};

	Parms.MeleeDamageModifier = MeleeDamageModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnPlayerDamageMultiplierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   PlayerDamage                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnPlayerDamageMultiplierChanged(float PlayerDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnPlayerDamageMultiplierChanged");

	Params::StatsAttributeSetListener_OnPlayerDamageMultiplierChanged Parms{};

	Parms.PlayerDamage = PlayerDamage;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnRangedDamageModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   RangedDamageModifier                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnRangedDamageModifierChanged(float RangedDamageModifier)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnRangedDamageModifierChanged");

	Params::StatsAttributeSetListener_OnRangedDamageModifierChanged Parms{};

	Parms.RangedDamageModifier = RangedDamageModifier;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnStrengthChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnStrengthChanged(float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnStrengthChanged");

	Params::StatsAttributeSetListener_OnStrengthChanged Parms{};

	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnStrengthModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Strength                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnStrengthModifierChanged(float Strength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnStrengthModifierChanged");

	Params::StatsAttributeSetListener_OnStrengthModifierChanged Parms{};

	Parms.Strength = Strength;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnSubtletyChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Subtlety                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnSubtletyChanged(float Subtlety)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnSubtletyChanged");

	Params::StatsAttributeSetListener_OnSubtletyChanged Parms{};

	Parms.Subtlety = Subtlety;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSetListener.OnSubtletyModifierChanged
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// float                                   Subtlety                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void IStatsAttributeSetListener::OnSubtletyModifierChanged(float Subtlety)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSetListener", "OnSubtletyModifierChanged");

	Params::StatsAttributeSetListener_OnSubtletyModifierChanged Parms{};

	Parms.Subtlety = Subtlety;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_Agility
// (Native, Protected)

void UStatsAttributeSet::OnRep_Agility()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_Agility");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_AgilityModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_AgilityModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_AgilityModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_ArmorModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_ArmorModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_ArmorModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_CritChance
// (Native, Protected)

void UStatsAttributeSet::OnRep_CritChance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_CritChance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_CritMultiplier
// (Native, Protected)

void UStatsAttributeSet::OnRep_CritMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_CritMultiplier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_Endurance
// (Native, Protected)

void UStatsAttributeSet::OnRep_Endurance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_Endurance");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_EnduranceModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_EnduranceModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_EnduranceModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_Health
// (Native, Protected)

void UStatsAttributeSet::OnRep_Health()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_Health");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_HealthModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_HealthModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_HealthModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_LevelDamageModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_LevelDamageModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_LevelDamageModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_MeleeDamageModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_MeleeDamageModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_MeleeDamageModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_PlayerDamageMultiplier
// (Native, Protected)

void UStatsAttributeSet::OnRep_PlayerDamageMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_PlayerDamageMultiplier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_RangedDamageModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_RangedDamageModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_RangedDamageModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_Strength
// (Native, Protected)

void UStatsAttributeSet::OnRep_Strength()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_Strength");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_StrengthModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_StrengthModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_StrengthModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_Subtlety
// (Native, Protected)

void UStatsAttributeSet::OnRep_Subtlety()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_Subtlety");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.StatsAttributeSet.OnRep_SubtletyModifier
// (Native, Protected)

void UStatsAttributeSet::OnRep_SubtletyModifier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("StatsAttributeSet", "OnRep_SubtletyModifier");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SubObjective.GetIsCompleted
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASubObjective::GetIsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "GetIsCompleted");

	Params::SubObjective_GetIsCompleted Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SubObjective.GetIsUnlocked
// (Final, BlueprintCosmetic, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ASubObjective::GetIsUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "GetIsUnlocked");

	Params::SubObjective_GetIsUnlocked Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SubObjective.GetText
// (BlueprintCosmetic, Native, Event, Public, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class FText                             ReturnValue                                            (Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)

class FText ASubObjective::GetText()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "GetText");

	Params::SubObjective_GetText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.SubObjective.OnRep_bIsCompleted
// (Final, Native, Private)

void ASubObjective::OnRep_bIsCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "OnRep_bIsCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SubObjective.OnRep_bIsUnlocked
// (Final, Native, Private)

void ASubObjective::OnRep_bIsUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "OnRep_bIsUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SubObjective.OwningObjectiveDestroyed
// (Final, Native, Protected)
// Parameters:
// struct FObjectiveAndOwningPlayer        Objective                                              (Parm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ASubObjective::OwningObjectiveDestroyed(const struct FObjectiveAndOwningPlayer& Objective)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "OwningObjectiveDestroyed");

	Params::SubObjective_OwningObjectiveDestroyed Parms{};

	Parms.Objective = std::move(Objective);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SubObjective.SetIsUnlocked
// (Final, Native, Public)
// Parameters:
// bool                                    IsUnlocked                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ASubObjective::SetIsUnlocked(bool IsUnlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "SetIsUnlocked");

	Params::SubObjective_SetIsUnlocked Parms{};

	Parms.IsUnlocked = IsUnlocked;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.SubObjective.SubObjectiveCompleted
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)

void ASubObjective::SubObjectiveCompleted()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "SubObjectiveCompleted");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SubObjective.UpdateIsUnlocked
// (Final, Native, Public)

void ASubObjective::UpdateIsUnlocked()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "UpdateIsUnlocked");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.SubObjective.UpdateUI
// (Final, BlueprintCosmetic, Native, Protected, BlueprintCallable)

void ASubObjective::UpdateUI()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("SubObjective", "UpdateUI");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.TaskSpawner.GetAllSpawnersSupportingTypes
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// TArray<TSubclassOf<class AActor>>       SupportingTypes                                        (Parm, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> ATaskSpawner::GetAllSpawnersSupportingTypes(const TArray<TSubclassOf<class AActor>>& SupportingTypes, class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TaskSpawner", "GetAllSpawnersSupportingTypes");

	Params::TaskSpawner_GetAllSpawnersSupportingTypes Parms{};

	Parms.SupportingTypes = std::move(SupportingTypes);
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TaskSpawner.CanSpawnType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>               TaskType                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ATaskSpawner::CanSpawnType(TSubclassOf<class AActor> TaskType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSpawner", "CanSpawnType");

	Params::TaskSpawner_CanSpawnType Parms{};

	Parms.TaskType = TaskType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TaskSpawner.ClaimSpawner
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           SpawnedActor                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATaskSpawner::ClaimSpawner(class AActor* SpawnedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSpawner", "ClaimSpawner");

	Params::TaskSpawner_ClaimSpawner Parms{};

	Parms.SpawnedActor = SpawnedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TaskSpawner.GetFirstSpawnableType
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// TSubclassOf<class AActor>               ParentType                                             (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class AActor>               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class AActor> ATaskSpawner::GetFirstSpawnableType(TSubclassOf<class AActor> ParentType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSpawner", "GetFirstSpawnableType");

	Params::TaskSpawner_GetFirstSpawnableType Parms{};

	Parms.ParentType = ParentType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TaskSpawner.OnGroundsKeeperChanged
// (Final, Native, Private)
// Parameters:
// class AGroundsKeeper*                   OldGroundsKeeper                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGroundsKeeper*                   NewGroundskeeper                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATaskSpawner::OnGroundsKeeperChanged(class AGroundsKeeper* OldGroundsKeeper, class AGroundsKeeper* NewGroundskeeper)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSpawner", "OnGroundsKeeperChanged");

	Params::TaskSpawner_OnGroundsKeeperChanged Parms{};

	Parms.OldGroundsKeeper = OldGroundsKeeper;
	Parms.NewGroundskeeper = NewGroundskeeper;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TaskSpawner.ReleaseSpawner
// (Final, Native, Public)
// Parameters:
// class AActor*                           DestroyedActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ATaskSpawner::ReleaseSpawner(class AActor* DestroyedActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSpawner", "ReleaseSpawner");

	Params::TaskSpawner_ReleaseSpawner Parms{};

	Parms.DestroyedActor = DestroyedActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TaskSpawner.SpawnTask
// (Native, Event, Public, BlueprintEvent)
// Parameters:
// TSubclassOf<class AActor>               TaskType                                               (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AActor* ATaskSpawner::SpawnTask(TSubclassOf<class AActor> TaskType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSpawner", "SpawnTask");

	Params::TaskSpawner_SpawnTask Parms{};

	Parms.TaskType = TaskType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TaskSpawner.GetTaskTransform
// (Native, Event, Public, HasDefaults, BlueprintEvent, Const)
// Parameters:
// struct FTransform                       ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FTransform ATaskSpawner::GetTaskTransform() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TaskSpawner", "GetTaskTransform");

	Params::TaskSpawner_GetTaskTransform Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamAssignableInterface.SetTeamType
// (Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// ETeamType                               TeamType                                               (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITeamAssignableInterface::SetTeamType(const ETeamType TeamType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamAssignableInterface", "SetTeamType");

	Params::TeamAssignableInterface_SetTeamType Parms{};

	Parms.TeamType = TeamType;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamColoredStaticMeshActor.SetTeam
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FTeam                            Team                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

void ATeamColoredStaticMeshActor::SetTeam(const struct FTeam& Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamColoredStaticMeshActor", "SetTeam");

	Params::TeamColoredStaticMeshActor_SetTeam Parms{};

	Parms.Team = std::move(Team);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamScoreInterface.AddScore
// (BlueprintAuthorityOnly, Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITeamScoreInterface::AddScore(int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamScoreInterface", "AddScore");

	Params::TeamScoreInterface_AddScore Parms{};

	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamScoreInterface.SubtractScore
// (BlueprintAuthorityOnly, Native, Event, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   Score                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ITeamScoreInterface::SubtractScore(int32 Score)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("TeamScoreInterface", "SubtractScore");

	Params::TeamScoreInterface_SubtractScore Parms{};

	Parms.Score = Score;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.TeamUtilityLibrary.DoAllTeamsExist
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTeamUtilityLibrary::DoAllTeamsExist(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "DoAllTeamsExist");

	Params::TeamUtilityLibrary_DoAllTeamsExist Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.DoesTeamExist
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   TeamId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTeamUtilityLibrary::DoesTeamExist(const uint8 TeamId, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "DoesTeamExist");

	Params::TeamUtilityLibrary_DoesTeamExist Parms{};

	Parms.TeamId = TeamId;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetGroundsKeeperAtPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFoundTeam                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class ATeamVolume*>              OverlappingTeamVolumes                                 (Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
// class AGroundsKeeper*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGroundsKeeper* UTeamUtilityLibrary::GetGroundsKeeperAtPoint(const class UObject* WorldContextObject, const struct FVector& Point, bool* bFoundTeam, TArray<class ATeamVolume*>* OverlappingTeamVolumes)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetGroundsKeeperAtPoint");

	Params::TeamUtilityLibrary_GetGroundsKeeperAtPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFoundTeam != nullptr)
		*bFoundTeam = Parms.bFoundTeam;

	if (OverlappingTeamVolumes != nullptr)
		*OverlappingTeamVolumes = std::move(Parms.OverlappingTeamVolumes);

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetGroundsKeeperByTeamId
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AGroundsKeeper*                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class AGroundsKeeper* UTeamUtilityLibrary::GetGroundsKeeperByTeamId(const class UObject* WorldContextObject, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetGroundsKeeperByTeamId");

	Params::TeamUtilityLibrary_GetGroundsKeeperByTeamId Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetMinimumTeamID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UTeamUtilityLibrary::GetMinimumTeamID()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetMinimumTeamID");

	Params::TeamUtilityLibrary_GetMinimumTeamID Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetNextTeamID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UTeamUtilityLibrary::GetNextTeamID(uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetNextTeamID");

	Params::TeamUtilityLibrary_GetNextTeamID Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetNumberOfActiveTeams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UTeamUtilityLibrary::GetNumberOfActiveTeams(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetNumberOfActiveTeams");

	Params::TeamUtilityLibrary_GetNumberOfActiveTeams Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetPlayerControllersOfTeam
// (Final, BlueprintAuthorityOnly, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APlayerControllerJP*>      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerControllerJP*> UTeamUtilityLibrary::GetPlayerControllersOfTeam(const class UObject* WorldContextObject, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetPlayerControllersOfTeam");

	Params::TeamUtilityLibrary_GetPlayerControllersOfTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetPlayersOfTeam
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class APlayerStateJP*>           ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class APlayerStateJP*> UTeamUtilityLibrary::GetPlayersOfTeam(const class UObject* WorldContextObject, uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetPlayersOfTeam");

	Params::TeamUtilityLibrary_GetPlayersOfTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetTeam
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTeam                      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTeam UTeamUtilityLibrary::GetTeam(uint8 TeamId, const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetTeam");

	Params::TeamUtilityLibrary_GetTeam Parms{};

	Parms.TeamId = TeamId;
	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetTeamAtPoint
// (Final, Native, Static, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Point                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bFoundTeam                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FGameplayTag                     TeamVolumeGameplayTag                                  (Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// const struct FTeam                      ReturnValue                                            (ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)

const struct FTeam UTeamUtilityLibrary::GetTeamAtPoint(const class UObject* WorldContextObject, const struct FVector& Point, bool* bFoundTeam, struct FGameplayTag* TeamVolumeGameplayTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetTeamAtPoint");

	Params::TeamUtilityLibrary_GetTeamAtPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.Point = std::move(Point);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (bFoundTeam != nullptr)
		*bFoundTeam = Parms.bFoundTeam;

	if (TeamVolumeGameplayTag != nullptr)
		*TeamVolumeGameplayTag = std::move(Parms.TeamVolumeGameplayTag);

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetTeams
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<struct FTeam>                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<struct FTeam> UTeamUtilityLibrary::GetTeams(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetTeams");

	Params::TeamUtilityLibrary_GetTeams Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.GetTeamWithLeastPlayersID
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// uint8                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

uint8 UTeamUtilityLibrary::GetTeamWithLeastPlayersID(const class UObject* WorldContextObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "GetTeamWithLeastPlayersID");

	Params::TeamUtilityLibrary_GetTeamWithLeastPlayersID Parms{};

	Parms.WorldContextObject = WorldContextObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.IsTeamIDValid
// (Final, Native, Static, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// uint8                                   TeamId                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTeamUtilityLibrary::IsTeamIDValid(uint8 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "IsTeamIDValid");

	Params::TeamUtilityLibrary_IsTeamIDValid Parms{};

	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TeamUtilityLibrary.IsTeamValid
// (Final, Native, Static, Public, HasOutParams, BlueprintCallable, BlueprintPure)
// Parameters:
// struct FTeam                            Team                                                   (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UTeamUtilityLibrary::IsTeamValid(const struct FTeam& Team)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TeamUtilityLibrary", "IsTeamValid");

	Params::TeamUtilityLibrary_IsTeamValid Parms{};

	Parms.Team = std::move(Team);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.TurretFunctionLibrary.GetOverlappingActorsWithInterface
// (Final, Native, Static, Public, BlueprintCallable)
// Parameters:
// class UPrimitiveComponent*              OverlapComponent                                       (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class IInterface>           InterfaceClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TArray<class AActor*>                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)

TArray<class AActor*> UTurretFunctionLibrary::GetOverlappingActorsWithInterface(class UPrimitiveComponent* OverlapComponent, TSubclassOf<class IInterface> InterfaceClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("TurretFunctionLibrary", "GetOverlappingActorsWithInterface");

	Params::TurretFunctionLibrary_GetOverlappingActorsWithInterface Parms{};

	Parms.OverlapComponent = OverlapComponent;
	Parms.InterfaceClass = InterfaceClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.CharacterInitializationStepComponent.ReceivePlayerStateChanged
// (Event, Public, BlueprintEvent)
// Parameters:
// bool                                    ValidPlayerState                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UCharacterInitializationStepComponent::ReceivePlayerStateChanged(bool ValidPlayerState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("CharacterInitializationStepComponent", "ReceivePlayerStateChanged");

	Params::CharacterInitializationStepComponent_ReceivePlayerStateChanged Parms{};

	Parms.ValidPlayerState = ValidPlayerState;

	UObject::ProcessEvent(Func, &Parms);
}


// Function JP.EconomySubsystem.BeginPlayerEconomy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RecipientActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEconomySubsystem::BeginPlayerEconomy(class AActor* RecipientActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "BeginPlayerEconomy");

	Params::EconomySubsystem_BeginPlayerEconomy Parms{};

	Parms.RecipientActor = RecipientActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EconomySubsystem.BeginPlayerEconomyLateJoin
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RecipientActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEconomySubsystem::BeginPlayerEconomyLateJoin(class AActor* RecipientActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "BeginPlayerEconomyLateJoin");

	Params::EconomySubsystem_BeginPlayerEconomyLateJoin Parms{};

	Parms.RecipientActor = RecipientActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EconomySubsystem.CanAfford
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UEconomyDefinition*               EconomyToTest                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           EconomyOwner                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEconomySubsystem::CanAfford(class UEconomyDefinition* EconomyToTest, class AActor* EconomyOwner)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "CanAfford");

	Params::EconomySubsystem_CanAfford Parms{};

	Parms.EconomyToTest = EconomyToTest;
	Parms.EconomyOwner = EconomyOwner;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomySubsystem.DepositEconomy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEconomyDefinition*               EconomyToAdd                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           RecipientActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEconomySubsystem::DepositEconomy(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToAdd, class AActor* RecipientActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "DepositEconomy");

	Params::EconomySubsystem_DepositEconomy Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EconomyToAdd = EconomyToAdd;
	Parms.RecipientActor = RecipientActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EconomySubsystem.DepositEconomyToTeam
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEconomyDefinition*               EconomyToAdd                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEconomySubsystem::DepositEconomyToTeam(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToAdd, const int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "DepositEconomyToTeam");

	Params::EconomySubsystem_DepositEconomyToTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EconomyToAdd = EconomyToAdd;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EconomySubsystem.DepositEconomyToTeamAtPoint
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEconomyDefinition*               EconomyToAdd                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEconomySubsystem::DepositEconomyToTeamAtPoint(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToAdd, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "DepositEconomyToTeamAtPoint");

	Params::EconomySubsystem_DepositEconomyToTeamAtPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EconomyToAdd = EconomyToAdd;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EconomySubsystem.EndPlayerEconomy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RecipientActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEconomySubsystem::EndPlayerEconomy(class AActor* RecipientActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "EndPlayerEconomy");

	Params::EconomySubsystem_EndPlayerEconomy Parms{};

	Parms.RecipientActor = RecipientActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EconomySubsystem.GetPassiveIncomePerTick
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RecipientActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEconomySubsystem::GetPassiveIncomePerTick(class AActor* RecipientActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "GetPassiveIncomePerTick");

	Params::EconomySubsystem_GetPassiveIncomePerTick Parms{};

	Parms.RecipientActor = RecipientActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomySubsystem.GetPassiveIncomeStat
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RecipientActor                                         (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

float UEconomySubsystem::GetPassiveIncomeStat(class AActor* RecipientActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "GetPassiveIncomeStat");

	Params::EconomySubsystem_GetPassiveIncomeStat Parms{};

	Parms.RecipientActor = RecipientActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomySubsystem.GrantKillReward
// (Final, Native, Public, HasOutParams, BlueprintCallable)
// Parameters:
// struct FKillReward                      KillReward                                             (ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FKillInfo                        Info                                                   (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void UEconomySubsystem::GrantKillReward(const struct FKillReward& KillReward, const struct FKillInfo& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "GrantKillReward");

	Params::EconomySubsystem_GrantKillReward Parms{};

	Parms.KillReward = std::move(KillReward);
	Parms.Info = std::move(Info);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EconomySubsystem.SetPassiveIncomePerTick
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class AActor*                           RecipientActor                                         (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   NewValue                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UEconomySubsystem::SetPassiveIncomePerTick(const class AActor* RecipientActor, float NewValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "SetPassiveIncomePerTick");

	Params::EconomySubsystem_SetPassiveIncomePerTick Parms{};

	Parms.RecipientActor = RecipientActor;
	Parms.NewValue = NewValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.EconomySubsystem.WithdrawEconomy
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEconomyDefinition*               EconomyToRemove                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           GiverActor                                             (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEconomySubsystem::WithdrawEconomy(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToRemove, class AActor* GiverActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "WithdrawEconomy");

	Params::EconomySubsystem_WithdrawEconomy Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EconomyToRemove = EconomyToRemove;
	Parms.GiverActor = GiverActor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomySubsystem.WithdrawEconomyFromTeam
// (Final, BlueprintAuthorityOnly, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEconomyDefinition*               EconomyToRemove                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   TeamId                                                 (ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEconomySubsystem::WithdrawEconomyFromTeam(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToRemove, const int32 TeamId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "WithdrawEconomyFromTeam");

	Params::EconomySubsystem_WithdrawEconomyFromTeam Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EconomyToRemove = EconomyToRemove;
	Parms.TeamId = TeamId;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomySubsystem.WithdrawEconomyFromTeamAtPoint
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// class UObject*                          WorldContextObject                                     (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEconomyDefinition*               EconomyToRemove                                        (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FVector                          Position                                               (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEconomySubsystem::WithdrawEconomyFromTeamAtPoint(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToRemove, const struct FVector& Position)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "WithdrawEconomyFromTeamAtPoint");

	Params::EconomySubsystem_WithdrawEconomyFromTeamAtPoint Parms{};

	Parms.WorldContextObject = WorldContextObject;
	Parms.EconomyToRemove = EconomyToRemove;
	Parms.Position = std::move(Position);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomySubsystem.CanAffordResourceType
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EResourceType                           Type                                                   (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class AActor*                           Owner                                                  (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class UEconomyDefinition*               EconomyToTest                                          (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UEconomySubsystem::CanAffordResourceType(EResourceType Type, const class AActor* Owner, class UEconomyDefinition* EconomyToTest) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "CanAffordResourceType");

	Params::EconomySubsystem_CanAffordResourceType Parms{};

	Parms.Type = Type;
	Parms.Owner = Owner;
	Parms.EconomyToTest = EconomyToTest;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.EconomySubsystem.GetPlayerEconomy
// (Final, BlueprintAuthorityOnly, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class APlayerController*                PlayerController                                       (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// struct FResourceData                    Money                                                  (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FResourceData                    Wood                                                   (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FResourceData                    Perfectness                                            (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
// struct FResourceData                    PassiveIncome                                          (Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)

void UEconomySubsystem::GetPlayerEconomy(class APlayerController* PlayerController, struct FResourceData* Money, struct FResourceData* Wood, struct FResourceData* Perfectness, struct FResourceData* PassiveIncome) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "GetPlayerEconomy");

	Params::EconomySubsystem_GetPlayerEconomy Parms{};

	Parms.PlayerController = PlayerController;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Money != nullptr)
		*Money = std::move(Parms.Money);

	if (Wood != nullptr)
		*Wood = std::move(Parms.Wood);

	if (Perfectness != nullptr)
		*Perfectness = std::move(Parms.Perfectness);

	if (PassiveIncome != nullptr)
		*PassiveIncome = std::move(Parms.PassiveIncome);
}


// Function JP.EconomySubsystem.GetPlayerEconomyAsText
// (Final, BlueprintCosmetic, Native, Public, HasOutParams, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FText                             Money                                                  (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText                             Wood                                                   (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText                             Perfectness                                            (Parm, OutParm, NativeAccessSpecifierPublic)
// class FText                             PerfectnessNormalised                                  (Parm, OutParm, NativeAccessSpecifierPublic)

void UEconomySubsystem::GetPlayerEconomyAsText(class FText* Money, class FText* Wood, class FText* Perfectness, class FText* PerfectnessNormalised) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("EconomySubsystem", "GetPlayerEconomyAsText");

	Params::EconomySubsystem_GetPlayerEconomyAsText Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	if (Money != nullptr)
		*Money = std::move(Parms.Money);

	if (Wood != nullptr)
		*Wood = std::move(Parms.Wood);

	if (Perfectness != nullptr)
		*Perfectness = std::move(Parms.Perfectness);

	if (PerfectnessNormalised != nullptr)
		*PerfectnessNormalised = std::move(Parms.PerfectnessNormalised);
}


// Function JP.PlayerEconomyComponent.OnRep_PlayerEconomy
// (Final, Native, Private)

void UPlayerEconomyComponent::OnRep_PlayerEconomy()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEconomyComponent", "OnRep_PlayerEconomy");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerEconomyComponent.ServerAddMoneyCheat
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEconomyComponent::ServerAddMoneyCheat(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEconomyComponent", "ServerAddMoneyCheat");

	Params::PlayerEconomyComponent_ServerAddMoneyCheat Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerEconomyComponent.ServerAddPassiveIncome
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEconomyComponent::ServerAddPassiveIncome(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEconomyComponent", "ServerAddPassiveIncome");

	Params::PlayerEconomyComponent_ServerAddPassiveIncome Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.PlayerEconomyComponent.ServerAddWoodCheat
// (Net, NetReliable, Native, Event, Public, NetServer)
// Parameters:
// float                                   Amount                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UPlayerEconomyComponent::ServerAddWoodCheat(float Amount)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("PlayerEconomyComponent", "ServerAddWoodCheat");

	Params::PlayerEconomyComponent_ServerAddWoodCheat Parms{};

	Parms.Amount = Amount;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraLocalPlayer.OnCompletedAudioDeviceSwap
// (Final, Native, Protected, HasOutParams)
// Parameters:
// struct FSwapAudioOutputResult           SwapResult                                             (ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)

void ULyraLocalPlayer::OnCompletedAudioDeviceSwap(const struct FSwapAudioOutputResult& SwapResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLocalPlayer", "OnCompletedAudioDeviceSwap");

	Params::LyraLocalPlayer_OnCompletedAudioDeviceSwap Parms{};

	Parms.SwapResult = std::move(SwapResult);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraLocalPlayer.OnControllerChangedTeam
// (Final, Native, Private)
// Parameters:
// class UObject*                          TeamAgent                                              (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   OldTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// int32                                   NewTeam                                                (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraLocalPlayer::OnControllerChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLocalPlayer", "OnControllerChangedTeam");

	Params::LyraLocalPlayer_OnControllerChangedTeam Parms{};

	Parms.TeamAgent = TeamAgent;
	Parms.OldTeam = OldTeam;
	Parms.NewTeam = NewTeam;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraLocalPlayer.GetLocalSettings
// (Final, Native, Public, Const)
// Parameters:
// class ULyraSettingsLocal*               ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraSettingsLocal* ULyraLocalPlayer::GetLocalSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLocalPlayer", "GetLocalSettings");

	Params::LyraLocalPlayer_GetLocalSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraLocalPlayer.GetSharedSettings
// (Final, Native, Public, Const)
// Parameters:
// class ULyraSettingsShared*              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class ULyraSettingsShared* ULyraLocalPlayer::GetSharedSettings() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLocalPlayer", "GetSharedSettings");

	Params::LyraLocalPlayer_GetSharedSettings Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.MaterialProgressBar.AnimateProgressFromCurrent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::AnimateProgressFromCurrent(float End, float AnimSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "AnimateProgressFromCurrent");

	Params::MaterialProgressBar_AnimateProgressFromCurrent Parms{};

	Parms.End = End;
	Parms.AnimSpeed = AnimSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MaterialProgressBar.AnimateProgressFromStart
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Start                                                  (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   End                                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// float                                   AnimSpeed                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::AnimateProgressFromStart(float Start, float End, float AnimSpeed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "AnimateProgressFromStart");

	Params::MaterialProgressBar_AnimateProgressFromStart Parms{};

	Parms.Start = Start;
	Parms.End = End;
	Parms.AnimSpeed = AnimSpeed;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// DelegateFunction JP.MaterialProgressBar.OnFillAnimationFinished__DelegateSignature
// (MulticastDelegate, Public, Delegate)

void UMaterialProgressBar::OnFillAnimationFinished__DelegateSignature()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "OnFillAnimationFinished__DelegateSignature");

	UObject::ProcessEvent(Func, nullptr);
}


// Function JP.MaterialProgressBar.SetColorA
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ColorA                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetColorA(const struct FLinearColor& ColorA)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetColorA");

	Params::MaterialProgressBar_SetColorA Parms{};

	Parms.ColorA = std::move(ColorA);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MaterialProgressBar.SetColorB
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ColorB                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetColorB(const struct FLinearColor& ColorB)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetColorB");

	Params::MaterialProgressBar_SetColorB Parms{};

	Parms.ColorB = std::move(ColorB);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MaterialProgressBar.SetColorBackground
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FLinearColor                     ColorBackground                                        (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetColorBackground(const struct FLinearColor& ColorBackground)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetColorBackground");

	Params::MaterialProgressBar_SetColorBackground Parms{};

	Parms.ColorBackground = std::move(ColorBackground);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MaterialProgressBar.SetProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   Progress                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetProgress(float Progress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetProgress");

	Params::MaterialProgressBar_SetProgress Parms{};

	Parms.Progress = Progress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MaterialProgressBar.SetStartProgress
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// float                                   StartProgress                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMaterialProgressBar::SetStartProgress(float StartProgress)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MaterialProgressBar", "SetStartProgress");

	Params::MaterialProgressBar_SetStartProgress Parms{};

	Parms.StartProgress = StartProgress;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraTabButtonInterface.SetTabLabelInfo
// (Native, Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FLyraTabDescriptor               TabDescriptor                                          (ConstParm, Parm, OutParm, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)

void ILyraTabButtonInterface::SetTabLabelInfo(const struct FLyraTabDescriptor& TabDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTabButtonInterface", "SetTabLabelInfo");

	Params::LyraTabButtonInterface_SetTabLabelInfo Parms{};

	Parms.TabDescriptor = std::move(TabDescriptor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraWidgetFactory.FindWidgetClassForData
// (Native, Event, Public, BlueprintEvent, Const)
// Parameters:
// class UObject*                          Data                                                   (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// TSubclassOf<class UUserWidget>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidget> ULyraWidgetFactory::FindWidgetClassForData(const class UObject* Data) const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraWidgetFactory", "FindWidgetClassForData");

	Params::LyraWidgetFactory_FindWidgetClassForData Parms{};

	Parms.Data = Data;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraLoadingScreenSubsystem.SetLoadingScreenContentWidget
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSubclassOf<class UUserWidget>          NewWidgetClass                                         (Parm, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraLoadingScreenSubsystem::SetLoadingScreenContentWidget(TSubclassOf<class UUserWidget> NewWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLoadingScreenSubsystem", "SetLoadingScreenContentWidget");

	Params::LyraLoadingScreenSubsystem_SetLoadingScreenContentWidget Parms{};

	Parms.NewWidgetClass = NewWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraLoadingScreenSubsystem.GetLoadingScreenContentWidget
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSubclassOf<class UUserWidget>          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSubclassOf<class UUserWidget> ULyraLoadingScreenSubsystem::GetLoadingScreenContentWidget() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraLoadingScreenSubsystem", "GetLoadingScreenContentWidget");

	Params::LyraLoadingScreenSubsystem_GetLoadingScreenContentWidget Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.SetAutoRemoveWhenIndicatorComponentIsNull
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    CanAutomaticallyRemove                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetAutoRemoveWhenIndicatorComponentIsNull(bool CanAutomaticallyRemove)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetAutoRemoveWhenIndicatorComponentIsNull");

	Params::IndicatorDescriptor_SetAutoRemoveWhenIndicatorComponentIsNull Parms{};

	Parms.CanAutomaticallyRemove = CanAutomaticallyRemove;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetBoundingBoxAnchor
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          InBoundingBoxAnchor                                    (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetBoundingBoxAnchor(const struct FVector& InBoundingBoxAnchor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetBoundingBoxAnchor");

	Params::IndicatorDescriptor_SetBoundingBoxAnchor Parms{};

	Parms.InBoundingBoxAnchor = std::move(InBoundingBoxAnchor);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetClampToScreen
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetClampToScreen(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetClampToScreen");

	Params::IndicatorDescriptor_SetClampToScreen Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetComponentSocketName
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class FName                             SocketName                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetComponentSocketName(class FName SocketName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetComponentSocketName");

	Params::IndicatorDescriptor_SetComponentSocketName Parms{};

	Parms.SocketName = SocketName;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetDataObject
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UObject*                          InDataObject                                           (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetDataObject(class UObject* InDataObject)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetDataObject");

	Params::IndicatorDescriptor_SetDataObject Parms{};

	Parms.InDataObject = InDataObject;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetDesiredVisibility
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    InVisible                                              (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetDesiredVisibility(bool InVisible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetDesiredVisibility");

	Params::IndicatorDescriptor_SetDesiredVisibility Parms{};

	Parms.InVisible = InVisible;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetHAlign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EHorizontalAlignment                    InHAlignment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetHAlign(EHorizontalAlignment InHAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetHAlign");

	Params::IndicatorDescriptor_SetHAlign Parms{};

	Parms.InHAlignment = InHAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetIndicatorClass
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// TSoftClassPtr<class UClass>             InIndicatorWidgetClass                                 (Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetIndicatorClass(TSoftClassPtr<class UClass> InIndicatorWidgetClass)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetIndicatorClass");

	Params::IndicatorDescriptor_SetIndicatorClass Parms{};

	Parms.InIndicatorWidgetClass = InIndicatorWidgetClass;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetPriority
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// int32                                   InPriority                                             (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetPriority(int32 InPriority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetPriority");

	Params::IndicatorDescriptor_SetPriority Parms{};

	Parms.InPriority = InPriority;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetProjectionMode
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EActorCanvasProjectionMode              InProjectionMode                                       (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetProjectionMode(EActorCanvasProjectionMode InProjectionMode)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetProjectionMode");

	Params::IndicatorDescriptor_SetProjectionMode Parms{};

	Parms.InProjectionMode = InProjectionMode;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetSceneComponent
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class USceneComponent*                  InComponent                                            (Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetSceneComponent(class USceneComponent* InComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetSceneComponent");

	Params::IndicatorDescriptor_SetSceneComponent Parms{};

	Parms.InComponent = InComponent;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetScreenSpaceOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetScreenSpaceOffset(const struct FVector2D& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetScreenSpaceOffset");

	Params::IndicatorDescriptor_SetScreenSpaceOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetShowClampToScreenArrow
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// bool                                    bValue                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetShowClampToScreenArrow(bool bValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetShowClampToScreenArrow");

	Params::IndicatorDescriptor_SetShowClampToScreenArrow Parms{};

	Parms.bValue = bValue;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetVAlign
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// EVerticalAlignment                      InVAlignment                                           (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetVAlign(EVerticalAlignment InVAlignment)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetVAlign");

	Params::IndicatorDescriptor_SetVAlign Parms{};

	Parms.InVAlignment = InVAlignment;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.SetWorldPositionOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Offset                                                 (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UIndicatorDescriptor::SetWorldPositionOffset(const struct FVector& Offset)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "SetWorldPositionOffset");

	Params::IndicatorDescriptor_SetWorldPositionOffset Parms{};

	Parms.Offset = std::move(Offset);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.UnregisterIndicator
// (Final, Native, Public, BlueprintCallable)

void UIndicatorDescriptor::UnregisterIndicator()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "UnregisterIndicator");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.IndicatorDescriptor.GetAutoRemoveWhenIndicatorComponentIsNull
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndicatorDescriptor::GetAutoRemoveWhenIndicatorComponentIsNull() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetAutoRemoveWhenIndicatorComponentIsNull");

	Params::IndicatorDescriptor_GetAutoRemoveWhenIndicatorComponentIsNull Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetBoundingBoxAnchor
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UIndicatorDescriptor::GetBoundingBoxAnchor() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetBoundingBoxAnchor");

	Params::IndicatorDescriptor_GetBoundingBoxAnchor Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetClampToScreen
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndicatorDescriptor::GetClampToScreen() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetClampToScreen");

	Params::IndicatorDescriptor_GetClampToScreen Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetComponentSocketName
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class FName                             ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class FName UIndicatorDescriptor::GetComponentSocketName() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetComponentSocketName");

	Params::IndicatorDescriptor_GetComponentSocketName Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetDataObject
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UObject*                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UObject* UIndicatorDescriptor::GetDataObject() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetDataObject");

	Params::IndicatorDescriptor_GetDataObject Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetHAlign
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EHorizontalAlignment                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EHorizontalAlignment UIndicatorDescriptor::GetHAlign() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetHAlign");

	Params::IndicatorDescriptor_GetHAlign Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetIndicatorClass
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// TSoftClassPtr<class UClass>             ReturnValue                                            (Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

TSoftClassPtr<class UClass> UIndicatorDescriptor::GetIndicatorClass() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetIndicatorClass");

	Params::IndicatorDescriptor_GetIndicatorClass Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetIsVisible
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndicatorDescriptor::GetIsVisible() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetIsVisible");

	Params::IndicatorDescriptor_GetIsVisible Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetPriority
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// int32                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

int32 UIndicatorDescriptor::GetPriority() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetPriority");

	Params::IndicatorDescriptor_GetPriority Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetProjectionMode
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EActorCanvasProjectionMode              ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EActorCanvasProjectionMode UIndicatorDescriptor::GetProjectionMode() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetProjectionMode");

	Params::IndicatorDescriptor_GetProjectionMode Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetSceneComponent
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class USceneComponent*                  ReturnValue                                            (ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class USceneComponent* UIndicatorDescriptor::GetSceneComponent() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetSceneComponent");

	Params::IndicatorDescriptor_GetSceneComponent Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetScreenSpaceOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector2D                        ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector2D UIndicatorDescriptor::GetScreenSpaceOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetScreenSpaceOffset");

	Params::IndicatorDescriptor_GetScreenSpaceOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetShowClampToScreenArrow
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool UIndicatorDescriptor::GetShowClampToScreenArrow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetShowClampToScreenArrow");

	Params::IndicatorDescriptor_GetShowClampToScreenArrow Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetVAlign
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// EVerticalAlignment                      ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

EVerticalAlignment UIndicatorDescriptor::GetVAlign() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetVAlign");

	Params::IndicatorDescriptor_GetVAlign Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.IndicatorDescriptor.GetWorldPositionOffset
// (Final, Native, Public, HasDefaults, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FVector UIndicatorDescriptor::GetWorldPositionOffset() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("IndicatorDescriptor", "GetWorldPositionOffset");

	Params::IndicatorDescriptor_GetWorldPositionOffset Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraIndicatorManagerComponent.AddIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UIndicatorDescriptor*             IndicatorDescriptor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraIndicatorManagerComponent::AddIndicator(class UIndicatorDescriptor* IndicatorDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraIndicatorManagerComponent", "AddIndicator");

	Params::LyraIndicatorManagerComponent_AddIndicator Parms{};

	Parms.IndicatorDescriptor = IndicatorDescriptor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraIndicatorManagerComponent.RemoveIndicator
// (Final, Native, Public, BlueprintCallable)
// Parameters:
// class UIndicatorDescriptor*             IndicatorDescriptor                                    (Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraIndicatorManagerComponent::RemoveIndicator(class UIndicatorDescriptor* IndicatorDescriptor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraIndicatorManagerComponent", "RemoveIndicator");

	Params::LyraIndicatorManagerComponent_RemoveIndicator Parms{};

	Parms.IndicatorDescriptor = IndicatorDescriptor;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSimulatedInputWidget.FlushSimulatedInput
// (Final, Native, Public, BlueprintCallable)

void ULyraSimulatedInputWidget::FlushSimulatedInput()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "FlushSimulatedInput");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSimulatedInputWidget.InputKeyValue
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector                          Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSimulatedInputWidget::InputKeyValue(const struct FVector& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "InputKeyValue");

	Params::LyraSimulatedInputWidget_InputKeyValue Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSimulatedInputWidget.InputKeyValue2D
// (Final, Native, Public, HasOutParams, HasDefaults, BlueprintCallable)
// Parameters:
// struct FVector2D                        Value                                                  (ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void ULyraSimulatedInputWidget::InputKeyValue2D(const struct FVector2D& Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "InputKeyValue2D");

	Params::LyraSimulatedInputWidget_InputKeyValue2D Parms{};

	Parms.Value = std::move(Value);

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraSimulatedInputWidget.GetAssociatedAction
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// const class UInputAction*               ReturnValue                                            (ConstParm, Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

const class UInputAction* ULyraSimulatedInputWidget::GetAssociatedAction() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "GetAssociatedAction");

	Params::LyraSimulatedInputWidget_GetAssociatedAction Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSimulatedInputWidget.GetEnhancedInputSubsystem
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// class UEnhancedInputLocalPlayerSubsystem*ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

class UEnhancedInputLocalPlayerSubsystem* ULyraSimulatedInputWidget::GetEnhancedInputSubsystem() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "GetEnhancedInputSubsystem");

	Params::LyraSimulatedInputWidget_GetEnhancedInputSubsystem Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraSimulatedInputWidget.GetSimulatedKey
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// struct FKey                             ReturnValue                                            (Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)

struct FKey ULyraSimulatedInputWidget::GetSimulatedKey() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraSimulatedInputWidget", "GetSimulatedKey");

	Params::LyraSimulatedInputWidget_GetSimulatedKey Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraTouchRegion.ShouldSimulateInput
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

bool ULyraTouchRegion::ShouldSimulateInput() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraTouchRegion", "ShouldSimulateInput");

	Params::LyraTouchRegion_ShouldSimulateInput Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraPerfStatContainerBase.UpdateVisibilityOfChildren
// (Final, Native, Public, BlueprintCallable)

void ULyraPerfStatContainerBase::UpdateVisibilityOfChildren()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPerfStatContainerBase", "UpdateVisibilityOfChildren");

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, nullptr);

	Func->FunctionFlags = Flgs;
}


// Function JP.LyraPerfStatWidgetBase.FetchStatValue
// (Final, Native, Public, BlueprintCallable, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

double ULyraPerfStatWidgetBase::FetchStatValue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPerfStatWidgetBase", "FetchStatValue");

	Params::LyraPerfStatWidgetBase_FetchStatValue Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.LyraPerfStatWidgetBase.GetStatToDisplay
// (Final, Native, Public, BlueprintCallable, BlueprintPure, Const)
// Parameters:
// ELyraDisplayablePerformanceStat         ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

ELyraDisplayablePerformanceStat ULyraPerfStatWidgetBase::GetStatToDisplay() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("LyraPerfStatWidgetBase", "GetStatToDisplay");

	Params::LyraPerfStatWidgetBase_GetStatToDisplay Parms{};

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;

	return Parms.ReturnValue;
}


// Function JP.MainMenuFlowControllerStateComponent.OnExperienceLoaded
// (Final, Native, Private)
// Parameters:
// class UExperienceDefinition*            Experience                                             (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenuFlowControllerStateComponent::OnExperienceLoaded(const class UExperienceDefinition* Experience)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuFlowControllerStateComponent", "OnExperienceLoaded");

	Params::MainMenuFlowControllerStateComponent_OnExperienceLoaded Parms{};

	Parms.Experience = Experience;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}


// Function JP.MainMenuFlowControllerStateComponent.OnUserInitialized
// (Final, Native, Private)
// Parameters:
// class UCommonUserInfo*                  UserInfo                                               (ConstParm, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// bool                                    bSuccess                                               (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// class FText                             Error                                                  (Parm, NativeAccessSpecifierPublic)
// ECommonUserPrivilege                    RequestedPrivilege                                     (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
// ECommonUserOnlineContext                OnlineContext                                          (Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

void UMainMenuFlowControllerStateComponent::OnUserInitialized(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestedPrivilege, ECommonUserOnlineContext OnlineContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("MainMenuFlowControllerStateComponent", "OnUserInitialized");

	Params::MainMenuFlowControllerStateComponent_OnUserInitialized Parms{};

	Parms.UserInfo = UserInfo;
	Parms.bSuccess = bSuccess;
	Parms.Error = std::move(Error);
	Parms.RequestedPrivilege = RequestedPrivilege;
	Parms.OnlineContext = OnlineContext;

	auto Flgs = Func->FunctionFlags;
	Func->FunctionFlags |= 0x400;

	UObject::ProcessEvent(Func, &Parms);

	Func->FunctionFlags = Flgs;
}

}

