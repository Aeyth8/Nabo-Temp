#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_ProjectileBase

#include "Basic.hpp"

#include "BP_ProjectileBase_classes.hpp"
#include "BP_ProjectileBase_parameters.hpp"


namespace SDK
{

// Function BP_ProjectileBase.BP_ProjectileBase_C.ActivateNiagaraSystems
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Actrivate                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::ActivateNiagaraSystems(bool Actrivate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "ActivateNiagaraSystems");

	Params::BP_ProjectileBase_C_ActivateNiagaraSystems Parms{};

	Parms.Actrivate = Actrivate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.Apply Hit Effects On Valid Entity
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit_Result                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UAbilitySystemComponent*          Instigator_ASC                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponent*          HitTarget_ASC                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::Apply_Hit_Effects_On_Valid_Entity(const struct FHitResult& Hit_Result, class UAbilitySystemComponent* Instigator_ASC, class UAbilitySystemComponent* HitTarget_ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "Apply Hit Effects On Valid Entity");

	Params::BP_ProjectileBase_C_Apply_Hit_Effects_On_Valid_Entity Parms{};

	Parms.Hit_Result = std::move(Hit_Result);
	Parms.Instigator_ASC = Instigator_ASC;
	Parms.HitTarget_ASC = HitTarget_ASC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.ApplyHitEffects
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::ApplyHitEffects(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "ApplyHitEffects");

	Params::BP_ProjectileBase_C_ApplyHitEffects Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.ApplyKillAssistedEffect
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAbilitySystemComponent*          TargetASC                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::ApplyKillAssistedEffect(class UAbilitySystemComponent* TargetASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "ApplyKillAssistedEffect");

	Params::BP_ProjectileBase_C_ApplyKillAssistedEffect Parms{};

	Parms.TargetASC = TargetASC;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.Audio Default Impact
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::Audio_Default_Impact(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "Audio Default Impact");

	Params::BP_ProjectileBase_C_Audio_Default_Impact Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.Audio Material Layer
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPhysicalMaterial*                PhysicalMaterial                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::Audio_Material_Layer(const struct FVector& Location, class UPhysicalMaterial* PhysicalMaterial)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "Audio Material Layer");

	Params::BP_ProjectileBase_C_Audio_Material_Layer Parms{};

	Parms.Location = std::move(Location);
	Parms.PhysicalMaterial = PhysicalMaterial;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.BndEvt__BP_ProjectileBase_PlayerCollider_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult                       SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::BndEvt__BP_ProjectileBase_PlayerCollider_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "BndEvt__BP_ProjectileBase_PlayerCollider_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_ProjectileBase_C_BndEvt__BP_ProjectileBase_PlayerCollider_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.CacheOwnerInfo
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_ProjectileBase_C::CacheOwnerInfo()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "CacheOwnerInfo");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.CalculateDamageFalloffMultiplier
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_ProjectileBase_C::CalculateDamageFalloffMultiplier()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "CalculateDamageFalloffMultiplier");

	Params::BP_ProjectileBase_C_CalculateDamageFalloffMultiplier Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.CalculateImpactAngle
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FVector                          Impact_Velocity                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_ProjectileBase_C::CalculateImpactAngle(const struct FHitResult& Hit, const struct FVector& Impact_Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "CalculateImpactAngle");

	Params::BP_ProjectileBase_C_CalculateImpactAngle Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Impact_Velocity = std::move(Impact_Velocity);

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.CanActivateTrap
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_ProjectileBase_C::CanActivateTrap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "CanActivateTrap");

	Params::BP_ProjectileBase_C_CanActivateTrap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.CheckImpactAbilitySystemComponents
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class FString                           Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    Is_Valid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponent*          Instigator_ASC                                         (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponent*          Target_ASC                                             (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::CheckImpactAbilitySystemComponents(const struct FHitResult& Hit, const class FString& Reason, bool* Is_Valid, class UAbilitySystemComponent** Instigator_ASC, class UAbilitySystemComponent** Target_ASC)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "CheckImpactAbilitySystemComponents");

	Params::BP_ProjectileBase_C_CheckImpactAbilitySystemComponents Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Reason = std::move(Reason);

	UObject::ProcessEvent(Func, &Parms);

	if (Is_Valid != nullptr)
		*Is_Valid = Parms.Is_Valid;

	if (Instigator_ASC != nullptr)
		*Instigator_ASC = Parms.Instigator_ASC;

	if (Target_ASC != nullptr)
		*Target_ASC = Parms.Target_ASC;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.DamageAppliedCue
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_ProjectileBase_C::DamageAppliedCue()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "DamageAppliedCue");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.DamageTarget
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UAbilitySystemComponent*          Instigator_Ability_System_Component                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponent*          Hit_Actor_Ability_System_Component                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::DamageTarget(const struct FHitResult& Hit, class UAbilitySystemComponent* Instigator_Ability_System_Component, class UAbilitySystemComponent* Hit_Actor_Ability_System_Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "DamageTarget");

	Params::BP_ProjectileBase_C_DamageTarget Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Instigator_Ability_System_Component = Instigator_Ability_System_Component;
	Parms.Hit_Actor_Ability_System_Component = Hit_Actor_Ability_System_Component;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.DeactivatePooledActor
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_ProjectileBase_C::DeactivatePooledActor()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "DeactivatePooledActor");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.DisableProjectile
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_ProjectileBase_C::DisableProjectile()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "DisableProjectile");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.DoTargetImpactCosmetics
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::DoTargetImpactCosmetics(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "DoTargetImpactCosmetics");

	Params::BP_ProjectileBase_C_DoTargetImpactCosmetics Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.ExecuteUbergraph_BP_ProjectileBase
// (Final, UbergraphFunction, HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::ExecuteUbergraph_BP_ProjectileBase(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "ExecuteUbergraph_BP_ProjectileBase");

	Params::BP_ProjectileBase_C_ExecuteUbergraph_BP_ProjectileBase Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.GetDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// double                                  ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

double ABP_ProjectileBase_C::GetDamage()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "GetDamage");

	Params::BP_ProjectileBase_C_GetDamage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.GetProjectileComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UProjectileMovementComponent*     ProjectileComponent_0                                  (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::GetProjectileComponent(class UProjectileMovementComponent** ProjectileComponent_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "GetProjectileComponent");

	Params::BP_ProjectileBase_C_GetProjectileComponent Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ProjectileComponent_0 != nullptr)
		*ProjectileComponent_0 = Parms.ProjectileComponent_0;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.HandleBounce
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FVector                          Impact_Velocity                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::HandleBounce(const struct FHitResult& Hit, const struct FVector& Impact_Velocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "HandleBounce");

	Params::BP_ProjectileBase_C_HandleBounce Parms{};

	Parms.Hit = std::move(Hit);
	Parms.Impact_Velocity = std::move(Impact_Velocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.HandleProjectileStop
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::HandleProjectileStop(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "HandleProjectileStop");

	Params::BP_ProjectileBase_C_HandleProjectileStop Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.HandleShieldImpact
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::HandleShieldImpact(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "HandleShieldImpact");

	Params::BP_ProjectileBase_C_HandleShieldImpact Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.HasValidAbilitySystemComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Validation_Target                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    LogReason                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString                           Reason                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// class FString                           Target_ASC                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// bool                                    Is_Valid                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAbilitySystemComponent*          Target_Ability_System_Component                        (Parm, OutParm, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::HasValidAbilitySystemComponent(class AActor* Validation_Target, bool LogReason, const class FString& Reason, const class FString& Target_ASC, bool* Is_Valid, class UAbilitySystemComponent** Target_Ability_System_Component)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "HasValidAbilitySystemComponent");

	Params::BP_ProjectileBase_C_HasValidAbilitySystemComponent Parms{};

	Parms.Validation_Target = Validation_Target;
	Parms.LogReason = LogReason;
	Parms.Reason = std::move(Reason);
	Parms.Target_ASC = std::move(Target_ASC);

	UObject::ProcessEvent(Func, &Parms);

	if (Is_Valid != nullptr)
		*Is_Valid = Parms.Is_Valid;

	if (Target_Ability_System_Component != nullptr)
		*Target_Ability_System_Component = Parms.Target_Ability_System_Component;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.HighConstrastModeChanged
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    IsEnabled                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::HighConstrastModeChanged(bool IsEnabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "HighConstrastModeChanged");

	Params::BP_ProjectileBase_C_HighConstrastModeChanged Parms{};

	Parms.IsEnabled = IsEnabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.Hit Self on Spawn
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    HitSelf                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::Hit_Self_on_Spawn(class AActor* OtherActor, bool* HitSelf)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "Hit Self on Spawn");

	Params::BP_ProjectileBase_C_Hit_Self_on_Spawn Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);

	if (HitSelf != nullptr)
		*HitSelf = Parms.HitSelf;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.IgnoreCollisionWithTeammates
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_ProjectileBase_C::IgnoreCollisionWithTeammates()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "IgnoreCollisionWithTeammates");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.IsNewTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    IsNewTarget_0                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::IsNewTarget(class AActor* HitActor, bool* IsNewTarget_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "IsNewTarget");

	Params::BP_ProjectileBase_C_IsNewTarget Parms{};

	Parms.HitActor = HitActor;

	UObject::ProcessEvent(Func, &Parms);

	if (IsNewTarget_0 != nullptr)
		*IsNewTarget_0 = Parms.IsNewTarget_0;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.IsSameTeam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Return                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::IsSameTeam(class UObject* HitActor, bool* Return)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "IsSameTeam");

	Params::BP_ProjectileBase_C_IsSameTeam Parms{};

	Parms.HitActor = HitActor;

	UObject::ProcessEvent(Func, &Parms);

	if (Return != nullptr)
		*Return = Parms.Return;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.K2_OnReset
// (Event, Public, BlueprintEvent)

void ABP_ProjectileBase_C::K2_OnReset()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "K2_OnReset");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.OnProjectileBounce
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// struct FVector                          ImpactVelocity                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::OnProjectileBounce(const struct FHitResult& ImpactResult, const struct FVector& ImpactVelocity)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "OnProjectileBounce");

	Params::BP_ProjectileBase_C_OnProjectileBounce Parms{};

	Parms.ImpactResult = std::move(ImpactResult);
	Parms.ImpactVelocity = std::move(ImpactVelocity);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.OnProjectileStop
// (HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       ImpactResult                                           (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::OnProjectileStop(const struct FHitResult& ImpactResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "OnProjectileStop");

	Params::BP_ProjectileBase_C_OnProjectileStop Parms{};

	Parms.ImpactResult = std::move(ImpactResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.OnVelocityRedirect
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          NewVelocityWorldSpace                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::OnVelocityRedirect(const struct FVector& NewVelocityWorldSpace)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "OnVelocityRedirect");

	Params::BP_ProjectileBase_C_OnVelocityRedirect Parms{};

	Parms.NewVelocityWorldSpace = std::move(NewVelocityWorldSpace);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.PlayHitMarker
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Hit_Actor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::PlayHitMarker(class AActor* Hit_Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "PlayHitMarker");

	Params::BP_ProjectileBase_C_PlayHitMarker Parms{};

	Parms.Hit_Actor = Hit_Actor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.PlayImpactEffect
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::PlayImpactEffect(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "PlayImpactEffect");

	Params::BP_ProjectileBase_C_PlayImpactEffect Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.PooledBeginPlay
// (Event, Public, BlueprintEvent)

void ABP_ProjectileBase_C::PooledBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "PooledBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.ProjectileBelongsToLocalPlayer
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

bool ABP_ProjectileBase_C::ProjectileBelongsToLocalPlayer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "ProjectileBelongsToLocalPlayer");

	Params::BP_ProjectileBase_C_ProjectileBelongsToLocalPlayer Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.Server_SpawnDecals
// (Net, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::Server_SpawnDecals(const struct FHitResult& HitResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "Server_SpawnDecals");

	Params::BP_ProjectileBase_C_Server_SpawnDecals Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.Set Collisions With
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)
// bool                                    Ignore                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::Set_Collisions_With(class AActor* TargetActor, bool Ignore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "Set Collisions With");

	Params::BP_ProjectileBase_C_Set_Collisions_With Parms{};

	Parms.TargetActor = TargetActor;
	Parms.Ignore = Ignore;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.SetHighContrastMode
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    Enabled                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::SetHighContrastMode(bool Enabled)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "SetHighContrastMode");

	Params::BP_ProjectileBase_C_SetHighContrastMode Parms{};

	Parms.Enabled = Enabled;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.SetLocationRotationAndInitialVelocity
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_ProjectileBase_C::SetLocationRotationAndInitialVelocity()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "SetLocationRotationAndInitialVelocity");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.SetMeshComponent
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_ProjectileBase_C::SetMeshComponent()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "SetMeshComponent");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.SetNewInstigator
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            NewInstigator                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, NoDestructor, HasGetValueTypeHash)

void ABP_ProjectileBase_C::SetNewInstigator(class APawn* NewInstigator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "SetNewInstigator");

	Params::BP_ProjectileBase_C_SetNewInstigator Parms{};

	Parms.NewInstigator = NewInstigator;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.SetSpeed
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_ProjectileBase_C::SetSpeed()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "SetSpeed");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.Spawn Hit Cosmetics
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::Spawn_Hit_Cosmetics(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "Spawn Hit Cosmetics");

	Params::BP_ProjectileBase_C_Spawn_Hit_Cosmetics Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.Spawn Hit Decal
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::Spawn_Hit_Decal(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "Spawn Hit Decal");

	Params::BP_ProjectileBase_C_Spawn_Hit_Decal Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.SpawnDebugSphere
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Hit                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::SpawnDebugSphere(const struct FHitResult& Hit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "SpawnDebugSphere");

	Params::BP_ProjectileBase_C_SpawnDebugSphere Parms{};

	Parms.Hit = std::move(Hit);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_ProjectileBase.BP_ProjectileBase_C.TryKnockbackMessItem
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       Info                                                   (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_ProjectileBase_C::TryKnockbackMessItem(const struct FHitResult& Info)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_ProjectileBase_C", "TryKnockbackMessItem");

	Params::BP_ProjectileBase_C_TryKnockbackMessItem Parms{};

	Parms.Info = std::move(Info);

	UObject::ProcessEvent(Func, &Parms);
}

}

