#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JP

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "IWAnalytics_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "JP_structs.hpp"
#include "CommonUI_classes.hpp"
#include "GASIW_structs.hpp"
#include "GASIW_classes.hpp"
#include "IWOnlineServices_structs.hpp"
#include "IWOnlineServices_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "IWCore_classes.hpp"
#include "EnhancedInput_structs.hpp"
#include "EnhancedInput_classes.hpp"
#include "ModularGameplayActors_classes.hpp"
#include "CommonUser_structs.hpp"
#include "CommonUser_classes.hpp"
#include "SlateCore_structs.hpp"
#include "ModularGameplay_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "AudioMixer_structs.hpp"
#include "CommonGame_classes.hpp"
#include "NetCore_structs.hpp"
#include "AIModule_classes.hpp"
#include "Inventory_structs.hpp"
#include "Inventory_classes.hpp"
#include "CommonInput_structs.hpp"
#include "GameSettings_classes.hpp"
#include "DeveloperSettings_structs.hpp"
#include "DeveloperSettings_classes.hpp"
#include "InputCore_structs.hpp"
#include "IWExperiences_classes.hpp"
#include "TargetingSystem_classes.hpp"
#include "GameFeatures_classes.hpp"


namespace SDK
{

// Class JP.InitializationFlowStepBase
// 0x0058 (0x0080 - 0x0028)
class UInitializationFlowStepBase : public UObject
{
public:
	uint8                                         Pad_28[0x58];                                      // 0x0028(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InitializationFlowStepBase">();
	}
	static class UInitializationFlowStepBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInitializationFlowStepBase>();
	}
};
static_assert(alignof(UInitializationFlowStepBase) == 0x000008, "Wrong alignment on UInitializationFlowStepBase");
static_assert(sizeof(UInitializationFlowStepBase) == 0x000080, "Wrong size on UInitializationFlowStepBase");

// Class JP.LobbyConfigurationSummaryWidget
// 0x0008 (0x02E8 - 0x02E0)
class ULobbyConfigurationSummaryWidget : public UUserWidget
{
public:
	TSubclassOf<class UMatchConfigurationWidget>  MatchConfigurationWidgetClass;                     // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyViewModel(const struct FLobbyConfigurationSummaryViewModel& InModel);
	void HandleConfigurationChanged();
	void InspectConfiguration();

	bool CanUserEditConfiguration() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyConfigurationSummaryWidget">();
	}
	static class ULobbyConfigurationSummaryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyConfigurationSummaryWidget>();
	}
};
static_assert(alignof(ULobbyConfigurationSummaryWidget) == 0x000008, "Wrong alignment on ULobbyConfigurationSummaryWidget");
static_assert(sizeof(ULobbyConfigurationSummaryWidget) == 0x0002E8, "Wrong size on ULobbyConfigurationSummaryWidget");
static_assert(offsetof(ULobbyConfigurationSummaryWidget, MatchConfigurationWidgetClass) == 0x0002E0, "Member 'ULobbyConfigurationSummaryWidget::MatchConfigurationWidgetClass' has a wrong offset!");

// Class JP.AuthenticationInitializationStepBase
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStepBase : public UInitializationFlowStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStepBase">();
	}
	static class UAuthenticationInitializationStepBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStepBase>();
	}
};
static_assert(alignof(UAuthenticationInitializationStepBase) == 0x000008, "Wrong alignment on UAuthenticationInitializationStepBase");
static_assert(sizeof(UAuthenticationInitializationStepBase) == 0x000080, "Wrong size on UAuthenticationInitializationStepBase");

// Class JP.AsyncAction_GetCurrencyAmountWhenReady
// 0x0018 (0x0048 - 0x0030)
class UAsyncAction_GetCurrencyAmountWhenReady final : public UAsyncAction_OnlineServicesBase
{
public:
	FMulticastInlineDelegateProperty_             OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_GetCurrencyAmountWhenReady* GetCurrencyAmountWhenReady(class UObject* WorldContextObject, const struct FGameplayTag& CurrencyTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_GetCurrencyAmountWhenReady">();
	}
	static class UAsyncAction_GetCurrencyAmountWhenReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_GetCurrencyAmountWhenReady>();
	}
};
static_assert(alignof(UAsyncAction_GetCurrencyAmountWhenReady) == 0x000008, "Wrong alignment on UAsyncAction_GetCurrencyAmountWhenReady");
static_assert(sizeof(UAsyncAction_GetCurrencyAmountWhenReady) == 0x000048, "Wrong size on UAsyncAction_GetCurrencyAmountWhenReady");
static_assert(offsetof(UAsyncAction_GetCurrencyAmountWhenReady, OnReady) == 0x000030, "Member 'UAsyncAction_GetCurrencyAmountWhenReady::OnReady' has a wrong offset!");

// Class JP.SeasonPassRewardEntryWidgetBase
// 0x0000 (0x02E0 - 0x02E0)
class USeasonPassRewardEntryWidgetBase : public UUserWidget
{
public:
	void StartLoadGuard();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassRewardEntryWidgetBase">();
	}
	static class USeasonPassRewardEntryWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassRewardEntryWidgetBase>();
	}
};
static_assert(alignof(USeasonPassRewardEntryWidgetBase) == 0x000008, "Wrong alignment on USeasonPassRewardEntryWidgetBase");
static_assert(sizeof(USeasonPassRewardEntryWidgetBase) == 0x0002E0, "Wrong size on USeasonPassRewardEntryWidgetBase");

// Class JP.SeasonPassSingleRewardEntryWidget
// 0x0010 (0x02F0 - 0x02E0)
class USeasonPassSingleRewardEntryWidget : public USeasonPassRewardEntryWidgetBase
{
public:
	class UNamedSlot*                             Content;                                           // 0x02E0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class URewardContentFactory>      ContentFactory;                                    // 0x02E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HandleRewardContentCreated(class UUserWidget* NewRewardWidget, ESeasonPassRewardType RewardType);
	void K2_HandleEmptyReward();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassSingleRewardEntryWidget">();
	}
	static class USeasonPassSingleRewardEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassSingleRewardEntryWidget>();
	}
};
static_assert(alignof(USeasonPassSingleRewardEntryWidget) == 0x000008, "Wrong alignment on USeasonPassSingleRewardEntryWidget");
static_assert(sizeof(USeasonPassSingleRewardEntryWidget) == 0x0002F0, "Wrong size on USeasonPassSingleRewardEntryWidget");
static_assert(offsetof(USeasonPassSingleRewardEntryWidget, Content) == 0x0002E0, "Member 'USeasonPassSingleRewardEntryWidget::Content' has a wrong offset!");
static_assert(offsetof(USeasonPassSingleRewardEntryWidget, ContentFactory) == 0x0002E8, "Member 'USeasonPassSingleRewardEntryWidget::ContentFactory' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_Login
// 0x0020 (0x00A0 - 0x0080)
class UAuthenticationInitializationStep_Login final : public UAuthenticationInitializationStepBase
{
public:
	uint8                                         Pad_80[0x20];                                      // 0x0080(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_Login">();
	}
	static class UAuthenticationInitializationStep_Login* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_Login>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_Login) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_Login");
static_assert(sizeof(UAuthenticationInitializationStep_Login) == 0x0000A0, "Wrong size on UAuthenticationInitializationStep_Login");

// Class JP.LyraBrightnessEditor
// 0x0050 (0x0480 - 0x0430)
class ULyraBrightnessEditor final : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_430[0x20];                                     // 0x0430(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanCancel;                                        // 0x0450(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0xF];                                      // 0x0451(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        Switcher_SafeZoneMessage;                          // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonRichTextBlock*                   RichText_Default;                                  // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      Button_Back;                                       // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      Button_Done;                                       // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleBackClicked();
	void HandleDoneClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraBrightnessEditor">();
	}
	static class ULyraBrightnessEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraBrightnessEditor>();
	}
};
static_assert(alignof(ULyraBrightnessEditor) == 0x000008, "Wrong alignment on ULyraBrightnessEditor");
static_assert(sizeof(ULyraBrightnessEditor) == 0x000480, "Wrong size on ULyraBrightnessEditor");
static_assert(offsetof(ULyraBrightnessEditor, bCanCancel) == 0x000450, "Member 'ULyraBrightnessEditor::bCanCancel' has a wrong offset!");
static_assert(offsetof(ULyraBrightnessEditor, Switcher_SafeZoneMessage) == 0x000460, "Member 'ULyraBrightnessEditor::Switcher_SafeZoneMessage' has a wrong offset!");
static_assert(offsetof(ULyraBrightnessEditor, RichText_Default) == 0x000468, "Member 'ULyraBrightnessEditor::RichText_Default' has a wrong offset!");
static_assert(offsetof(ULyraBrightnessEditor, Button_Back) == 0x000470, "Member 'ULyraBrightnessEditor::Button_Back' has a wrong offset!");
static_assert(offsetof(ULyraBrightnessEditor, Button_Done) == 0x000478, "Member 'ULyraBrightnessEditor::Button_Done' has a wrong offset!");

// Class JP.AsyncAction_LocalUserOnlineServicesBase
// 0x0000 (0x0030 - 0x0030)
class UAsyncAction_LocalUserOnlineServicesBase : public UAsyncAction_OnlineServicesBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_LocalUserOnlineServicesBase">();
	}
	static class UAsyncAction_LocalUserOnlineServicesBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_LocalUserOnlineServicesBase>();
	}
};
static_assert(alignof(UAsyncAction_LocalUserOnlineServicesBase) == 0x000008, "Wrong alignment on UAsyncAction_LocalUserOnlineServicesBase");
static_assert(sizeof(UAsyncAction_LocalUserOnlineServicesBase) == 0x000030, "Wrong size on UAsyncAction_LocalUserOnlineServicesBase");

// Class JP.AsyncAction_GetProfileXPWhenReady
// 0x0010 (0x0040 - 0x0030)
class UAsyncAction_GetProfileXPWhenReady final : public UAsyncAction_LocalUserOnlineServicesBase
{
public:
	FMulticastInlineDelegateProperty_             OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_GetProfileXPWhenReady* GetProfileXPWhenReady(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_GetProfileXPWhenReady">();
	}
	static class UAsyncAction_GetProfileXPWhenReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_GetProfileXPWhenReady>();
	}
};
static_assert(alignof(UAsyncAction_GetProfileXPWhenReady) == 0x000008, "Wrong alignment on UAsyncAction_GetProfileXPWhenReady");
static_assert(sizeof(UAsyncAction_GetProfileXPWhenReady) == 0x000040, "Wrong size on UAsyncAction_GetProfileXPWhenReady");
static_assert(offsetof(UAsyncAction_GetProfileXPWhenReady, OnReady) == 0x000030, "Member 'UAsyncAction_GetProfileXPWhenReady::OnReady' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_StoreAgreedEulaVersion
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_StoreAgreedEulaVersion final : public UAuthenticationInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_StoreAgreedEulaVersion">();
	}
	static class UAuthenticationInitializationStep_StoreAgreedEulaVersion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_StoreAgreedEulaVersion>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_StoreAgreedEulaVersion) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_StoreAgreedEulaVersion");
static_assert(sizeof(UAuthenticationInitializationStep_StoreAgreedEulaVersion) == 0x000080, "Wrong size on UAuthenticationInitializationStep_StoreAgreedEulaVersion");

// Class JP.PartyInviteWrapper
// 0x0020 (0x0048 - 0x0028)
class UPartyInviteWrapper final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyInviteWrapper">();
	}
	static class UPartyInviteWrapper* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyInviteWrapper>();
	}
};
static_assert(alignof(UPartyInviteWrapper) == 0x000008, "Wrong alignment on UPartyInviteWrapper");
static_assert(sizeof(UPartyInviteWrapper) == 0x000048, "Wrong size on UPartyInviteWrapper");

// Class JP.BaseCoordinator
// 0x0018 (0x0040 - 0x0028)
class UBaseCoordinator : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TDelegate<void(class UBaseCoordinator* Coordinator)>> OnceCallbacks;                                     // 0x0030(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BaseCoordinator">();
	}
	static class UBaseCoordinator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBaseCoordinator>();
	}
};
static_assert(alignof(UBaseCoordinator) == 0x000008, "Wrong alignment on UBaseCoordinator");
static_assert(sizeof(UBaseCoordinator) == 0x000040, "Wrong size on UBaseCoordinator");
static_assert(offsetof(UBaseCoordinator, OnceCallbacks) == 0x000030, "Member 'UBaseCoordinator::OnceCallbacks' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_CacheCurrencyData
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_CacheCurrencyData final : public UAuthenticationInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_CacheCurrencyData">();
	}
	static class UAuthenticationInitializationStep_CacheCurrencyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_CacheCurrencyData>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_CacheCurrencyData) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_CacheCurrencyData");
static_assert(sizeof(UAuthenticationInitializationStep_CacheCurrencyData) == 0x000080, "Wrong size on UAuthenticationInitializationStep_CacheCurrencyData");

// Class JP.LyraSettingsShared
// 0x0078 (0x00D0 - 0x0058)
class ULyraSettingsShared final : public ULocalPlayerSaveGame
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EColorBlindMode                               ColorBlindMode;                                    // 0x0070(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ColorBlindStrength;                                // 0x0074(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bForceFeedbackEnabled;                             // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GamepadMoveStickDeadZone;                          // 0x007C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GamepadLookStickDeadZone;                          // 0x0080(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerHapticsEnabled;                            // 0x0084(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTriggerPullUsesHapticThreshold;                   // 0x0085(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TriggerHapticStrength;                             // 0x0086(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TriggerHapticStartPosition;                        // 0x0087(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELyraAllowBackgroundAudioSetting              AllowAudioInBackground;                            // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PendingCulture;                                    // 0x0090(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	double                                        MouseSensitivityX;                                 // 0x00A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        MouseSensitivityY;                                 // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	double                                        TargetingMultiplier;                               // 0x00B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInvertVerticalAxis;                               // 0x00C0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInvertHorizontalAxis;                             // 0x00C1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELyraGamepadSensitivity                       GamepadLookSensitivityPreset;                      // 0x00C2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	ELyraGamepadSensitivity                       GamepadTargetingSensitivityPreset;                 // 0x00C3(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FieldOfView;                                       // 0x00C4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAllowAudioInBackgroundSetting(ELyraAllowBackgroundAudioSetting NewValue);
	void SetColorBlindMode(EColorBlindMode InMode);
	void SetColorBlindStrength(int32 InColorBlindStrength);
	void SetForceFeedbackEnabled(const bool NewValue);
	void SetFOV(float NewValue);
	void SetGamepadLookStickDeadZone(const float NewValue);
	void SetGamepadMoveStickDeadZone(const float NewValue);
	void SetGamepadTargetingSensitivityPreset(ELyraGamepadSensitivity NewValue);
	void SetInvertHorizontalAxis(bool NewValue);
	void SetInvertHorizontalAxisMouse(bool NewValue);
	void SetInvertVerticalAxis(bool NewValue);
	void SetInvertVerticalAxisMouse(bool NewValue);
	void SetLookSensitivityPreset(ELyraGamepadSensitivity NewValue);
	void SetMouseSensitivityX(double NewValue);
	void SetMouseSensitivityY(double NewValue);
	void SetTargetingMultiplier(double NewValue);
	void SetTriggerHapticsEnabled(const bool NewValue);
	void SetTriggerHapticStartPosition(const uint8 NewValue);
	void SetTriggerHapticStrength(const uint8 NewValue);
	void SetTriggerPullUsesHapticThreshold(const bool NewValue);

	ELyraAllowBackgroundAudioSetting GetAllowAudioInBackgroundSetting() const;
	EColorBlindMode GetColorBlindMode() const;
	int32 GetColorBlindStrength() const;
	bool GetForceFeedbackEnabled() const;
	float GetFOV() const;
	ELyraGamepadSensitivity GetGamepadLookSensitivityPreset() const;
	float GetGamepadLookStickDeadZone() const;
	float GetGamepadMoveStickDeadZone() const;
	ELyraGamepadSensitivity GetGamepadTargetingSensitivityPreset() const;
	bool GetInvertHorizontalAxis() const;
	bool GetInvertHorizontalAxisMouse() const;
	bool GetInvertVerticalAxis() const;
	bool GetInvertVerticalAxisMouse() const;
	double GetMouseSensitivityX() const;
	double GetMouseSensitivityY() const;
	double GetTargetingMultiplier() const;
	bool GetTriggerHapticsEnabled() const;
	uint8 GetTriggerHapticStartPosition() const;
	uint8 GetTriggerHapticStrength() const;
	bool GetTriggerPullUsesHapticThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingsShared">();
	}
	static class ULyraSettingsShared* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingsShared>();
	}
};
static_assert(alignof(ULyraSettingsShared) == 0x000008, "Wrong alignment on ULyraSettingsShared");
static_assert(sizeof(ULyraSettingsShared) == 0x0000D0, "Wrong size on ULyraSettingsShared");
static_assert(offsetof(ULyraSettingsShared, ColorBlindMode) == 0x000070, "Member 'ULyraSettingsShared::ColorBlindMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, ColorBlindStrength) == 0x000074, "Member 'ULyraSettingsShared::ColorBlindStrength' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bForceFeedbackEnabled) == 0x000078, "Member 'ULyraSettingsShared::bForceFeedbackEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, GamepadMoveStickDeadZone) == 0x00007C, "Member 'ULyraSettingsShared::GamepadMoveStickDeadZone' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, GamepadLookStickDeadZone) == 0x000080, "Member 'ULyraSettingsShared::GamepadLookStickDeadZone' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bTriggerHapticsEnabled) == 0x000084, "Member 'ULyraSettingsShared::bTriggerHapticsEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bTriggerPullUsesHapticThreshold) == 0x000085, "Member 'ULyraSettingsShared::bTriggerPullUsesHapticThreshold' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, TriggerHapticStrength) == 0x000086, "Member 'ULyraSettingsShared::TriggerHapticStrength' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, TriggerHapticStartPosition) == 0x000087, "Member 'ULyraSettingsShared::TriggerHapticStartPosition' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, AllowAudioInBackground) == 0x000088, "Member 'ULyraSettingsShared::AllowAudioInBackground' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, PendingCulture) == 0x000090, "Member 'ULyraSettingsShared::PendingCulture' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, MouseSensitivityX) == 0x0000A8, "Member 'ULyraSettingsShared::MouseSensitivityX' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, MouseSensitivityY) == 0x0000B0, "Member 'ULyraSettingsShared::MouseSensitivityY' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, TargetingMultiplier) == 0x0000B8, "Member 'ULyraSettingsShared::TargetingMultiplier' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bInvertVerticalAxis) == 0x0000C0, "Member 'ULyraSettingsShared::bInvertVerticalAxis' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, bInvertHorizontalAxis) == 0x0000C1, "Member 'ULyraSettingsShared::bInvertHorizontalAxis' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, GamepadLookSensitivityPreset) == 0x0000C2, "Member 'ULyraSettingsShared::GamepadLookSensitivityPreset' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, GamepadTargetingSensitivityPreset) == 0x0000C3, "Member 'ULyraSettingsShared::GamepadTargetingSensitivityPreset' has a wrong offset!");
static_assert(offsetof(ULyraSettingsShared, FieldOfView) == 0x0000C4, "Member 'ULyraSettingsShared::FieldOfView' has a wrong offset!");

// Class JP.ArmorAttributeSet
// 0x0020 (0x0050 - 0x0030)
class UArmorAttributeSet final : public UAttributeSetIW
{
public:
	struct FGameplayAttributeData                 MeleeArmor;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ProjectileArmor;                                   // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_MeleeArmor();
	void OnRep_ProjectileArmor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ArmorAttributeSet">();
	}
	static class UArmorAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UArmorAttributeSet>();
	}
};
static_assert(alignof(UArmorAttributeSet) == 0x000008, "Wrong alignment on UArmorAttributeSet");
static_assert(sizeof(UArmorAttributeSet) == 0x000050, "Wrong size on UArmorAttributeSet");
static_assert(offsetof(UArmorAttributeSet, MeleeArmor) == 0x000030, "Member 'UArmorAttributeSet::MeleeArmor' has a wrong offset!");
static_assert(offsetof(UArmorAttributeSet, ProjectileArmor) == 0x000040, "Member 'UArmorAttributeSet::ProjectileArmor' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_CacheStoreData
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_CacheStoreData final : public UAuthenticationInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_CacheStoreData">();
	}
	static class UAuthenticationInitializationStep_CacheStoreData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_CacheStoreData>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_CacheStoreData) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_CacheStoreData");
static_assert(sizeof(UAuthenticationInitializationStep_CacheStoreData) == 0x000080, "Wrong size on UAuthenticationInitializationStep_CacheStoreData");

// Class JP.AnimNotify_PlaySoundForPerspective
// 0x0018 (0x0070 - 0x0058)
class UAnimNotify_PlaySoundForPerspective final : public UAnimNotify_PlaySound
{
public:
	bool                                          bPlayForFirstPersonPerspective;                    // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenMontageEnds;                              // 0x0059(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        AudioComponent;                                    // 0x0060(0x0008)(ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           BoundMontage;                                      // 0x0068(0x0008)(BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnMontageEnded(class UAnimMontage* Montage, bool bInterrupted) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AnimNotify_PlaySoundForPerspective">();
	}
	static class UAnimNotify_PlaySoundForPerspective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAnimNotify_PlaySoundForPerspective>();
	}
};
static_assert(alignof(UAnimNotify_PlaySoundForPerspective) == 0x000008, "Wrong alignment on UAnimNotify_PlaySoundForPerspective");
static_assert(sizeof(UAnimNotify_PlaySoundForPerspective) == 0x000070, "Wrong size on UAnimNotify_PlaySoundForPerspective");
static_assert(offsetof(UAnimNotify_PlaySoundForPerspective, bPlayForFirstPersonPerspective) == 0x000058, "Member 'UAnimNotify_PlaySoundForPerspective::bPlayForFirstPersonPerspective' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundForPerspective, bStopWhenMontageEnds) == 0x000059, "Member 'UAnimNotify_PlaySoundForPerspective::bStopWhenMontageEnds' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundForPerspective, AudioComponent) == 0x000060, "Member 'UAnimNotify_PlaySoundForPerspective::AudioComponent' has a wrong offset!");
static_assert(offsetof(UAnimNotify_PlaySoundForPerspective, BoundMontage) == 0x000068, "Member 'UAnimNotify_PlaySoundForPerspective::BoundMontage' has a wrong offset!");

// Class JP.SeasonPassRewardWidgetCatalogItemInterface
// 0x0000 (0x0028 - 0x0028)
class ISeasonPassRewardWidgetCatalogItemInterface final : public IInterface
{
public:
	void ApplyCatalogItemData(const struct FSeasonPassCatalogItem& Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassRewardWidgetCatalogItemInterface">();
	}
	static class ISeasonPassRewardWidgetCatalogItemInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISeasonPassRewardWidgetCatalogItemInterface>();
	}
};
static_assert(alignof(ISeasonPassRewardWidgetCatalogItemInterface) == 0x000008, "Wrong alignment on ISeasonPassRewardWidgetCatalogItemInterface");
static_assert(sizeof(ISeasonPassRewardWidgetCatalogItemInterface) == 0x000028, "Wrong size on ISeasonPassRewardWidgetCatalogItemInterface");

// Class JP.AuthenticationInitializationStep_AccountData
// 0x0008 (0x0088 - 0x0080)
class UAuthenticationInitializationStep_AccountData final : public UAuthenticationInitializationStepBase
{
public:
	class UIdentityOnlineServiceHandler*          IdentityHandler;                                   // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleUserAvatarLoaded(bool bInWasSuccessful, TSoftObjectPtr<class UTexture> InResultTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_AccountData">();
	}
	static class UAuthenticationInitializationStep_AccountData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_AccountData>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_AccountData) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_AccountData");
static_assert(sizeof(UAuthenticationInitializationStep_AccountData) == 0x000088, "Wrong size on UAuthenticationInitializationStep_AccountData");
static_assert(offsetof(UAuthenticationInitializationStep_AccountData, IdentityHandler) == 0x000080, "Member 'UAuthenticationInitializationStep_AccountData::IdentityHandler' has a wrong offset!");

// Class JP.EndCondition
// 0x0018 (0x02A8 - 0x0290)
class AEndCondition : public AInfo
{
public:
	class FText                                   EliminationDescription;                            // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   EndConditionName;                                  // 0x02A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void EliminateTeam(uint8 TeamId);

	class FName GetEndConditionName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndCondition">();
	}
	static class AEndCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEndCondition>();
	}
};
static_assert(alignof(AEndCondition) == 0x000008, "Wrong alignment on AEndCondition");
static_assert(sizeof(AEndCondition) == 0x0002A8, "Wrong size on AEndCondition");
static_assert(offsetof(AEndCondition, EliminationDescription) == 0x000290, "Member 'AEndCondition::EliminationDescription' has a wrong offset!");
static_assert(offsetof(AEndCondition, EndConditionName) == 0x0002A0, "Member 'AEndCondition::EndConditionName' has a wrong offset!");

// Class JP.TeamColorFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTeamColorFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static uint8 GetLocalPlayerTeamId(class UObject* WorldContext);
	static struct FLinearColor GetTeamColorForTeamId(class UObject* WorldContext, uint8 TeamId);
	static struct FLinearColor GetTeamColorForTeamType(ETeamType TeamType);
	static uint8 GetTeamIdFromTeamType(class UObject* WorldContext, ETeamType TeamType);
	static uint8 GetTeamIdFromTeamTypeFromSpecificPlayerPointOfView(class APlayerController* PlayerController, ETeamType TeamTypeToConvert);
	static ETeamType GetTeamTypeFromTeamId(class UObject* WorldContext, uint8 TeamId);
	static ETeamType GetTeamTypeFromTeamIdFromSpecificPlayerPointOfView(class APlayerController* PlayerController, uint8 TeamIdToConvert);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamColorFunctionLibrary">();
	}
	static class UTeamColorFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamColorFunctionLibrary>();
	}
};
static_assert(alignof(UTeamColorFunctionLibrary) == 0x000008, "Wrong alignment on UTeamColorFunctionLibrary");
static_assert(sizeof(UTeamColorFunctionLibrary) == 0x000028, "Wrong size on UTeamColorFunctionLibrary");

// Class JP.AuthenticationInitializationStep_GameData
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_GameData final : public UAuthenticationInitializationStepBase
{
public:
	void OnFinishedUpdatingGameData();
	void OnLoggedIn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_GameData">();
	}
	static class UAuthenticationInitializationStep_GameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_GameData>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_GameData) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_GameData");
static_assert(sizeof(UAuthenticationInitializationStep_GameData) == 0x000080, "Wrong size on UAuthenticationInitializationStep_GameData");

// Class JP.SocialListWidget
// 0x0048 (0x0328 - 0x02E0)
class USocialListWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UNamedSlot*                             ListSlot;                                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Header;                                            // 0x02F0(0x0010)(Edit, BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CollapsedToPartyWidgetAnimation;                   // 0x0300(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CollapsedToFillWidgetAnimation;                    // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       CollapsedToFullWidgetAnimation;                    // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       FillToFullWidgetAnimation;                         // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x8];                                      // 0x0320(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BlueprintApplyListStateNoAnimation(const ESocialListState InListState);
	void SetHeader(const class FString& StringToAppend);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialListWidget">();
	}
	static class USocialListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialListWidget>();
	}
};
static_assert(alignof(USocialListWidget) == 0x000008, "Wrong alignment on USocialListWidget");
static_assert(sizeof(USocialListWidget) == 0x000328, "Wrong size on USocialListWidget");
static_assert(offsetof(USocialListWidget, ListSlot) == 0x0002E8, "Member 'USocialListWidget::ListSlot' has a wrong offset!");
static_assert(offsetof(USocialListWidget, Header) == 0x0002F0, "Member 'USocialListWidget::Header' has a wrong offset!");
static_assert(offsetof(USocialListWidget, CollapsedToPartyWidgetAnimation) == 0x000300, "Member 'USocialListWidget::CollapsedToPartyWidgetAnimation' has a wrong offset!");
static_assert(offsetof(USocialListWidget, CollapsedToFillWidgetAnimation) == 0x000308, "Member 'USocialListWidget::CollapsedToFillWidgetAnimation' has a wrong offset!");
static_assert(offsetof(USocialListWidget, CollapsedToFullWidgetAnimation) == 0x000310, "Member 'USocialListWidget::CollapsedToFullWidgetAnimation' has a wrong offset!");
static_assert(offsetof(USocialListWidget, FillToFullWidgetAnimation) == 0x000318, "Member 'USocialListWidget::FillToFullWidgetAnimation' has a wrong offset!");

// Class JP.AssetManagerJP
// 0x0000 (0x04D0 - 0x04D0)
class UAssetManagerJP final : public UAssetManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AssetManagerJP">();
	}
	static class UAssetManagerJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAssetManagerJP>();
	}
};
static_assert(alignof(UAssetManagerJP) == 0x000008, "Wrong alignment on UAssetManagerJP");
static_assert(sizeof(UAssetManagerJP) == 0x0004D0, "Wrong size on UAssetManagerJP");

// Class JP.AuthenticationInitializationStep_ValidateFirstTimeLoginRewards
// 0x00C8 (0x0148 - 0x0080)
class UAuthenticationInitializationStep_ValidateFirstTimeLoginRewards final : public UAuthenticationInitializationStepBase
{
public:
	uint8                                         Pad_80[0xC8];                                      // 0x0080(0x00C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_ValidateFirstTimeLoginRewards">();
	}
	static class UAuthenticationInitializationStep_ValidateFirstTimeLoginRewards* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_ValidateFirstTimeLoginRewards>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_ValidateFirstTimeLoginRewards) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_ValidateFirstTimeLoginRewards");
static_assert(sizeof(UAuthenticationInitializationStep_ValidateFirstTimeLoginRewards) == 0x000148, "Wrong size on UAuthenticationInitializationStep_ValidateFirstTimeLoginRewards");

// Class JP.LyraActionWidget
// 0x0000 (0x0490 - 0x0490)
class ULyraActionWidget final : public UCommonActionWidget
{
public:
	class UInputAction*                           AssociatedInputAction;                             // 0x0488(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraActionWidget">();
	}
	static class ULyraActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraActionWidget>();
	}
};
static_assert(alignof(ULyraActionWidget) == 0x000010, "Wrong alignment on ULyraActionWidget");
static_assert(sizeof(ULyraActionWidget) == 0x000490, "Wrong size on ULyraActionWidget");
static_assert(offsetof(ULyraActionWidget, AssociatedInputAction) == 0x000488, "Member 'ULyraActionWidget::AssociatedInputAction' has a wrong offset!");

// Class JP.AchievementStatMetaData
// 0x0010 (0x0040 - 0x0030)
class UAchievementStatMetaData final : public UPrimaryDataAsset
{
public:
	class FName                                   AchievementStatAPIName;                            // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAchievementStatUpdateMethod                  UpdateMethod;                                      // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementStatMetaData">();
	}
	static class UAchievementStatMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementStatMetaData>();
	}
};
static_assert(alignof(UAchievementStatMetaData) == 0x000008, "Wrong alignment on UAchievementStatMetaData");
static_assert(sizeof(UAchievementStatMetaData) == 0x000040, "Wrong size on UAchievementStatMetaData");
static_assert(offsetof(UAchievementStatMetaData, AchievementStatAPIName) == 0x000030, "Member 'UAchievementStatMetaData::AchievementStatAPIName' has a wrong offset!");
static_assert(offsetof(UAchievementStatMetaData, UpdateMethod) == 0x000038, "Member 'UAchievementStatMetaData::UpdateMethod' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_SeasonPass
// 0x0078 (0x00F8 - 0x0080)
class UAuthenticationInitializationStep_SeasonPass final : public UAuthenticationInitializationStepBase
{
public:
	uint8                                         Pad_80[0x78];                                      // 0x0080(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_SeasonPass">();
	}
	static class UAuthenticationInitializationStep_SeasonPass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_SeasonPass>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_SeasonPass) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_SeasonPass");
static_assert(sizeof(UAuthenticationInitializationStep_SeasonPass) == 0x0000F8, "Wrong size on UAuthenticationInitializationStep_SeasonPass");

// Class JP.AchievementsGameInstanceSubsystem
// 0x0008 (0x0038 - 0x0030)
class UAchievementsGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetAchievements();
	void UnlockAchievement(const TSoftObjectPtr<class UAchievementMetaData> AchievementMetaData);
	void UpdateAchievementStatFloat(const TSoftObjectPtr<class UAchievementStatMetaData> AchievementStatMetaData, const float StatValue);
	void UpdateAchievementStatInt(const TSoftObjectPtr<class UAchievementStatMetaData> AchievementStatMetaData, const int32 StatValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementsGameInstanceSubsystem">();
	}
	static class UAchievementsGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementsGameInstanceSubsystem>();
	}
};
static_assert(alignof(UAchievementsGameInstanceSubsystem) == 0x000008, "Wrong alignment on UAchievementsGameInstanceSubsystem");
static_assert(sizeof(UAchievementsGameInstanceSubsystem) == 0x000038, "Wrong size on UAchievementsGameInstanceSubsystem");

// Class JP.TeamableInterface
// 0x0000 (0x0028 - 0x0028)
class ITeamableInterface final : public IInterface
{
public:
	struct FTeam GetTeam() const;
	uint8 GetTeamID() const;
	bool HasTeam() const;
	bool TakeDamageFromAllTeams() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamableInterface">();
	}
	static class ITeamableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITeamableInterface>();
	}
};
static_assert(alignof(ITeamableInterface) == 0x000008, "Wrong alignment on ITeamableInterface");
static_assert(sizeof(ITeamableInterface) == 0x000028, "Wrong size on ITeamableInterface");

// Class JP.AuthenticationInitializationStep_PlayerInventory
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_PlayerInventory final : public UAuthenticationInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_PlayerInventory">();
	}
	static class UAuthenticationInitializationStep_PlayerInventory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_PlayerInventory>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_PlayerInventory) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_PlayerInventory");
static_assert(sizeof(UAuthenticationInitializationStep_PlayerInventory) == 0x000080, "Wrong size on UAuthenticationInitializationStep_PlayerInventory");

// Class JP.JPCommonActivatableWidgetSwitcher
// 0x0010 (0x0250 - 0x0240)
class UJPCommonActivatableWidgetSwitcher final : public UCommonActivatableWidgetSwitcher
{
public:
	FMulticastInlineDelegateProperty_             BP_OnActiveWidgetIndexChanged;                     // 0x0240(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPCommonActivatableWidgetSwitcher">();
	}
	static class UJPCommonActivatableWidgetSwitcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPCommonActivatableWidgetSwitcher>();
	}
};
static_assert(alignof(UJPCommonActivatableWidgetSwitcher) == 0x000008, "Wrong alignment on UJPCommonActivatableWidgetSwitcher");
static_assert(sizeof(UJPCommonActivatableWidgetSwitcher) == 0x000250, "Wrong size on UJPCommonActivatableWidgetSwitcher");
static_assert(offsetof(UJPCommonActivatableWidgetSwitcher, BP_OnActiveWidgetIndexChanged) == 0x000240, "Member 'UJPCommonActivatableWidgetSwitcher::BP_OnActiveWidgetIndexChanged' has a wrong offset!");

// Class JP.AmmoAttributeSet
// 0x00A0 (0x00D0 - 0x0030)
class UAmmoAttributeSet final : public UAttributeSetIW
{
public:
	struct FGameplayAttributeData                 SlingshotAmmo;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SlingshotMaxAmmo;                                  // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OrangeCannonAmmo;                                  // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 OrangeCannonMaxAmmo;                               // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireworkBoxAmmo;                                   // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 FireworkBoxMaxAmmo;                                // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WrenchAmmo;                                        // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 WrenchMaxAmmo;                                     // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_FireworkBoxAmmo(const struct FGameplayAttributeData& OldFireworkBoxAmmo);
	void OnRep_FireworkBoxMaxAmmo(const struct FGameplayAttributeData& OldFireworkBoxAmmoMax);
	void OnRep_OrangeCannonAmmo(const struct FGameplayAttributeData& OldOrangeCannonAmmo);
	void OnRep_OrangeCannonMaxAmmo(const struct FGameplayAttributeData& OldOrangeCannonAmmoMax);
	void OnRep_SlingshotAmmo(const struct FGameplayAttributeData& OldSlingshotAmmo);
	void OnRep_SlingshotMaxAmmo(const struct FGameplayAttributeData& OldSlingshotAmmoMax);
	void OnRep_WrenchAmmo(const struct FGameplayAttributeData& OldWrenchAmmo);
	void OnRep_WrenchMaxAmmo(const struct FGameplayAttributeData& OldWrenchAmmoMax);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoAttributeSet">();
	}
	static class UAmmoAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAmmoAttributeSet>();
	}
};
static_assert(alignof(UAmmoAttributeSet) == 0x000008, "Wrong alignment on UAmmoAttributeSet");
static_assert(sizeof(UAmmoAttributeSet) == 0x0000D0, "Wrong size on UAmmoAttributeSet");
static_assert(offsetof(UAmmoAttributeSet, SlingshotAmmo) == 0x000030, "Member 'UAmmoAttributeSet::SlingshotAmmo' has a wrong offset!");
static_assert(offsetof(UAmmoAttributeSet, SlingshotMaxAmmo) == 0x000040, "Member 'UAmmoAttributeSet::SlingshotMaxAmmo' has a wrong offset!");
static_assert(offsetof(UAmmoAttributeSet, OrangeCannonAmmo) == 0x000050, "Member 'UAmmoAttributeSet::OrangeCannonAmmo' has a wrong offset!");
static_assert(offsetof(UAmmoAttributeSet, OrangeCannonMaxAmmo) == 0x000060, "Member 'UAmmoAttributeSet::OrangeCannonMaxAmmo' has a wrong offset!");
static_assert(offsetof(UAmmoAttributeSet, FireworkBoxAmmo) == 0x000070, "Member 'UAmmoAttributeSet::FireworkBoxAmmo' has a wrong offset!");
static_assert(offsetof(UAmmoAttributeSet, FireworkBoxMaxAmmo) == 0x000080, "Member 'UAmmoAttributeSet::FireworkBoxMaxAmmo' has a wrong offset!");
static_assert(offsetof(UAmmoAttributeSet, WrenchAmmo) == 0x000090, "Member 'UAmmoAttributeSet::WrenchAmmo' has a wrong offset!");
static_assert(offsetof(UAmmoAttributeSet, WrenchMaxAmmo) == 0x0000A0, "Member 'UAmmoAttributeSet::WrenchMaxAmmo' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_BattlePassItems
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_BattlePassItems final : public UAuthenticationInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_BattlePassItems">();
	}
	static class UAuthenticationInitializationStep_BattlePassItems* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_BattlePassItems>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_BattlePassItems) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_BattlePassItems");
static_assert(sizeof(UAuthenticationInitializationStep_BattlePassItems) == 0x000080, "Wrong size on UAuthenticationInitializationStep_BattlePassItems");

// Class JP.SocialFriendEntryWidget
// 0x0048 (0x0328 - 0x02E0)
class USocialFriendEntryWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialUserEntryWidget*                 UserEntryWidget;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialFriendInteractionWidget*         InteractionWidget;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonVisualAttachment*                InviteSentWidget;                                  // 0x0310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       InviteSentWidgetAnimation;                         // 0x0318(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFriendEntryViewModel*                  ViewModel;                                         // 0x0320(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetLocalizedStatusInfo(const EOnlineServicesFriendStatus Status, class FText* StatusText, struct FLinearColor* Color);
	void SetIsInviteSent(const bool bIsInviteSent);
	void SetStatus(const EOnlineServicesFriendStatus Status);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialFriendEntryWidget">();
	}
	static class USocialFriendEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialFriendEntryWidget>();
	}
};
static_assert(alignof(USocialFriendEntryWidget) == 0x000008, "Wrong alignment on USocialFriendEntryWidget");
static_assert(sizeof(USocialFriendEntryWidget) == 0x000328, "Wrong size on USocialFriendEntryWidget");
static_assert(offsetof(USocialFriendEntryWidget, UserEntryWidget) == 0x000300, "Member 'USocialFriendEntryWidget::UserEntryWidget' has a wrong offset!");
static_assert(offsetof(USocialFriendEntryWidget, InteractionWidget) == 0x000308, "Member 'USocialFriendEntryWidget::InteractionWidget' has a wrong offset!");
static_assert(offsetof(USocialFriendEntryWidget, InviteSentWidget) == 0x000310, "Member 'USocialFriendEntryWidget::InviteSentWidget' has a wrong offset!");
static_assert(offsetof(USocialFriendEntryWidget, InviteSentWidgetAnimation) == 0x000318, "Member 'USocialFriendEntryWidget::InviteSentWidgetAnimation' has a wrong offset!");
static_assert(offsetof(USocialFriendEntryWidget, ViewModel) == 0x000320, "Member 'USocialFriendEntryWidget::ViewModel' has a wrong offset!");

// Class JP.AsyncAction_WaitForClientAuthenticationInitialized
// 0x0010 (0x0040 - 0x0030)
class UAsyncAction_WaitForClientAuthenticationInitialized final : public UAsyncAction_OnlineServicesBase
{
public:
	FMulticastInlineDelegateProperty_             OnClientAuthenticationInitialized;                 // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_WaitForClientAuthenticationInitialized* WaitForClientAuthenticationInitialized(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_WaitForClientAuthenticationInitialized">();
	}
	static class UAsyncAction_WaitForClientAuthenticationInitialized* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_WaitForClientAuthenticationInitialized>();
	}
};
static_assert(alignof(UAsyncAction_WaitForClientAuthenticationInitialized) == 0x000008, "Wrong alignment on UAsyncAction_WaitForClientAuthenticationInitialized");
static_assert(sizeof(UAsyncAction_WaitForClientAuthenticationInitialized) == 0x000040, "Wrong size on UAsyncAction_WaitForClientAuthenticationInitialized");
static_assert(offsetof(UAsyncAction_WaitForClientAuthenticationInitialized, OnClientAuthenticationInitialized) == 0x000030, "Member 'UAsyncAction_WaitForClientAuthenticationInitialized::OnClientAuthenticationInitialized' has a wrong offset!");

// Class JP.PlayerControllerJPExtensionComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPlayerControllerJPExtensionComponent final : public UPlayerControllerExtensionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerJPExtensionComponent">();
	}
	static class UPlayerControllerJPExtensionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerControllerJPExtensionComponent>();
	}
};
static_assert(alignof(UPlayerControllerJPExtensionComponent) == 0x000008, "Wrong alignment on UPlayerControllerJPExtensionComponent");
static_assert(sizeof(UPlayerControllerJPExtensionComponent) == 0x0000A0, "Wrong size on UPlayerControllerJPExtensionComponent");

// Class JP.AuthenticationInitializationStep_Neighbors
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_Neighbors final : public UAuthenticationInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_Neighbors">();
	}
	static class UAuthenticationInitializationStep_Neighbors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_Neighbors>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_Neighbors) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_Neighbors");
static_assert(sizeof(UAuthenticationInitializationStep_Neighbors) == 0x000080, "Wrong size on UAuthenticationInitializationStep_Neighbors");

// Class JP.GameModeJP
// 0x0050 (0x03C0 - 0x0370)
class AGameModeJP : public AModularGameMode
{
public:
	class UPlayerAdmissionComponent*              PlayerAdmissionComponent;                          // 0x0370(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadoutVerificationServerComponent*    LoadoutVerificationServerComponent;                // 0x0378(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTeamBased;                                        // 0x0380(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x3];                                      // 0x0381(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchTime;                                         // 0x0384(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Map;                                               // 0x0388(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 GameMode;                                          // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x18];                                     // 0x03A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AGameModeJP* GetGameModeJP(class UObject* WorldContextObject);

	int32 GetEnemyHouseEssentialKills(const class APlayerStateJP* PlayerStateJP);
	int32 GetTeamHouseEssentialLost(const class APlayerStateJP* PlayerStateJP);
	void ServerTravel(TSoftObjectPtr<class UWorld> TargetLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeJP">();
	}
	static class AGameModeJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeJP>();
	}
};
static_assert(alignof(AGameModeJP) == 0x000008, "Wrong alignment on AGameModeJP");
static_assert(sizeof(AGameModeJP) == 0x0003C0, "Wrong size on AGameModeJP");
static_assert(offsetof(AGameModeJP, PlayerAdmissionComponent) == 0x000370, "Member 'AGameModeJP::PlayerAdmissionComponent' has a wrong offset!");
static_assert(offsetof(AGameModeJP, LoadoutVerificationServerComponent) == 0x000378, "Member 'AGameModeJP::LoadoutVerificationServerComponent' has a wrong offset!");
static_assert(offsetof(AGameModeJP, bTeamBased) == 0x000380, "Member 'AGameModeJP::bTeamBased' has a wrong offset!");
static_assert(offsetof(AGameModeJP, MatchTime) == 0x000384, "Member 'AGameModeJP::MatchTime' has a wrong offset!");
static_assert(offsetof(AGameModeJP, Map) == 0x000388, "Member 'AGameModeJP::Map' has a wrong offset!");
static_assert(offsetof(AGameModeJP, GameMode) == 0x000398, "Member 'AGameModeJP::GameMode' has a wrong offset!");

// Class JP.GameModeJP_Match
// 0x00A8 (0x0468 - 0x03C0)
class AGameModeJP_Match : public AGameModeJP
{
public:
	float                                         MatchStartFallbackTimeoutInSeconds;                // 0x03C0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             TeamEliminatedDelegate;                            // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AEndCondition>>      EndConditions;                                     // 0x03D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x28];                                     // 0x03E8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ShutdownGracefulHandle;                            // 0x0410(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IsAllClientsHousesLoadedFallbackTimeoutTime;       // 0x0420(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_424[0x4];                                      // 0x0424(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<uint8>                                 PlayerTeamOrder;                                   // 0x0428(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bHasInitializedTeamOrderEditor;                    // 0x0438(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_439[0x7];                                      // 0x0439(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           IsAllClientsHousesLoadedFallbackTimerHandle;       // 0x0440(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x20];                                     // 0x0448(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool EndConditionEnabled(class UObject* WorldContextObject, TSubclassOf<class AEndCondition> EndConditionType);
	static class AEndCondition* GetEndCondition(class UObject* WorldContextObject, TSubclassOf<class AEndCondition> EndConditionType);

	bool CanShutdownGracefully();
	void CanShutdownGracefully_Internal();
	class AActor* ChoosePlayerStart_Implementation(class AController* Player);
	void GracefulShutdownBegin();
	void HandlePlayerBlockedListInitialized(class APlayerState* PlayerState);
	void OnKill(const struct FGameplayTag& Channel, const struct FKillGameplayMessage& MessagePayload);
	void RestartMatch();
	void ServerDoneLoadingHouses();

	void AddEndCondition(TSubclassOf<class AEndCondition> EndConditionType) const;
	bool IsAllClientsHousesLoaded() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeJP_Match">();
	}
	static class AGameModeJP_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeJP_Match>();
	}
};
static_assert(alignof(AGameModeJP_Match) == 0x000008, "Wrong alignment on AGameModeJP_Match");
static_assert(sizeof(AGameModeJP_Match) == 0x000468, "Wrong size on AGameModeJP_Match");
static_assert(offsetof(AGameModeJP_Match, MatchStartFallbackTimeoutInSeconds) == 0x0003C0, "Member 'AGameModeJP_Match::MatchStartFallbackTimeoutInSeconds' has a wrong offset!");
static_assert(offsetof(AGameModeJP_Match, TeamEliminatedDelegate) == 0x0003C8, "Member 'AGameModeJP_Match::TeamEliminatedDelegate' has a wrong offset!");
static_assert(offsetof(AGameModeJP_Match, EndConditions) == 0x0003D8, "Member 'AGameModeJP_Match::EndConditions' has a wrong offset!");
static_assert(offsetof(AGameModeJP_Match, ShutdownGracefulHandle) == 0x000410, "Member 'AGameModeJP_Match::ShutdownGracefulHandle' has a wrong offset!");
static_assert(offsetof(AGameModeJP_Match, IsAllClientsHousesLoadedFallbackTimeoutTime) == 0x000420, "Member 'AGameModeJP_Match::IsAllClientsHousesLoadedFallbackTimeoutTime' has a wrong offset!");
static_assert(offsetof(AGameModeJP_Match, PlayerTeamOrder) == 0x000428, "Member 'AGameModeJP_Match::PlayerTeamOrder' has a wrong offset!");
static_assert(offsetof(AGameModeJP_Match, bHasInitializedTeamOrderEditor) == 0x000438, "Member 'AGameModeJP_Match::bHasInitializedTeamOrderEditor' has a wrong offset!");
static_assert(offsetof(AGameModeJP_Match, IsAllClientsHousesLoadedFallbackTimerHandle) == 0x000440, "Member 'AGameModeJP_Match::IsAllClientsHousesLoadedFallbackTimerHandle' has a wrong offset!");

// Class JP.AbilityTask_WaitForActorOutOfFocus
// 0x0048 (0x00C8 - 0x0080)
class UAbilityTask_WaitForActorOutOfFocus final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnOutOfFocus;                                      // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         Interval;                                          // 0x0090(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  Tags;                                              // 0x0098(0x0020)(NativeAccessSpecifierPublic)
	class AActor*                                 FocusedActor;                                      // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitForActorOutOfFocus* WaitForActorOutOfFocus(class UGameplayAbility* OwningAbility, class AActor* ActorToFind, const struct FGameplayTagContainer& TagsToLookFor, float CheckInterval);

	void CheckOnOutOfFocus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitForActorOutOfFocus">();
	}
	static class UAbilityTask_WaitForActorOutOfFocus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitForActorOutOfFocus>();
	}
};
static_assert(alignof(UAbilityTask_WaitForActorOutOfFocus) == 0x000008, "Wrong alignment on UAbilityTask_WaitForActorOutOfFocus");
static_assert(sizeof(UAbilityTask_WaitForActorOutOfFocus) == 0x0000C8, "Wrong size on UAbilityTask_WaitForActorOutOfFocus");
static_assert(offsetof(UAbilityTask_WaitForActorOutOfFocus, OnOutOfFocus) == 0x000080, "Member 'UAbilityTask_WaitForActorOutOfFocus::OnOutOfFocus' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitForActorOutOfFocus, Interval) == 0x000090, "Member 'UAbilityTask_WaitForActorOutOfFocus::Interval' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitForActorOutOfFocus, Tags) == 0x000098, "Member 'UAbilityTask_WaitForActorOutOfFocus::Tags' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitForActorOutOfFocus, FocusedActor) == 0x0000B8, "Member 'UAbilityTask_WaitForActorOutOfFocus::FocusedActor' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_PlayerWallet
// 0x0008 (0x0088 - 0x0080)
class UAuthenticationInitializationStep_PlayerWallet final : public UAuthenticationInitializationStepBase
{
public:
	class ULocalUserOnlineServicesGameInstanceSubsystem* LocalUserGIS;                                      // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_PlayerWallet">();
	}
	static class UAuthenticationInitializationStep_PlayerWallet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_PlayerWallet>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_PlayerWallet) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_PlayerWallet");
static_assert(sizeof(UAuthenticationInitializationStep_PlayerWallet) == 0x000088, "Wrong size on UAuthenticationInitializationStep_PlayerWallet");
static_assert(offsetof(UAuthenticationInitializationStep_PlayerWallet, LocalUserGIS) == 0x000080, "Member 'UAuthenticationInitializationStep_PlayerWallet::LocalUserGIS' has a wrong offset!");

// Class JP.WarmupActor
// 0x0000 (0x0290 - 0x0290)
class AWarmupActor : public AActor
{
public:
	void DisableWarmup();
	void EnableWarmup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WarmupActor">();
	}
	static class AWarmupActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWarmupActor>();
	}
};
static_assert(alignof(AWarmupActor) == 0x000008, "Wrong alignment on AWarmupActor");
static_assert(sizeof(AWarmupActor) == 0x000290, "Wrong size on AWarmupActor");

// Class JP.AuthenticationInitializationStep_PlayerProgression
// 0x0008 (0x0088 - 0x0080)
class UAuthenticationInitializationStep_PlayerProgression final : public UAuthenticationInitializationStepBase
{
public:
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_PlayerProgression">();
	}
	static class UAuthenticationInitializationStep_PlayerProgression* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_PlayerProgression>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_PlayerProgression) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_PlayerProgression");
static_assert(sizeof(UAuthenticationInitializationStep_PlayerProgression) == 0x000088, "Wrong size on UAuthenticationInitializationStep_PlayerProgression");

// Class JP.JPGameSettingValueDiscreteDynamic
// 0x0010 (0x01C8 - 0x01B8)
class UJPGameSettingValueDiscreteDynamic : public UGameSettingValueDiscreteDynamic
{
public:
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueDiscreteDynamic">();
	}
	static class UJPGameSettingValueDiscreteDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueDiscreteDynamic>();
	}
};
static_assert(alignof(UJPGameSettingValueDiscreteDynamic) == 0x000008, "Wrong alignment on UJPGameSettingValueDiscreteDynamic");
static_assert(sizeof(UJPGameSettingValueDiscreteDynamic) == 0x0001C8, "Wrong size on UJPGameSettingValueDiscreteDynamic");

// Class JP.LyraSettingValueDiscreteDynamic_AudioOutputDevice
// 0x0058 (0x0220 - 0x01C8)
class ULyraSettingValueDiscreteDynamic_AudioOutputDevice final : public UJPGameSettingValueDiscreteDynamic
{
public:
	uint8                                         Pad_1C8[0x58];                                     // 0x01C8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DefaultDeviceChanged(EAudioDeviceChangedRole InRole, const class FString& DeviceID);
	void DeviceAddedOrRemoved(const class FString& DeviceID);
	void OnAudioOutputDevicesObtained(const TArray<struct FAudioOutputDeviceInfo>& AvailableDevices);
	void OnCompletedDeviceSwap(const struct FSwapAudioOutputResult& SwapResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscreteDynamic_AudioOutputDevice">();
	}
	static class ULyraSettingValueDiscreteDynamic_AudioOutputDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscreteDynamic_AudioOutputDevice>();
	}
};
static_assert(alignof(ULyraSettingValueDiscreteDynamic_AudioOutputDevice) == 0x000008, "Wrong alignment on ULyraSettingValueDiscreteDynamic_AudioOutputDevice");
static_assert(sizeof(ULyraSettingValueDiscreteDynamic_AudioOutputDevice) == 0x000220, "Wrong size on ULyraSettingValueDiscreteDynamic_AudioOutputDevice");

// Class JP.AuthenticationInitializationStep_PlayerLoadout
// 0x0010 (0x0090 - 0x0080)
class UAuthenticationInitializationStep_PlayerLoadout final : public UAuthenticationInitializationStepBase
{
public:
	class ULocalUserOnlineServicesGameInstanceSubsystem* LocalUserGIS;                                      // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineStoreGameInstanceSubsystem*      StoreGIS;                                          // 0x0088(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_PlayerLoadout">();
	}
	static class UAuthenticationInitializationStep_PlayerLoadout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_PlayerLoadout>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_PlayerLoadout) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_PlayerLoadout");
static_assert(sizeof(UAuthenticationInitializationStep_PlayerLoadout) == 0x000090, "Wrong size on UAuthenticationInitializationStep_PlayerLoadout");
static_assert(offsetof(UAuthenticationInitializationStep_PlayerLoadout, LocalUserGIS) == 0x000080, "Member 'UAuthenticationInitializationStep_PlayerLoadout::LocalUserGIS' has a wrong offset!");
static_assert(offsetof(UAuthenticationInitializationStep_PlayerLoadout, StoreGIS) == 0x000088, "Member 'UAuthenticationInitializationStep_PlayerLoadout::StoreGIS' has a wrong offset!");

// Class JP.SocialBlockedPlayerEntryWidget
// 0x0038 (0x0318 - 0x02E0)
class USocialBlockedPlayerEntryWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialUserEntryWidget*                 UserEntryWidget;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialBlockedPlayerInteractionWidget*  InteractionWidget;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBlockedPlayerEntryViewModel*           ViewModel;                                         // 0x0310(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetLocalizedStatusInfo(class FText* StatusText, struct FLinearColor* Color);
	void SetStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialBlockedPlayerEntryWidget">();
	}
	static class USocialBlockedPlayerEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialBlockedPlayerEntryWidget>();
	}
};
static_assert(alignof(USocialBlockedPlayerEntryWidget) == 0x000008, "Wrong alignment on USocialBlockedPlayerEntryWidget");
static_assert(sizeof(USocialBlockedPlayerEntryWidget) == 0x000318, "Wrong size on USocialBlockedPlayerEntryWidget");
static_assert(offsetof(USocialBlockedPlayerEntryWidget, UserEntryWidget) == 0x000300, "Member 'USocialBlockedPlayerEntryWidget::UserEntryWidget' has a wrong offset!");
static_assert(offsetof(USocialBlockedPlayerEntryWidget, InteractionWidget) == 0x000308, "Member 'USocialBlockedPlayerEntryWidget::InteractionWidget' has a wrong offset!");
static_assert(offsetof(USocialBlockedPlayerEntryWidget, ViewModel) == 0x000310, "Member 'USocialBlockedPlayerEntryWidget::ViewModel' has a wrong offset!");

// Class JP.AbilityTask_WaitInputReleaseOrTimer
// 0x0040 (0x00C0 - 0x0080)
class UAbilityTask_WaitInputReleaseOrTimer final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnTimerFinish;                                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputRelease;                                    // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_WaitInputReleaseOrTimer* WaitInputReleaseOrTimer(class UGameplayAbility* OwningAbility, float Time, bool bTestAlreadyReleased);

	void OnReleaseCallback();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_WaitInputReleaseOrTimer">();
	}
	static class UAbilityTask_WaitInputReleaseOrTimer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_WaitInputReleaseOrTimer>();
	}
};
static_assert(alignof(UAbilityTask_WaitInputReleaseOrTimer) == 0x000008, "Wrong alignment on UAbilityTask_WaitInputReleaseOrTimer");
static_assert(sizeof(UAbilityTask_WaitInputReleaseOrTimer) == 0x0000C0, "Wrong size on UAbilityTask_WaitInputReleaseOrTimer");
static_assert(offsetof(UAbilityTask_WaitInputReleaseOrTimer, OnTimerFinish) == 0x000080, "Member 'UAbilityTask_WaitInputReleaseOrTimer::OnTimerFinish' has a wrong offset!");
static_assert(offsetof(UAbilityTask_WaitInputReleaseOrTimer, OnInputRelease) == 0x000090, "Member 'UAbilityTask_WaitInputReleaseOrTimer::OnInputRelease' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_CleanupParties
// 0x0028 (0x00A8 - 0x0080)
class UAuthenticationInitializationStep_CleanupParties final : public UAuthenticationInitializationStepBase
{
public:
	uint8                                         Pad_80[0x28];                                      // 0x0080(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_CleanupParties">();
	}
	static class UAuthenticationInitializationStep_CleanupParties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_CleanupParties>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_CleanupParties) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_CleanupParties");
static_assert(sizeof(UAuthenticationInitializationStep_CleanupParties) == 0x0000A8, "Wrong size on UAuthenticationInitializationStep_CleanupParties");

// Class JP.ItemUnlockRequest
// 0x0090 (0x00B8 - 0x0028)
class UItemUnlockRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USharedEconomyOnlineServiceHandler*     SharedEconomyHandler;                              // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClientEconomyOnlineServiceHandler*     ClientEconomyHandler;                              // 0x0050(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x60];                                      // 0x0058(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemUnlockRequest">();
	}
	static class UItemUnlockRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemUnlockRequest>();
	}
};
static_assert(alignof(UItemUnlockRequest) == 0x000008, "Wrong alignment on UItemUnlockRequest");
static_assert(sizeof(UItemUnlockRequest) == 0x0000B8, "Wrong size on UItemUnlockRequest");
static_assert(offsetof(UItemUnlockRequest, SharedEconomyHandler) == 0x000048, "Member 'UItemUnlockRequest::SharedEconomyHandler' has a wrong offset!");
static_assert(offsetof(UItemUnlockRequest, ClientEconomyHandler) == 0x000050, "Member 'UItemUnlockRequest::ClientEconomyHandler' has a wrong offset!");

// Class JP.AbilityCost_Attribute
// 0x0000 (0x0028 - 0x0028)
class UAbilityCost_Attribute final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityCost_Attribute">();
	}
	static class UAbilityCost_Attribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityCost_Attribute>();
	}
};
static_assert(alignof(UAbilityCost_Attribute) == 0x000008, "Wrong alignment on UAbilityCost_Attribute");
static_assert(sizeof(UAbilityCost_Attribute) == 0x000028, "Wrong size on UAbilityCost_Attribute");

// Class JP.AuthenticationInitializationStep_ReconcilePartyInvites
// 0x0020 (0x00A0 - 0x0080)
class UAuthenticationInitializationStep_ReconcilePartyInvites final : public UAuthenticationInitializationStepBase
{
public:
	class UPartyOnlineServiceHandler*             ServicePartyPtr;                                   // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x18];                                      // 0x0088(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_ReconcilePartyInvites">();
	}
	static class UAuthenticationInitializationStep_ReconcilePartyInvites* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_ReconcilePartyInvites>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_ReconcilePartyInvites) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_ReconcilePartyInvites");
static_assert(sizeof(UAuthenticationInitializationStep_ReconcilePartyInvites) == 0x0000A0, "Wrong size on UAuthenticationInitializationStep_ReconcilePartyInvites");
static_assert(offsetof(UAuthenticationInitializationStep_ReconcilePartyInvites, ServicePartyPtr) == 0x000080, "Member 'UAuthenticationInitializationStep_ReconcilePartyInvites::ServicePartyPtr' has a wrong offset!");

// Class JP.AsyncTaskEffectStackChanged
// 0x0028 (0x0058 - 0x0030)
class UAsyncTaskEffectStackChanged final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnGameplayEffectStackChange;                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	class UAbilitySystemComponent*                ASC;                                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncTaskEffectStackChanged* ListenForGameplayEffectStackChange(class UAbilitySystemComponent* AbilitySystemComponent, const struct FGameplayTag& EffectGameplayTag);

	void EndTask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncTaskEffectStackChanged">();
	}
	static class UAsyncTaskEffectStackChanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncTaskEffectStackChanged>();
	}
};
static_assert(alignof(UAsyncTaskEffectStackChanged) == 0x000008, "Wrong alignment on UAsyncTaskEffectStackChanged");
static_assert(sizeof(UAsyncTaskEffectStackChanged) == 0x000058, "Wrong size on UAsyncTaskEffectStackChanged");
static_assert(offsetof(UAsyncTaskEffectStackChanged, OnGameplayEffectStackChange) == 0x000030, "Member 'UAsyncTaskEffectStackChanged::OnGameplayEffectStackChange' has a wrong offset!");
static_assert(offsetof(UAsyncTaskEffectStackChanged, ASC) == 0x000040, "Member 'UAsyncTaskEffectStackChanged::ASC' has a wrong offset!");

// Class JP.PlayerJoinHandShakePlayerStateComponent
// 0x0048 (0x00E8 - 0x00A0)
class UPlayerJoinHandShakePlayerStateComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ElapsedTimeWhenJoinedMatch;                        // 0x00D0(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayerStateJoinStatus                        JoinStatus;                                        // 0x00D4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsBlockedListInitialized;                          // 0x00D5(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D6[0x12];                                      // 0x00D6(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_ElapsedTimeWhenJoinedMatch();
	void OnRep_IsBlockedListInitialized();
	void OnRep_JoinStatus();

	bool GetIsBlockedListInitialized() const;
	EPlayerStateJoinStatus GetJoinStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerJoinHandShakePlayerStateComponent">();
	}
	static class UPlayerJoinHandShakePlayerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerJoinHandShakePlayerStateComponent>();
	}
};
static_assert(alignof(UPlayerJoinHandShakePlayerStateComponent) == 0x000008, "Wrong alignment on UPlayerJoinHandShakePlayerStateComponent");
static_assert(sizeof(UPlayerJoinHandShakePlayerStateComponent) == 0x0000E8, "Wrong size on UPlayerJoinHandShakePlayerStateComponent");
static_assert(offsetof(UPlayerJoinHandShakePlayerStateComponent, ElapsedTimeWhenJoinedMatch) == 0x0000D0, "Member 'UPlayerJoinHandShakePlayerStateComponent::ElapsedTimeWhenJoinedMatch' has a wrong offset!");
static_assert(offsetof(UPlayerJoinHandShakePlayerStateComponent, JoinStatus) == 0x0000D4, "Member 'UPlayerJoinHandShakePlayerStateComponent::JoinStatus' has a wrong offset!");
static_assert(offsetof(UPlayerJoinHandShakePlayerStateComponent, IsBlockedListInitialized) == 0x0000D5, "Member 'UPlayerJoinHandShakePlayerStateComponent::IsBlockedListInitialized' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_CalculatePlaytestRemainingDuration
// 0x0008 (0x0088 - 0x0080)
class UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration final : public UAuthenticationInitializationStepBase
{
public:
	class ULocalUserOnlineServicesGameInstanceSubsystem* LocalUserGIS;                                      // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_CalculatePlaytestRemainingDuration">();
	}
	static class UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration");
static_assert(sizeof(UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration) == 0x000088, "Wrong size on UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration");
static_assert(offsetof(UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration, LocalUserGIS) == 0x000080, "Member 'UAuthenticationInitializationStep_CalculatePlaytestRemainingDuration::LocalUserGIS' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_QualityOfService
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_QualityOfService final : public UAuthenticationInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_QualityOfService">();
	}
	static class UAuthenticationInitializationStep_QualityOfService* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_QualityOfService>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_QualityOfService) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_QualityOfService");
static_assert(sizeof(UAuthenticationInitializationStep_QualityOfService) == 0x000080, "Wrong size on UAuthenticationInitializationStep_QualityOfService");

// Class JP.AuthenticationInitializationStep_Achievements
// 0x0008 (0x0088 - 0x0080)
class UAuthenticationInitializationStep_Achievements final : public UAuthenticationInitializationStepBase
{
public:
	class UAchievementsGameInstanceSubsystem*     AchievementsGIS;                                   // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_Achievements">();
	}
	static class UAuthenticationInitializationStep_Achievements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_Achievements>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_Achievements) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_Achievements");
static_assert(sizeof(UAuthenticationInitializationStep_Achievements) == 0x000088, "Wrong size on UAuthenticationInitializationStep_Achievements");
static_assert(offsetof(UAuthenticationInitializationStep_Achievements, AchievementsGIS) == 0x000080, "Member 'UAuthenticationInitializationStep_Achievements::AchievementsGIS' has a wrong offset!");

// Class JP.MainMenuInitializationStepBase
// 0x0000 (0x0080 - 0x0080)
class UMainMenuInitializationStepBase : public UInitializationFlowStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStepBase">();
	}
	static class UMainMenuInitializationStepBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStepBase>();
	}
};
static_assert(alignof(UMainMenuInitializationStepBase) == 0x000008, "Wrong alignment on UMainMenuInitializationStepBase");
static_assert(sizeof(UMainMenuInitializationStepBase) == 0x000080, "Wrong size on UMainMenuInitializationStepBase");

// Class JP.MainMenuInitializationStep_ReadFriends
// 0x0018 (0x0098 - 0x0080)
class UMainMenuInitializationStep_ReadFriends final : public UMainMenuInitializationStepBase
{
public:
	class UFriendsOnlineServiceHandler*           FriendsPtr;                                        // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStep_ReadFriends">();
	}
	static class UMainMenuInitializationStep_ReadFriends* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStep_ReadFriends>();
	}
};
static_assert(alignof(UMainMenuInitializationStep_ReadFriends) == 0x000008, "Wrong alignment on UMainMenuInitializationStep_ReadFriends");
static_assert(sizeof(UMainMenuInitializationStep_ReadFriends) == 0x000098, "Wrong size on UMainMenuInitializationStep_ReadFriends");
static_assert(offsetof(UMainMenuInitializationStep_ReadFriends, FriendsPtr) == 0x000080, "Member 'UMainMenuInitializationStep_ReadFriends::FriendsPtr' has a wrong offset!");

// Class JP.AsyncAction_WaitForLoadingScreenToHide
// 0x0018 (0x0048 - 0x0030)
class UAsyncAction_WaitForLoadingScreenToHide final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnLoadingScreenHidden;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContext;                                      // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAsyncAction_WaitForLoadingScreenToHide* WaitForLoadingScreenToHide(class UObject* WorldContextObject);

	void OnLoadingScreenStatusChanged(bool LoadingScreenVisibilityChanged);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_WaitForLoadingScreenToHide">();
	}
	static class UAsyncAction_WaitForLoadingScreenToHide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_WaitForLoadingScreenToHide>();
	}
};
static_assert(alignof(UAsyncAction_WaitForLoadingScreenToHide) == 0x000008, "Wrong alignment on UAsyncAction_WaitForLoadingScreenToHide");
static_assert(sizeof(UAsyncAction_WaitForLoadingScreenToHide) == 0x000048, "Wrong size on UAsyncAction_WaitForLoadingScreenToHide");
static_assert(offsetof(UAsyncAction_WaitForLoadingScreenToHide, OnLoadingScreenHidden) == 0x000030, "Member 'UAsyncAction_WaitForLoadingScreenToHide::OnLoadingScreenHidden' has a wrong offset!");
static_assert(offsetof(UAsyncAction_WaitForLoadingScreenToHide, WorldContext) == 0x000040, "Member 'UAsyncAction_WaitForLoadingScreenToHide::WorldContext' has a wrong offset!");

// Class JP.AuthenticationInitialization_RecoverMatch
// 0x0148 (0x01C8 - 0x0080)
class UAuthenticationInitialization_RecoverMatch final : public UAuthenticationInitializationStepBase
{
public:
	uint8                                         Pad_80[0x138];                                     // 0x0080(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CachedDedicatedServerURL;                          // 0x01B8(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AbortReconnect();
	void Reconnect(const TDelegate<void(bool Success)> OnComplete);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitialization_RecoverMatch">();
	}
	static class UAuthenticationInitialization_RecoverMatch* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitialization_RecoverMatch>();
	}
};
static_assert(alignof(UAuthenticationInitialization_RecoverMatch) == 0x000008, "Wrong alignment on UAuthenticationInitialization_RecoverMatch");
static_assert(sizeof(UAuthenticationInitialization_RecoverMatch) == 0x0001C8, "Wrong size on UAuthenticationInitialization_RecoverMatch");
static_assert(offsetof(UAuthenticationInitialization_RecoverMatch, CachedDedicatedServerURL) == 0x0001B8, "Member 'UAuthenticationInitialization_RecoverMatch::CachedDedicatedServerURL' has a wrong offset!");

// Class JP.AsyncAction_WaitForCoordinatorActivationBase
// 0x0000 (0x0030 - 0x0030)
class UAsyncAction_WaitForCoordinatorActivationBase : public UBlueprintAsyncActionBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_WaitForCoordinatorActivationBase">();
	}
	static class UAsyncAction_WaitForCoordinatorActivationBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_WaitForCoordinatorActivationBase>();
	}
};
static_assert(alignof(UAsyncAction_WaitForCoordinatorActivationBase) == 0x000008, "Wrong alignment on UAsyncAction_WaitForCoordinatorActivationBase");
static_assert(sizeof(UAsyncAction_WaitForCoordinatorActivationBase) == 0x000030, "Wrong size on UAsyncAction_WaitForCoordinatorActivationBase");

// Class JP.AsyncAction_WaitForCoordinatorActivation_UIDataIsReady
// 0x0010 (0x0040 - 0x0030)
class UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady final : public UAsyncAction_WaitForCoordinatorActivationBase
{
public:
	FMulticastInlineDelegateProperty_             OnCoordinatorActivated;                            // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady* WaitForUIDataIsReadyCoordinator(class UObject* WorldContextObject);

	void HandleCoordinatorActivated(class UBaseCoordinator* Coordinator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_WaitForCoordinatorActivation_UIDataIsReady">();
	}
	static class UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady>();
	}
};
static_assert(alignof(UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady) == 0x000008, "Wrong alignment on UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady");
static_assert(sizeof(UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady) == 0x000040, "Wrong size on UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady");
static_assert(offsetof(UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady, OnCoordinatorActivated) == 0x000030, "Member 'UAsyncAction_WaitForCoordinatorActivation_UIDataIsReady::OnCoordinatorActivated' has a wrong offset!");

// Class JP.PlayerControllerJP
// 0x0050 (0x08A8 - 0x0858)
class APlayerControllerJP : public ACommonPlayerController
{
public:
	uint8                                         Pad_858[0x8];                                      // 0x0858(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerControllerJPExtensionComponent*  PlayerControllerJPExtensionComponent;              // 0x0860(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerControllerPartyIdChanged;                  // 0x0868(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_878[0x8];                                      // 0x0878(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULocalUserOnlineServicesGameInstanceSubsystem* LocalUserGIS;                                      // 0x0880(0x0008)(ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_888[0x20];                                     // 0x0888(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ExecuteCheat(const class FString& Command, class UObject* WorldContextObject);

	void BlueprintLog(const class FString& CategoryName, const class FString& NewMinVerbosityLevel);
	void BlueprintLogList();
	void BlueprintLogReset();
	void ChangeTeam(uint8 Team);
	void Client_ReceiveMessage(const class FString& Message, const EMessageType& Type);
	void Client_UpdateLoadout();
	void Client_UpdateOwnedHouses();
	void Client_UpdateOwnedNeighbors();
	void HandlePartyChanged();
	void OnOwnedHousesUpdated(const TArray<struct FOnlineStoreItemData>& OwnedItems, const TArray<struct FOnlineStoreItemData>& UnownedItems);
	void PlayerAcceptedToLeaveMatch();
	void ReadFriendsList();
	void Server_ChangeCharacterRole(const struct FCharacterRoleData& NewCharacterRole);
	void Server_ChangeHouseIdentifierVote(const struct FGameplayTag& HouseIdentifierVote);
	void Server_ChangeMatchConfiguration(const struct FMatchConfiguration& InNewConfig);
	void Server_ChangeOwnedHouses(const TArray<struct FGameplayTag>& OwnedHouses);
	void Server_ChangeTeam(uint8 TeamId);
	void Server_ExecuteCheat(const class FString& Command);
	void Server_PlayerAcceptedToLeaveMatch();
	void Server_SendMasterPlayerAccountId(const class FString& MasterPlayerAccountId);
	void Server_SendMessageToAll(const class FString& Message);
	void Server_SendTitlePlayerAccountId(const class FString& TitlePlayerAccountId);
	void Server_SetOwnedNeighbors(const TArray<struct FGameplayTag>& InOwnedNeighbors);
	void Server_SetPartyIdString(const class FString& InPartyIdString);
	void Server_SetUserOnlineID(const struct FUniqueNetIdRepl& InID);
	void StartMatchmaking(const class FString& QueueName);

	void Client_UpdateCachedCurrencies() const;
	bool HasJoinedMatchInProgress() const;
	void JoinSession(const class FString& SessionId) const;
	void PrintTeam() const;
	void UpdateSeasonPass(const class FString& SeasonPassName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerJP">();
	}
	static class APlayerControllerJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerJP>();
	}
};
static_assert(alignof(APlayerControllerJP) == 0x000008, "Wrong alignment on APlayerControllerJP");
static_assert(sizeof(APlayerControllerJP) == 0x0008A8, "Wrong size on APlayerControllerJP");
static_assert(offsetof(APlayerControllerJP, PlayerControllerJPExtensionComponent) == 0x000860, "Member 'APlayerControllerJP::PlayerControllerJPExtensionComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP, OnPlayerControllerPartyIdChanged) == 0x000868, "Member 'APlayerControllerJP::OnPlayerControllerPartyIdChanged' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP, LocalUserGIS) == 0x000880, "Member 'APlayerControllerJP::LocalUserGIS' has a wrong offset!");

// Class JP.PlayerControllerJP_Match
// 0x0198 (0x0A40 - 0x08A8)
class APlayerControllerJP_Match : public APlayerControllerJP
{
public:
	uint8                                         Pad_8A8[0x28];                                     // 0x08A8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class URoomControllerComponent*               RoomControllerComponent;                           // 0x08D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    KilledByNonPlayerCountMap;                         // 0x08D8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    KilledByPlayerCountMap;                            // 0x0928(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         DefaultFOV;                                        // 0x0978(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_97C[0x4];                                      // 0x097C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   HUDMatchWidgetClass;                               // 0x0980(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                CheatWindow;                                       // 0x09A8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     ItemSpawnLookup;                                   // 0x09B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     CheatSpawnedActorsDataTable;                       // 0x09C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FVector                                SpawnItemGroundOffset;                             // 0x09D0(0x0018)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJPHUDWidget_Match*                     HUDMatchWidgetInstance;                            // 0x09E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          UseObjectPoolingForHUDMatchWidget;                 // 0x09F0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9F1[0x3];                                      // 0x09F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UUserWidget>             CheatWindowInstance;                               // 0x09F4(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9FC[0x2C];                                     // 0x09FC(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHasInitializedPlayer;                             // 0x0A28(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A29[0x17];                                     // 0x0A29(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddMoney(float Amount);
	void AddPassiveIncome(float Amount);
	void AddPerfectness(float Amount);
	void AddWood(float Amount);
	void CheatRemoveSpecialAbilityCooldown();
	void CheatRespawnAsNeighbor(class FName NeighborID);
	void CheatSpawnActor(class FName DataTableRowName);
	void Client_AssignMatchRewards(const struct FMatchRewards& Rewards);
	void EndGame();
	void EndWarmup();
	struct FMatchRewards GetMatchRewards();
	void HandleHUDMatchWidgetAdded(class UJPHUDWidget_Match* HUDWidget);
	void K2_InitializePlayer();
	void KillPlayer();
	void LoginTwitch();
	void OnDefaultFOVChanged();
	void RestartMatch();
	void Server_CheatCancelSpecialAbilityCooldown();
	void Server_CheatSpawnActor(const class FName& DataTableRowName);
	void Server_RespawnAsNeighbor(const struct FGameplayTag& NewNeighbor);
	void Server_SpawnItem(const class FName& ItemName);
	void Server_TeleportToLocation(float X, float Y, float Z);
	void ServerNotifyLoadedHouses();
	void SpawnItem(class FName ItemName);
	void StartTwitchIntegration();
	void TeleportToLocation(float X, float Y, float Z);
	void ToggleCheatWindow();

	class UJPHUDWidget_Match* GetMatchHUDWidget() const;
	bool HasMatchRewards() const;
	bool IsHousesLoadedOnClient() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerJP_Match">();
	}
	static class APlayerControllerJP_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerJP_Match>();
	}
};
static_assert(alignof(APlayerControllerJP_Match) == 0x000008, "Wrong alignment on APlayerControllerJP_Match");
static_assert(sizeof(APlayerControllerJP_Match) == 0x000A40, "Wrong size on APlayerControllerJP_Match");
static_assert(offsetof(APlayerControllerJP_Match, RoomControllerComponent) == 0x0008D0, "Member 'APlayerControllerJP_Match::RoomControllerComponent' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, KilledByNonPlayerCountMap) == 0x0008D8, "Member 'APlayerControllerJP_Match::KilledByNonPlayerCountMap' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, KilledByPlayerCountMap) == 0x000928, "Member 'APlayerControllerJP_Match::KilledByPlayerCountMap' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, DefaultFOV) == 0x000978, "Member 'APlayerControllerJP_Match::DefaultFOV' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, HUDMatchWidgetClass) == 0x000980, "Member 'APlayerControllerJP_Match::HUDMatchWidgetClass' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, CheatWindow) == 0x0009A8, "Member 'APlayerControllerJP_Match::CheatWindow' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, ItemSpawnLookup) == 0x0009B0, "Member 'APlayerControllerJP_Match::ItemSpawnLookup' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, CheatSpawnedActorsDataTable) == 0x0009C0, "Member 'APlayerControllerJP_Match::CheatSpawnedActorsDataTable' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, SpawnItemGroundOffset) == 0x0009D0, "Member 'APlayerControllerJP_Match::SpawnItemGroundOffset' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, HUDMatchWidgetInstance) == 0x0009E8, "Member 'APlayerControllerJP_Match::HUDMatchWidgetInstance' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, UseObjectPoolingForHUDMatchWidget) == 0x0009F0, "Member 'APlayerControllerJP_Match::UseObjectPoolingForHUDMatchWidget' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, CheatWindowInstance) == 0x0009F4, "Member 'APlayerControllerJP_Match::CheatWindowInstance' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Match, bHasInitializedPlayer) == 0x000A28, "Member 'APlayerControllerJP_Match::bHasInitializedPlayer' has a wrong offset!");

// Class JP.PlayerControllerJP_Tutorial
// 0x0000 (0x0A40 - 0x0A40)
class APlayerControllerJP_Tutorial : public APlayerControllerJP_Match
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerJP_Tutorial">();
	}
	static class APlayerControllerJP_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerJP_Tutorial>();
	}
};
static_assert(alignof(APlayerControllerJP_Tutorial) == 0x000008, "Wrong alignment on APlayerControllerJP_Tutorial");
static_assert(sizeof(APlayerControllerJP_Tutorial) == 0x000A40, "Wrong size on APlayerControllerJP_Tutorial");

// Class JP.UpdateGameDataStepBase
// 0x0050 (0x0078 - 0x0028)
class UUpdateGameDataStepBase : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStepBase">();
	}
	static class UUpdateGameDataStepBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStepBase>();
	}
};
static_assert(alignof(UUpdateGameDataStepBase) == 0x000008, "Wrong alignment on UUpdateGameDataStepBase");
static_assert(sizeof(UUpdateGameDataStepBase) == 0x000078, "Wrong size on UUpdateGameDataStepBase");

// Class JP.LyraActivatableWidget
// 0x0008 (0x0438 - 0x0430)
class ULyraActivatableWidget : public UCommonActivatableWidget
{
public:
	ELyraWidgetInputMode                          InputConfig;                                       // 0x0430(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EMouseCaptureMode                             GameMouseCaptureMode;                              // 0x0431(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_432[0x6];                                      // 0x0432(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraActivatableWidget">();
	}
	static class ULyraActivatableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraActivatableWidget>();
	}
};
static_assert(alignof(ULyraActivatableWidget) == 0x000008, "Wrong alignment on ULyraActivatableWidget");
static_assert(sizeof(ULyraActivatableWidget) == 0x000438, "Wrong size on ULyraActivatableWidget");
static_assert(offsetof(ULyraActivatableWidget, InputConfig) == 0x000430, "Member 'ULyraActivatableWidget::InputConfig' has a wrong offset!");
static_assert(offsetof(ULyraActivatableWidget, GameMouseCaptureMode) == 0x000431, "Member 'ULyraActivatableWidget::GameMouseCaptureMode' has a wrong offset!");

// Class JP.JPHUDWidget_Match
// 0x0008 (0x0440 - 0x0438)
class UJPHUDWidget_Match : public ULyraActivatableWidget
{
public:
	class UOverlay*                               Overlay_RuntimeAddedWidgets;                       // 0x0438(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UJPHUDWidget_Match* GetMatchHUDWidget(class UObject* WorldContext);

	bool AddRuntimeChildWidget(class UUserWidget* Widget);
	bool AddRuntimeChildWidgetAt(class UUserWidget* Widget, int32 Index_0);
	bool RemoveRuntimeChildWidget(class UUserWidget* Widget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPHUDWidget_Match">();
	}
	static class UJPHUDWidget_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPHUDWidget_Match>();
	}
};
static_assert(alignof(UJPHUDWidget_Match) == 0x000008, "Wrong alignment on UJPHUDWidget_Match");
static_assert(sizeof(UJPHUDWidget_Match) == 0x000440, "Wrong size on UJPHUDWidget_Match");
static_assert(offsetof(UJPHUDWidget_Match, Overlay_RuntimeAddedWidgets) == 0x000438, "Member 'UJPHUDWidget_Match::Overlay_RuntimeAddedWidgets' has a wrong offset!");

// Class JP.WarmupComponent
// 0x0078 (0x0118 - 0x00A0)
class UWarmupComponent : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnWarmupEnded;                                     // 0x00A0(0x0010)(Edit, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x00B0(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           OnSecondsLeftTimerHandle;                          // 0x00B8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ServerEndTime;                                     // 0x00C0(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasEnded;                                         // 0x00C4(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TDelegate<void()>, float>                OnSecondsLeftDelegates;                            // 0x00C8(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void CheckTimeLeftDelegates();
	bool IsWarmupActive();
	void K2_WarmupEnded();
	void ListenOnWarmupSecondsLeft(float SecondsLeft, TDelegate<void()> Delegate);
	void OnExperienceLoaded(const class UExperienceDefinition* Definition);
	void OnRep_HasEnded();
	void OnTimerEnded();

	float GetEndTime() const;
	float GetTimeLeft() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WarmupComponent">();
	}
	static class UWarmupComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWarmupComponent>();
	}
};
static_assert(alignof(UWarmupComponent) == 0x000008, "Wrong alignment on UWarmupComponent");
static_assert(sizeof(UWarmupComponent) == 0x000118, "Wrong size on UWarmupComponent");
static_assert(offsetof(UWarmupComponent, OnWarmupEnded) == 0x0000A0, "Member 'UWarmupComponent::OnWarmupEnded' has a wrong offset!");
static_assert(offsetof(UWarmupComponent, Handle) == 0x0000B0, "Member 'UWarmupComponent::Handle' has a wrong offset!");
static_assert(offsetof(UWarmupComponent, OnSecondsLeftTimerHandle) == 0x0000B8, "Member 'UWarmupComponent::OnSecondsLeftTimerHandle' has a wrong offset!");
static_assert(offsetof(UWarmupComponent, ServerEndTime) == 0x0000C0, "Member 'UWarmupComponent::ServerEndTime' has a wrong offset!");
static_assert(offsetof(UWarmupComponent, bHasEnded) == 0x0000C4, "Member 'UWarmupComponent::bHasEnded' has a wrong offset!");
static_assert(offsetof(UWarmupComponent, OnSecondsLeftDelegates) == 0x0000C8, "Member 'UWarmupComponent::OnSecondsLeftDelegates' has a wrong offset!");

// Class JP.AsyncAction_AwaitPlayerStateJPLobbyReady
// 0x0038 (0x0068 - 0x0030)
class UAsyncAction_AwaitPlayerStateJPLobbyReady final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTimeout;                                         // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class APlayerStateJP_Lobby*                   PlayerState;                                       // 0x0050(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TimeoutDuration;                                   // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0xC];                                       // 0x005C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_AwaitPlayerStateJPLobbyReady* AwaitPlayerStateJPLobbyReady(class UObject* WorldContextObject, class APlayerStateJP_Lobby* PlayerState_0, float TimeoutDuration_0);

	void OnPlayerStateReady();
	void OnPlayerXPChanged(class APlayerStateJP* BroadcastPlayerState, const struct FPlayerXP& PlayerXP);
	void OnTimerExpired();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_AwaitPlayerStateJPLobbyReady">();
	}
	static class UAsyncAction_AwaitPlayerStateJPLobbyReady* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_AwaitPlayerStateJPLobbyReady>();
	}
};
static_assert(alignof(UAsyncAction_AwaitPlayerStateJPLobbyReady) == 0x000008, "Wrong alignment on UAsyncAction_AwaitPlayerStateJPLobbyReady");
static_assert(sizeof(UAsyncAction_AwaitPlayerStateJPLobbyReady) == 0x000068, "Wrong size on UAsyncAction_AwaitPlayerStateJPLobbyReady");
static_assert(offsetof(UAsyncAction_AwaitPlayerStateJPLobbyReady, OnReady) == 0x000030, "Member 'UAsyncAction_AwaitPlayerStateJPLobbyReady::OnReady' has a wrong offset!");
static_assert(offsetof(UAsyncAction_AwaitPlayerStateJPLobbyReady, OnTimeout) == 0x000040, "Member 'UAsyncAction_AwaitPlayerStateJPLobbyReady::OnTimeout' has a wrong offset!");
static_assert(offsetof(UAsyncAction_AwaitPlayerStateJPLobbyReady, PlayerState) == 0x000050, "Member 'UAsyncAction_AwaitPlayerStateJPLobbyReady::PlayerState' has a wrong offset!");
static_assert(offsetof(UAsyncAction_AwaitPlayerStateJPLobbyReady, TimeoutDuration) == 0x000058, "Member 'UAsyncAction_AwaitPlayerStateJPLobbyReady::TimeoutDuration' has a wrong offset!");

// Class JP.UpdateGameDataStep_TitleConfig
// 0x0010 (0x0088 - 0x0078)
class UUpdateGameDataStep_TitleConfig final : public UUpdateGameDataStepBase
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStep_TitleConfig">();
	}
	static class UUpdateGameDataStep_TitleConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStep_TitleConfig>();
	}
};
static_assert(alignof(UUpdateGameDataStep_TitleConfig) == 0x000008, "Wrong alignment on UUpdateGameDataStep_TitleConfig");
static_assert(sizeof(UUpdateGameDataStep_TitleConfig) == 0x000088, "Wrong size on UUpdateGameDataStep_TitleConfig");

// Class JP.SplineAudioEmitter
// 0x0018 (0x02A8 - 0x0290)
class ASplineAudioEmitter final : public AActor
{
public:
	class UAudioComponent*                        AudioComponent;                                    // 0x0290(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USplineComponent*                       SplineComponent;                                   // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsePlayerCameraHeight;                            // 0x02A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A1[0x3];                                      // 0x02A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActorTickInterval;                                 // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SplineAudioEmitter">();
	}
	static class ASplineAudioEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASplineAudioEmitter>();
	}
};
static_assert(alignof(ASplineAudioEmitter) == 0x000008, "Wrong alignment on ASplineAudioEmitter");
static_assert(sizeof(ASplineAudioEmitter) == 0x0002A8, "Wrong size on ASplineAudioEmitter");
static_assert(offsetof(ASplineAudioEmitter, AudioComponent) == 0x000290, "Member 'ASplineAudioEmitter::AudioComponent' has a wrong offset!");
static_assert(offsetof(ASplineAudioEmitter, SplineComponent) == 0x000298, "Member 'ASplineAudioEmitter::SplineComponent' has a wrong offset!");
static_assert(offsetof(ASplineAudioEmitter, bUsePlayerCameraHeight) == 0x0002A0, "Member 'ASplineAudioEmitter::bUsePlayerCameraHeight' has a wrong offset!");
static_assert(offsetof(ASplineAudioEmitter, ActorTickInterval) == 0x0002A4, "Member 'ASplineAudioEmitter::ActorTickInterval' has a wrong offset!");

// Class JP.AsyncAction_WaitForLocalPlayerStateSet
// 0x0010 (0x0040 - 0x0030)
class UAsyncAction_WaitForLocalPlayerStateSet final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnLocalPlayerStateSet;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_WaitForLocalPlayerStateSet* WaitForLocalPlayerStateSet(class UObject* WorldContextObject);

	void HandlePlayerStateSet(class UCommonLocalPlayer* CommonLocalPlayer, class APlayerState* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_WaitForLocalPlayerStateSet">();
	}
	static class UAsyncAction_WaitForLocalPlayerStateSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_WaitForLocalPlayerStateSet>();
	}
};
static_assert(alignof(UAsyncAction_WaitForLocalPlayerStateSet) == 0x000008, "Wrong alignment on UAsyncAction_WaitForLocalPlayerStateSet");
static_assert(sizeof(UAsyncAction_WaitForLocalPlayerStateSet) == 0x000040, "Wrong size on UAsyncAction_WaitForLocalPlayerStateSet");
static_assert(offsetof(UAsyncAction_WaitForLocalPlayerStateSet, OnLocalPlayerStateSet) == 0x000030, "Member 'UAsyncAction_WaitForLocalPlayerStateSet::OnLocalPlayerStateSet' has a wrong offset!");

// Class JP.UpdateGameDataStep_ActiveNeighbors
// 0x0010 (0x0088 - 0x0078)
class UUpdateGameDataStep_ActiveNeighbors final : public UUpdateGameDataStepBase
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FNeighborOnlineServicesContainer GetActiveNeighbors(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStep_ActiveNeighbors">();
	}
	static class UUpdateGameDataStep_ActiveNeighbors* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStep_ActiveNeighbors>();
	}
};
static_assert(alignof(UUpdateGameDataStep_ActiveNeighbors) == 0x000008, "Wrong alignment on UUpdateGameDataStep_ActiveNeighbors");
static_assert(sizeof(UUpdateGameDataStep_ActiveNeighbors) == 0x000088, "Wrong size on UUpdateGameDataStep_ActiveNeighbors");

// Class JP.LyraSettingValueScalarDynamic_SafeZoneValue
// 0x0000 (0x0210 - 0x0210)
class ULyraSettingValueScalarDynamic_SafeZoneValue final : public UGameSettingValueScalarDynamic
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueScalarDynamic_SafeZoneValue">();
	}
	static class ULyraSettingValueScalarDynamic_SafeZoneValue* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueScalarDynamic_SafeZoneValue>();
	}
};
static_assert(alignof(ULyraSettingValueScalarDynamic_SafeZoneValue) == 0x000008, "Wrong alignment on ULyraSettingValueScalarDynamic_SafeZoneValue");
static_assert(sizeof(ULyraSettingValueScalarDynamic_SafeZoneValue) == 0x000210, "Wrong size on ULyraSettingValueScalarDynamic_SafeZoneValue");

// Class JP.AsyncAction_StartMainMenuInitialization
// 0x0030 (0x0060 - 0x0030)
class UAsyncAction_StartMainMenuInitialization final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnSucceeded;                                       // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStepUpdated;                                     // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_StartMainMenuInitialization* StartMainMenuInitialization(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_StartMainMenuInitialization">();
	}
	static class UAsyncAction_StartMainMenuInitialization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_StartMainMenuInitialization>();
	}
};
static_assert(alignof(UAsyncAction_StartMainMenuInitialization) == 0x000008, "Wrong alignment on UAsyncAction_StartMainMenuInitialization");
static_assert(sizeof(UAsyncAction_StartMainMenuInitialization) == 0x000060, "Wrong size on UAsyncAction_StartMainMenuInitialization");
static_assert(offsetof(UAsyncAction_StartMainMenuInitialization, OnSucceeded) == 0x000030, "Member 'UAsyncAction_StartMainMenuInitialization::OnSucceeded' has a wrong offset!");
static_assert(offsetof(UAsyncAction_StartMainMenuInitialization, OnFailed) == 0x000040, "Member 'UAsyncAction_StartMainMenuInitialization::OnFailed' has a wrong offset!");
static_assert(offsetof(UAsyncAction_StartMainMenuInitialization, OnStepUpdated) == 0x000050, "Member 'UAsyncAction_StartMainMenuInitialization::OnStepUpdated' has a wrong offset!");

// Class JP.UpdateGameDataStep_ActiveHouses
// 0x0010 (0x0088 - 0x0078)
class UUpdateGameDataStep_ActiveHouses final : public UUpdateGameDataStepBase
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FHouseOnlineServicesContainer GetActiveHouses(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStep_ActiveHouses">();
	}
	static class UUpdateGameDataStep_ActiveHouses* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStep_ActiveHouses>();
	}
};
static_assert(alignof(UUpdateGameDataStep_ActiveHouses) == 0x000008, "Wrong alignment on UUpdateGameDataStep_ActiveHouses");
static_assert(sizeof(UUpdateGameDataStep_ActiveHouses) == 0x000088, "Wrong size on UUpdateGameDataStep_ActiveHouses");

// Class JP.AsyncAction_SetDefaultCharacterSettings
// 0x0070 (0x00A0 - 0x0030)
class UAsyncAction_SetDefaultCharacterSettings final : public UAsyncAction_OnlineServicesBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_SetDefaultCharacterSettings* SetDefaultCharacterSettings(class UObject* WorldContextObject, const struct FDefaultCharacterSettings& DefaultCharacterSettings);

	void HandleError(int32 ErrorCode, const class FString& ErrorMessage);
	void HandleSuccess();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_SetDefaultCharacterSettings">();
	}
	static class UAsyncAction_SetDefaultCharacterSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_SetDefaultCharacterSettings>();
	}
};
static_assert(alignof(UAsyncAction_SetDefaultCharacterSettings) == 0x000008, "Wrong alignment on UAsyncAction_SetDefaultCharacterSettings");
static_assert(sizeof(UAsyncAction_SetDefaultCharacterSettings) == 0x0000A0, "Wrong size on UAsyncAction_SetDefaultCharacterSettings");
static_assert(offsetof(UAsyncAction_SetDefaultCharacterSettings, OnSuccess) == 0x000030, "Member 'UAsyncAction_SetDefaultCharacterSettings::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAsyncAction_SetDefaultCharacterSettings, OnError) == 0x000040, "Member 'UAsyncAction_SetDefaultCharacterSettings::OnError' has a wrong offset!");

// Class JP.SessionSearchStatics
// 0x0000 (0x0028 - 0x0028)
class USessionSearchStatics final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class UCommonSession_SearchResult*> CloneSearchResults(const TArray<class UCommonSession_SearchResult*>& Values);
	static class FString DebugDumpToString(const class UCommonSession_SearchResult* Value, const bool IncludeResultValues, const bool IncludeSessionValues, const bool IncludeBaseSettings, const bool IncludeMemberSettings, const bool IncludeCustomSettings);
	static TArray<class UCommonSession_SearchResult*> RemoveEmpty(const TArray<class UCommonSession_SearchResult*>& Values);
	static TArray<class UCommonSession_SearchResult*> RemoveFull(const TArray<class UCommonSession_SearchResult*>& Values);
	static TArray<class UCommonSession_SearchResult*> RemoveVersionMismatch(const TArray<class UCommonSession_SearchResult*>& Values);
	static TArray<class UCommonSession_SearchResult*> SortSearchResults(const TArray<class UCommonSession_SearchResult*>& Values, const bool Ascending, const bool SortByPing, const bool SortByCreatedTimestamp, const bool SortByLobbyName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SessionSearchStatics">();
	}
	static class USessionSearchStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<USessionSearchStatics>();
	}
};
static_assert(alignof(USessionSearchStatics) == 0x000008, "Wrong alignment on USessionSearchStatics");
static_assert(sizeof(USessionSearchStatics) == 0x000028, "Wrong size on USessionSearchStatics");

// Class JP.UpdateGameDataStep_ActivePerks
// 0x0060 (0x00D8 - 0x0078)
class UUpdateGameDataStep_ActivePerks final : public UUpdateGameDataStepBase
{
public:
	uint8                                         Pad_78[0x60];                                      // 0x0078(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FPerkOnlineServicesContainer GetActivePerks(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStep_ActivePerks">();
	}
	static class UUpdateGameDataStep_ActivePerks* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStep_ActivePerks>();
	}
};
static_assert(alignof(UUpdateGameDataStep_ActivePerks) == 0x000008, "Wrong alignment on UUpdateGameDataStep_ActivePerks");
static_assert(sizeof(UUpdateGameDataStep_ActivePerks) == 0x0000D8, "Wrong size on UUpdateGameDataStep_ActivePerks");

// Class JP.GameModeJP_Lobby
// 0x0008 (0x03C8 - 0x03C0)
class AGameModeJP_Lobby final : public AGameModeJP
{
public:
	uint8                                         Pad_3C0[0x8];                                      // 0x03C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceTravel();
	void HandlePlayerBlockedListInitialized(class APlayerState* PlayerState);
	void HandlePlayerControllerPartyIdChanged(class APlayerControllerJP* PlayerControllerJP, const class FString& OldPartyId, const class FString& NewPartyId);
	void HandlePlayerHouseVoteChanged(class APlayerStateJP* PlayerState, const struct FGameplayTag& OldHouseIdentifier, const struct FGameplayTag& NewHouseIdentifier);
	void HandlePlayerTeamIdChanged(class APlayerStateJP* PlayerState, const uint8& TeamId);
	void HandleStartLobbyTravelCountdownBegun(float InDesiredTravelTimestamp);
	bool IsLobbyFull();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeJP_Lobby">();
	}
	static class AGameModeJP_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeJP_Lobby>();
	}
};
static_assert(alignof(AGameModeJP_Lobby) == 0x000008, "Wrong alignment on AGameModeJP_Lobby");
static_assert(sizeof(AGameModeJP_Lobby) == 0x0003C8, "Wrong size on AGameModeJP_Lobby");

// Class JP.UIDataIsReadyCoordinator
// 0x0010 (0x0050 - 0x0040)
class UUIDataIsReadyCoordinator final : public UBaseCoordinator
{
public:
	class UWorld*                                 World;                                             // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClientAuthenticationInitializationGameInstanceSubsystem* ClientAuthInitSubsystem;                           // 0x0048(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UIDataIsReadyCoordinator">();
	}
	static class UUIDataIsReadyCoordinator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUIDataIsReadyCoordinator>();
	}
};
static_assert(alignof(UUIDataIsReadyCoordinator) == 0x000008, "Wrong alignment on UUIDataIsReadyCoordinator");
static_assert(sizeof(UUIDataIsReadyCoordinator) == 0x000050, "Wrong size on UUIDataIsReadyCoordinator");
static_assert(offsetof(UUIDataIsReadyCoordinator, World) == 0x000040, "Member 'UUIDataIsReadyCoordinator::World' has a wrong offset!");
static_assert(offsetof(UUIDataIsReadyCoordinator, ClientAuthInitSubsystem) == 0x000048, "Member 'UUIDataIsReadyCoordinator::ClientAuthInitSubsystem' has a wrong offset!");

// Class JP.UpdateGameDataStep_ActiveRewards
// 0x00E0 (0x0158 - 0x0078)
class UUpdateGameDataStep_ActiveRewards final : public UUpdateGameDataStepBase
{
public:
	uint8                                         Pad_78[0xE0];                                      // 0x0078(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FRewardOnlineServicesContainer GetActiveRewards(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStep_ActiveRewards">();
	}
	static class UUpdateGameDataStep_ActiveRewards* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStep_ActiveRewards>();
	}
};
static_assert(alignof(UUpdateGameDataStep_ActiveRewards) == 0x000008, "Wrong alignment on UUpdateGameDataStep_ActiveRewards");
static_assert(sizeof(UUpdateGameDataStep_ActiveRewards) == 0x000158, "Wrong size on UUpdateGameDataStep_ActiveRewards");

// Class JP.UpdateGameDataStep_FirstTimeLoginRewards
// 0x0050 (0x00C8 - 0x0078)
class UUpdateGameDataStep_FirstTimeLoginRewards final : public UUpdateGameDataStepBase
{
public:
	uint8                                         Pad_78[0x50];                                      // 0x0078(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FFirstTimeLoginRewardsData GetFirstTimeLoginRewards(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStep_FirstTimeLoginRewards">();
	}
	static class UUpdateGameDataStep_FirstTimeLoginRewards* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStep_FirstTimeLoginRewards>();
	}
};
static_assert(alignof(UUpdateGameDataStep_FirstTimeLoginRewards) == 0x000008, "Wrong alignment on UUpdateGameDataStep_FirstTimeLoginRewards");
static_assert(sizeof(UUpdateGameDataStep_FirstTimeLoginRewards) == 0x0000C8, "Wrong size on UUpdateGameDataStep_FirstTimeLoginRewards");

// Class JP.GroundskeeperProxy
// 0x0008 (0x0298 - 0x0290)
class AGroundskeeperProxy final : public AActor
{
public:
	class AGroundsKeeper*                         CachedGroundskeeper;                               // 0x0290(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundskeeperProxy">();
	}
	static class AGroundskeeperProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGroundskeeperProxy>();
	}
};
static_assert(alignof(AGroundskeeperProxy) == 0x000008, "Wrong alignment on AGroundskeeperProxy");
static_assert(sizeof(AGroundskeeperProxy) == 0x000298, "Wrong size on AGroundskeeperProxy");
static_assert(offsetof(AGroundskeeperProxy, CachedGroundskeeper) == 0x000290, "Member 'AGroundskeeperProxy::CachedGroundskeeper' has a wrong offset!");

// Class JP.LoadAssetFromOnlineServicesIdBase
// 0x0028 (0x0058 - 0x0030)
class ULoadAssetFromOnlineServicesIdBase : public UBlueprintAsyncActionBase
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                LoadedObject;                                      // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadAssetFromOnlineServicesIdBase">();
	}
	static class ULoadAssetFromOnlineServicesIdBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadAssetFromOnlineServicesIdBase>();
	}
};
static_assert(alignof(ULoadAssetFromOnlineServicesIdBase) == 0x000008, "Wrong alignment on ULoadAssetFromOnlineServicesIdBase");
static_assert(sizeof(ULoadAssetFromOnlineServicesIdBase) == 0x000058, "Wrong size on ULoadAssetFromOnlineServicesIdBase");
static_assert(offsetof(ULoadAssetFromOnlineServicesIdBase, LoadedObject) == 0x000040, "Member 'ULoadAssetFromOnlineServicesIdBase::LoadedObject' has a wrong offset!");

// Class JP.UpdateGameDataStep_QuickPlay
// 0x0030 (0x00A8 - 0x0078)
class UUpdateGameDataStep_QuickPlay final : public UUpdateGameDataStepBase
{
public:
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FQuickPlaySettings GetQuickPlayConfiguration(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStep_QuickPlay">();
	}
	static class UUpdateGameDataStep_QuickPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStep_QuickPlay>();
	}
};
static_assert(alignof(UUpdateGameDataStep_QuickPlay) == 0x000008, "Wrong alignment on UUpdateGameDataStep_QuickPlay");
static_assert(sizeof(UUpdateGameDataStep_QuickPlay) == 0x0000A8, "Wrong size on UUpdateGameDataStep_QuickPlay");

// Class JP.SocialListWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class ISocialListWidgetInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialListWidgetInterface">();
	}
	static class ISocialListWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISocialListWidgetInterface>();
	}
};
static_assert(alignof(ISocialListWidgetInterface) == 0x000008, "Wrong alignment on ISocialListWidgetInterface");
static_assert(sizeof(ISocialListWidgetInterface) == 0x000028, "Wrong size on ISocialListWidgetInterface");

// Class JP.SeasonPassRewardWidget_CatalogItem
// 0x0030 (0x0310 - 0x02E0)
class USeasonPassRewardWidget_CatalogItem : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UCatalogItemRewardContentFactory> ContentFactory;                                    // 0x0300(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNamedSlot*                             RewardContent;                                     // 0x0308(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void HideLoadGuard();
	void ShowLoadGuard();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassRewardWidget_CatalogItem">();
	}
	static class USeasonPassRewardWidget_CatalogItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassRewardWidget_CatalogItem>();
	}
};
static_assert(alignof(USeasonPassRewardWidget_CatalogItem) == 0x000008, "Wrong alignment on USeasonPassRewardWidget_CatalogItem");
static_assert(sizeof(USeasonPassRewardWidget_CatalogItem) == 0x000310, "Wrong size on USeasonPassRewardWidget_CatalogItem");
static_assert(offsetof(USeasonPassRewardWidget_CatalogItem, ContentFactory) == 0x000300, "Member 'USeasonPassRewardWidget_CatalogItem::ContentFactory' has a wrong offset!");
static_assert(offsetof(USeasonPassRewardWidget_CatalogItem, RewardContent) == 0x000308, "Member 'USeasonPassRewardWidget_CatalogItem::RewardContent' has a wrong offset!");

// Class JP.AbilitySystemComponentJP
// 0x0020 (0x1328 - 0x1308)
class UAbilitySystemComponentJP final : public UAbilitySystemComponentIW
{
public:
	FMulticastInlineDelegateProperty_             K2_OnGameplayAbilityGranted;                       // 0x1308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             K2_OnGameplayAbilityRemoved;                       // 0x1318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CopyComponent(class UAbilitySystemComponent* Target);

	bool HasAnyAbilityByClass(const TSubclassOf<class UGameplayAbility> AbilityClass) const;
	bool HasAnyAbilityWithTag(const struct FGameplayTagContainer& Tags, const bool bExactMatch) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilitySystemComponentJP">();
	}
	static class UAbilitySystemComponentJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemComponentJP>();
	}
};
static_assert(alignof(UAbilitySystemComponentJP) == 0x000008, "Wrong alignment on UAbilitySystemComponentJP");
static_assert(sizeof(UAbilitySystemComponentJP) == 0x001328, "Wrong size on UAbilitySystemComponentJP");
static_assert(offsetof(UAbilitySystemComponentJP, K2_OnGameplayAbilityGranted) == 0x001308, "Member 'UAbilitySystemComponentJP::K2_OnGameplayAbilityGranted' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentJP, K2_OnGameplayAbilityRemoved) == 0x001318, "Member 'UAbilitySystemComponentJP::K2_OnGameplayAbilityRemoved' has a wrong offset!");

// Class JP.AbilitySystemGlobalsJP
// 0x0000 (0x02F8 - 0x02F8)
class UAbilitySystemGlobalsJP final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilitySystemGlobalsJP">();
	}
	static class UAbilitySystemGlobalsJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemGlobalsJP>();
	}
};
static_assert(alignof(UAbilitySystemGlobalsJP) == 0x000008, "Wrong alignment on UAbilitySystemGlobalsJP");
static_assert(sizeof(UAbilitySystemGlobalsJP) == 0x0002F8, "Wrong size on UAbilitySystemGlobalsJP");

// Class JP.AbilityTask_CreateChargeTimerWidget
// 0x0040 (0x00C0 - 0x0080)
class UAbilityTask_CreateChargeTimerWidget final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnTimerFinish;                                     // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInputRelease;                                    // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          TestAlreadyReleased;                               // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ChargeTime;                                        // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAbilityTask_WaitInputReleaseOrTimer*   ReleaseOrTimerTask;                                // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                WidgetToSpawn;                                     // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UUserWidget*                            SpawnedWidget;                                     // 0x00B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UAbilityTask_CreateChargeTimerWidget* CreateChargeTimerWidget(class UGameplayAbility* OwningAbility, TSubclassOf<class UUserWidget> Class_0, float Time, bool bTestAlreadyReleased);

	bool BeginSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, TSubclassOf<class UUserWidget> Class_0, class AActor** SpawnedActor);
	void FinishSpawningActor(class UGameplayAbility* OwningAbility, const struct FGameplayAbilityTargetDataHandle& TargetData, class AActor* SpawnedActor);
	void OnReleaseCallback(float ElapsedTime);
	void OnTimeFinish();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_CreateChargeTimerWidget">();
	}
	static class UAbilityTask_CreateChargeTimerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_CreateChargeTimerWidget>();
	}
};
static_assert(alignof(UAbilityTask_CreateChargeTimerWidget) == 0x000008, "Wrong alignment on UAbilityTask_CreateChargeTimerWidget");
static_assert(sizeof(UAbilityTask_CreateChargeTimerWidget) == 0x0000C0, "Wrong size on UAbilityTask_CreateChargeTimerWidget");
static_assert(offsetof(UAbilityTask_CreateChargeTimerWidget, OnTimerFinish) == 0x000080, "Member 'UAbilityTask_CreateChargeTimerWidget::OnTimerFinish' has a wrong offset!");
static_assert(offsetof(UAbilityTask_CreateChargeTimerWidget, OnInputRelease) == 0x000090, "Member 'UAbilityTask_CreateChargeTimerWidget::OnInputRelease' has a wrong offset!");
static_assert(offsetof(UAbilityTask_CreateChargeTimerWidget, TestAlreadyReleased) == 0x0000A0, "Member 'UAbilityTask_CreateChargeTimerWidget::TestAlreadyReleased' has a wrong offset!");
static_assert(offsetof(UAbilityTask_CreateChargeTimerWidget, ChargeTime) == 0x0000A4, "Member 'UAbilityTask_CreateChargeTimerWidget::ChargeTime' has a wrong offset!");
static_assert(offsetof(UAbilityTask_CreateChargeTimerWidget, ReleaseOrTimerTask) == 0x0000A8, "Member 'UAbilityTask_CreateChargeTimerWidget::ReleaseOrTimerTask' has a wrong offset!");
static_assert(offsetof(UAbilityTask_CreateChargeTimerWidget, WidgetToSpawn) == 0x0000B0, "Member 'UAbilityTask_CreateChargeTimerWidget::WidgetToSpawn' has a wrong offset!");
static_assert(offsetof(UAbilityTask_CreateChargeTimerWidget, SpawnedWidget) == 0x0000B8, "Member 'UAbilityTask_CreateChargeTimerWidget::SpawnedWidget' has a wrong offset!");

// Class JP.TargetingFilterTask_BlueprintLogic
// 0x0000 (0x0028 - 0x0028)
class UTargetingFilterTask_BlueprintLogic : public UTargetingFilterTask_BasicFilterTemplate
{
public:
	bool ShouldFilterTargetBP(const class AActor* HitActor, const class AActor* Source) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingFilterTask_BlueprintLogic">();
	}
	static class UTargetingFilterTask_BlueprintLogic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingFilterTask_BlueprintLogic>();
	}
};
static_assert(alignof(UTargetingFilterTask_BlueprintLogic) == 0x000008, "Wrong alignment on UTargetingFilterTask_BlueprintLogic");
static_assert(sizeof(UTargetingFilterTask_BlueprintLogic) == 0x000028, "Wrong size on UTargetingFilterTask_BlueprintLogic");

// Class JP.AchievementMetaData
// 0x0008 (0x0038 - 0x0030)
class UAchievementMetaData final : public UPrimaryDataAsset
{
public:
	class FName                                   AchievementAPIName;                                // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AchievementMetaData">();
	}
	static class UAchievementMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAchievementMetaData>();
	}
};
static_assert(alignof(UAchievementMetaData) == 0x000008, "Wrong alignment on UAchievementMetaData");
static_assert(sizeof(UAchievementMetaData) == 0x000038, "Wrong size on UAchievementMetaData");
static_assert(offsetof(UAchievementMetaData, AchievementAPIName) == 0x000030, "Member 'UAchievementMetaData::AchievementAPIName' has a wrong offset!");

// Class JP.SessionResultViewModel
// 0x0008 (0x0030 - 0x0028)
class USessionResultViewModel final : public UObject
{
public:
	class UCommonSession_SearchResult*            Original;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class USessionResultViewModel* CreateViewModel(class UCommonSession_SearchResult* Target);

	int32 GetAvailablePlayerSlots() const;
	bool GetIsReachable() const;
	int32 GetMaxPlayerSlots() const;
	int32 GetPingInMs() const;
	class FString GetSessionName() const;
	class FString GetSessionOwner() const;
	int32 GetTakenPlayerSlots() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SessionResultViewModel">();
	}
	static class USessionResultViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USessionResultViewModel>();
	}
};
static_assert(alignof(USessionResultViewModel) == 0x000008, "Wrong alignment on USessionResultViewModel");
static_assert(sizeof(USessionResultViewModel) == 0x000030, "Wrong size on USessionResultViewModel");
static_assert(offsetof(USessionResultViewModel, Original) == 0x000028, "Member 'USessionResultViewModel::Original' has a wrong offset!");

// Class JP.AmmoAttributeSetListener
// 0x0000 (0x0028 - 0x0028)
class IAmmoAttributeSetListener final : public IInterface
{
public:
	void OnFireworkBoxAmmoChanged(float Ammo);
	void OnFireworkBoxMaxAmmoChanged(float MaxAmmo);
	void OnOrangeCannonAmmoChanged(float Ammo);
	void OnOrangeCannonMaxAmmoChanged(float MaxAmmo);
	void OnSlingshotAmmoChanged(float Ammo);
	void OnSlingshotMaxAmmoChanged(float MaxAmmo);
	void OnWrenchAmmoChanged(float Ammo);
	void OnWrenchMaxAmmoChanged(float MaxAmmo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AmmoAttributeSetListener">();
	}
	static class IAmmoAttributeSetListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAmmoAttributeSetListener>();
	}
};
static_assert(alignof(IAmmoAttributeSetListener) == 0x000008, "Wrong alignment on IAmmoAttributeSetListener");
static_assert(sizeof(IAmmoAttributeSetListener) == 0x000028, "Wrong size on IAmmoAttributeSetListener");

// Class JP.AsyncAction_GetDefaultCharacterSettings
// 0x0020 (0x0050 - 0x0030)
class UAsyncAction_GetDefaultCharacterSettings final : public UAsyncAction_OnlineServicesBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnError;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_GetDefaultCharacterSettings* GetDefaultCharacterSettings(class UObject* WorldContextObject);

	void HandleError(int32 ErrorCode, const class FString& ErrorMessage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_GetDefaultCharacterSettings">();
	}
	static class UAsyncAction_GetDefaultCharacterSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_GetDefaultCharacterSettings>();
	}
};
static_assert(alignof(UAsyncAction_GetDefaultCharacterSettings) == 0x000008, "Wrong alignment on UAsyncAction_GetDefaultCharacterSettings");
static_assert(sizeof(UAsyncAction_GetDefaultCharacterSettings) == 0x000050, "Wrong size on UAsyncAction_GetDefaultCharacterSettings");
static_assert(offsetof(UAsyncAction_GetDefaultCharacterSettings, OnSuccess) == 0x000030, "Member 'UAsyncAction_GetDefaultCharacterSettings::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAsyncAction_GetDefaultCharacterSettings, OnError) == 0x000040, "Member 'UAsyncAction_GetDefaultCharacterSettings::OnError' has a wrong offset!");

// Class JP.ShopWidgetMain
// 0x0020 (0x0450 - 0x0430)
class UShopWidgetMain : public UCommonActivatableWidget
{
public:
	TArray<class UShopWidgetItemEntry*>           ShopItemWidgets;                                   // 0x0430(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UShopManagerComponent*                  ShopManagerComponent;                              // 0x0440(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetupControllerNavigation(const TArray<class UWrapBox*>& WrapBoxes);
	void ShopItemUpdated(const struct FShopItemViewModel& ShopItemViewModel, uint8 TeamId);
	void UpdateLastOpenedShopCategory(const EShopItemCategory LastOpenShopCategory);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopWidgetMain">();
	}
	static class UShopWidgetMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopWidgetMain>();
	}
};
static_assert(alignof(UShopWidgetMain) == 0x000008, "Wrong alignment on UShopWidgetMain");
static_assert(sizeof(UShopWidgetMain) == 0x000450, "Wrong size on UShopWidgetMain");
static_assert(offsetof(UShopWidgetMain, ShopItemWidgets) == 0x000430, "Member 'UShopWidgetMain::ShopItemWidgets' has a wrong offset!");
static_assert(offsetof(UShopWidgetMain, ShopManagerComponent) == 0x000440, "Member 'UShopWidgetMain::ShopManagerComponent' has a wrong offset!");

// Class JP.AsyncAction_ListenForOnJoinSessionComplete
// 0x0020 (0x0050 - 0x0030)
class UAsyncAction_ListenForOnJoinSessionComplete final : public UCancellableAsyncAction
{
public:
	FMulticastInlineDelegateProperty_             OnJoinSessionComplete;                             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObject*                                WorldContextObject;                                // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAsyncAction_ListenForOnJoinSessionComplete* ListenForOnJoinSessionComplete(class UObject* WorldContextObject_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_ListenForOnJoinSessionComplete">();
	}
	static class UAsyncAction_ListenForOnJoinSessionComplete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_ListenForOnJoinSessionComplete>();
	}
};
static_assert(alignof(UAsyncAction_ListenForOnJoinSessionComplete) == 0x000008, "Wrong alignment on UAsyncAction_ListenForOnJoinSessionComplete");
static_assert(sizeof(UAsyncAction_ListenForOnJoinSessionComplete) == 0x000050, "Wrong size on UAsyncAction_ListenForOnJoinSessionComplete");
static_assert(offsetof(UAsyncAction_ListenForOnJoinSessionComplete, OnJoinSessionComplete) == 0x000030, "Member 'UAsyncAction_ListenForOnJoinSessionComplete::OnJoinSessionComplete' has a wrong offset!");
static_assert(offsetof(UAsyncAction_ListenForOnJoinSessionComplete, WorldContextObject) == 0x000040, "Member 'UAsyncAction_ListenForOnJoinSessionComplete::WorldContextObject' has a wrong offset!");

// Class JP.ServiceMessage
// 0x0038 (0x0060 - 0x0028)
class UServiceMessage final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetBackgroundUrl();
	int32 GetId();
	class FString GetMessage();
	class FString GetMessageLink();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServiceMessage">();
	}
	static class UServiceMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServiceMessage>();
	}
};
static_assert(alignof(UServiceMessage) == 0x000008, "Wrong alignment on UServiceMessage");
static_assert(sizeof(UServiceMessage) == 0x000060, "Wrong size on UServiceMessage");

// Class JP.LyraAssetManager
// 0x0100 (0x05D0 - 0x04D0)
class ULyraAssetManager final : public UAssetManager
{
public:
	TSoftObjectPtr<class ULyraGameData>           LyraGameDataPath;                                  // 0x04D0(0x0028)(Config, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<TSubclassOf<class UObject>, class UPrimaryDataAsset*> GameDataMap;                                       // 0x04F8(0x0050)(Transient, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_548[0x10];                                     // 0x0548(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class UObject*>                          LoadedAssets;                                      // 0x0558(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x28];                                     // 0x05A8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAssetManager">();
	}
	static class ULyraAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAssetManager>();
	}
};
static_assert(alignof(ULyraAssetManager) == 0x000008, "Wrong alignment on ULyraAssetManager");
static_assert(sizeof(ULyraAssetManager) == 0x0005D0, "Wrong size on ULyraAssetManager");
static_assert(offsetof(ULyraAssetManager, LyraGameDataPath) == 0x0004D0, "Member 'ULyraAssetManager::LyraGameDataPath' has a wrong offset!");
static_assert(offsetof(ULyraAssetManager, GameDataMap) == 0x0004F8, "Member 'ULyraAssetManager::GameDataMap' has a wrong offset!");
static_assert(offsetof(ULyraAssetManager, LoadedAssets) == 0x000558, "Member 'ULyraAssetManager::LoadedAssets' has a wrong offset!");

// Class JP.AsyncAction_LoadPawnDefinitionFromOnlineServiceId
// 0x0010 (0x0068 - 0x0058)
class UAsyncAction_LoadPawnDefinitionFromOnlineServiceId final : public ULoadAssetFromOnlineServicesIdBase
{
public:
	FMulticastInlineDelegateProperty_             OnSuccess;                                         // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_LoadPawnDefinitionFromOnlineServiceId* LoadPawnDefinitionFromOnlineServiceId(class UObject* WorldContextObject, const class FString& OnlineServiceId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_LoadPawnDefinitionFromOnlineServiceId">();
	}
	static class UAsyncAction_LoadPawnDefinitionFromOnlineServiceId* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_LoadPawnDefinitionFromOnlineServiceId>();
	}
};
static_assert(alignof(UAsyncAction_LoadPawnDefinitionFromOnlineServiceId) == 0x000008, "Wrong alignment on UAsyncAction_LoadPawnDefinitionFromOnlineServiceId");
static_assert(sizeof(UAsyncAction_LoadPawnDefinitionFromOnlineServiceId) == 0x000068, "Wrong size on UAsyncAction_LoadPawnDefinitionFromOnlineServiceId");
static_assert(offsetof(UAsyncAction_LoadPawnDefinitionFromOnlineServiceId, OnSuccess) == 0x000058, "Member 'UAsyncAction_LoadPawnDefinitionFromOnlineServiceId::OnSuccess' has a wrong offset!");

// Class JP.AsyncAction_LoginWithInitialization
// 0x0030 (0x0060 - 0x0030)
class UAsyncAction_LoginWithInitialization final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnStepUpdate;                                      // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_LoginWithInitialization* LoginWithInitialization(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_LoginWithInitialization">();
	}
	static class UAsyncAction_LoginWithInitialization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_LoginWithInitialization>();
	}
};
static_assert(alignof(UAsyncAction_LoginWithInitialization) == 0x000008, "Wrong alignment on UAsyncAction_LoginWithInitialization");
static_assert(sizeof(UAsyncAction_LoginWithInitialization) == 0x000060, "Wrong size on UAsyncAction_LoginWithInitialization");
static_assert(offsetof(UAsyncAction_LoginWithInitialization, OnFinished) == 0x000030, "Member 'UAsyncAction_LoginWithInitialization::OnFinished' has a wrong offset!");
static_assert(offsetof(UAsyncAction_LoginWithInitialization, OnFailed) == 0x000040, "Member 'UAsyncAction_LoginWithInitialization::OnFailed' has a wrong offset!");
static_assert(offsetof(UAsyncAction_LoginWithInitialization, OnStepUpdate) == 0x000050, "Member 'UAsyncAction_LoginWithInitialization::OnStepUpdate' has a wrong offset!");

// Class JP.AsyncAction_WaitForLoggedIn
// 0x0010 (0x0040 - 0x0030)
class UAsyncAction_WaitForLoggedIn final : public UAsyncAction_OnlineServicesBase
{
public:
	FMulticastInlineDelegateProperty_             OnLoggedIn;                                        // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAsyncAction_WaitForLoggedIn* WaitForLoggedIn(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AsyncAction_WaitForLoggedIn">();
	}
	static class UAsyncAction_WaitForLoggedIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAsyncAction_WaitForLoggedIn>();
	}
};
static_assert(alignof(UAsyncAction_WaitForLoggedIn) == 0x000008, "Wrong alignment on UAsyncAction_WaitForLoggedIn");
static_assert(sizeof(UAsyncAction_WaitForLoggedIn) == 0x000040, "Wrong size on UAsyncAction_WaitForLoggedIn");
static_assert(offsetof(UAsyncAction_WaitForLoggedIn, OnLoggedIn) == 0x000030, "Member 'UAsyncAction_WaitForLoggedIn::OnLoggedIn' has a wrong offset!");

// Class JP.AuthenticationInitializationStep_Entitlements
// 0x0000 (0x0080 - 0x0080)
class UAuthenticationInitializationStep_Entitlements final : public UAuthenticationInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AuthenticationInitializationStep_Entitlements">();
	}
	static class UAuthenticationInitializationStep_Entitlements* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAuthenticationInitializationStep_Entitlements>();
	}
};
static_assert(alignof(UAuthenticationInitializationStep_Entitlements) == 0x000008, "Wrong alignment on UAuthenticationInitializationStep_Entitlements");
static_assert(sizeof(UAuthenticationInitializationStep_Entitlements) == 0x000080, "Wrong size on UAuthenticationInitializationStep_Entitlements");

// Class JP.BasePlayerStateWatcher
// 0x0030 (0x0058 - 0x0028)
class UBasePlayerStateWatcher : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class APlayerStateJP>>  TrackedPlayerStates;                               // 0x0048(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void HandlePlayerStateAddedToGameState(class APlayerState* AddedPlayerState);
	void HandlePlayerStateRemovedFromGameState(class APlayerState* RemovedPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BasePlayerStateWatcher">();
	}
	static class UBasePlayerStateWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBasePlayerStateWatcher>();
	}
};
static_assert(alignof(UBasePlayerStateWatcher) == 0x000008, "Wrong alignment on UBasePlayerStateWatcher");
static_assert(sizeof(UBasePlayerStateWatcher) == 0x000058, "Wrong size on UBasePlayerStateWatcher");
static_assert(offsetof(UBasePlayerStateWatcher, TrackedPlayerStates) == 0x000048, "Member 'UBasePlayerStateWatcher::TrackedPlayerStates' has a wrong offset!");

// Class JP.BattlePassConfigurationAsset
// 0x0058 (0x0088 - 0x0030)
class UBattlePassConfigurationAsset final : public UDataAsset
{
public:
	int32                                         ExpectedBattlePassLevels;                          // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExpectRewardsOnAllLevels;                          // 0x0034(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ExpectNeverBothFreeAndPremiumRewardsOnSameLevel;   // 0x0035(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   ExpectedRewardTagParents;                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FBattlePassConfiguration               Configuration;                                     // 0x0048(0x0040)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static const class UBattlePassConfigurationAsset* GetCurrentBattlePassConfiguration();

	TArray<struct FBattlePassLevelRewards> GetAllBattlePassRewardsBetweenLevels(int32 FromBattlePassLevelInclusive, int32 ToBattlePassLevelInclusive);
	TArray<struct FGameplayTag> GetAllBattlePassRewardsBetweenLevelsFlattened(int32 FromBattlePassLevelInclusive, int32 ToBattlePassLevelInclusive, bool IncludeFreeRewards, bool IncludePremiumRewards);
	struct FBattlePassLevelRewards TryGetBattlePassRewardsAtLevel(bool* Found, int32 BattlePassLevel);

	int32 ClampBattlePassIndexToValidRange(int32 BattlePassIndex, bool* OutValidRange) const;
	int32 ClampBattlePassLevelToValidRange(int32 BattlePassLevel, bool* OutValidRange) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassConfigurationAsset">();
	}
	static class UBattlePassConfigurationAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassConfigurationAsset>();
	}
};
static_assert(alignof(UBattlePassConfigurationAsset) == 0x000008, "Wrong alignment on UBattlePassConfigurationAsset");
static_assert(sizeof(UBattlePassConfigurationAsset) == 0x000088, "Wrong size on UBattlePassConfigurationAsset");
static_assert(offsetof(UBattlePassConfigurationAsset, ExpectedBattlePassLevels) == 0x000030, "Member 'UBattlePassConfigurationAsset::ExpectedBattlePassLevels' has a wrong offset!");
static_assert(offsetof(UBattlePassConfigurationAsset, ExpectRewardsOnAllLevels) == 0x000034, "Member 'UBattlePassConfigurationAsset::ExpectRewardsOnAllLevels' has a wrong offset!");
static_assert(offsetof(UBattlePassConfigurationAsset, ExpectNeverBothFreeAndPremiumRewardsOnSameLevel) == 0x000035, "Member 'UBattlePassConfigurationAsset::ExpectNeverBothFreeAndPremiumRewardsOnSameLevel' has a wrong offset!");
static_assert(offsetof(UBattlePassConfigurationAsset, ExpectedRewardTagParents) == 0x000038, "Member 'UBattlePassConfigurationAsset::ExpectedRewardTagParents' has a wrong offset!");
static_assert(offsetof(UBattlePassConfigurationAsset, Configuration) == 0x000048, "Member 'UBattlePassConfigurationAsset::Configuration' has a wrong offset!");

// Class JP.PlayerStartQueryWorldSubsystem
// 0x0028 (0x0058 - 0x0030)
class UPlayerStartQueryWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x28];                                      // 0x0030(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FPlayerStartQueryResult Query(const struct FPlayerStartQueryRequest& Request);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartQueryWorldSubsystem">();
	}
	static class UPlayerStartQueryWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStartQueryWorldSubsystem>();
	}
};
static_assert(alignof(UPlayerStartQueryWorldSubsystem) == 0x000008, "Wrong alignment on UPlayerStartQueryWorldSubsystem");
static_assert(sizeof(UPlayerStartQueryWorldSubsystem) == 0x000058, "Wrong size on UPlayerStartQueryWorldSubsystem");

// Class JP.PlayerRewardDataAsset
// 0x0050 (0x0088 - 0x0038)
class UPlayerRewardDataAsset : public UTagLookupPrimaryDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class URarity*                                Rarity;                                            // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static void Sort(TArray<class UPlayerRewardDataAsset*>& PlayerRewardDataAssets);
	static bool TryGetPlayerRewardDataAsset(const struct FGameplayTag& PlayerRewardDataAssetID, TSoftObjectPtr<class UPlayerRewardDataAsset>* OutSoftPlayerRewardDataAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerRewardDataAsset">();
	}
	static class UPlayerRewardDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerRewardDataAsset>();
	}
};
static_assert(alignof(UPlayerRewardDataAsset) == 0x000008, "Wrong alignment on UPlayerRewardDataAsset");
static_assert(sizeof(UPlayerRewardDataAsset) == 0x000088, "Wrong size on UPlayerRewardDataAsset");
static_assert(offsetof(UPlayerRewardDataAsset, Name_0) == 0x000038, "Member 'UPlayerRewardDataAsset::Name_0' has a wrong offset!");
static_assert(offsetof(UPlayerRewardDataAsset, Description) == 0x000048, "Member 'UPlayerRewardDataAsset::Description' has a wrong offset!");
static_assert(offsetof(UPlayerRewardDataAsset, Rarity) == 0x000058, "Member 'UPlayerRewardDataAsset::Rarity' has a wrong offset!");
static_assert(offsetof(UPlayerRewardDataAsset, Icon) == 0x000060, "Member 'UPlayerRewardDataAsset::Icon' has a wrong offset!");

// Class JP.SubObjectiveDefinition
// 0x0028 (0x0050 - 0x0028)
class USubObjectiveDefinition : public UObject
{
public:
	struct FGameplayTag                           ObjectiveTag;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ASubObjective>              SubObjectiveActor;                                 // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPreconditionBase*>              Preconditions;                                     // 0x0038(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bIsOptional;                                       // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubObjectiveDefinition">();
	}
	static class USubObjectiveDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<USubObjectiveDefinition>();
	}
};
static_assert(alignof(USubObjectiveDefinition) == 0x000008, "Wrong alignment on USubObjectiveDefinition");
static_assert(sizeof(USubObjectiveDefinition) == 0x000050, "Wrong size on USubObjectiveDefinition");
static_assert(offsetof(USubObjectiveDefinition, ObjectiveTag) == 0x000028, "Member 'USubObjectiveDefinition::ObjectiveTag' has a wrong offset!");
static_assert(offsetof(USubObjectiveDefinition, SubObjectiveActor) == 0x000030, "Member 'USubObjectiveDefinition::SubObjectiveActor' has a wrong offset!");
static_assert(offsetof(USubObjectiveDefinition, Preconditions) == 0x000038, "Member 'USubObjectiveDefinition::Preconditions' has a wrong offset!");
static_assert(offsetof(USubObjectiveDefinition, bIsOptional) == 0x000048, "Member 'USubObjectiveDefinition::bIsOptional' has a wrong offset!");

// Class JP.BattlePassCurrencyRewardDefinition
// 0x0030 (0x00B8 - 0x0088)
class UBattlePassCurrencyRewardDefinition final : public UPlayerRewardDataAsset
{
public:
	TSoftObjectPtr<class UOnlineCurrency>         Currency;                                          // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Amount;                                            // 0x00B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool TryGetBattlePassCurrencyRewardDefinition(const struct FGameplayTag& BattlePassRewardCurrencyID, TSoftObjectPtr<class UBattlePassCurrencyRewardDefinition>* OutSoftBattlePassCurrencyRewardDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassCurrencyRewardDefinition">();
	}
	static class UBattlePassCurrencyRewardDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassCurrencyRewardDefinition>();
	}
};
static_assert(alignof(UBattlePassCurrencyRewardDefinition) == 0x000008, "Wrong alignment on UBattlePassCurrencyRewardDefinition");
static_assert(sizeof(UBattlePassCurrencyRewardDefinition) == 0x0000B8, "Wrong size on UBattlePassCurrencyRewardDefinition");
static_assert(offsetof(UBattlePassCurrencyRewardDefinition, Currency) == 0x000088, "Member 'UBattlePassCurrencyRewardDefinition::Currency' has a wrong offset!");
static_assert(offsetof(UBattlePassCurrencyRewardDefinition, Amount) == 0x0000B0, "Member 'UBattlePassCurrencyRewardDefinition::Amount' has a wrong offset!");

// Class JP.BattlePassItemsRequest
// 0x0118 (0x0140 - 0x0028)
class UBattlePassItemsRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x110];                                     // 0x0028(0x0110)(Fixing Size After Last Property [ Dumper-7 ])
	class USharedEconomyOnlineServiceHandler*     EconomyHandler;                                    // 0x0138(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassItemsRequest">();
	}
	static class UBattlePassItemsRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassItemsRequest>();
	}
};
static_assert(alignof(UBattlePassItemsRequest) == 0x000008, "Wrong alignment on UBattlePassItemsRequest");
static_assert(sizeof(UBattlePassItemsRequest) == 0x000140, "Wrong size on UBattlePassItemsRequest");
static_assert(offsetof(UBattlePassItemsRequest, EconomyHandler) == 0x000138, "Member 'UBattlePassItemsRequest::EconomyHandler' has a wrong offset!");

// Class JP.BattlePassMetaData
// 0x0038 (0x0070 - 0x0038)
class UBattlePassMetaData final : public UTagLookupPrimaryDataAsset
{
public:
	class FText                                   DisplayName;                                       // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              DisplayIcon;                                       // 0x0048(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool TryGetBattlePassMetaData(const struct FGameplayTag& BattlePassID, TSoftObjectPtr<class UBattlePassMetaData>* OutSoftBattlePassMetaData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BattlePassMetaData">();
	}
	static class UBattlePassMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBattlePassMetaData>();
	}
};
static_assert(alignof(UBattlePassMetaData) == 0x000008, "Wrong alignment on UBattlePassMetaData");
static_assert(sizeof(UBattlePassMetaData) == 0x000070, "Wrong size on UBattlePassMetaData");
static_assert(offsetof(UBattlePassMetaData, DisplayName) == 0x000038, "Member 'UBattlePassMetaData::DisplayName' has a wrong offset!");
static_assert(offsetof(UBattlePassMetaData, DisplayIcon) == 0x000048, "Member 'UBattlePassMetaData::DisplayIcon' has a wrong offset!");

// Class JP.PlayerStateJP
// 0x0358 (0x06A0 - 0x0348)
class APlayerStateJP : public AModularPlayerState
{
public:
	uint8                                         Pad_348[0x18];                                     // 0x0348(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerStateJPExtensionComponent*       PlayerStateJPExtensionComponent;                   // 0x0360(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerStateJP_ReplicationMonitorComponent* ReplicationMonitorComponent;                       // 0x0368(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerLoadoutChanged;                            // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnMasterPlayerAccountIdChanged;                    // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTitlePlayerAccountIdChanged;                     // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUserAvatarChanged;                               // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamIdChanged;                                   // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamChanged;                                     // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamHousePoolChanged;                            // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnKillsChanged;                                    // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnDeathsChanged;                                   // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnAssistsChanged;                                  // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsInPartyChanged;                                // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHouseIdentifierVoteChanged;                      // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnOwnedHousesChanged;                              // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNameChanged;                                     // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCharacterRoleChanged;                            // 0x0450(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerXPChanged;                                 // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEndOfMatchDataChanged;                           // 0x0470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnNeighborIdentifierChanged;                       // 0x0480(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_490[0x18];                                     // 0x0490(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FUniqueNetIdRepl                       OnlineUserID;                                      // 0x04A8(0x0030)(Net, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 EOS_ID;                                            // 0x04D8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 MasterPlayerAccountId;                             // 0x04E8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 TitlePlayerAccountId;                              // 0x04F8(0x0010)(Net, ZeroConstructor, RepNotify, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TeamId;                                            // 0x0508(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_509[0x7];                                      // 0x0509(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCharacterRoleData                     CharacterRole;                                     // 0x0510(0x0060)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           SelectedNeighborIdentifier;                        // 0x0570(0x0008)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Kills;                                             // 0x0578(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Deaths;                                            // 0x057C(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Assists;                                           // 0x0580(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           HouseIdentifierVote;                               // 0x0584(0x0008)(Net, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58C[0x4];                                      // 0x058C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayTag>                   OwnedHouses;                                       // 0x0590(0x0010)(Net, ZeroConstructor, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FPlayerXP                              PlayerXP;                                          // 0x05A0(0x0020)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	struct FEndOfMatchPlayerData                  EndOfMatchData;                                    // 0x05C0(0x0001)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C1[0x7];                                      // 0x05C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlayerLoadout                         Loadout;                                           // 0x05C8(0x0028)(Net, RepNotify, Protected, NativeAccessSpecifierProtected)
	bool                                          IsInParty;                                         // 0x05F0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ShowTooltips;                                      // 0x05F1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5F2[0x6];                                      // 0x05F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<struct FGameplayTag>                     CompletedTooltips;                                 // 0x05F8(0x0050)(BlueprintVisible, Protected, NativeAccessSpecifierProtected)
	class UChatReplicationComponent*              ChatComponent;                                     // 0x0648(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayerAbandonedMatch;                             // 0x0650(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_651[0x17];                                     // 0x0651(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              UserAvatar;                                        // 0x0668(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_690[0x10];                                     // 0x0690(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadcastOnTeamChanged();
	void CompletedTooltip(const struct FGameplayTag& TooltipTag);
	struct FTooltipTagCollection GetCompletedTooltips();
	TSoftObjectPtr<class UNeighborSkinDefinition> GetCurrentlySelectedSkinDefinition();
	struct FGameplayTag GetCurrentlySelectedSkinIdentifier();
	struct FGameplayTag GetCurrentlySelectedUniqueItemSkinIdentifier();
	struct FNeighborLoadout GetSelectedNeighborLoadout();
	bool GetShowTooltips();
	TSoftObjectPtr<class UItemSkinDefinition> GetUniqueItemSkinDefinitionForNeighbor(const struct FGameplayTag& NeighborIdentifier);
	void HandleUserAvatarLoaded(bool bInWasSuccessful, TSoftObjectPtr<class UTexture> InResultTexture);
	void IncrementAssists();
	void IncrementDeaths();
	void IncrementKills();
	void OnRep_Assists();
	void OnRep_CharacterRole();
	void OnRep_Deaths();
	void OnRep_EndOfMatchData();
	void OnRep_EOS_ID();
	void OnRep_HouseIdentifierVote(const struct FGameplayTag& OldValue);
	void OnRep_IsInParty();
	void OnRep_Kills();
	void OnRep_Loadout();
	void OnRep_MasterPlayerAccountId();
	void OnRep_NeighborIdentifier();
	void OnRep_OnlineUserID();
	void OnRep_OwnedHouses();
	void OnRep_PlayerAbandonedMatch();
	void OnRep_PlayerXP();
	void OnRep_TeamID();
	void OnRep_TitlePlayerAccountId();
	void Server_SetShowTooltips(bool Show);
	void SetAssists(const int32 NewAssists);
	void SetDeaths(const int32 NewDeaths);
	void SetKills(const int32 NewKills);
	bool TryGetItemSkinDefinition(const struct FGameplayTag& ItemId, const struct FGameplayTag& NeighborIdentifier, TSoftObjectPtr<class UItemSkinDefinition>* OutSkinDefinition);
	bool TryGetItemSkinDefinitionForCurrentNeighbor(const struct FGameplayTag& ItemId, TSoftObjectPtr<class UItemSkinDefinition>* OutSkinDefinition);

	int32 GetAssists() const;
	struct FCharacterRoleData GetCharacterRole() const;
	int32 GetCharacterXP(const struct FGameplayTag& CharacterTag) const;
	int32 GetDeaths() const;
	struct FEndOfMatchPlayerData GetEndOfMatchData() const;
	struct FGameplayTag GetHouseIdentifierVote() const;
	bool GetIsInParty() const;
	int32 GetKills() const;
	const struct FPlayerLoadout GetLoadout() const;
	class FString GetMasterPlayerAccountId() const;
	TSoftObjectPtr<class UNeighborDefinition> GetNeighborDefinition() const;
	struct FGameplayTag GetNeighborIdentifier() const;
	TArray<struct FGameplayTag> GetOwnedHouses() const;
	class UPerkManagerComponent* GetPerkManagerComponent() const;
	class FString GetPlayerDisplayName() const;
	int32 GetProfileXP() const;
	TSoftObjectPtr<class UNeighborSkinDefinition> GetSkinDefinitionForNeighbor(const struct FGameplayTag& NeighborIdentifier) const;
	const struct FTeam GetTeam() const;
	uint8 GetTeamID() const;
	class FString GetTitlePlayerAccountId() const;
	TSoftObjectPtr<class UTexture2D> GetUserAvatar() const;
	bool HasLoadout() const;
	bool IsLocalPlayerState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateJP">();
	}
	static class APlayerStateJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStateJP>();
	}
};
static_assert(alignof(APlayerStateJP) == 0x000008, "Wrong alignment on APlayerStateJP");
static_assert(sizeof(APlayerStateJP) == 0x0006A0, "Wrong size on APlayerStateJP");
static_assert(offsetof(APlayerStateJP, PlayerStateJPExtensionComponent) == 0x000360, "Member 'APlayerStateJP::PlayerStateJPExtensionComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, ReplicationMonitorComponent) == 0x000368, "Member 'APlayerStateJP::ReplicationMonitorComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnPlayerLoadoutChanged) == 0x000370, "Member 'APlayerStateJP::OnPlayerLoadoutChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnMasterPlayerAccountIdChanged) == 0x000380, "Member 'APlayerStateJP::OnMasterPlayerAccountIdChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnTitlePlayerAccountIdChanged) == 0x000390, "Member 'APlayerStateJP::OnTitlePlayerAccountIdChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnUserAvatarChanged) == 0x0003A0, "Member 'APlayerStateJP::OnUserAvatarChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnTeamIdChanged) == 0x0003B0, "Member 'APlayerStateJP::OnTeamIdChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnTeamChanged) == 0x0003C0, "Member 'APlayerStateJP::OnTeamChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnTeamHousePoolChanged) == 0x0003D0, "Member 'APlayerStateJP::OnTeamHousePoolChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnKillsChanged) == 0x0003E0, "Member 'APlayerStateJP::OnKillsChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnDeathsChanged) == 0x0003F0, "Member 'APlayerStateJP::OnDeathsChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnAssistsChanged) == 0x000400, "Member 'APlayerStateJP::OnAssistsChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnIsInPartyChanged) == 0x000410, "Member 'APlayerStateJP::OnIsInPartyChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnHouseIdentifierVoteChanged) == 0x000420, "Member 'APlayerStateJP::OnHouseIdentifierVoteChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnOwnedHousesChanged) == 0x000430, "Member 'APlayerStateJP::OnOwnedHousesChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnNameChanged) == 0x000440, "Member 'APlayerStateJP::OnNameChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnCharacterRoleChanged) == 0x000450, "Member 'APlayerStateJP::OnCharacterRoleChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnPlayerXPChanged) == 0x000460, "Member 'APlayerStateJP::OnPlayerXPChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnEndOfMatchDataChanged) == 0x000470, "Member 'APlayerStateJP::OnEndOfMatchDataChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnNeighborIdentifierChanged) == 0x000480, "Member 'APlayerStateJP::OnNeighborIdentifierChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OnlineUserID) == 0x0004A8, "Member 'APlayerStateJP::OnlineUserID' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, EOS_ID) == 0x0004D8, "Member 'APlayerStateJP::EOS_ID' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, MasterPlayerAccountId) == 0x0004E8, "Member 'APlayerStateJP::MasterPlayerAccountId' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, TitlePlayerAccountId) == 0x0004F8, "Member 'APlayerStateJP::TitlePlayerAccountId' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, TeamId) == 0x000508, "Member 'APlayerStateJP::TeamId' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, CharacterRole) == 0x000510, "Member 'APlayerStateJP::CharacterRole' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, SelectedNeighborIdentifier) == 0x000570, "Member 'APlayerStateJP::SelectedNeighborIdentifier' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, Kills) == 0x000578, "Member 'APlayerStateJP::Kills' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, Deaths) == 0x00057C, "Member 'APlayerStateJP::Deaths' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, Assists) == 0x000580, "Member 'APlayerStateJP::Assists' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, HouseIdentifierVote) == 0x000584, "Member 'APlayerStateJP::HouseIdentifierVote' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, OwnedHouses) == 0x000590, "Member 'APlayerStateJP::OwnedHouses' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, PlayerXP) == 0x0005A0, "Member 'APlayerStateJP::PlayerXP' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, EndOfMatchData) == 0x0005C0, "Member 'APlayerStateJP::EndOfMatchData' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, Loadout) == 0x0005C8, "Member 'APlayerStateJP::Loadout' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, IsInParty) == 0x0005F0, "Member 'APlayerStateJP::IsInParty' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, ShowTooltips) == 0x0005F1, "Member 'APlayerStateJP::ShowTooltips' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, CompletedTooltips) == 0x0005F8, "Member 'APlayerStateJP::CompletedTooltips' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, ChatComponent) == 0x000648, "Member 'APlayerStateJP::ChatComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, bPlayerAbandonedMatch) == 0x000650, "Member 'APlayerStateJP::bPlayerAbandonedMatch' has a wrong offset!");
static_assert(offsetof(APlayerStateJP, UserAvatar) == 0x000668, "Member 'APlayerStateJP::UserAvatar' has a wrong offset!");

// Class JP.PlayerStateJP_Match
// 0x01B8 (0x0858 - 0x06A0)
class APlayerStateJP_Match : public APlayerStateJP
{
public:
	FMulticastInlineDelegateProperty_             OnDeathRespawnTimeWindowChanged;                   // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UPlayerEconomyComponent*                PlayerEconomyComponent;                            // 0x06B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPlayerMatchRecord*                     PlayerMatchRecord;                                 // 0x06B8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectiveManagerComponent*             ObjectiveManagerComponent;                         // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FItemInstanceArray                     BackupInventoryArray;                              // 0x06C8(0x0140)(ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_808[0x10];                                     // 0x0808(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerJoinHandShakePlayerStateComponent* PlayerJoinHandShakeComponent;                      // 0x0818(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UEconomyDefinition*                     AssistEconomy;                                     // 0x0820(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDeathRespawnTimeWindow                DeathRespawnTimeWindow;                            // 0x0828(0x0010)(Net, RepNotify, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_838[0x20];                                     // 0x0838(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_DeathRespawnTimeWindow();
	void SetDeathRespawnTimeWindow(const struct FDeathRespawnTimeWindow& NewDeathRespawnTimeWindow);

	struct FDeathRespawnTimeWindow GetDeathRespawnTimeWindow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateJP_Match">();
	}
	static class APlayerStateJP_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStateJP_Match>();
	}
};
static_assert(alignof(APlayerStateJP_Match) == 0x000008, "Wrong alignment on APlayerStateJP_Match");
static_assert(sizeof(APlayerStateJP_Match) == 0x000858, "Wrong size on APlayerStateJP_Match");
static_assert(offsetof(APlayerStateJP_Match, OnDeathRespawnTimeWindowChanged) == 0x0006A0, "Member 'APlayerStateJP_Match::OnDeathRespawnTimeWindowChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Match, PlayerEconomyComponent) == 0x0006B0, "Member 'APlayerStateJP_Match::PlayerEconomyComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Match, PlayerMatchRecord) == 0x0006B8, "Member 'APlayerStateJP_Match::PlayerMatchRecord' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Match, ObjectiveManagerComponent) == 0x0006C0, "Member 'APlayerStateJP_Match::ObjectiveManagerComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Match, BackupInventoryArray) == 0x0006C8, "Member 'APlayerStateJP_Match::BackupInventoryArray' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Match, PlayerJoinHandShakeComponent) == 0x000818, "Member 'APlayerStateJP_Match::PlayerJoinHandShakeComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Match, AssistEconomy) == 0x000820, "Member 'APlayerStateJP_Match::AssistEconomy' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Match, DeathRespawnTimeWindow) == 0x000828, "Member 'APlayerStateJP_Match::DeathRespawnTimeWindow' has a wrong offset!");

// Class JP.BlueprintFunctionLibraryJP
// 0x0000 (0x0028 - 0x0028)
class UBlueprintFunctionLibraryJP final : public UBlueprintFunctionLibrary
{
public:
	static bool CanNeighborBePicked(const class UObject* WorldContextObject, const struct FGameplayTag& NeighborIDTag, const uint8 TeamId);
	static bool ContainsTagStack(struct FGameplayTagStackContainer& Container, const struct FGameplayTag& Tag);
	static void CopyToClipboard(const class FString& NewClipboard);
	static struct FCombatParticipant CreateCombatParticipantFromPlayer(class APlayerStateJP_Match* Player);
	static void EffectContextAddCombatParticipant(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FCombatParticipant& Data);
	static void EffectContextAddKillData(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FKillData& Data);
	static void EffectContextAddKillMethod(const struct FGameplayEffectSpecHandle& SpecHandle, TSoftObjectPtr<class UItemDefinition> ItemDefinition, TSoftClassPtr<class UClass> GameplayAbility);
	static struct FCombatParticipant EffectContextGetCombatParticipant(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static struct FKillData EffectContextGetKillData(const struct FGameplayEffectContextHandle& EffectContextHandle);
	static float EvaluateFloatValue(EArithmeticOperators Operator, float Value1, float Value2);
	static int32 EvaluateIntValue(EArithmeticOperators Operator, int32 Value1, int32 Value2);
	static float EvaluateRuntimeFloatCurve(const class UObject* WorldContextObject, const struct FRuntimeFloatCurve& Curve, float Time);
	static struct FVector3f EvaluateVectorValue(EArithmeticOperators Operator, const struct FVector3f& Value1, const struct FVector3f& Value2);
	static TArray<class UGameplayEffectComponent*> FindComponents(TSubclassOf<class UGameplayEffectIW> GameplayEffect, TSubclassOf<class UGameplayEffectComponent> ClassToFind);
	static void FindScreenEdgeLocationForWorldLocation(class UObject* WorldContextObject, const struct FVector& InLocation, const float EdgePercent, const struct FVector2D& ViewportCenterLoc, struct FVector2D* OutScreenPosition, float* OutRotationAngleDegrees, bool* bIsOnScreen);
	static void FlushPlayerControllerInput(class APlayerController* PlayerController);
	static struct FGameplayTagContainer GetAbilityTagsFromSpec(const struct FGameplayEffectSpec& Spec);
	static struct FCombatParticipant GetAssistingCombatParticipantFromASC(const struct FGameplayTag& AssistType, class UAbilitySystemComponent* ASC, class UPlayerMatchRecord* PlayerToIgnore);
	static struct FColor GetDefaultPerkColor();
	static EDirectionAxis GetDirectionAxisFromVector(const struct FVector& Vector);
	static class FText GetDisplayNameFromCombatParticipant(const class UObject* WorldContextObject, const struct FCombatParticipant& Participant);
	static struct FGameplayEffectContextHandle GetEffectContextHandleFromGameplayEffectSpec(const struct FGameplayEffectSpec& Spec);
	static float GetExpectedDuration(TSubclassOf<class UGameplayEffectIW> GameplayEffect);
	static class APlayerControllerJP* GetFirstPlayerControllerJP(const class UObject* WorldContextObject);
	static class APlayerControllerJP_Lobby* GetFirstPlayerControllerJP_Lobby(const class UObject* WorldContextObject, bool PrintError);
	static class APlayerControllerJP_Match* GetFirstPlayerControllerJP_Match(const class UObject* WorldContextObject, bool PrintError);
	static class APlayerStateJP* GetFirstPlayerStateJP(const class UObject* WorldContextObject);
	static class APlayerStateJP_Lobby* GetFirstPlayerStateJP_Lobby(const class UObject* WorldContextObject);
	static class APlayerStateJP_Match* GetFirstPlayerStateJP_Match(const class UObject* WorldContextObject);
	static class AGameModeJP_Lobby* GetGameModeJP_Lobby(const class UObject* WorldContextObject);
	static class AGameModeJP_Match* GetGameModeJP_Match(const class UObject* WorldContextObject);
	static TSubclassOf<class UGameplayAbility> GetGameplayAbilityForInputTag(class UEquipmentInstance* EquipmentInstance, const struct FGameplayTag& GameplayTag);
	static struct FGameplayTagContainer GetGameplayTagChildren(const struct FGameplayTag& ParentGameplayTag);
	static class FString GetGameplayTagRootName(const struct FGameplayTag& TagToSplit);
	static class AGameStateJP* GetGameStateJP(const class UObject* WorldContextObject);
	static class AGameStateJP_Lobby* GetGameStateJP_Lobby(const class UObject* WorldContextObject);
	static class AGameStateJP_Match* GetGameStateJP_Match(const class UObject* WorldContextObject);
	static bool GetIsPie();
	static class APlayerControllerJP_Lobby* GetLocalPlayerControllerJP_Lobby(const class UObject* WorldContextObject, bool PrintError);
	static class APlayerControllerJP_Match* GetLocalPlayerControllerJP_Match(const class UObject* WorldContextObject, bool PrintError);
	static class FString GetOnlineServicesID(class UObject* Object);
	static int32 GetStencilValueFromMask(const struct FGameplayTag& InTag);
	static int32 GetTagStackAmount(const struct FGameplayTagStack& TagStack);
	static int32 GetTagStackCount(struct FGameplayTagStackContainer& Container, const struct FGameplayTag& Tag);
	static struct FGameplayTag GetTagStackTag(const struct FGameplayTagStack& TagStack);
	static const struct FGameplayTagContainer GetTargetTagsFromSpec(const struct FGameplayEffectSpec& Spec);
	static class UCommonGameDialogDescriptor* GetTutorialPromptDialogDescriptor(const class FText& Body);
	static const class UTweakableData* GetTweakableData();
	static bool IsActorReplicatingMovement(class AActor* Actor);
	static bool IsKeyboardFocused();
	static bool IsSceneComponentOnScreen(const class UObject* WorldContextObject, const class USceneComponent* SceneComponent);
	static bool IsSceneComponentOnScreenWithSlack(const class UObject* WorldContextObject, const class USceneComponent* SceneComponent, const struct FVector& LocalSpaceExtraSize);
	static bool IsWorldPositionOnScreen(const class UObject* WorldContextObject, const struct FVector& WorldLocation);
	static bool LegalPlacement(const struct FDeployabeLegality& LegalityStruct);
	static void SendMessageToAll(const class FString& Message, const class UObject* WorldContextObject);
	static void SetTagStack(struct FGameplayTagStackContainer& Container, const struct FGameplayTag& Tag, int32 NewStacks);
	static void SimulateMouseScrollInput(const struct FKey& InKey, float Value);
	static void SimulatePlayerAnalogInput(const struct FKey& InKey, float Value);
	static void SimulatePlayerInputKeyDown(const struct FKey& InKey);
	static void SimulatePlayerInputKeyUp(const struct FKey& InKey);
	static void SortRoomData(TArray<struct FRoomData>& RoomCollection);
	static TArray<class FString> SplitGameplayTagName(const struct FGameplayTag& TagToSplit);
	static void TraceForHitsWithInterface(class UObject* WorldContextObject, const double Range, const double Width, const double Height, const double TraceHeightOffset, const struct FVector& TraceFromLocation, const struct FRotator& TraceRotation, class AActor* Owner, TSubclassOf<class IInterface> Interface, bool Debug, const TArray<EObjectTypeQuery>& ObjectTypes, const TArray<class AActor*>& ActorsToIgnore, TArray<struct FHitResult>* AcceptedHits, bool* NoHits, bool* OnlyHitWorldStatic);
	static void TryAddTagStacksToItemInInventory(class UGameplayAbility* Ability, const TSoftObjectPtr<class UItemDefinition> ItemDefinition, const TMap<struct FGameplayTag, int32>& TagStacksToAdd);
	static void TrySetTagStacksForItemInInventory(class UGameplayAbility* Ability, const TSoftObjectPtr<class UItemDefinition> ItemDefinition, const TMap<struct FGameplayTag, int32>& TagStacksToSet);
	static void TrySubtractTagStacksFromItemInInventory(class UGameplayAbility* Ability, const TSoftObjectPtr<class UItemDefinition> ItemDefinition, const TMap<struct FGameplayTag, int32>& TagStacksToSubtract);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintFunctionLibraryJP">();
	}
	static class UBlueprintFunctionLibraryJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintFunctionLibraryJP>();
	}
};
static_assert(alignof(UBlueprintFunctionLibraryJP) == 0x000008, "Wrong alignment on UBlueprintFunctionLibraryJP");
static_assert(sizeof(UBlueprintFunctionLibraryJP) == 0x000028, "Wrong size on UBlueprintFunctionLibraryJP");

// Class JP.SocialRecentPlayerInteractionWidget
// 0x0020 (0x0300 - 0x02E0)
class USocialRecentPlayerInteractionWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadGuardButton*                       BlockButton;                                       // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnBlockButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialRecentPlayerInteractionWidget">();
	}
	static class USocialRecentPlayerInteractionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialRecentPlayerInteractionWidget>();
	}
};
static_assert(alignof(USocialRecentPlayerInteractionWidget) == 0x000008, "Wrong alignment on USocialRecentPlayerInteractionWidget");
static_assert(sizeof(USocialRecentPlayerInteractionWidget) == 0x000300, "Wrong size on USocialRecentPlayerInteractionWidget");
static_assert(offsetof(USocialRecentPlayerInteractionWidget, BlockButton) == 0x0002F8, "Member 'USocialRecentPlayerInteractionWidget::BlockButton' has a wrong offset!");

// Class JP.BlueprintLogging
// 0x0000 (0x0028 - 0x0028)
class UBlueprintLogging final : public UBlueprintFunctionLibrary
{
public:
	static void Print(const class FString& CategoryName, const class FString& InString, EVerbosity Verbosity, const struct FLinearColor& TextColor, float Duration);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintLogging">();
	}
	static class UBlueprintLogging* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintLogging>();
	}
};
static_assert(alignof(UBlueprintLogging) == 0x000008, "Wrong alignment on UBlueprintLogging");
static_assert(sizeof(UBlueprintLogging) == 0x000028, "Wrong size on UBlueprintLogging");

// Class JP.BlueprintStringLibraryJP
// 0x0000 (0x0028 - 0x0028)
class UBlueprintStringLibraryJP final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_PlayerLoadoutToString(const struct FPlayerLoadout& InLoadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintStringLibraryJP">();
	}
	static class UBlueprintStringLibraryJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintStringLibraryJP>();
	}
};
static_assert(alignof(UBlueprintStringLibraryJP) == 0x000008, "Wrong alignment on UBlueprintStringLibraryJP");
static_assert(sizeof(UBlueprintStringLibraryJP) == 0x000028, "Wrong size on UBlueprintStringLibraryJP");

// Class JP.BuyAmmoBehavior
// 0x0000 (0x0028 - 0x0028)
class UBuyAmmoBehavior : public UObject
{
public:
	int32 GetAmmoToAdd(class UItemInstance* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuyAmmoBehavior">();
	}
	static class UBuyAmmoBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuyAmmoBehavior>();
	}
};
static_assert(alignof(UBuyAmmoBehavior) == 0x000008, "Wrong alignment on UBuyAmmoBehavior");
static_assert(sizeof(UBuyAmmoBehavior) == 0x000028, "Wrong size on UBuyAmmoBehavior");

// Class JP.SocialPartyFollowLeaderPasswordMenu
// 0x0018 (0x02F8 - 0x02E0)
class USocialPartyFollowLeaderPasswordMenu final : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Canceled();
	void EnteredPassword(const class FString& Password);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialPartyFollowLeaderPasswordMenu">();
	}
	static class USocialPartyFollowLeaderPasswordMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialPartyFollowLeaderPasswordMenu>();
	}
};
static_assert(alignof(USocialPartyFollowLeaderPasswordMenu) == 0x000008, "Wrong alignment on USocialPartyFollowLeaderPasswordMenu");
static_assert(sizeof(USocialPartyFollowLeaderPasswordMenu) == 0x0002F8, "Wrong size on USocialPartyFollowLeaderPasswordMenu");

// Class JP.BuyAmmoBehavior_Full
// 0x0000 (0x0028 - 0x0028)
class UBuyAmmoBehavior_Full final : public UBuyAmmoBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuyAmmoBehavior_Full">();
	}
	static class UBuyAmmoBehavior_Full* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuyAmmoBehavior_Full>();
	}
};
static_assert(alignof(UBuyAmmoBehavior_Full) == 0x000008, "Wrong alignment on UBuyAmmoBehavior_Full");
static_assert(sizeof(UBuyAmmoBehavior_Full) == 0x000028, "Wrong size on UBuyAmmoBehavior_Full");

// Class JP.TeamAssignableManager
// 0x0060 (0x02F0 - 0x0290)
class ATeamAssignableManager : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<class AActor*>                           TeamAssignableActors;                              // 0x0298(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, Protected, NativeAccessSpecifierProtected)
	ETeamType                                     CurrentTeamType;                                   // 0x02E8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E9[0x7];                                      // 0x02E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GatherReferences();

	class AGroundsKeeper* FindOwningGroundsKeeper() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamAssignableManager">();
	}
	static class ATeamAssignableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamAssignableManager>();
	}
};
static_assert(alignof(ATeamAssignableManager) == 0x000008, "Wrong alignment on ATeamAssignableManager");
static_assert(sizeof(ATeamAssignableManager) == 0x0002F0, "Wrong size on ATeamAssignableManager");
static_assert(offsetof(ATeamAssignableManager, TeamAssignableActors) == 0x000298, "Member 'ATeamAssignableManager::TeamAssignableActors' has a wrong offset!");
static_assert(offsetof(ATeamAssignableManager, CurrentTeamType) == 0x0002E8, "Member 'ATeamAssignableManager::CurrentTeamType' has a wrong offset!");

// Class JP.BuyAmmoBehavior_Specified
// 0x0008 (0x0030 - 0x0028)
class UBuyAmmoBehavior_Specified final : public UBuyAmmoBehavior
{
public:
	int32                                         AmmoBuyAmount;                                     // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BuyAmmoBehavior_Specified">();
	}
	static class UBuyAmmoBehavior_Specified* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBuyAmmoBehavior_Specified>();
	}
};
static_assert(alignof(UBuyAmmoBehavior_Specified) == 0x000008, "Wrong alignment on UBuyAmmoBehavior_Specified");
static_assert(sizeof(UBuyAmmoBehavior_Specified) == 0x000030, "Wrong size on UBuyAmmoBehavior_Specified");
static_assert(offsetof(UBuyAmmoBehavior_Specified, AmmoBuyAmount) == 0x000028, "Member 'UBuyAmmoBehavior_Specified::AmmoBuyAmount' has a wrong offset!");

// Class JP.CharacterDeathComponent
// 0x0088 (0x0128 - 0x00A0)
class UCharacterDeathComponent : public UActorComponent
{
public:
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyOnDeath;                             // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToApplyOnRespawn;                           // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToRemoveOnDeath;                            // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UGameplayEffect>>    EffectsToRemoveOnRespawn;                          // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TSubclassOf<class APawn>                      SpectatorPawnToUse;                                // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeUntilSpectatorControl;                         // 0x00E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  SpawnedSpectatorPawn;                              // 0x00F0(0x0008)(BlueprintVisible, Net, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AController*                            OriginalController;                                // 0x00F8(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class APawn*                                  OriginalPawn;                                      // 0x0100(0x0008)(BlueprintVisible, ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTimerHandle                           SwitchToSpectatorTimerHandle;                      // 0x0108(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           RespawnTimerHandle;                                // 0x0110(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AActor*                                 NewCharacterToControl;                             // 0x0118(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_120[0x8];                                      // 0x0120(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginRespawn();
	void FinishRespawnCooldown();
	class AController* GetOriginalController();
	class APawn* GetOriginalPawn();
	class APawn* GetSpectatorPawn();
	void KillCharacter(float RespawnTime);
	void RespawnCharacter(class AActor* NewCharacter);
	void SetWantsToRespawn(bool InWantsToRespawn);
	void SpectatorPawnSpawned();

	bool GetWantsToRespawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterDeathComponent">();
	}
	static class UCharacterDeathComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterDeathComponent>();
	}
};
static_assert(alignof(UCharacterDeathComponent) == 0x000008, "Wrong alignment on UCharacterDeathComponent");
static_assert(sizeof(UCharacterDeathComponent) == 0x000128, "Wrong size on UCharacterDeathComponent");
static_assert(offsetof(UCharacterDeathComponent, EffectsToApplyOnDeath) == 0x0000A0, "Member 'UCharacterDeathComponent::EffectsToApplyOnDeath' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, EffectsToApplyOnRespawn) == 0x0000B0, "Member 'UCharacterDeathComponent::EffectsToApplyOnRespawn' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, EffectsToRemoveOnDeath) == 0x0000C0, "Member 'UCharacterDeathComponent::EffectsToRemoveOnDeath' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, EffectsToRemoveOnRespawn) == 0x0000D0, "Member 'UCharacterDeathComponent::EffectsToRemoveOnRespawn' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, SpectatorPawnToUse) == 0x0000E0, "Member 'UCharacterDeathComponent::SpectatorPawnToUse' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, TimeUntilSpectatorControl) == 0x0000E8, "Member 'UCharacterDeathComponent::TimeUntilSpectatorControl' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, SpawnedSpectatorPawn) == 0x0000F0, "Member 'UCharacterDeathComponent::SpawnedSpectatorPawn' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, OriginalController) == 0x0000F8, "Member 'UCharacterDeathComponent::OriginalController' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, OriginalPawn) == 0x000100, "Member 'UCharacterDeathComponent::OriginalPawn' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, SwitchToSpectatorTimerHandle) == 0x000108, "Member 'UCharacterDeathComponent::SwitchToSpectatorTimerHandle' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, RespawnTimerHandle) == 0x000110, "Member 'UCharacterDeathComponent::RespawnTimerHandle' has a wrong offset!");
static_assert(offsetof(UCharacterDeathComponent, NewCharacterToControl) == 0x000118, "Member 'UCharacterDeathComponent::NewCharacterToControl' has a wrong offset!");

// Class JP.CharacterEmoteComponent
// 0x0010 (0x00B0 - 0x00A0)
class UCharacterEmoteComponent final : public UActorComponent
{
public:
	TArray<struct FUEmoteWheelEntryData>          Entries;                                           // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterEmoteComponent">();
	}
	static class UCharacterEmoteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterEmoteComponent>();
	}
};
static_assert(alignof(UCharacterEmoteComponent) == 0x000008, "Wrong alignment on UCharacterEmoteComponent");
static_assert(sizeof(UCharacterEmoteComponent) == 0x0000B0, "Wrong size on UCharacterEmoteComponent");
static_assert(offsetof(UCharacterEmoteComponent, Entries) == 0x0000A0, "Member 'UCharacterEmoteComponent::Entries' has a wrong offset!");

// Class JP.PartyMemberEntryViewModel
// 0x0010 (0x0038 - 0x0028)
class UPartyMemberEntryViewModel final : public UObject
{
public:
	class UOnlineServicesPartyMember*             PartyMember;                                       // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyMemberEntryViewModel">();
	}
	static class UPartyMemberEntryViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPartyMemberEntryViewModel>();
	}
};
static_assert(alignof(UPartyMemberEntryViewModel) == 0x000008, "Wrong alignment on UPartyMemberEntryViewModel");
static_assert(sizeof(UPartyMemberEntryViewModel) == 0x000038, "Wrong size on UPartyMemberEntryViewModel");
static_assert(offsetof(UPartyMemberEntryViewModel, PartyMember) == 0x000028, "Member 'UPartyMemberEntryViewModel::PartyMember' has a wrong offset!");

// Class JP.CharacterItemAnimDefinition
// 0x0040 (0x0070 - 0x0030)
class UCharacterItemAnimDefinition : public UDataAsset
{
public:
	TArray<class UAnimMontage*>                   OneShotMontage;                                    // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   ChargeMontage;                                     // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   OnReleaseMontage;                                  // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   OnEquippedMontage;                                 // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterItemAnimDefinition">();
	}
	static class UCharacterItemAnimDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterItemAnimDefinition>();
	}
};
static_assert(alignof(UCharacterItemAnimDefinition) == 0x000008, "Wrong alignment on UCharacterItemAnimDefinition");
static_assert(sizeof(UCharacterItemAnimDefinition) == 0x000070, "Wrong size on UCharacterItemAnimDefinition");
static_assert(offsetof(UCharacterItemAnimDefinition, OneShotMontage) == 0x000030, "Member 'UCharacterItemAnimDefinition::OneShotMontage' has a wrong offset!");
static_assert(offsetof(UCharacterItemAnimDefinition, ChargeMontage) == 0x000040, "Member 'UCharacterItemAnimDefinition::ChargeMontage' has a wrong offset!");
static_assert(offsetof(UCharacterItemAnimDefinition, OnReleaseMontage) == 0x000050, "Member 'UCharacterItemAnimDefinition::OnReleaseMontage' has a wrong offset!");
static_assert(offsetof(UCharacterItemAnimDefinition, OnEquippedMontage) == 0x000060, "Member 'UCharacterItemAnimDefinition::OnEquippedMontage' has a wrong offset!");

// Class JP.StaticMeshActorJP
// 0x0000 (0x02A0 - 0x02A0)
class AStaticMeshActorJP : public AStaticMeshActor
{
public:
	void K2_FellOutOfWorld();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaticMeshActorJP">();
	}
	static class AStaticMeshActorJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AStaticMeshActorJP>();
	}
};
static_assert(alignof(AStaticMeshActorJP) == 0x000008, "Wrong alignment on AStaticMeshActorJP");
static_assert(sizeof(AStaticMeshActorJP) == 0x0002A0, "Wrong size on AStaticMeshActorJP");

// Class JP.CharacterJP
// 0x0060 (0x06D0 - 0x0670)
class ACharacterJP : public AModularCharacter
{
public:
	uint8                                         Pad_670[0x18];                                     // 0x0670(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             TeamMaterialsDatatable;                            // 0x0688(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               ReplicatedControlRotation;                         // 0x0690(0x0018)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAbilitySystemComponentJP*              AbilitySystemComponent;                            // 0x06A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPawnExtensionComponent*                PawnExtensionComponent;                            // 0x06B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPawnInputExtensionComponent*           PawnInputExtensionComponent;                       // 0x06B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UNeighborSpecialAbilitiesComponent*     SpecialAbilitiesComponent;                         // 0x06C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           CharacterIdTag;                                    // 0x06C8(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UNeighborDefinition* GetDefinition();
	struct FTransform GetTransformOfThirdPersonBone(class FName BoneName);
	void K2_FellOutOfWorld();
	void K2_HealthAttributeChanged(float OldValue, float NewValue);
	void K2_InitializePlayer();
	void K2_OnRep_PlayerState(const class APlayerStateJP_Match* PlayerStateJP_Match);
	void KilledByNonPlayer(const class FString& KillerObject);
	void KilledByPlayer(const struct FGameplayTag& KillerPawnTag);
	void MovementInputPreProcess(struct FVector& WorldDirection, float& ScaleValue, bool& bForce);

	struct FGameplayTag GetCharacterIdTag() const;
	class UMaterialInstance* GetTeamMaterial() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterJP">();
	}
	static class ACharacterJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<ACharacterJP>();
	}
};
static_assert(alignof(ACharacterJP) == 0x000010, "Wrong alignment on ACharacterJP");
static_assert(sizeof(ACharacterJP) == 0x0006D0, "Wrong size on ACharacterJP");
static_assert(offsetof(ACharacterJP, TeamMaterialsDatatable) == 0x000688, "Member 'ACharacterJP::TeamMaterialsDatatable' has a wrong offset!");
static_assert(offsetof(ACharacterJP, ReplicatedControlRotation) == 0x000690, "Member 'ACharacterJP::ReplicatedControlRotation' has a wrong offset!");
static_assert(offsetof(ACharacterJP, AbilitySystemComponent) == 0x0006A8, "Member 'ACharacterJP::AbilitySystemComponent' has a wrong offset!");
static_assert(offsetof(ACharacterJP, PawnExtensionComponent) == 0x0006B0, "Member 'ACharacterJP::PawnExtensionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterJP, PawnInputExtensionComponent) == 0x0006B8, "Member 'ACharacterJP::PawnInputExtensionComponent' has a wrong offset!");
static_assert(offsetof(ACharacterJP, SpecialAbilitiesComponent) == 0x0006C0, "Member 'ACharacterJP::SpecialAbilitiesComponent' has a wrong offset!");
static_assert(offsetof(ACharacterJP, CharacterIdTag) == 0x0006C8, "Member 'ACharacterJP::CharacterIdTag' has a wrong offset!");

// Class JP.CharacterMaskComponent
// 0x0010 (0x00B0 - 0x00A0)
class UCharacterMaskComponent final : public UActorComponent
{
public:
	TArray<struct FGameplayTag>                   MaskStack;                                         // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void PopMask(const struct FGameplayTag& InTag);
	void PushMask(const struct FGameplayTag& InTag);
	void RefreshMask();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMaskComponent">();
	}
	static class UCharacterMaskComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMaskComponent>();
	}
};
static_assert(alignof(UCharacterMaskComponent) == 0x000008, "Wrong alignment on UCharacterMaskComponent");
static_assert(sizeof(UCharacterMaskComponent) == 0x0000B0, "Wrong size on UCharacterMaskComponent");
static_assert(offsetof(UCharacterMaskComponent, MaskStack) == 0x0000A0, "Member 'UCharacterMaskComponent::MaskStack' has a wrong offset!");

// Class JP.ChargeableWidget
// 0x0000 (0x0028 - 0x0028)
class IChargeableWidget final : public IInterface
{
public:
	void OnCancelCharge();
	void OnCompleteCharge();
	void OnStartCharge(float ChargeTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ChargeableWidget">();
	}
	static class IChargeableWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<IChargeableWidget>();
	}
};
static_assert(alignof(IChargeableWidget) == 0x000008, "Wrong alignment on IChargeableWidget");
static_assert(sizeof(IChargeableWidget) == 0x000028, "Wrong size on IChargeableWidget");

// Class JP.RecentPlayerEntryViewModel
// 0x0008 (0x0030 - 0x0028)
class URecentPlayerEntryViewModel final : public UObject
{
public:
	class UOnlineServicesRecentPlayer*            RecentPlayer;                                      // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RecentPlayerEntryViewModel">();
	}
	static class URecentPlayerEntryViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<URecentPlayerEntryViewModel>();
	}
};
static_assert(alignof(URecentPlayerEntryViewModel) == 0x000008, "Wrong alignment on URecentPlayerEntryViewModel");
static_assert(sizeof(URecentPlayerEntryViewModel) == 0x000030, "Wrong size on URecentPlayerEntryViewModel");
static_assert(offsetof(URecentPlayerEntryViewModel, RecentPlayer) == 0x000028, "Member 'URecentPlayerEntryViewModel::RecentPlayer' has a wrong offset!");

// Class JP.ClientAuthenticationInitializationGameInstanceSubsystem
// 0x0038 (0x0068 - 0x0030)
class UClientAuthenticationInitializationGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x30];                                      // 0x0030(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UInitializationFlowComponent*           InitializationFlowComponent;                       // 0x0060(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UCommonGameDialogDescriptor* GetClientGameInitializationFailedDescriptor(const class FText& Body);

	bool IsFinished() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ClientAuthenticationInitializationGameInstanceSubsystem">();
	}
	static class UClientAuthenticationInitializationGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UClientAuthenticationInitializationGameInstanceSubsystem>();
	}
};
static_assert(alignof(UClientAuthenticationInitializationGameInstanceSubsystem) == 0x000008, "Wrong alignment on UClientAuthenticationInitializationGameInstanceSubsystem");
static_assert(sizeof(UClientAuthenticationInitializationGameInstanceSubsystem) == 0x000068, "Wrong size on UClientAuthenticationInitializationGameInstanceSubsystem");
static_assert(offsetof(UClientAuthenticationInitializationGameInstanceSubsystem, InitializationFlowComponent) == 0x000060, "Member 'UClientAuthenticationInitializationGameInstanceSubsystem::InitializationFlowComponent' has a wrong offset!");

// Class JP.ServerTimeoutGameInstanceSubsystem
// 0x0010 (0x0040 - 0x0030)
class UServerTimeoutGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UTimeoutHandler*                        TimeoutHandler;                                    // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerTimeoutGameInstanceSubsystem">();
	}
	static class UServerTimeoutGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerTimeoutGameInstanceSubsystem>();
	}
};
static_assert(alignof(UServerTimeoutGameInstanceSubsystem) == 0x000008, "Wrong alignment on UServerTimeoutGameInstanceSubsystem");
static_assert(sizeof(UServerTimeoutGameInstanceSubsystem) == 0x000040, "Wrong size on UServerTimeoutGameInstanceSubsystem");
static_assert(offsetof(UServerTimeoutGameInstanceSubsystem, TimeoutHandler) == 0x000038, "Member 'UServerTimeoutGameInstanceSubsystem::TimeoutHandler' has a wrong offset!");

// Class JP.CommonSessionSubsystemAccelbyte
// 0x0000 (0x00E0 - 0x00E0)
class UCommonSessionSubsystemAccelbyte final : public UCommonSessionSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CommonSessionSubsystemAccelbyte">();
	}
	static class UCommonSessionSubsystemAccelbyte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCommonSessionSubsystemAccelbyte>();
	}
};
static_assert(alignof(UCommonSessionSubsystemAccelbyte) == 0x000008, "Wrong alignment on UCommonSessionSubsystemAccelbyte");
static_assert(sizeof(UCommonSessionSubsystemAccelbyte) == 0x0000E0, "Wrong size on UCommonSessionSubsystemAccelbyte");

// Class JP.CoordinatorWorldSubsystem
// 0x0008 (0x0038 - 0x0030)
class UCoordinatorWorldSubsystem final : public UWorldSubsystem
{
public:
	class UUIDataIsReadyCoordinator*              UIDataIsReadyCoordinator;                          // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CoordinatorWorldSubsystem">();
	}
	static class UCoordinatorWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCoordinatorWorldSubsystem>();
	}
};
static_assert(alignof(UCoordinatorWorldSubsystem) == 0x000008, "Wrong alignment on UCoordinatorWorldSubsystem");
static_assert(sizeof(UCoordinatorWorldSubsystem) == 0x000038, "Wrong size on UCoordinatorWorldSubsystem");
static_assert(offsetof(UCoordinatorWorldSubsystem, UIDataIsReadyCoordinator) == 0x000030, "Member 'UCoordinatorWorldSubsystem::UIDataIsReadyCoordinator' has a wrong offset!");

// Class JP.CurrencyDataAsset
// 0x0050 (0x0080 - 0x0030)
class UCurrencyDataAsset final : public UDataAsset
{
public:
	class FString                                 Code;                                              // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            Color;                                             // 0x0068(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurrencyDataAsset">();
	}
	static class UCurrencyDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurrencyDataAsset>();
	}
};
static_assert(alignof(UCurrencyDataAsset) == 0x000008, "Wrong alignment on UCurrencyDataAsset");
static_assert(sizeof(UCurrencyDataAsset) == 0x000080, "Wrong size on UCurrencyDataAsset");
static_assert(offsetof(UCurrencyDataAsset, Code) == 0x000030, "Member 'UCurrencyDataAsset::Code' has a wrong offset!");
static_assert(offsetof(UCurrencyDataAsset, Icon) == 0x000040, "Member 'UCurrencyDataAsset::Icon' has a wrong offset!");
static_assert(offsetof(UCurrencyDataAsset, Color) == 0x000068, "Member 'UCurrencyDataAsset::Color' has a wrong offset!");

// Class JP.SocialUserEntryWidget
// 0x0018 (0x02F8 - 0x02E0)
class USocialUserEntryWidget : public UUserWidget
{
public:
	class UNamedSlot*                             InteractionWidgetSlot;                             // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCommonTextBlock*                       UserNameText;                                      // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonTextBlock*                       UserStatusText;                                    // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	struct FMargin GetListItemPadding();
	void SetAvatar(class UOnlineServicesUserBase* User);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialUserEntryWidget">();
	}
	static class USocialUserEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialUserEntryWidget>();
	}
};
static_assert(alignof(USocialUserEntryWidget) == 0x000008, "Wrong alignment on USocialUserEntryWidget");
static_assert(sizeof(USocialUserEntryWidget) == 0x0002F8, "Wrong size on USocialUserEntryWidget");
static_assert(offsetof(USocialUserEntryWidget, InteractionWidgetSlot) == 0x0002E0, "Member 'USocialUserEntryWidget::InteractionWidgetSlot' has a wrong offset!");
static_assert(offsetof(USocialUserEntryWidget, UserNameText) == 0x0002E8, "Member 'USocialUserEntryWidget::UserNameText' has a wrong offset!");
static_assert(offsetof(USocialUserEntryWidget, UserStatusText) == 0x0002F0, "Member 'USocialUserEntryWidget::UserStatusText' has a wrong offset!");

// Class JP.CurveInterpolationComponent
// 0x0040 (0x00E0 - 0x00A0)
class UCurveInterpolationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0xC];                                       // 0x00A0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DurationMultiplier;                                // 0x00AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveFloat*                            InterpolationCurve;                                // 0x00B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ValueMultiplier;                                   // 0x00B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCurveInterpolationUpdate;                        // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCurveInterpolationComplete;                      // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void StartInterpolationEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CurveInterpolationComponent">();
	}
	static class UCurveInterpolationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCurveInterpolationComponent>();
	}
};
static_assert(alignof(UCurveInterpolationComponent) == 0x000008, "Wrong alignment on UCurveInterpolationComponent");
static_assert(sizeof(UCurveInterpolationComponent) == 0x0000E0, "Wrong size on UCurveInterpolationComponent");
static_assert(offsetof(UCurveInterpolationComponent, DurationMultiplier) == 0x0000AC, "Member 'UCurveInterpolationComponent::DurationMultiplier' has a wrong offset!");
static_assert(offsetof(UCurveInterpolationComponent, InterpolationCurve) == 0x0000B0, "Member 'UCurveInterpolationComponent::InterpolationCurve' has a wrong offset!");
static_assert(offsetof(UCurveInterpolationComponent, ValueMultiplier) == 0x0000B8, "Member 'UCurveInterpolationComponent::ValueMultiplier' has a wrong offset!");
static_assert(offsetof(UCurveInterpolationComponent, OnCurveInterpolationUpdate) == 0x0000C0, "Member 'UCurveInterpolationComponent::OnCurveInterpolationUpdate' has a wrong offset!");
static_assert(offsetof(UCurveInterpolationComponent, OnCurveInterpolationComplete) == 0x0000D0, "Member 'UCurveInterpolationComponent::OnCurveInterpolationComplete' has a wrong offset!");

// Class JP.TaskBox
// 0x0000 (0x0560 - 0x0560)
class UTaskBox final : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskBox">();
	}
	static class UTaskBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTaskBox>();
	}
};
static_assert(alignof(UTaskBox) == 0x000010, "Wrong alignment on UTaskBox");
static_assert(sizeof(UTaskBox) == 0x000560, "Wrong size on UTaskBox");

// Class JP.DeathDurabilityChangeBehavior
// 0x0000 (0x0028 - 0x0028)
class UDeathDurabilityChangeBehavior : public UObject
{
public:
	int32 GetNewDurability(class UItemInstance* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathDurabilityChangeBehavior">();
	}
	static class UDeathDurabilityChangeBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathDurabilityChangeBehavior>();
	}
};
static_assert(alignof(UDeathDurabilityChangeBehavior) == 0x000008, "Wrong alignment on UDeathDurabilityChangeBehavior");
static_assert(sizeof(UDeathDurabilityChangeBehavior) == 0x000028, "Wrong size on UDeathDurabilityChangeBehavior");

// Class JP.DeathDurabilityChangeBehavior_ChangeByAmount
// 0x0008 (0x0030 - 0x0028)
class UDeathDurabilityChangeBehavior_ChangeByAmount final : public UDeathDurabilityChangeBehavior
{
public:
	int32                                         DurabilityChangeAmount;                            // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathDurabilityChangeBehavior_ChangeByAmount">();
	}
	static class UDeathDurabilityChangeBehavior_ChangeByAmount* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathDurabilityChangeBehavior_ChangeByAmount>();
	}
};
static_assert(alignof(UDeathDurabilityChangeBehavior_ChangeByAmount) == 0x000008, "Wrong alignment on UDeathDurabilityChangeBehavior_ChangeByAmount");
static_assert(sizeof(UDeathDurabilityChangeBehavior_ChangeByAmount) == 0x000030, "Wrong size on UDeathDurabilityChangeBehavior_ChangeByAmount");
static_assert(offsetof(UDeathDurabilityChangeBehavior_ChangeByAmount, DurabilityChangeAmount) == 0x000028, "Member 'UDeathDurabilityChangeBehavior_ChangeByAmount::DurabilityChangeAmount' has a wrong offset!");

// Class JP.LyraConfirmationScreen
// 0x0040 (0x0470 - 0x0430)
class ULyraConfirmationScreen : public UCommonGameDialog
{
public:
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonTextBlock*                       Text_Title;                                        // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonRichTextBlock*                   RichText_Description;                              // 0x0448(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDynamicEntryBox*                       EntryBox_Buttons;                                  // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonBorder*                          Border_TapToCloseZone;                             // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FDataTableRowHandle                    CancelAction;                                      // 0x0460(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)

public:
	struct FEventReply HandleTapToCloseZoneMouseButtonDown(const struct FGeometry& MyGeometry, const struct FPointerEvent& MouseEvent);

	class UDynamicEntryBox* GetEntryBoxButtonsWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraConfirmationScreen">();
	}
	static class ULyraConfirmationScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraConfirmationScreen>();
	}
};
static_assert(alignof(ULyraConfirmationScreen) == 0x000008, "Wrong alignment on ULyraConfirmationScreen");
static_assert(sizeof(ULyraConfirmationScreen) == 0x000470, "Wrong size on ULyraConfirmationScreen");
static_assert(offsetof(ULyraConfirmationScreen, Text_Title) == 0x000440, "Member 'ULyraConfirmationScreen::Text_Title' has a wrong offset!");
static_assert(offsetof(ULyraConfirmationScreen, RichText_Description) == 0x000448, "Member 'ULyraConfirmationScreen::RichText_Description' has a wrong offset!");
static_assert(offsetof(ULyraConfirmationScreen, EntryBox_Buttons) == 0x000450, "Member 'ULyraConfirmationScreen::EntryBox_Buttons' has a wrong offset!");
static_assert(offsetof(ULyraConfirmationScreen, Border_TapToCloseZone) == 0x000458, "Member 'ULyraConfirmationScreen::Border_TapToCloseZone' has a wrong offset!");
static_assert(offsetof(ULyraConfirmationScreen, CancelAction) == 0x000460, "Member 'ULyraConfirmationScreen::CancelAction' has a wrong offset!");

// Class JP.DeathDurabilityChangeBehavior_Full
// 0x0000 (0x0028 - 0x0028)
class UDeathDurabilityChangeBehavior_Full final : public UDeathDurabilityChangeBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathDurabilityChangeBehavior_Full">();
	}
	static class UDeathDurabilityChangeBehavior_Full* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathDurabilityChangeBehavior_Full>();
	}
};
static_assert(alignof(UDeathDurabilityChangeBehavior_Full) == 0x000008, "Wrong alignment on UDeathDurabilityChangeBehavior_Full");
static_assert(sizeof(UDeathDurabilityChangeBehavior_Full) == 0x000028, "Wrong size on UDeathDurabilityChangeBehavior_Full");

// Class JP.DeathInterface
// 0x0000 (0x0028 - 0x0028)
class IDeathInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathInterface">();
	}
	static class IDeathInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IDeathInterface>();
	}
};
static_assert(alignof(IDeathInterface) == 0x000008, "Wrong alignment on IDeathInterface");
static_assert(sizeof(IDeathInterface) == 0x000028, "Wrong size on IDeathInterface");

// Class JP.UpdateGameDataStep_SeasonPass
// 0x0010 (0x0088 - 0x0078)
class UUpdateGameDataStep_SeasonPass final : public UUpdateGameDataStepBase
{
public:
	uint8                                         Pad_78[0x10];                                      // 0x0078(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"UpdateGameDataStep_SeasonPass">();
	}
	static class UUpdateGameDataStep_SeasonPass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UUpdateGameDataStep_SeasonPass>();
	}
};
static_assert(alignof(UUpdateGameDataStep_SeasonPass) == 0x000008, "Wrong alignment on UUpdateGameDataStep_SeasonPass");
static_assert(sizeof(UUpdateGameDataStep_SeasonPass) == 0x000088, "Wrong size on UUpdateGameDataStep_SeasonPass");

// Class JP.DeathRespawnTimeWindowFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UDeathRespawnTimeWindowFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static float GetTimeUntilEndOfTimeWindow(class UObject* WorldContext, const struct FDeathRespawnTimeWindow& DeathRespawnTimeWindow);
	static bool IsAfterTimeWindow(class UObject* WorldContext, const struct FDeathRespawnTimeWindow& DeathRespawnTimeWindow);
	static bool IsBeforeTimeWindow(class UObject* WorldContext, const struct FDeathRespawnTimeWindow& DeathRespawnTimeWindow);
	static bool IsInTimeWindow(class UObject* WorldContext, const struct FDeathRespawnTimeWindow& DeathRespawnTimeWindow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DeathRespawnTimeWindowFunctionLibrary">();
	}
	static class UDeathRespawnTimeWindowFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDeathRespawnTimeWindowFunctionLibrary>();
	}
};
static_assert(alignof(UDeathRespawnTimeWindowFunctionLibrary) == 0x000008, "Wrong alignment on UDeathRespawnTimeWindowFunctionLibrary");
static_assert(sizeof(UDeathRespawnTimeWindowFunctionLibrary) == 0x000028, "Wrong size on UDeathRespawnTimeWindowFunctionLibrary");

// Class JP.DedicatedServerInitializationStepBase
// 0x0000 (0x0080 - 0x0080)
class UDedicatedServerInitializationStepBase : public UInitializationFlowStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerInitializationStepBase">();
	}
	static class UDedicatedServerInitializationStepBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerInitializationStepBase>();
	}
};
static_assert(alignof(UDedicatedServerInitializationStepBase) == 0x000008, "Wrong alignment on UDedicatedServerInitializationStepBase");
static_assert(sizeof(UDedicatedServerInitializationStepBase) == 0x000080, "Wrong size on UDedicatedServerInitializationStepBase");

// Class JP.LyraFrontendStateComponent
// 0x0088 (0x0128 - 0x00A0)
class ULyraFrontendStateComponent final : public UGameStateComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PressStartScreenClass;                             // 0x00B0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   MainScreenClass;                                   // 0x00D8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_100[0x28];                                     // 0x0100(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnUserInitialized(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestedPrivilege, ECommonUserOnlineContext OnlineContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraFrontendStateComponent">();
	}
	static class ULyraFrontendStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraFrontendStateComponent>();
	}
};
static_assert(alignof(ULyraFrontendStateComponent) == 0x000008, "Wrong alignment on ULyraFrontendStateComponent");
static_assert(sizeof(ULyraFrontendStateComponent) == 0x000128, "Wrong size on ULyraFrontendStateComponent");
static_assert(offsetof(ULyraFrontendStateComponent, PressStartScreenClass) == 0x0000B0, "Member 'ULyraFrontendStateComponent::PressStartScreenClass' has a wrong offset!");
static_assert(offsetof(ULyraFrontendStateComponent, MainScreenClass) == 0x0000D8, "Member 'ULyraFrontendStateComponent::MainScreenClass' has a wrong offset!");

// Class JP.DedicatedServerInitializationStep_GameData
// 0x0000 (0x0080 - 0x0080)
class UDedicatedServerInitializationStep_GameData final : public UDedicatedServerInitializationStepBase
{
public:
	void OnFinishedUpdatingGameData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerInitializationStep_GameData">();
	}
	static class UDedicatedServerInitializationStep_GameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerInitializationStep_GameData>();
	}
};
static_assert(alignof(UDedicatedServerInitializationStep_GameData) == 0x000008, "Wrong alignment on UDedicatedServerInitializationStep_GameData");
static_assert(sizeof(UDedicatedServerInitializationStep_GameData) == 0x000080, "Wrong size on UDedicatedServerInitializationStep_GameData");

// Class JP.DedicatedServerInternalGameData
// 0x0050 (0x0080 - 0x0030)
class UDedicatedServerInternalGameData final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerInternalGameData">();
	}
	static class UDedicatedServerInternalGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerInternalGameData>();
	}
};
static_assert(alignof(UDedicatedServerInternalGameData) == 0x000008, "Wrong alignment on UDedicatedServerInternalGameData");
static_assert(sizeof(UDedicatedServerInternalGameData) == 0x000080, "Wrong size on UDedicatedServerInternalGameData");

// Class JP.TeamInitializationStepComponent
// 0x0008 (0x00A8 - 0x00A0)
class UTeamInitializationStepComponent : public UGameStateComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_AllTeamsCreated();
	void K2_AllTeamsReplicated();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamInitializationStepComponent">();
	}
	static class UTeamInitializationStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamInitializationStepComponent>();
	}
};
static_assert(alignof(UTeamInitializationStepComponent) == 0x000008, "Wrong alignment on UTeamInitializationStepComponent");
static_assert(sizeof(UTeamInitializationStepComponent) == 0x0000A8, "Wrong size on UTeamInitializationStepComponent");

// Class JP.TeamInitializationStepComponent_Tutorial
// 0x0000 (0x00A8 - 0x00A8)
class UTeamInitializationStepComponent_Tutorial final : public UTeamInitializationStepComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamInitializationStepComponent_Tutorial">();
	}
	static class UTeamInitializationStepComponent_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamInitializationStepComponent_Tutorial>();
	}
};
static_assert(alignof(UTeamInitializationStepComponent_Tutorial) == 0x000008, "Wrong alignment on UTeamInitializationStepComponent_Tutorial");
static_assert(sizeof(UTeamInitializationStepComponent_Tutorial) == 0x0000A8, "Wrong size on UTeamInitializationStepComponent_Tutorial");

// Class JP.DedicatedServerInitializationStep_InternalGameData
// 0x0000 (0x0080 - 0x0080)
class UDedicatedServerInitializationStep_InternalGameData final : public UDedicatedServerInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerInitializationStep_InternalGameData">();
	}
	static class UDedicatedServerInitializationStep_InternalGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerInitializationStep_InternalGameData>();
	}
};
static_assert(alignof(UDedicatedServerInitializationStep_InternalGameData) == 0x000008, "Wrong alignment on UDedicatedServerInitializationStep_InternalGameData");
static_assert(sizeof(UDedicatedServerInitializationStep_InternalGameData) == 0x000080, "Wrong size on UDedicatedServerInitializationStep_InternalGameData");

// Class JP.DedicatedServerInitializationStep_Login
// 0x0008 (0x0088 - 0x0080)
class UDedicatedServerInitializationStep_Login final : public UDedicatedServerInitializationStepBase
{
public:
	class UServerAuthOnlineServiceHandler*        ServerAuth;                                        // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerInitializationStep_Login">();
	}
	static class UDedicatedServerInitializationStep_Login* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerInitializationStep_Login>();
	}
};
static_assert(alignof(UDedicatedServerInitializationStep_Login) == 0x000008, "Wrong alignment on UDedicatedServerInitializationStep_Login");
static_assert(sizeof(UDedicatedServerInitializationStep_Login) == 0x000088, "Wrong size on UDedicatedServerInitializationStep_Login");
static_assert(offsetof(UDedicatedServerInitializationStep_Login, ServerAuth) == 0x000080, "Member 'UDedicatedServerInitializationStep_Login::ServerAuth' has a wrong offset!");

// Class JP.IndicatorLibrary
// 0x0000 (0x0028 - 0x0028)
class UIndicatorLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class ULyraIndicatorManagerComponent* GetIndicatorManagerComponent(class AController* Controller);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndicatorLibrary">();
	}
	static class UIndicatorLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIndicatorLibrary>();
	}
};
static_assert(alignof(UIndicatorLibrary) == 0x000008, "Wrong alignment on UIndicatorLibrary");
static_assert(sizeof(UIndicatorLibrary) == 0x000028, "Wrong size on UIndicatorLibrary");

// Class JP.DedicatedServerInitializationWorldSubsystem
// 0x0008 (0x0038 - 0x0030)
class UDedicatedServerInitializationWorldSubsystem final : public UWorldSubsystem
{
public:
	class UInitializationFlowComponent*           FlowComponent;                                     // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerInitializationWorldSubsystem">();
	}
	static class UDedicatedServerInitializationWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerInitializationWorldSubsystem>();
	}
};
static_assert(alignof(UDedicatedServerInitializationWorldSubsystem) == 0x000008, "Wrong alignment on UDedicatedServerInitializationWorldSubsystem");
static_assert(sizeof(UDedicatedServerInitializationWorldSubsystem) == 0x000038, "Wrong size on UDedicatedServerInitializationWorldSubsystem");
static_assert(offsetof(UDedicatedServerInitializationWorldSubsystem, FlowComponent) == 0x000030, "Member 'UDedicatedServerInitializationWorldSubsystem::FlowComponent' has a wrong offset!");

// Class JP.DedicatedServerRewardsSubsystem
// 0x0010 (0x0040 - 0x0030)
class UDedicatedServerRewardsSubsystem final : public UWorldSubsystem
{
public:
	TArray<class USeasonPassRewardOperation*>     Operations;                                        // 0x0030(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DedicatedServerRewardsSubsystem">();
	}
	static class UDedicatedServerRewardsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDedicatedServerRewardsSubsystem>();
	}
};
static_assert(alignof(UDedicatedServerRewardsSubsystem) == 0x000008, "Wrong alignment on UDedicatedServerRewardsSubsystem");
static_assert(sizeof(UDedicatedServerRewardsSubsystem) == 0x000040, "Wrong size on UDedicatedServerRewardsSubsystem");
static_assert(offsetof(UDedicatedServerRewardsSubsystem, Operations) == 0x000030, "Member 'UDedicatedServerRewardsSubsystem::Operations' has a wrong offset!");

// Class JP.LyraAudioSettings
// 0x0120 (0x0158 - 0x0038)
class ULyraAudioSettings final : public UDeveloperSettings
{
public:
	struct FSoftObjectPath                        DefaultControlBusMix;                              // 0x0038(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        LoadingScreenControlBusMix;                        // 0x0058(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        UserSettingsControlBusMix;                         // 0x0078(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        OverallVolumeControlBus;                           // 0x0098(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        MusicVolumeControlBus;                             // 0x00B8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        SoundFXVolumeControlBus;                           // 0x00D8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        DialogueVolumeControlBus;                          // 0x00F8(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        VoiceChatVolumeControlBus;                         // 0x0118(0x0020)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLyraSubmixEffectChainMap>      HDRAudioSubmixEffectChain;                         // 0x0138(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FLyraSubmixEffectChainMap>      LDRAudioSubmixEffectChain;                         // 0x0148(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAudioSettings">();
	}
	static class ULyraAudioSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAudioSettings>();
	}
};
static_assert(alignof(ULyraAudioSettings) == 0x000008, "Wrong alignment on ULyraAudioSettings");
static_assert(sizeof(ULyraAudioSettings) == 0x000158, "Wrong size on ULyraAudioSettings");
static_assert(offsetof(ULyraAudioSettings, DefaultControlBusMix) == 0x000038, "Member 'ULyraAudioSettings::DefaultControlBusMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, LoadingScreenControlBusMix) == 0x000058, "Member 'ULyraAudioSettings::LoadingScreenControlBusMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, UserSettingsControlBusMix) == 0x000078, "Member 'ULyraAudioSettings::UserSettingsControlBusMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, OverallVolumeControlBus) == 0x000098, "Member 'ULyraAudioSettings::OverallVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, MusicVolumeControlBus) == 0x0000B8, "Member 'ULyraAudioSettings::MusicVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, SoundFXVolumeControlBus) == 0x0000D8, "Member 'ULyraAudioSettings::SoundFXVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, DialogueVolumeControlBus) == 0x0000F8, "Member 'ULyraAudioSettings::DialogueVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, VoiceChatVolumeControlBus) == 0x000118, "Member 'ULyraAudioSettings::VoiceChatVolumeControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, HDRAudioSubmixEffectChain) == 0x000138, "Member 'ULyraAudioSettings::HDRAudioSubmixEffectChain' has a wrong offset!");
static_assert(offsetof(ULyraAudioSettings, LDRAudioSubmixEffectChain) == 0x000148, "Member 'ULyraAudioSettings::LDRAudioSubmixEffectChain' has a wrong offset!");

// Class JP.DistanceScalingWidgetComponent
// 0x0030 (0x06C0 - 0x0690)
class UDistanceScalingWidgetComponent final : public UWidgetComponent
{
public:
	float                                         MaxDistance;                                       // 0x0690(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CloseScale;                                        // 0x0694(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarScale;                                          // 0x0698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickInterval;                                      // 0x069C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckLineOfSight;                                 // 0x06A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A1[0x3];                                      // 0x06A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LineOfSightUpdateInterval;                         // 0x06A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A8[0x18];                                     // 0x06A8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlayerEnterRadius();
	void OnPlayerExitRadius();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DistanceScalingWidgetComponent">();
	}
	static class UDistanceScalingWidgetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDistanceScalingWidgetComponent>();
	}
};
static_assert(alignof(UDistanceScalingWidgetComponent) == 0x000010, "Wrong alignment on UDistanceScalingWidgetComponent");
static_assert(sizeof(UDistanceScalingWidgetComponent) == 0x0006C0, "Wrong size on UDistanceScalingWidgetComponent");
static_assert(offsetof(UDistanceScalingWidgetComponent, MaxDistance) == 0x000690, "Member 'UDistanceScalingWidgetComponent::MaxDistance' has a wrong offset!");
static_assert(offsetof(UDistanceScalingWidgetComponent, CloseScale) == 0x000694, "Member 'UDistanceScalingWidgetComponent::CloseScale' has a wrong offset!");
static_assert(offsetof(UDistanceScalingWidgetComponent, FarScale) == 0x000698, "Member 'UDistanceScalingWidgetComponent::FarScale' has a wrong offset!");
static_assert(offsetof(UDistanceScalingWidgetComponent, TickInterval) == 0x00069C, "Member 'UDistanceScalingWidgetComponent::TickInterval' has a wrong offset!");
static_assert(offsetof(UDistanceScalingWidgetComponent, bCheckLineOfSight) == 0x0006A0, "Member 'UDistanceScalingWidgetComponent::bCheckLineOfSight' has a wrong offset!");
static_assert(offsetof(UDistanceScalingWidgetComponent, LineOfSightUpdateInterval) == 0x0006A4, "Member 'UDistanceScalingWidgetComponent::LineOfSightUpdateInterval' has a wrong offset!");

// Class JP.DriveByVan
// 0x0010 (0x0328 - 0x0318)
class ADriveByVan : public APawn
{
public:
	uint8                                         Pad_318[0x8];                                      // 0x0318(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAbilitySystemComponentJP*              AbilitySystemComponent;                            // 0x0320(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DriveByVan">();
	}
	static class ADriveByVan* GetDefaultObj()
	{
		return GetDefaultObjImpl<ADriveByVan>();
	}
};
static_assert(alignof(ADriveByVan) == 0x000008, "Wrong alignment on ADriveByVan");
static_assert(sizeof(ADriveByVan) == 0x000328, "Wrong size on ADriveByVan");
static_assert(offsetof(ADriveByVan, AbilitySystemComponent) == 0x000320, "Member 'ADriveByVan::AbilitySystemComponent' has a wrong offset!");

// Class JP.LyraHUDLayout
// 0x0028 (0x0460 - 0x0438)
class ULyraHUDLayout final : public ULyraActivatableWidget
{
public:
	TSoftClassPtr<class UClass>                   EscapeMenuClass;                                   // 0x0438(0x0028)(Edit, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHUDLayout">();
	}
	static class ULyraHUDLayout* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraHUDLayout>();
	}
};
static_assert(alignof(ULyraHUDLayout) == 0x000008, "Wrong alignment on ULyraHUDLayout");
static_assert(sizeof(ULyraHUDLayout) == 0x000460, "Wrong size on ULyraHUDLayout");
static_assert(offsetof(ULyraHUDLayout, EscapeMenuClass) == 0x000438, "Member 'ULyraHUDLayout::EscapeMenuClass' has a wrong offset!");

// Class JP.DropBehavior
// 0x0000 (0x0028 - 0x0028)
class UDropBehavior : public UObject
{
public:
	int32 GetDroppedAmmoCount(class UItemInstance* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropBehavior">();
	}
	static class UDropBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropBehavior>();
	}
};
static_assert(alignof(UDropBehavior) == 0x000008, "Wrong alignment on UDropBehavior");
static_assert(sizeof(UDropBehavior) == 0x000028, "Wrong size on UDropBehavior");

// Class JP.DropBehavior_Maximum
// 0x0008 (0x0030 - 0x0028)
class UDropBehavior_Maximum final : public UDropBehavior
{
public:
	int32                                         MaximumAmmoDropAmount;                             // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropBehavior_Maximum">();
	}
	static class UDropBehavior_Maximum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropBehavior_Maximum>();
	}
};
static_assert(alignof(UDropBehavior_Maximum) == 0x000008, "Wrong alignment on UDropBehavior_Maximum");
static_assert(sizeof(UDropBehavior_Maximum) == 0x000030, "Wrong size on UDropBehavior_Maximum");
static_assert(offsetof(UDropBehavior_Maximum, MaximumAmmoDropAmount) == 0x000028, "Member 'UDropBehavior_Maximum::MaximumAmmoDropAmount' has a wrong offset!");

// Class JP.TutorialPromptedSaveGame
// 0x0000 (0x0028 - 0x0028)
class UTutorialPromptedSaveGame final : public USaveGame
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TutorialPromptedSaveGame">();
	}
	static class UTutorialPromptedSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTutorialPromptedSaveGame>();
	}
};
static_assert(alignof(UTutorialPromptedSaveGame) == 0x000008, "Wrong alignment on UTutorialPromptedSaveGame");
static_assert(sizeof(UTutorialPromptedSaveGame) == 0x000028, "Wrong size on UTutorialPromptedSaveGame");

// Class JP.DropBehaviour_All
// 0x0000 (0x0028 - 0x0028)
class UDropBehaviour_All final : public UDropBehavior
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"DropBehaviour_All">();
	}
	static class UDropBehaviour_All* GetDefaultObj()
	{
		return GetDefaultObjImpl<UDropBehaviour_All>();
	}
};
static_assert(alignof(UDropBehaviour_All) == 0x000008, "Wrong alignment on UDropBehaviour_All");
static_assert(sizeof(UDropBehaviour_All) == 0x000028, "Wrong size on UDropBehaviour_All");

// Class JP.EditorUserSettingsJP
// 0x0040 (0x0068 - 0x0028)
class UEditorUserSettingsJP final : public UObject
{
public:
	bool                                          bDisableInitialSpecialAbilityCooldown;             // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUseEditorPlayerLoadout;                      // 0x0029(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class UItemDefinition>> StartingInventory;                                 // 0x0030(0x0010)(Edit, ZeroConstructor, Config, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoClientAuthenticationInPlayInEditor;     // 0x0040(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowServerAuthenticationInPlayInEditor;          // 0x0041(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x6];                                       // 0x0042(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPlayerLoadout>                 EditorLoadoutOverride;                             // 0x0048(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<uint8>                                 EditorTeamOrderOverride;                           // 0x0058(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EditorUserSettingsJP">();
	}
	static class UEditorUserSettingsJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEditorUserSettingsJP>();
	}
};
static_assert(alignof(UEditorUserSettingsJP) == 0x000008, "Wrong alignment on UEditorUserSettingsJP");
static_assert(sizeof(UEditorUserSettingsJP) == 0x000068, "Wrong size on UEditorUserSettingsJP");
static_assert(offsetof(UEditorUserSettingsJP, bDisableInitialSpecialAbilityCooldown) == 0x000028, "Member 'UEditorUserSettingsJP::bDisableInitialSpecialAbilityCooldown' has a wrong offset!");
static_assert(offsetof(UEditorUserSettingsJP, bForceUseEditorPlayerLoadout) == 0x000029, "Member 'UEditorUserSettingsJP::bForceUseEditorPlayerLoadout' has a wrong offset!");
static_assert(offsetof(UEditorUserSettingsJP, StartingInventory) == 0x000030, "Member 'UEditorUserSettingsJP::StartingInventory' has a wrong offset!");
static_assert(offsetof(UEditorUserSettingsJP, bEnableAutoClientAuthenticationInPlayInEditor) == 0x000040, "Member 'UEditorUserSettingsJP::bEnableAutoClientAuthenticationInPlayInEditor' has a wrong offset!");
static_assert(offsetof(UEditorUserSettingsJP, bAllowServerAuthenticationInPlayInEditor) == 0x000041, "Member 'UEditorUserSettingsJP::bAllowServerAuthenticationInPlayInEditor' has a wrong offset!");
static_assert(offsetof(UEditorUserSettingsJP, EditorLoadoutOverride) == 0x000048, "Member 'UEditorUserSettingsJP::EditorLoadoutOverride' has a wrong offset!");
static_assert(offsetof(UEditorUserSettingsJP, EditorTeamOrderOverride) == 0x000058, "Member 'UEditorUserSettingsJP::EditorTeamOrderOverride' has a wrong offset!");

// Class JP.ObjectiveAction
// 0x0000 (0x0028 - 0x0028)
class UObjectiveAction : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveAction">();
	}
	static class UObjectiveAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveAction>();
	}
};
static_assert(alignof(UObjectiveAction) == 0x000008, "Wrong alignment on UObjectiveAction");
static_assert(sizeof(UObjectiveAction) == 0x000028, "Wrong size on UObjectiveAction");

// Class JP.ObjectiveAction_Reward
// 0x0008 (0x0030 - 0x0028)
class UObjectiveAction_Reward final : public UObjectiveAction
{
public:
	class UObjectiveRewardBase*                   Reward;                                            // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveAction_Reward">();
	}
	static class UObjectiveAction_Reward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveAction_Reward>();
	}
};
static_assert(alignof(UObjectiveAction_Reward) == 0x000008, "Wrong alignment on UObjectiveAction_Reward");
static_assert(sizeof(UObjectiveAction_Reward) == 0x000030, "Wrong size on UObjectiveAction_Reward");
static_assert(offsetof(UObjectiveAction_Reward, Reward) == 0x000028, "Member 'UObjectiveAction_Reward::Reward' has a wrong offset!");

// Class JP.EndTimeBase
// 0x0000 (0x0028 - 0x0028)
class UEndTimeBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTimeBase">();
	}
	static class UEndTimeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTimeBase>();
	}
};
static_assert(alignof(UEndTimeBase) == 0x000008, "Wrong alignment on UEndTimeBase");
static_assert(sizeof(UEndTimeBase) == 0x000028, "Wrong size on UEndTimeBase");

// Class JP.PlayerEconomy
// 0x0050 (0x0078 - 0x0028)
class UPlayerEconomy final : public UObject
{
public:
	float                                         TeamMoneyReceived;                                 // 0x0028(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TeamWoodReceived;                                  // 0x002C(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FResourceData                          Money;                                             // 0x0030(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FResourceData                          Wood;                                              // 0x0038(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FResourceData                          Perfectness;                                       // 0x0040(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	struct FResourceData                          PassiveIncome;                                     // 0x0048(0x0008)(Net, RepNotify, NoDestructor, NativeAccessSpecifierPrivate)
	TArray<struct FResourcePayload>               PersonalEconomyDuringGame;                         // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FTimerHandle                           EconomyOverTimeTimer;                              // 0x0060(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEconomyDefinition*                     EconomyOverTimeDefinition;                         // 0x0068(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Money(struct FResourceData* OldMoney);
	void OnRep_PassiveIncomeAmount(struct FResourceData* OldPassiveIncome);
	void OnRep_Perfectness();
	void OnRep_Wood(struct FResourceData* OldWood);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerEconomy">();
	}
	static class UPlayerEconomy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerEconomy>();
	}
};
static_assert(alignof(UPlayerEconomy) == 0x000008, "Wrong alignment on UPlayerEconomy");
static_assert(sizeof(UPlayerEconomy) == 0x000078, "Wrong size on UPlayerEconomy");
static_assert(offsetof(UPlayerEconomy, TeamMoneyReceived) == 0x000028, "Member 'UPlayerEconomy::TeamMoneyReceived' has a wrong offset!");
static_assert(offsetof(UPlayerEconomy, TeamWoodReceived) == 0x00002C, "Member 'UPlayerEconomy::TeamWoodReceived' has a wrong offset!");
static_assert(offsetof(UPlayerEconomy, Money) == 0x000030, "Member 'UPlayerEconomy::Money' has a wrong offset!");
static_assert(offsetof(UPlayerEconomy, Wood) == 0x000038, "Member 'UPlayerEconomy::Wood' has a wrong offset!");
static_assert(offsetof(UPlayerEconomy, Perfectness) == 0x000040, "Member 'UPlayerEconomy::Perfectness' has a wrong offset!");
static_assert(offsetof(UPlayerEconomy, PassiveIncome) == 0x000048, "Member 'UPlayerEconomy::PassiveIncome' has a wrong offset!");
static_assert(offsetof(UPlayerEconomy, PersonalEconomyDuringGame) == 0x000050, "Member 'UPlayerEconomy::PersonalEconomyDuringGame' has a wrong offset!");
static_assert(offsetof(UPlayerEconomy, EconomyOverTimeTimer) == 0x000060, "Member 'UPlayerEconomy::EconomyOverTimeTimer' has a wrong offset!");
static_assert(offsetof(UPlayerEconomy, EconomyOverTimeDefinition) == 0x000068, "Member 'UPlayerEconomy::EconomyOverTimeDefinition' has a wrong offset!");

// Class JP.EndTime_GameplayMessage
// 0x0008 (0x0030 - 0x0028)
class UEndTime_GameplayMessage final : public UEndTimeBase
{
public:
	struct FGameplayTag                           ChannelTag;                                        // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTime_GameplayMessage">();
	}
	static class UEndTime_GameplayMessage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTime_GameplayMessage>();
	}
};
static_assert(alignof(UEndTime_GameplayMessage) == 0x000008, "Wrong alignment on UEndTime_GameplayMessage");
static_assert(sizeof(UEndTime_GameplayMessage) == 0x000030, "Wrong size on UEndTime_GameplayMessage");
static_assert(offsetof(UEndTime_GameplayMessage, ChannelTag) == 0x000028, "Member 'UEndTime_GameplayMessage::ChannelTag' has a wrong offset!");

// Class JP.EndTime_Timer
// 0x0010 (0x0038 - 0x0028)
class UEndTime_Timer final : public UEndTimeBase
{
public:
	float                                         SecondsUntilEnd;                                   // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UObjectiveInstance*                     RelatedObjective;                                  // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BroadcastTimerEndedGameplayMessage();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EndTime_Timer">();
	}
	static class UEndTime_Timer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEndTime_Timer>();
	}
};
static_assert(alignof(UEndTime_Timer) == 0x000008, "Wrong alignment on UEndTime_Timer");
static_assert(sizeof(UEndTime_Timer) == 0x000038, "Wrong size on UEndTime_Timer");
static_assert(offsetof(UEndTime_Timer, SecondsUntilEnd) == 0x000028, "Member 'UEndTime_Timer::SecondsUntilEnd' has a wrong offset!");
static_assert(offsetof(UEndTime_Timer, RelatedObjective) == 0x000030, "Member 'UEndTime_Timer::RelatedObjective' has a wrong offset!");

// Class JP.ObjectiveDefinition
// 0x0028 (0x0058 - 0x0030)
class UObjectiveDefinition final : public UDataAsset
{
public:
	TArray<class UObjectiveAction*>               Actions;                                           // 0x0030(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USubObjectiveDefinition*>        SubObjectiveDefinitions;                           // 0x0040(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           TooltipTag;                                        // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class UObjectiveAction* FindActionByType(TSubclassOf<class UObjectiveAction> ActionType) const;
	TArray<class UObjectiveAction*> FindActionsByType(TSubclassOf<class UObjectiveAction> ActionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveDefinition">();
	}
	static class UObjectiveDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveDefinition>();
	}
};
static_assert(alignof(UObjectiveDefinition) == 0x000008, "Wrong alignment on UObjectiveDefinition");
static_assert(sizeof(UObjectiveDefinition) == 0x000058, "Wrong size on UObjectiveDefinition");
static_assert(offsetof(UObjectiveDefinition, Actions) == 0x000030, "Member 'UObjectiveDefinition::Actions' has a wrong offset!");
static_assert(offsetof(UObjectiveDefinition, SubObjectiveDefinitions) == 0x000040, "Member 'UObjectiveDefinition::SubObjectiveDefinitions' has a wrong offset!");
static_assert(offsetof(UObjectiveDefinition, TooltipTag) == 0x000050, "Member 'UObjectiveDefinition::TooltipTag' has a wrong offset!");

// Class JP.EnvironmentSelectionWidgetBase
// 0x0020 (0x0300 - 0x02E0)
class UEnvironmentSelectionWidgetBase final : public UUserWidget
{
public:
	TArray<struct FEnvironmentDefinition>         AvailableTitles;                                   // 0x02E0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2F0[0x10];                                     // 0x02F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SelectEnvironment(const struct FEnvironmentDefinition& Environment);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EnvironmentSelectionWidgetBase">();
	}
	static class UEnvironmentSelectionWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEnvironmentSelectionWidgetBase>();
	}
};
static_assert(alignof(UEnvironmentSelectionWidgetBase) == 0x000008, "Wrong alignment on UEnvironmentSelectionWidgetBase");
static_assert(sizeof(UEnvironmentSelectionWidgetBase) == 0x000300, "Wrong size on UEnvironmentSelectionWidgetBase");
static_assert(offsetof(UEnvironmentSelectionWidgetBase, AvailableTitles) == 0x0002E0, "Member 'UEnvironmentSelectionWidgetBase::AvailableTitles' has a wrong offset!");

// Class JP.TeamSetterInterface
// 0x0000 (0x0028 - 0x0028)
class ITeamSetterInterface final : public IInterface
{
public:
	void SetTeam(uint8 NewTeam);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamSetterInterface">();
	}
	static class ITeamSetterInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITeamSetterInterface>();
	}
};
static_assert(alignof(ITeamSetterInterface) == 0x000008, "Wrong alignment on ITeamSetterInterface");
static_assert(sizeof(ITeamSetterInterface) == 0x000028, "Wrong size on ITeamSetterInterface");

// Class JP.EquipmentActorToSpawnModifier_ItemSkins
// 0x0000 (0x0028 - 0x0028)
class UEquipmentActorToSpawnModifier_ItemSkins final : public UEquipmentActorToSpawnModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentActorToSpawnModifier_ItemSkins">();
	}
	static class UEquipmentActorToSpawnModifier_ItemSkins* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentActorToSpawnModifier_ItemSkins>();
	}
};
static_assert(alignof(UEquipmentActorToSpawnModifier_ItemSkins) == 0x000008, "Wrong alignment on UEquipmentActorToSpawnModifier_ItemSkins");
static_assert(sizeof(UEquipmentActorToSpawnModifier_ItemSkins) == 0x000028, "Wrong size on UEquipmentActorToSpawnModifier_ItemSkins");

// Class JP.WorldCallbackSubsystem
// 0x00A0 (0x00E0 - 0x0040)
class UWorldCallbackSubsystem final : public UTickableWorldSubsystem
{
public:
	uint8                                         Pad_40[0xA0];                                      // 0x0040(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldCallbackSubsystem">();
	}
	static class UWorldCallbackSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWorldCallbackSubsystem>();
	}
};
static_assert(alignof(UWorldCallbackSubsystem) == 0x000008, "Wrong alignment on UWorldCallbackSubsystem");
static_assert(sizeof(UWorldCallbackSubsystem) == 0x0000E0, "Wrong size on UWorldCallbackSubsystem");

// Class JP.EULAWidget
// 0x0038 (0x0318 - 0x02E0)
class UEULAWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EulaText;                                          // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TitleText;                                         // 0x0308(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnAgreeButtonClicked();
	void SetEulaText();
	void SetTitleText();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EULAWidget">();
	}
	static class UEULAWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEULAWidget>();
	}
};
static_assert(alignof(UEULAWidget) == 0x000008, "Wrong alignment on UEULAWidget");
static_assert(sizeof(UEULAWidget) == 0x000318, "Wrong size on UEULAWidget");
static_assert(offsetof(UEULAWidget, EulaText) == 0x0002F8, "Member 'UEULAWidget::EulaText' has a wrong offset!");
static_assert(offsetof(UEULAWidget, TitleText) == 0x000308, "Member 'UEULAWidget::TitleText' has a wrong offset!");

// Class JP.FinancesBundlePurchaseListWidget
// 0x0070 (0x0350 - 0x02E0)
class UFinancesBundlePurchaseListWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x10];                                     // 0x02E0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UCommonButtonBase*> BundleButtons;                                     // 0x02F0(0x0050)(BlueprintVisible, ExportObject, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_340[0x10];                                     // 0x0340(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindBundleButtons();
	void OnBundleClicked(const class FString& PlatformID);
	void SetStoreOffers(const TArray<struct FPlatformStoreOffer>& PlatformStoreOffers);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinancesBundlePurchaseListWidget">();
	}
	static class UFinancesBundlePurchaseListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFinancesBundlePurchaseListWidget>();
	}
};
static_assert(alignof(UFinancesBundlePurchaseListWidget) == 0x000008, "Wrong alignment on UFinancesBundlePurchaseListWidget");
static_assert(sizeof(UFinancesBundlePurchaseListWidget) == 0x000350, "Wrong size on UFinancesBundlePurchaseListWidget");
static_assert(offsetof(UFinancesBundlePurchaseListWidget, BundleButtons) == 0x0002F0, "Member 'UFinancesBundlePurchaseListWidget::BundleButtons' has a wrong offset!");

// Class JP.ObjectiveRewardBase
// 0x0000 (0x0028 - 0x0028)
class UObjectiveRewardBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveRewardBase">();
	}
	static class UObjectiveRewardBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveRewardBase>();
	}
};
static_assert(alignof(UObjectiveRewardBase) == 0x000008, "Wrong alignment on UObjectiveRewardBase");
static_assert(sizeof(UObjectiveRewardBase) == 0x000028, "Wrong size on UObjectiveRewardBase");

// Class JP.FinancesWidget
// 0x0038 (0x0318 - 0x02E0)
class UFinancesWidget : public UUserWidget
{
public:
	class UCommonLoadGuard*                       LoadGuard;                                         // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UFinancesBundlePurchaseListWidget*      BundlePurchaseListWidget;                          // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonTextBlock*                       RequiredCurrenciesText;                            // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FPlatformStoreOffer>            StoreOffers;                                       // 0x02F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x8];                                      // 0x0308(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UStorePurchaseOnlineServiceHandler*     StorePurchaseHandler;                              // 0x0310(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ChangeThrobberMessage(const EPlatformStoreState StoreState);
	void DismissThrobber();
	void LoadData();
	void ShowPurchaseErrorModal(const EPlatformStoreState StoreState, const class FString& TransactionId);
	void ShowPurchaseSuccessModal(const bool bWalletUpdateSucceeded, const struct FPlatformStoreOffer& StoreOffer, const class FString& TransactionId);
	void ShowThrobber();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FinancesWidget">();
	}
	static class UFinancesWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFinancesWidget>();
	}
};
static_assert(alignof(UFinancesWidget) == 0x000008, "Wrong alignment on UFinancesWidget");
static_assert(sizeof(UFinancesWidget) == 0x000318, "Wrong size on UFinancesWidget");
static_assert(offsetof(UFinancesWidget, LoadGuard) == 0x0002E0, "Member 'UFinancesWidget::LoadGuard' has a wrong offset!");
static_assert(offsetof(UFinancesWidget, BundlePurchaseListWidget) == 0x0002E8, "Member 'UFinancesWidget::BundlePurchaseListWidget' has a wrong offset!");
static_assert(offsetof(UFinancesWidget, RequiredCurrenciesText) == 0x0002F0, "Member 'UFinancesWidget::RequiredCurrenciesText' has a wrong offset!");
static_assert(offsetof(UFinancesWidget, StoreOffers) == 0x0002F8, "Member 'UFinancesWidget::StoreOffers' has a wrong offset!");
static_assert(offsetof(UFinancesWidget, StorePurchaseHandler) == 0x000310, "Member 'UFinancesWidget::StorePurchaseHandler' has a wrong offset!");

// Class JP.TraceFromPosition
// 0x0000 (0x0028 - 0x0028)
class ITraceFromPosition final : public IInterface
{
public:
	void GetTraceFromPosition(struct FVector* Location, struct FRotator* Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TraceFromPosition">();
	}
	static class ITraceFromPosition* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITraceFromPosition>();
	}
};
static_assert(alignof(ITraceFromPosition) == 0x000008, "Wrong alignment on ITraceFromPosition");
static_assert(sizeof(ITraceFromPosition) == 0x000028, "Wrong size on ITraceFromPosition");

// Class JP.GameDataGameInstanceSubsystem
// 0x0048 (0x0078 - 0x0030)
class UGameDataGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnUpdateGameDataFinishedDelegate;                  // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UUpdateGameDataStepBase*>        Steps;                                             // 0x0040(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceFullUpdateGameData();
	void ForceUpdateGameData(const struct FGameplayTagContainer& KeysToUpdate);
	void SoftFullUpdateGameData();
	void SoftUpdateGameData(const struct FGameplayTagContainer& KeysToUpdate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameDataGameInstanceSubsystem">();
	}
	static class UGameDataGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameDataGameInstanceSubsystem>();
	}
};
static_assert(alignof(UGameDataGameInstanceSubsystem) == 0x000008, "Wrong alignment on UGameDataGameInstanceSubsystem");
static_assert(sizeof(UGameDataGameInstanceSubsystem) == 0x000078, "Wrong size on UGameDataGameInstanceSubsystem");
static_assert(offsetof(UGameDataGameInstanceSubsystem, OnUpdateGameDataFinishedDelegate) == 0x000030, "Member 'UGameDataGameInstanceSubsystem::OnUpdateGameDataFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UGameDataGameInstanceSubsystem, Steps) == 0x000040, "Member 'UGameDataGameInstanceSubsystem::Steps' has a wrong offset!");

// Class JP.GameInstanceJP
// 0x0018 (0x01E8 - 0x01D0)
class UGameInstanceJP : public UCommonGameInstance
{
public:
	bool                                          bMainMenuVisited;                                  // 0x01D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainMenuIntroPlayed;                              // 0x01D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D2[0x6];                                      // 0x01D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             DoReconnect;                                       // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void AcceptToAbandonMatch();
	void CacheNetworkError(ENetworkFailure FailureType);
	void DisplayOkDialog(const class FText& Header, const class FText& Body);
	void K2_ReconnectToGameSession(class UAuthenticationInitialization_RecoverMatch* RecoverMatch);
	void OnHandleNetworkError();
	void OnReconnectAccept__DelegateSignature();
	void ReconnectToGameSession();
	void ReturnToMainMenuAsHostOrClient();
	void ReturnToMainMenuClient();

	class UCommonGameDialogDescriptor* GetOkDialogDescriptor(const class FText& Header, const class FText& Body) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameInstanceJP">();
	}
	static class UGameInstanceJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameInstanceJP>();
	}
};
static_assert(alignof(UGameInstanceJP) == 0x000008, "Wrong alignment on UGameInstanceJP");
static_assert(sizeof(UGameInstanceJP) == 0x0001E8, "Wrong size on UGameInstanceJP");
static_assert(offsetof(UGameInstanceJP, bMainMenuVisited) == 0x0001D0, "Member 'UGameInstanceJP::bMainMenuVisited' has a wrong offset!");
static_assert(offsetof(UGameInstanceJP, bMainMenuIntroPlayed) == 0x0001D1, "Member 'UGameInstanceJP::bMainMenuIntroPlayed' has a wrong offset!");
static_assert(offsetof(UGameInstanceJP, DoReconnect) == 0x0001D8, "Member 'UGameInstanceJP::DoReconnect' has a wrong offset!");

// Class JP.ObjectiveTrackingManager
// 0x0020 (0x00C0 - 0x00A0)
class UObjectiveTrackingManager final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnObjectiveTrackingChanged;                        // 0x00A0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FObjectiveTracker>              ObjectiveTrackers;                                 // 0x00B0(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void ChangeTrackedObjective(class APlayerStateJP* PlayerState);
	bool IsTrackingObjective(class APlayerStateJP* PlayerState, class UObjectiveDefinition* ObjectiveDefinition);
	void ObjectiveTrackingDelegate__DelegateSignature(const TArray<struct FObjectiveTracker>& ObjectiveTrackers_0);
	void OnRep_ObjectiveTrackers();
	void RemoveTrackersForObjective(const struct FObjectiveAndOwningPlayer& ObjectiveDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveTrackingManager">();
	}
	static class UObjectiveTrackingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveTrackingManager>();
	}
};
static_assert(alignof(UObjectiveTrackingManager) == 0x000008, "Wrong alignment on UObjectiveTrackingManager");
static_assert(sizeof(UObjectiveTrackingManager) == 0x0000C0, "Wrong size on UObjectiveTrackingManager");
static_assert(offsetof(UObjectiveTrackingManager, OnObjectiveTrackingChanged) == 0x0000A0, "Member 'UObjectiveTrackingManager::OnObjectiveTrackingChanged' has a wrong offset!");
static_assert(offsetof(UObjectiveTrackingManager, ObjectiveTrackers) == 0x0000B0, "Member 'UObjectiveTrackingManager::ObjectiveTrackers' has a wrong offset!");

// Class JP.GameModeJP_MainMenu
// 0x0008 (0x03C8 - 0x03C0)
class AGameModeJP_MainMenu : public AGameModeJP
{
public:
	class USanctionsSubsystem*                    SanctionsSubsystem;                                // 0x03C0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnExperienceLoaded(const class UExperienceDefinition* Definition);
	void ShowUserWasBannedDialog(class UCommonGameDialogDescriptor* Descriptor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeJP_MainMenu">();
	}
	static class AGameModeJP_MainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeJP_MainMenu>();
	}
};
static_assert(alignof(AGameModeJP_MainMenu) == 0x000008, "Wrong alignment on AGameModeJP_MainMenu");
static_assert(sizeof(AGameModeJP_MainMenu) == 0x0003C8, "Wrong size on AGameModeJP_MainMenu");
static_assert(offsetof(AGameModeJP_MainMenu, SanctionsSubsystem) == 0x0003C0, "Member 'AGameModeJP_MainMenu::SanctionsSubsystem' has a wrong offset!");

// Class JP.GameModeJP_Tutorial
// 0x0000 (0x0468 - 0x0468)
class AGameModeJP_Tutorial final : public AGameModeJP_Match
{
public:
	void K2_ExperienceLoaded();
	void OnExperienceLoaded(const class UExperienceDefinition* Definition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameModeJP_Tutorial">();
	}
	static class AGameModeJP_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameModeJP_Tutorial>();
	}
};
static_assert(alignof(AGameModeJP_Tutorial) == 0x000008, "Wrong alignment on AGameModeJP_Tutorial");
static_assert(sizeof(AGameModeJP_Tutorial) == 0x000468, "Wrong size on AGameModeJP_Tutorial");

// Class JP.GameplayAbilityJP
// 0x0008 (0x03B8 - 0x03B0)
class UGameplayAbilityJP : public UGameplayAbility
{
public:
	ECharacterInput                               Input;                                             // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEndOnInputRelease;                                // 0x03B1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B2[0x6];                                      // 0x03B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnInputReleased(float TimeHeld);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbilityJP">();
	}
	static class UGameplayAbilityJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityJP>();
	}
};
static_assert(alignof(UGameplayAbilityJP) == 0x000008, "Wrong alignment on UGameplayAbilityJP");
static_assert(sizeof(UGameplayAbilityJP) == 0x0003B8, "Wrong size on UGameplayAbilityJP");
static_assert(offsetof(UGameplayAbilityJP, Input) == 0x0003B0, "Member 'UGameplayAbilityJP::Input' has a wrong offset!");
static_assert(offsetof(UGameplayAbilityJP, bEndOnInputRelease) == 0x0003B1, "Member 'UGameplayAbilityJP::bEndOnInputRelease' has a wrong offset!");

// Class JP.ShopWidgetItemDetails
// 0x0000 (0x02E0 - 0x02E0)
class UShopWidgetItemDetails : public UUserWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopWidgetItemDetails">();
	}
	static class UShopWidgetItemDetails* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopWidgetItemDetails>();
	}
};
static_assert(alignof(UShopWidgetItemDetails) == 0x000008, "Wrong alignment on UShopWidgetItemDetails");
static_assert(sizeof(UShopWidgetItemDetails) == 0x0002E0, "Wrong size on UShopWidgetItemDetails");

// Class JP.GameplayAbility_NeighborSpecialAbilityBase
// 0x0030 (0x0490 - 0x0460)
class UGameplayAbility_NeighborSpecialAbilityBase final : public UGameplayAbilityIW
{
public:
	TSoftObjectPtr<class UNeighborSpecialAbilityDefinition> Definition;                                        // 0x0460(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_488[0x8];                                      // 0x0488(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UNeighborSpecialAbilityDefinition* GetDefinitionFromSourceObject(TSubclassOf<class UNeighborSpecialAbilityDefinition> DefinitionType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbility_NeighborSpecialAbilityBase">();
	}
	static class UGameplayAbility_NeighborSpecialAbilityBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbility_NeighborSpecialAbilityBase>();
	}
};
static_assert(alignof(UGameplayAbility_NeighborSpecialAbilityBase) == 0x000010, "Wrong alignment on UGameplayAbility_NeighborSpecialAbilityBase");
static_assert(sizeof(UGameplayAbility_NeighborSpecialAbilityBase) == 0x000490, "Wrong size on UGameplayAbility_NeighborSpecialAbilityBase");
static_assert(offsetof(UGameplayAbility_NeighborSpecialAbilityBase, Definition) == 0x000460, "Member 'UGameplayAbility_NeighborSpecialAbilityBase::Definition' has a wrong offset!");

// Class JP.GameSessionJP
// 0x0000 (0x02B8 - 0x02B8)
class AGameSessionJP final : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameSessionJP">();
	}
	static class AGameSessionJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameSessionJP>();
	}
};
static_assert(alignof(AGameSessionJP) == 0x000008, "Wrong alignment on AGameSessionJP");
static_assert(sizeof(AGameSessionJP) == 0x0002B8, "Wrong size on AGameSessionJP");

// Class JP.GameStateJP
// 0x0128 (0x0430 - 0x0308)
class AGameStateJP : public AModularGameState
{
public:
	FMulticastInlineDelegateProperty_             OnGameStarted;                                     // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameEnded;                                       // 0x0318(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamAdded;                                       // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamChanged;                                     // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateAdded;                                // 0x0348(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPlayerStateRemoved;                              // 0x0358(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnServerDebugInformationReplicated;                // 0x0368(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<struct FTeam>                          Teams;                                             // 0x0378(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_388[0x4];                                      // 0x0388(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsQuickPlayMatch;                                 // 0x038C(0x0001)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_38D[0x3];                                      // 0x038D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FServerDebugInformation                ServerDebugInformation;                            // 0x0390(0x0030)(Net, RepNotify, NativeAccessSpecifierPrivate)
	TArray<struct FTeam>                          CachedTeams;                                       // 0x03C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	bool                                          bHasGameEnded;                                     // 0x03D0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchConfiguration                    ReplicatedMatchConfiguration;                      // 0x03D8(0x0058)(Net, RepNotify, NativeAccessSpecifierPrivate)

public:
	static void SendTeamMessage(uint8 TeamId, const class FName InMessage, class UObject* WorldContextObject);

	void DisplayMessageToLocalPlayer(class FName Message);
	void DoSendTeamMessage(const uint8 InTeamID, const class FName InMessage);
	void GameEnded();
	TArray<uint8> GetAliveTeams();
	TArray<uint8> GetEliminatedTeams();
	const struct FTeam GetTeam(uint8 TeamId);
	uint8 GetWinningTeam();
	void HandleOwnedHousesChanged(class APlayerStateJP* PlayerState, const TArray<struct FGameplayTag>& NewOwnedHouses);
	void HandlePlayerStateAdded(class APlayerState* PlayerState);
	void HandlePlayerStateRemoved(class APlayerState* PlayerState);
	void OnRep_MatchConfiguration();
	void OnRep_ServerDebugInformation();
	void OnRep_Teams();
	void QueryBroadcastTeamChange();
	void SendMessageToPlayerController(const class FString& Message, const EMessageType& Type, class APlayerControllerJP* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateJP">();
	}
	static class AGameStateJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateJP>();
	}
};
static_assert(alignof(AGameStateJP) == 0x000008, "Wrong alignment on AGameStateJP");
static_assert(sizeof(AGameStateJP) == 0x000430, "Wrong size on AGameStateJP");
static_assert(offsetof(AGameStateJP, OnGameStarted) == 0x000308, "Member 'AGameStateJP::OnGameStarted' has a wrong offset!");
static_assert(offsetof(AGameStateJP, OnGameEnded) == 0x000318, "Member 'AGameStateJP::OnGameEnded' has a wrong offset!");
static_assert(offsetof(AGameStateJP, OnTeamAdded) == 0x000328, "Member 'AGameStateJP::OnTeamAdded' has a wrong offset!");
static_assert(offsetof(AGameStateJP, OnTeamChanged) == 0x000338, "Member 'AGameStateJP::OnTeamChanged' has a wrong offset!");
static_assert(offsetof(AGameStateJP, OnPlayerStateAdded) == 0x000348, "Member 'AGameStateJP::OnPlayerStateAdded' has a wrong offset!");
static_assert(offsetof(AGameStateJP, OnPlayerStateRemoved) == 0x000358, "Member 'AGameStateJP::OnPlayerStateRemoved' has a wrong offset!");
static_assert(offsetof(AGameStateJP, OnServerDebugInformationReplicated) == 0x000368, "Member 'AGameStateJP::OnServerDebugInformationReplicated' has a wrong offset!");
static_assert(offsetof(AGameStateJP, Teams) == 0x000378, "Member 'AGameStateJP::Teams' has a wrong offset!");
static_assert(offsetof(AGameStateJP, bIsQuickPlayMatch) == 0x00038C, "Member 'AGameStateJP::bIsQuickPlayMatch' has a wrong offset!");
static_assert(offsetof(AGameStateJP, ServerDebugInformation) == 0x000390, "Member 'AGameStateJP::ServerDebugInformation' has a wrong offset!");
static_assert(offsetof(AGameStateJP, CachedTeams) == 0x0003C0, "Member 'AGameStateJP::CachedTeams' has a wrong offset!");
static_assert(offsetof(AGameStateJP, bHasGameEnded) == 0x0003D0, "Member 'AGameStateJP::bHasGameEnded' has a wrong offset!");
static_assert(offsetof(AGameStateJP, ReplicatedMatchConfiguration) == 0x0003D8, "Member 'AGameStateJP::ReplicatedMatchConfiguration' has a wrong offset!");

// Class JP.GameStateJP_Lobby
// 0x0018 (0x0448 - 0x0430)
class AGameStateJP_Lobby final : public AGameStateJP
{
public:
	class ULobbyTravelComponent*                  LobbyTravelComponent;                              // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelVoteComponent*                    LevelVoteComponent;                                // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULobbyReadyComponent*                   LobbyReadyComponent;                               // 0x0440(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void HandleBackfillError(class UCommonGameDialogDescriptor* Descriptor);

	TArray<class APlayerStateJP_Lobby*> GetLobbyPlayerStatesArray() const;
	TMap<uint8, struct FLobbyPlayerStateGroup> GetLobbyPlayerStatesArrayGroupedByTeamId(const bool IncludeInvalidTeamID) const;
	TArray<struct FLobbyPlayerStateGroup> GetLobbyPlayerStatesArrayGroupedByTeamIdAsArray(const bool IncludeInvalidTeamID) const;
	struct FLobbyPlayerStateGroup GetLobbyPlayerStatesByTeamId(const uint8 TeamId) const;
	void ReturnToMainMenu() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateJP_Lobby">();
	}
	static class AGameStateJP_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateJP_Lobby>();
	}
};
static_assert(alignof(AGameStateJP_Lobby) == 0x000008, "Wrong alignment on AGameStateJP_Lobby");
static_assert(sizeof(AGameStateJP_Lobby) == 0x000448, "Wrong size on AGameStateJP_Lobby");
static_assert(offsetof(AGameStateJP_Lobby, LobbyTravelComponent) == 0x000430, "Member 'AGameStateJP_Lobby::LobbyTravelComponent' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Lobby, LevelVoteComponent) == 0x000438, "Member 'AGameStateJP_Lobby::LevelVoteComponent' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Lobby, LobbyReadyComponent) == 0x000440, "Member 'AGameStateJP_Lobby::LobbyReadyComponent' has a wrong offset!");

// Class JP.SimpleInventoryItemsRequest
// 0x0098 (0x00C0 - 0x0028)
class USimpleInventoryItemsRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x50];                                      // 0x0028(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UOnlineItemCacheSubsystem*              ItemCacheSystem;                                   // 0x0078(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USharedEconomyOnlineServiceHandler*     EconomyHandler;                                    // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x38];                                      // 0x0088(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SimpleInventoryItemsRequest">();
	}
	static class USimpleInventoryItemsRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<USimpleInventoryItemsRequest>();
	}
};
static_assert(alignof(USimpleInventoryItemsRequest) == 0x000008, "Wrong alignment on USimpleInventoryItemsRequest");
static_assert(sizeof(USimpleInventoryItemsRequest) == 0x0000C0, "Wrong size on USimpleInventoryItemsRequest");
static_assert(offsetof(USimpleInventoryItemsRequest, ItemCacheSystem) == 0x000078, "Member 'USimpleInventoryItemsRequest::ItemCacheSystem' has a wrong offset!");
static_assert(offsetof(USimpleInventoryItemsRequest, EconomyHandler) == 0x000080, "Member 'USimpleInventoryItemsRequest::EconomyHandler' has a wrong offset!");

// Class JP.GameStateJP_Match
// 0x0068 (0x0498 - 0x0430)
class AGameStateJP_Match : public AGameStateJP
{
public:
	TArray<class UPlayerMatchRecord*>             PlayerMatchRecordList;                             // 0x0430(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class ARoomManager*>                   FoundRoomManagers;                                 // 0x0440(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	class UHotjoinMatchComponent*                 HotjoinMatchComponent;                             // 0x0450(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HotJoinTimeLimit;                                  // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AEndCondition*>                  ActiveEndConditions;                               // 0x0460(0x0010)(Net, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class AEndCondition*                          FinalEndCondition;                                 // 0x0470(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UObjectiveTrackingManager*              ObjectiveTrackingManager;                          // 0x0478(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UShopManagerComponent*                  ShopManagerComponent;                              // 0x0480(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExpectedRoomManagerCount;                          // 0x0488(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48C[0xC];                                      // 0x048C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinalEndConditionSet(class AEndCondition* EndCondition);
	void OnMatchEnded();
	void OnRep_FinalEndCondition();

	bool AreAllRoomManagersFound() const;
	class AEndCondition* GetFinalEndCondition() const;
	const TArray<class ARoomManager*> GetFoundRoomManagers() const;
	struct FMatchPlayerStateGroup GetMatchPlayerStatesByTeamId(const uint8 TeamId) const;
	bool HasFinalEndCondition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateJP_Match">();
	}
	static class AGameStateJP_Match* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateJP_Match>();
	}
};
static_assert(alignof(AGameStateJP_Match) == 0x000008, "Wrong alignment on AGameStateJP_Match");
static_assert(sizeof(AGameStateJP_Match) == 0x000498, "Wrong size on AGameStateJP_Match");
static_assert(offsetof(AGameStateJP_Match, PlayerMatchRecordList) == 0x000430, "Member 'AGameStateJP_Match::PlayerMatchRecordList' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Match, FoundRoomManagers) == 0x000440, "Member 'AGameStateJP_Match::FoundRoomManagers' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Match, HotjoinMatchComponent) == 0x000450, "Member 'AGameStateJP_Match::HotjoinMatchComponent' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Match, HotJoinTimeLimit) == 0x000458, "Member 'AGameStateJP_Match::HotJoinTimeLimit' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Match, ActiveEndConditions) == 0x000460, "Member 'AGameStateJP_Match::ActiveEndConditions' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Match, FinalEndCondition) == 0x000470, "Member 'AGameStateJP_Match::FinalEndCondition' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Match, ObjectiveTrackingManager) == 0x000478, "Member 'AGameStateJP_Match::ObjectiveTrackingManager' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Match, ShopManagerComponent) == 0x000480, "Member 'AGameStateJP_Match::ShopManagerComponent' has a wrong offset!");
static_assert(offsetof(AGameStateJP_Match, ExpectedRoomManagerCount) == 0x000488, "Member 'AGameStateJP_Match::ExpectedRoomManagerCount' has a wrong offset!");

// Class JP.LyraPlatformSpecificRenderingSettings
// 0x0038 (0x0078 - 0x0040)
class ULyraPlatformSpecificRenderingSettings final : public UPlatformSettings
{
public:
	class FString                                 DefaultDeviceProfileSuffix;                        // 0x0040(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLyraQualityDeviceProfileVariant> UserFacingDeviceProfileOptions;                    // 0x0050(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bSupportsGranularVideoQualitySettings;             // 0x0060(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSupportsAutomaticVideoQualityBenchmark;           // 0x0061(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELyraFramePacingMode                          FramePacingMode;                                   // 0x0062(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MobileFrameRateLimits;                             // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlatformSpecificRenderingSettings">();
	}
	static class ULyraPlatformSpecificRenderingSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPlatformSpecificRenderingSettings>();
	}
};
static_assert(alignof(ULyraPlatformSpecificRenderingSettings) == 0x000008, "Wrong alignment on ULyraPlatformSpecificRenderingSettings");
static_assert(sizeof(ULyraPlatformSpecificRenderingSettings) == 0x000078, "Wrong size on ULyraPlatformSpecificRenderingSettings");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, DefaultDeviceProfileSuffix) == 0x000040, "Member 'ULyraPlatformSpecificRenderingSettings::DefaultDeviceProfileSuffix' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, UserFacingDeviceProfileOptions) == 0x000050, "Member 'ULyraPlatformSpecificRenderingSettings::UserFacingDeviceProfileOptions' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, bSupportsGranularVideoQualitySettings) == 0x000060, "Member 'ULyraPlatformSpecificRenderingSettings::bSupportsGranularVideoQualitySettings' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, bSupportsAutomaticVideoQualityBenchmark) == 0x000061, "Member 'ULyraPlatformSpecificRenderingSettings::bSupportsAutomaticVideoQualityBenchmark' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, FramePacingMode) == 0x000062, "Member 'ULyraPlatformSpecificRenderingSettings::FramePacingMode' has a wrong offset!");
static_assert(offsetof(ULyraPlatformSpecificRenderingSettings, MobileFrameRateLimits) == 0x000068, "Member 'ULyraPlatformSpecificRenderingSettings::MobileFrameRateLimits' has a wrong offset!");

// Class JP.GameStateJP_Tutorial
// 0x0008 (0x04A0 - 0x0498)
class AGameStateJP_Tutorial final : public AGameStateJP_Match
{
public:
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameStateJP_Tutorial">();
	}
	static class AGameStateJP_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGameStateJP_Tutorial>();
	}
};
static_assert(alignof(AGameStateJP_Tutorial) == 0x000008, "Wrong alignment on AGameStateJP_Tutorial");
static_assert(sizeof(AGameStateJP_Tutorial) == 0x0004A0, "Wrong size on AGameStateJP_Tutorial");

// Class JP.GA_ContinuousTrace
// 0x0050 (0x04B0 - 0x0460)
class UGA_ContinuousTrace : public UGameplayAbilityIW
{
public:
	TArray<struct FHitResult>                     AcceptedHits;                                      // 0x0460(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UAbilityTask_RepeatContinuous*          RepeatContinuousTask;                              // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Range;                                             // 0x0478(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Width;                                             // 0x0480(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_484[0x4];                                      // 0x0484(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class IInterface>                 Interface;                                         // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Debug;                                             // 0x0490(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_491[0x7];                                      // 0x0491(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0498(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A8[0x8];                                      // 0x04A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PerformTrace(int32 ActionNumber);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_ContinuousTrace">();
	}
	static class UGA_ContinuousTrace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_ContinuousTrace>();
	}
};
static_assert(alignof(UGA_ContinuousTrace) == 0x000010, "Wrong alignment on UGA_ContinuousTrace");
static_assert(sizeof(UGA_ContinuousTrace) == 0x0004B0, "Wrong size on UGA_ContinuousTrace");
static_assert(offsetof(UGA_ContinuousTrace, AcceptedHits) == 0x000460, "Member 'UGA_ContinuousTrace::AcceptedHits' has a wrong offset!");
static_assert(offsetof(UGA_ContinuousTrace, RepeatContinuousTask) == 0x000470, "Member 'UGA_ContinuousTrace::RepeatContinuousTask' has a wrong offset!");
static_assert(offsetof(UGA_ContinuousTrace, Range) == 0x000478, "Member 'UGA_ContinuousTrace::Range' has a wrong offset!");
static_assert(offsetof(UGA_ContinuousTrace, Height) == 0x00047C, "Member 'UGA_ContinuousTrace::Height' has a wrong offset!");
static_assert(offsetof(UGA_ContinuousTrace, Width) == 0x000480, "Member 'UGA_ContinuousTrace::Width' has a wrong offset!");
static_assert(offsetof(UGA_ContinuousTrace, Interface) == 0x000488, "Member 'UGA_ContinuousTrace::Interface' has a wrong offset!");
static_assert(offsetof(UGA_ContinuousTrace, Debug) == 0x000490, "Member 'UGA_ContinuousTrace::Debug' has a wrong offset!");
static_assert(offsetof(UGA_ContinuousTrace, ObjectTypes) == 0x000498, "Member 'UGA_ContinuousTrace::ObjectTypes' has a wrong offset!");

// Class JP.GA_Passive
// 0x0010 (0x0490 - 0x0480)
class UGA_Passive final : public UGameplayAbilityEquipment
{
public:
	bool                                          ActivateAbilityOnGranted;                          // 0x0480(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_481[0xF];                                      // 0x0481(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GA_Passive">();
	}
	static class UGA_Passive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGA_Passive>();
	}
};
static_assert(alignof(UGA_Passive) == 0x000010, "Wrong alignment on UGA_Passive");
static_assert(sizeof(UGA_Passive) == 0x000490, "Wrong size on UGA_Passive");
static_assert(offsetof(UGA_Passive, ActivateAbilityOnGranted) == 0x000480, "Member 'UGA_Passive::ActivateAbilityOnGranted' has a wrong offset!");

// Class JP.SocialBlockedPlayersListWidget
// 0x0038 (0x0318 - 0x02E0)
class USocialBlockedPlayersListWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialListWidget*                      BaseWidget;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraListView*                          ListView;                                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UBlockedPlayerEntryViewModel*>   BlockedPlayersList;                                // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BlueprintOnUnblockPlayerFailed();
	void UpdateBlockedPlayersList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialBlockedPlayersListWidget">();
	}
	static class USocialBlockedPlayersListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialBlockedPlayersListWidget>();
	}
};
static_assert(alignof(USocialBlockedPlayersListWidget) == 0x000008, "Wrong alignment on USocialBlockedPlayersListWidget");
static_assert(sizeof(USocialBlockedPlayersListWidget) == 0x000318, "Wrong size on USocialBlockedPlayersListWidget");
static_assert(offsetof(USocialBlockedPlayersListWidget, BaseWidget) == 0x0002E8, "Member 'USocialBlockedPlayersListWidget::BaseWidget' has a wrong offset!");
static_assert(offsetof(USocialBlockedPlayersListWidget, ListView) == 0x0002F0, "Member 'USocialBlockedPlayersListWidget::ListView' has a wrong offset!");
static_assert(offsetof(USocialBlockedPlayersListWidget, SocialGIS) == 0x0002F8, "Member 'USocialBlockedPlayersListWidget::SocialGIS' has a wrong offset!");
static_assert(offsetof(USocialBlockedPlayersListWidget, BlockedPlayersList) == 0x000308, "Member 'USocialBlockedPlayersListWidget::BlockedPlayersList' has a wrong offset!");

// Class JP.PerkSelectPopupWidgetBase
// 0x0048 (0x0478 - 0x0430)
class UPerkSelectPopupWidgetBase : public UCommonActivatableWidget
{
public:
	class UPanelWidget*                           PanelWidget;                                       // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UPerkSelectEntry>           EntryWidgetClass;                                  // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MinimumEntryCount;                                 // 0x0440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LocalPlayerNeighborId;                             // 0x0444(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           LocalPlayerEquippedPerkId;                         // 0x044C(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_454[0x4];                                      // 0x0454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPerkAndLevelRequirement>       AvailablePerks;                                    // 0x0458(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UPerkSelectEntry*>               EntryWidgets;                                      // 0x0468(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void DismissPopup();
	void SelectEntry(class UPerkSelectEntry* EntryWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkSelectPopupWidgetBase">();
	}
	static class UPerkSelectPopupWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkSelectPopupWidgetBase>();
	}
};
static_assert(alignof(UPerkSelectPopupWidgetBase) == 0x000008, "Wrong alignment on UPerkSelectPopupWidgetBase");
static_assert(sizeof(UPerkSelectPopupWidgetBase) == 0x000478, "Wrong size on UPerkSelectPopupWidgetBase");
static_assert(offsetof(UPerkSelectPopupWidgetBase, PanelWidget) == 0x000430, "Member 'UPerkSelectPopupWidgetBase::PanelWidget' has a wrong offset!");
static_assert(offsetof(UPerkSelectPopupWidgetBase, EntryWidgetClass) == 0x000438, "Member 'UPerkSelectPopupWidgetBase::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UPerkSelectPopupWidgetBase, MinimumEntryCount) == 0x000440, "Member 'UPerkSelectPopupWidgetBase::MinimumEntryCount' has a wrong offset!");
static_assert(offsetof(UPerkSelectPopupWidgetBase, LocalPlayerNeighborId) == 0x000444, "Member 'UPerkSelectPopupWidgetBase::LocalPlayerNeighborId' has a wrong offset!");
static_assert(offsetof(UPerkSelectPopupWidgetBase, LocalPlayerEquippedPerkId) == 0x00044C, "Member 'UPerkSelectPopupWidgetBase::LocalPlayerEquippedPerkId' has a wrong offset!");
static_assert(offsetof(UPerkSelectPopupWidgetBase, AvailablePerks) == 0x000458, "Member 'UPerkSelectPopupWidgetBase::AvailablePerks' has a wrong offset!");
static_assert(offsetof(UPerkSelectPopupWidgetBase, EntryWidgets) == 0x000468, "Member 'UPerkSelectPopupWidgetBase::EntryWidgets' has a wrong offset!");

// Class JP.GeneralPerkSelectPopupWidget
// 0x0000 (0x0478 - 0x0478)
class UGeneralPerkSelectPopupWidget final : public UPerkSelectPopupWidgetBase
{
public:
	void BlueprintHandleEntryWidgetCreated(class UPerkSelectEntry* EntryWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GeneralPerkSelectPopupWidget">();
	}
	static class UGeneralPerkSelectPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGeneralPerkSelectPopupWidget>();
	}
};
static_assert(alignof(UGeneralPerkSelectPopupWidget) == 0x000008, "Wrong alignment on UGeneralPerkSelectPopupWidget");
static_assert(sizeof(UGeneralPerkSelectPopupWidget) == 0x000478, "Wrong size on UGeneralPerkSelectPopupWidget");

// Class JP.GetServerDebugInformationAsyncAction
// 0x0010 (0x0040 - 0x0030)
class UGetServerDebugInformationAsyncAction final : public UBlueprintAsyncActionBase
{
public:
	FMulticastInlineDelegateProperty_             OnReady;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UGetServerDebugInformationAsyncAction* GetServerDebugInformation(class UObject* WorldContextObject);

	void OnServerDebugInformationReady(const struct FServerDebugInformation& Information);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetServerDebugInformationAsyncAction">();
	}
	static class UGetServerDebugInformationAsyncAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetServerDebugInformationAsyncAction>();
	}
};
static_assert(alignof(UGetServerDebugInformationAsyncAction) == 0x000008, "Wrong alignment on UGetServerDebugInformationAsyncAction");
static_assert(sizeof(UGetServerDebugInformationAsyncAction) == 0x000040, "Wrong size on UGetServerDebugInformationAsyncAction");
static_assert(offsetof(UGetServerDebugInformationAsyncAction, OnReady) == 0x000030, "Member 'UGetServerDebugInformationAsyncAction::OnReady' has a wrong offset!");

// Class JP.GE_EC_ActiveDuration
// 0x0000 (0x0040 - 0x0040)
class UGE_EC_ActiveDuration final : public UGameplayEffectExecutionCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GE_EC_ActiveDuration">();
	}
	static class UGE_EC_ActiveDuration* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGE_EC_ActiveDuration>();
	}
};
static_assert(alignof(UGE_EC_ActiveDuration) == 0x000008, "Wrong alignment on UGE_EC_ActiveDuration");
static_assert(sizeof(UGE_EC_ActiveDuration) == 0x000040, "Wrong size on UGE_EC_ActiveDuration");

// Class JP.SocialFriendsListWidget
// 0x0040 (0x0320 - 0x02E0)
class USocialFriendsListWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialListWidget*                      BaseWidget;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraListView*                          ListView;                                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x10];                                     // 0x0300(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UFriendEntryViewModel*>          FriendsList;                                       // 0x0310(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void OnPartyChanged();
	void UpdateFriendsList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialFriendsListWidget">();
	}
	static class USocialFriendsListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialFriendsListWidget>();
	}
};
static_assert(alignof(USocialFriendsListWidget) == 0x000008, "Wrong alignment on USocialFriendsListWidget");
static_assert(sizeof(USocialFriendsListWidget) == 0x000320, "Wrong size on USocialFriendsListWidget");
static_assert(offsetof(USocialFriendsListWidget, BaseWidget) == 0x0002E8, "Member 'USocialFriendsListWidget::BaseWidget' has a wrong offset!");
static_assert(offsetof(USocialFriendsListWidget, ListView) == 0x0002F0, "Member 'USocialFriendsListWidget::ListView' has a wrong offset!");
static_assert(offsetof(USocialFriendsListWidget, SocialGIS) == 0x0002F8, "Member 'USocialFriendsListWidget::SocialGIS' has a wrong offset!");
static_assert(offsetof(USocialFriendsListWidget, FriendsList) == 0x000310, "Member 'USocialFriendsListWidget::FriendsList' has a wrong offset!");

// Class JP.GroundsKeeper
// 0x0038 (0x02C8 - 0x0290)
class AGroundsKeeper : public AActor
{
public:
	uint8                                         SelectedTeamID;                                    // 0x0290(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UBoxComponent*                          Box;                                               // 0x0298(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnTeamChanged;                                     // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UObjectivesComponent*                   ObjectivesComponent;                               // 0x02B0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObjectiveManagerComponent*             ObjectiveManagerComponent;                         // 0x02B8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         TeamId;                                            // 0x02C0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_TeamID();
	void SubscribeToTeamEvents();

	struct FTeam GetTeam() const;
	uint8 GetTeamID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundsKeeper">();
	}
	static class AGroundsKeeper* GetDefaultObj()
	{
		return GetDefaultObjImpl<AGroundsKeeper>();
	}
};
static_assert(alignof(AGroundsKeeper) == 0x000008, "Wrong alignment on AGroundsKeeper");
static_assert(sizeof(AGroundsKeeper) == 0x0002C8, "Wrong size on AGroundsKeeper");
static_assert(offsetof(AGroundsKeeper, SelectedTeamID) == 0x000290, "Member 'AGroundsKeeper::SelectedTeamID' has a wrong offset!");
static_assert(offsetof(AGroundsKeeper, Box) == 0x000298, "Member 'AGroundsKeeper::Box' has a wrong offset!");
static_assert(offsetof(AGroundsKeeper, OnTeamChanged) == 0x0002A0, "Member 'AGroundsKeeper::OnTeamChanged' has a wrong offset!");
static_assert(offsetof(AGroundsKeeper, ObjectivesComponent) == 0x0002B0, "Member 'AGroundsKeeper::ObjectivesComponent' has a wrong offset!");
static_assert(offsetof(AGroundsKeeper, ObjectiveManagerComponent) == 0x0002B8, "Member 'AGroundsKeeper::ObjectiveManagerComponent' has a wrong offset!");
static_assert(offsetof(AGroundsKeeper, TeamId) == 0x0002C0, "Member 'AGroundsKeeper::TeamId' has a wrong offset!");

// Class JP.GroundskeeperReference
// 0x00A0 (0x02D0 - 0x0230)
class UGroundskeeperReference final : public USceneComponent
{
public:
	uint8                                         Pad_230[0x18];                                     // 0x0230(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bRecalculateGroundsKeeperOwnerOnBeginPlay;         // 0x0248(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableAutoFindGroundsKeeperOnMove;                // 0x0249(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_24A[0x6];                                      // 0x024A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class AGroundsKeeper>          GroundsKeeperOverride;                             // 0x0250(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AGroundskeeperProxy>     GroundskeeperProxy;                                // 0x0278(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AGroundsKeeper>          GroundsKeeperAutoFound;                            // 0x02A0(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPrintWarningIfMissingReference;                   // 0x02C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C9[0x7];                                      // 0x02C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearGroundsKeeperOwner();
	void RecalculateGroundsKeeperOwner();
	void SetGroundskeeperOverride(class AGroundsKeeper* NewGroundskeeper);

	class AGroundsKeeper* GetGroundsKeeper() const;
	const struct FTeam GetTeam() const;
	bool HasReference() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GroundskeeperReference">();
	}
	static class UGroundskeeperReference* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGroundskeeperReference>();
	}
};
static_assert(alignof(UGroundskeeperReference) == 0x000010, "Wrong alignment on UGroundskeeperReference");
static_assert(sizeof(UGroundskeeperReference) == 0x0002D0, "Wrong size on UGroundskeeperReference");
static_assert(offsetof(UGroundskeeperReference, bRecalculateGroundsKeeperOwnerOnBeginPlay) == 0x000248, "Member 'UGroundskeeperReference::bRecalculateGroundsKeeperOwnerOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UGroundskeeperReference, bEnableAutoFindGroundsKeeperOnMove) == 0x000249, "Member 'UGroundskeeperReference::bEnableAutoFindGroundsKeeperOnMove' has a wrong offset!");
static_assert(offsetof(UGroundskeeperReference, GroundsKeeperOverride) == 0x000250, "Member 'UGroundskeeperReference::GroundsKeeperOverride' has a wrong offset!");
static_assert(offsetof(UGroundskeeperReference, GroundskeeperProxy) == 0x000278, "Member 'UGroundskeeperReference::GroundskeeperProxy' has a wrong offset!");
static_assert(offsetof(UGroundskeeperReference, GroundsKeeperAutoFound) == 0x0002A0, "Member 'UGroundskeeperReference::GroundsKeeperAutoFound' has a wrong offset!");
static_assert(offsetof(UGroundskeeperReference, bPrintWarningIfMissingReference) == 0x0002C8, "Member 'UGroundskeeperReference::bPrintWarningIfMissingReference' has a wrong offset!");

// Class JP.GSInteractable
// 0x0000 (0x0028 - 0x0028)
class IGSInteractable final : public IInterface
{
public:
	void CancelInteraction(class UPrimitiveComponent* InteractionComponent);
	void InteractableCancelInteraction(class UPrimitiveComponent* InteractionComponent);
	void PostInteract(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent);
	void PreInteract(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent);
	void RegisterInteracter(class UPrimitiveComponent* InteractionComponent, class AActor* InteractingActor);
	void UnregisterInteracter(class UPrimitiveComponent* InteractionComponent, class AActor* InteractingActor);

	float GetInteractionDuration(class UPrimitiveComponent* InteractionComponent) const;
	void GetPostInteractSyncType(bool* bShouldSync, EAbilityTaskNetSyncType* Type, class UPrimitiveComponent* InteractionComponent) const;
	void GetPreInteractSyncType(bool* bShouldSync, EAbilityTaskNetSyncType* Type, class UPrimitiveComponent* InteractionComponent) const;
	bool IsAvailableForEnemyTeam(class UPrimitiveComponent* InteractionComponent) const;
	bool IsAvailableForInteraction(class AActor* InteractingActor, class UPrimitiveComponent* InteractionComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GSInteractable">();
	}
	static class IGSInteractable* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGSInteractable>();
	}
};
static_assert(alignof(IGSInteractable) == 0x000008, "Wrong alignment on IGSInteractable");
static_assert(sizeof(IGSInteractable) == 0x000028, "Wrong size on IGSInteractable");

// Class JP.PlayerLoadoutTelemetry
// 0x0038 (0x0098 - 0x0060)
class UPlayerLoadoutTelemetry final : public UIWAnalyticsEvent
{
public:
	struct FPlayerLoadoutTelemetryData            PlayerLoadoutTelemetryData;                        // 0x0060(0x0038)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerLoadoutTelemetry">();
	}
	static class UPlayerLoadoutTelemetry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerLoadoutTelemetry>();
	}
};
static_assert(alignof(UPlayerLoadoutTelemetry) == 0x000008, "Wrong alignment on UPlayerLoadoutTelemetry");
static_assert(sizeof(UPlayerLoadoutTelemetry) == 0x000098, "Wrong size on UPlayerLoadoutTelemetry");
static_assert(offsetof(UPlayerLoadoutTelemetry, PlayerLoadoutTelemetryData) == 0x000060, "Member 'UPlayerLoadoutTelemetry::PlayerLoadoutTelemetryData' has a wrong offset!");

// Class JP.HealthAttributeSetListener
// 0x0000 (0x0028 - 0x0028)
class IHealthAttributeSetListener final : public IInterface
{
public:
	void OnDamaged(float Delta, class AActor* Causer, const struct FCombatParticipant& CombatParticipant, const struct FKillMethod& KillMethod, const struct FVector_NetQuantize& Location);
	void OnHealthChanged(float Health, float MaxHealth);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthAttributeSetListener">();
	}
	static class IHealthAttributeSetListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IHealthAttributeSetListener>();
	}
};
static_assert(alignof(IHealthAttributeSetListener) == 0x000008, "Wrong alignment on IHealthAttributeSetListener");
static_assert(sizeof(IHealthAttributeSetListener) == 0x000028, "Wrong size on IHealthAttributeSetListener");

// Class JP.HealthAttributeSet
// 0x0048 (0x0078 - 0x0030)
class UHealthAttributeSet final : public UAttributeSetIW
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEmpty;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Health;                                            // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxHealth;                                         // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_Health();
	void OnRep_MaxHealth();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthAttributeSet">();
	}
	static class UHealthAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthAttributeSet>();
	}
};
static_assert(alignof(UHealthAttributeSet) == 0x000008, "Wrong alignment on UHealthAttributeSet");
static_assert(sizeof(UHealthAttributeSet) == 0x000078, "Wrong size on UHealthAttributeSet");
static_assert(offsetof(UHealthAttributeSet, OnChanged) == 0x000030, "Member 'UHealthAttributeSet::OnChanged' has a wrong offset!");
static_assert(offsetof(UHealthAttributeSet, OnEmpty) == 0x000040, "Member 'UHealthAttributeSet::OnEmpty' has a wrong offset!");
static_assert(offsetof(UHealthAttributeSet, Health) == 0x000050, "Member 'UHealthAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UHealthAttributeSet, MaxHealth) == 0x000060, "Member 'UHealthAttributeSet::MaxHealth' has a wrong offset!");

// Class JP.HealthComponent
// 0x0010 (0x00B0 - 0x00A0)
class UHealthComponent final : public UActorComponent
{
public:
	float                                         FStartHealth;                                      // 0x00A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FHealth;                                           // 0x00A4(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsDead;                                           // 0x00A8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HealDamage(float FHealAmount);
	bool IsDead();
	void TakeDamage(float FDamageAmount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HealthComponent">();
	}
	static class UHealthComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHealthComponent>();
	}
};
static_assert(alignof(UHealthComponent) == 0x000008, "Wrong alignment on UHealthComponent");
static_assert(sizeof(UHealthComponent) == 0x0000B0, "Wrong size on UHealthComponent");
static_assert(offsetof(UHealthComponent, FStartHealth) == 0x0000A0, "Member 'UHealthComponent::FStartHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, FHealth) == 0x0000A4, "Member 'UHealthComponent::FHealth' has a wrong offset!");
static_assert(offsetof(UHealthComponent, bIsDead) == 0x0000A8, "Member 'UHealthComponent::bIsDead' has a wrong offset!");

// Class JP.HitResultFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UHitResultFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FHitResult GetClosestHitResultByDistance(const TArray<struct FHitResult>& HitResults);
	static struct FHitResult GetFurthestHitResultByDistance(const TArray<struct FHitResult>& HitResults);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HitResultFunctionLibrary">();
	}
	static class UHitResultFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHitResultFunctionLibrary>();
	}
};
static_assert(alignof(UHitResultFunctionLibrary) == 0x000008, "Wrong alignment on UHitResultFunctionLibrary");
static_assert(sizeof(UHitResultFunctionLibrary) == 0x000028, "Wrong size on UHitResultFunctionLibrary");

// Class JP.LyraPerformanceStatSubsystem
// 0x0010 (0x0040 - 0x0030)
class ULyraPerformanceStatSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	double GetCachedStat(ELyraDisplayablePerformanceStat Stat) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPerformanceStatSubsystem">();
	}
	static class ULyraPerformanceStatSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPerformanceStatSubsystem>();
	}
};
static_assert(alignof(ULyraPerformanceStatSubsystem) == 0x000008, "Wrong alignment on ULyraPerformanceStatSubsystem");
static_assert(sizeof(ULyraPerformanceStatSubsystem) == 0x000040, "Wrong size on ULyraPerformanceStatSubsystem");

// Class JP.HotjoinMatchComponent
// 0x0020 (0x00C0 - 0x00A0)
class UHotjoinMatchComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         HouseEssentials;                                   // 0x00A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B8[0x8];                                       // 0x00B8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEssentialDestroyed();
	void OnTimerElapsed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HotjoinMatchComponent">();
	}
	static class UHotjoinMatchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHotjoinMatchComponent>();
	}
};
static_assert(alignof(UHotjoinMatchComponent) == 0x000008, "Wrong alignment on UHotjoinMatchComponent");
static_assert(sizeof(UHotjoinMatchComponent) == 0x0000C0, "Wrong size on UHotjoinMatchComponent");
static_assert(offsetof(UHotjoinMatchComponent, HouseEssentials) == 0x0000A8, "Member 'UHotjoinMatchComponent::HouseEssentials' has a wrong offset!");

// Class JP.HouseDefinition
// 0x00F8 (0x0180 - 0x0088)
class UHouseDefinition final : public UPlayerRewardDataAsset
{
public:
	TSoftObjectPtr<class UStaticMesh>             StaticMesh;                                        // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HousePreviewActor;                                 // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   FurnishedHousePreviewActor;                        // 0x00D8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DestroyedHousePreviewActor;                        // 0x0100(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              HouseCardPreviewTexture;                           // 0x0128(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsAvailable;                                       // 0x0150(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AssetRegistrySearchable, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UWorld>                  HouseLevelAsset;                                   // 0x0158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static bool TryGetHouseDefinition(const struct FGameplayTag& HouseID, TSoftObjectPtr<class UHouseDefinition>* OutSoftHouseDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HouseDefinition">();
	}
	static class UHouseDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHouseDefinition>();
	}
};
static_assert(alignof(UHouseDefinition) == 0x000008, "Wrong alignment on UHouseDefinition");
static_assert(sizeof(UHouseDefinition) == 0x000180, "Wrong size on UHouseDefinition");
static_assert(offsetof(UHouseDefinition, StaticMesh) == 0x000088, "Member 'UHouseDefinition::StaticMesh' has a wrong offset!");
static_assert(offsetof(UHouseDefinition, HousePreviewActor) == 0x0000B0, "Member 'UHouseDefinition::HousePreviewActor' has a wrong offset!");
static_assert(offsetof(UHouseDefinition, FurnishedHousePreviewActor) == 0x0000D8, "Member 'UHouseDefinition::FurnishedHousePreviewActor' has a wrong offset!");
static_assert(offsetof(UHouseDefinition, DestroyedHousePreviewActor) == 0x000100, "Member 'UHouseDefinition::DestroyedHousePreviewActor' has a wrong offset!");
static_assert(offsetof(UHouseDefinition, HouseCardPreviewTexture) == 0x000128, "Member 'UHouseDefinition::HouseCardPreviewTexture' has a wrong offset!");
static_assert(offsetof(UHouseDefinition, IsAvailable) == 0x000150, "Member 'UHouseDefinition::IsAvailable' has a wrong offset!");
static_assert(offsetof(UHouseDefinition, HouseLevelAsset) == 0x000158, "Member 'UHouseDefinition::HouseLevelAsset' has a wrong offset!");

// Class JP.HouseEssentialActor
// 0x0018 (0x02A8 - 0x0290)
class AHouseEssentialActor : public AActor
{
public:
	struct FGameplayTag                           HouseEssentialIdTag;                               // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEssentialDestroyed;                              // 0x0298(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HouseEssentialActor">();
	}
	static class AHouseEssentialActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHouseEssentialActor>();
	}
};
static_assert(alignof(AHouseEssentialActor) == 0x000008, "Wrong alignment on AHouseEssentialActor");
static_assert(sizeof(AHouseEssentialActor) == 0x0002A8, "Wrong size on AHouseEssentialActor");
static_assert(offsetof(AHouseEssentialActor, HouseEssentialIdTag) == 0x000290, "Member 'AHouseEssentialActor::HouseEssentialIdTag' has a wrong offset!");
static_assert(offsetof(AHouseEssentialActor, OnEssentialDestroyed) == 0x000298, "Member 'AHouseEssentialActor::OnEssentialDestroyed' has a wrong offset!");

// Class JP.TeamInitializationStepComponent_EliminationGameplay
// 0x0000 (0x00A8 - 0x00A8)
class UTeamInitializationStepComponent_EliminationGameplay final : public UTeamInitializationStepComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamInitializationStepComponent_EliminationGameplay">();
	}
	static class UTeamInitializationStepComponent_EliminationGameplay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamInitializationStepComponent_EliminationGameplay>();
	}
};
static_assert(alignof(UTeamInitializationStepComponent_EliminationGameplay) == 0x000008, "Wrong alignment on UTeamInitializationStepComponent_EliminationGameplay");
static_assert(sizeof(UTeamInitializationStepComponent_EliminationGameplay) == 0x0000A8, "Wrong size on UTeamInitializationStepComponent_EliminationGameplay");

// Class JP.HousePreviewActorBase
// 0x0008 (0x0298 - 0x0290)
class AHousePreviewActorBase : public AActor
{
public:
	struct FGameplayTag                           HouseID;                                           // 0x0290(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HousePreviewActorBase">();
	}
	static class AHousePreviewActorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AHousePreviewActorBase>();
	}
};
static_assert(alignof(AHousePreviewActorBase) == 0x000008, "Wrong alignment on AHousePreviewActorBase");
static_assert(sizeof(AHousePreviewActorBase) == 0x000298, "Wrong size on AHousePreviewActorBase");
static_assert(offsetof(AHousePreviewActorBase, HouseID) == 0x000290, "Member 'AHousePreviewActorBase::HouseID' has a wrong offset!");

// Class JP.HouseVotePopupEntryWidget
// 0x0010 (0x02F0 - 0x02E0)
class UHouseVotePopupEntryWidget final : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ApplyViewModel(const struct FHouseVotePopupEntryViewModel& ViewModel);
	void Clicked();
	void SetNoVote();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HouseVotePopupEntryWidget">();
	}
	static class UHouseVotePopupEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHouseVotePopupEntryWidget>();
	}
};
static_assert(alignof(UHouseVotePopupEntryWidget) == 0x000008, "Wrong alignment on UHouseVotePopupEntryWidget");
static_assert(sizeof(UHouseVotePopupEntryWidget) == 0x0002F0, "Wrong size on UHouseVotePopupEntryWidget");
static_assert(offsetof(UHouseVotePopupEntryWidget, OnClicked) == 0x0002E0, "Member 'UHouseVotePopupEntryWidget::OnClicked' has a wrong offset!");

// Class JP.TeamVolume
// 0x00A8 (0x0338 - 0x0290)
class ATeamVolume : public AActor
{
public:
	struct FGameplayTag                           TeamVolumeGameplayTag;                             // 0x0290(0x0008)(Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   CustomStaticMesh;                                  // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AGroundsKeeper>          GroundsKeeperOverride;                             // 0x02A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class AGroundsKeeper>          GroundsKeeperAutoFound;                            // 0x02C8(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x02F0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ActorClassFilter;                                  // 0x0300(0x0028)(Edit, EditConst, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0328(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	class AGroundsKeeper* GetGroundsKeeper() const;
	const struct FTeam GetTeam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamVolume">();
	}
	static class ATeamVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamVolume>();
	}
};
static_assert(alignof(ATeamVolume) == 0x000008, "Wrong alignment on ATeamVolume");
static_assert(sizeof(ATeamVolume) == 0x000338, "Wrong size on ATeamVolume");
static_assert(offsetof(ATeamVolume, TeamVolumeGameplayTag) == 0x000290, "Member 'ATeamVolume::TeamVolumeGameplayTag' has a wrong offset!");
static_assert(offsetof(ATeamVolume, CustomStaticMesh) == 0x000298, "Member 'ATeamVolume::CustomStaticMesh' has a wrong offset!");
static_assert(offsetof(ATeamVolume, GroundsKeeperOverride) == 0x0002A0, "Member 'ATeamVolume::GroundsKeeperOverride' has a wrong offset!");
static_assert(offsetof(ATeamVolume, GroundsKeeperAutoFound) == 0x0002C8, "Member 'ATeamVolume::GroundsKeeperAutoFound' has a wrong offset!");
static_assert(offsetof(ATeamVolume, ObjectTypes) == 0x0002F0, "Member 'ATeamVolume::ObjectTypes' has a wrong offset!");
static_assert(offsetof(ATeamVolume, ActorClassFilter) == 0x000300, "Member 'ATeamVolume::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(ATeamVolume, ActorsToIgnore) == 0x000328, "Member 'ATeamVolume::ActorsToIgnore' has a wrong offset!");

// Class JP.HouseVotePopupWidget
// 0x0090 (0x04C0 - 0x0430)
class UHouseVotePopupWidget final : public UCommonActivatableWidget
{
public:
	class UPanelWidget*                           PanelWidget;                                       // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UHouseVotePopupEntryWidget> EntryWidgetClass;                                  // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IncludeUnavailableHouseDefinitions;                // 0x0440(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumEntryCount;                                 // 0x0444(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UHouseVotePopupEntryWidget*>     EntryWidgets;                                      // 0x0448(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class UHouseDefinition>> ActiveOwnedHouses;                                 // 0x0458(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class ULobbyHouseVotePlayerStateWatcher*      PlayerStateWatcher;                                // 0x0468(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x50];                                     // 0x0470(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DismissPopup();
	void HandleEntryWidgetCreated(class UHouseVotePopupEntryWidget* EntryWidget);
	void HandlePlayerStateHouseIdentifierVoteChanged(class APlayerStateJP_Lobby* PlayerState, const struct FGameplayTag& OldHouseIdentifier, const struct FGameplayTag& NewHouseIdentifier);
	void HandlePlayerStateOwnedHousesChanged(class APlayerStateJP_Lobby* PlayerState, const TArray<struct FGameplayTag>& NewOwnedHouses);
	void HandlePlayerStateTeamHousePoolChanged(class APlayerStateJP_Lobby* PlayerState);
	void HandlePlayerStateTeamIdChanged(class APlayerStateJP_Lobby* PlayerState, const uint8& OldTeamID, const uint8& NewTeamID);
	void HandlePlayerStateTracked(class APlayerState* TrackedPlayerState, bool Initial);
	void HandlePlayerStateUntracked(class APlayerState* UntrackedPlayerState);
	void SelectEntry(class UHouseVotePopupEntryWidget* EntryWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"HouseVotePopupWidget">();
	}
	static class UHouseVotePopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UHouseVotePopupWidget>();
	}
};
static_assert(alignof(UHouseVotePopupWidget) == 0x000008, "Wrong alignment on UHouseVotePopupWidget");
static_assert(sizeof(UHouseVotePopupWidget) == 0x0004C0, "Wrong size on UHouseVotePopupWidget");
static_assert(offsetof(UHouseVotePopupWidget, PanelWidget) == 0x000430, "Member 'UHouseVotePopupWidget::PanelWidget' has a wrong offset!");
static_assert(offsetof(UHouseVotePopupWidget, EntryWidgetClass) == 0x000438, "Member 'UHouseVotePopupWidget::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UHouseVotePopupWidget, IncludeUnavailableHouseDefinitions) == 0x000440, "Member 'UHouseVotePopupWidget::IncludeUnavailableHouseDefinitions' has a wrong offset!");
static_assert(offsetof(UHouseVotePopupWidget, MinimumEntryCount) == 0x000444, "Member 'UHouseVotePopupWidget::MinimumEntryCount' has a wrong offset!");
static_assert(offsetof(UHouseVotePopupWidget, EntryWidgets) == 0x000448, "Member 'UHouseVotePopupWidget::EntryWidgets' has a wrong offset!");
static_assert(offsetof(UHouseVotePopupWidget, ActiveOwnedHouses) == 0x000458, "Member 'UHouseVotePopupWidget::ActiveOwnedHouses' has a wrong offset!");
static_assert(offsetof(UHouseVotePopupWidget, PlayerStateWatcher) == 0x000468, "Member 'UHouseVotePopupWidget::PlayerStateWatcher' has a wrong offset!");

// Class JP.IndicatorWidgetInterface
// 0x0000 (0x0028 - 0x0028)
class IIndicatorWidgetInterface final : public IInterface
{
public:
	void BindIndicator(class UIndicatorDescriptor* Indicator);
	void UnbindIndicator(const class UIndicatorDescriptor* Indicator);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndicatorWidgetInterface">();
	}
	static class IIndicatorWidgetInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IIndicatorWidgetInterface>();
	}
};
static_assert(alignof(IIndicatorWidgetInterface) == 0x000008, "Wrong alignment on IIndicatorWidgetInterface");
static_assert(sizeof(IIndicatorWidgetInterface) == 0x000028, "Wrong size on IIndicatorWidgetInterface");

// Class JP.LyraButtonBase
// 0x0020 (0x15C0 - 0x15A0)
#pragma pack(push, 0x1)
class alignas(0x10) ULyraButtonBase : public UCommonButtonBase
{
public:
	uint8                                         bOverride_ButtonText : 1;                          // 0x15A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate))
	uint8                                         Pad_15A1[0x7];                                     // 0x15A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonText;                                        // 0x15A8(0x0010)(Edit, NativeAccessSpecifierPrivate)

public:
	void SetButtonText(const class FText& InText);
	void UpdateButtonStyle();
	void UpdateButtonText(const class FText& InText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraButtonBase">();
	}
	static class ULyraButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraButtonBase>();
	}
};
#pragma pack(pop)
static_assert(alignof(ULyraButtonBase) == 0x000010, "Wrong alignment on ULyraButtonBase");
static_assert(sizeof(ULyraButtonBase) == 0x0015C0, "Wrong size on ULyraButtonBase");
static_assert(offsetof(ULyraButtonBase, ButtonText) == 0x0015A8, "Member 'ULyraButtonBase::ButtonText' has a wrong offset!");

// Class JP.LyraTabButtonBase
// 0x0010 (0x15D0 - 0x15C0)
class ULyraTabButtonBase : public ULyraButtonBase
{
public:
	uint8                                         Pad_15B8[0x8];                                     // 0x15B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonLazyImage*                       LazyImage_Icon;                                    // 0x15C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_15C8[0x8];                                     // 0x15C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTabLabelInfo_Implementation(const struct FLyraTabDescriptor& TabLabelInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTabButtonBase">();
	}
	static class ULyraTabButtonBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTabButtonBase>();
	}
};
static_assert(alignof(ULyraTabButtonBase) == 0x000010, "Wrong alignment on ULyraTabButtonBase");
static_assert(sizeof(ULyraTabButtonBase) == 0x0015D0, "Wrong size on ULyraTabButtonBase");
static_assert(offsetof(ULyraTabButtonBase, LazyImage_Icon) == 0x0015C0, "Member 'ULyraTabButtonBase::LazyImage_Icon' has a wrong offset!");

// Class JP.IncomeNotification
// 0x0000 (0x0290 - 0x0290)
class AIncomeNotification : public AActor
{
public:
	void Activate(float Score);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IncomeNotification">();
	}
	static class AIncomeNotification* GetDefaultObj()
	{
		return GetDefaultObjImpl<AIncomeNotification>();
	}
};
static_assert(alignof(AIncomeNotification) == 0x000008, "Wrong alignment on AIncomeNotification");
static_assert(sizeof(AIncomeNotification) == 0x000290, "Wrong size on AIncomeNotification");

// Class JP.InitializationFlowComponent
// 0x0088 (0x00B0 - 0x0028)
class UInitializationFlowComponent final : public UObject
{
public:
	uint8                                         Pad_28[0x40];                                      // 0x0028(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadingScreenManager*                  LoadingScreenManager;                              // 0x0068(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x30];                                      // 0x0070(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UInitializationFlowStepBase*            StepInstance;                                      // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InitializationFlowComponent">();
	}
	static class UInitializationFlowComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInitializationFlowComponent>();
	}
};
static_assert(alignof(UInitializationFlowComponent) == 0x000008, "Wrong alignment on UInitializationFlowComponent");
static_assert(sizeof(UInitializationFlowComponent) == 0x0000B0, "Wrong size on UInitializationFlowComponent");
static_assert(offsetof(UInitializationFlowComponent, LoadingScreenManager) == 0x000068, "Member 'UInitializationFlowComponent::LoadingScreenManager' has a wrong offset!");
static_assert(offsetof(UInitializationFlowComponent, StepInstance) == 0x0000A0, "Member 'UInitializationFlowComponent::StepInstance' has a wrong offset!");

// Class JP.InventoryItemsRequest
// 0x00C0 (0x00E8 - 0x0028)
class UInventoryItemsRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USharedEconomyOnlineServiceHandler*     EconomyHandler;                                    // 0x0048(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x98];                                      // 0x0050(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InventoryItemsRequest">();
	}
	static class UInventoryItemsRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInventoryItemsRequest>();
	}
};
static_assert(alignof(UInventoryItemsRequest) == 0x000008, "Wrong alignment on UInventoryItemsRequest");
static_assert(sizeof(UInventoryItemsRequest) == 0x0000E8, "Wrong size on UInventoryItemsRequest");
static_assert(offsetof(UInventoryItemsRequest, EconomyHandler) == 0x000048, "Member 'UInventoryItemsRequest::EconomyHandler' has a wrong offset!");

// Class JP.ItemAction_AmmoGranterItemDefinition
// 0x0028 (0x0050 - 0x0028)
class UItemAction_AmmoGranterItemDefinition final : public UItemAction
{
public:
	TSoftObjectPtr<class UItemDefinition>         ItemDefinition;                                    // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_AmmoGranterItemDefinition">();
	}
	static class UItemAction_AmmoGranterItemDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_AmmoGranterItemDefinition>();
	}
};
static_assert(alignof(UItemAction_AmmoGranterItemDefinition) == 0x000008, "Wrong alignment on UItemAction_AmmoGranterItemDefinition");
static_assert(sizeof(UItemAction_AmmoGranterItemDefinition) == 0x000050, "Wrong size on UItemAction_AmmoGranterItemDefinition");
static_assert(offsetof(UItemAction_AmmoGranterItemDefinition, ItemDefinition) == 0x000028, "Member 'UItemAction_AmmoGranterItemDefinition::ItemDefinition' has a wrong offset!");

// Class JP.NeighborSelectEntry
// 0x0010 (0x02F0 - 0x02E0)
class UNeighborSelectEntry final : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ApplyViewModel(const struct FNeighborSelectEntryViewModel& ViewModel);
	void Clicked();
	void SetRandomNeighbor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSelectEntry">();
	}
	static class UNeighborSelectEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborSelectEntry>();
	}
};
static_assert(alignof(UNeighborSelectEntry) == 0x000008, "Wrong alignment on UNeighborSelectEntry");
static_assert(sizeof(UNeighborSelectEntry) == 0x0002F0, "Wrong size on UNeighborSelectEntry");
static_assert(offsetof(UNeighborSelectEntry, OnClicked) == 0x0002E0, "Member 'UNeighborSelectEntry::OnClicked' has a wrong offset!");

// Class JP.ItemAction_AppliedBuffs
// 0x0010 (0x0038 - 0x0028)
class UItemAction_AppliedBuffs final : public UItemAction
{
public:
	TArray<struct FAppliedBuffInfo>               AppliedBuffs;                                      // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_AppliedBuffs">();
	}
	static class UItemAction_AppliedBuffs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_AppliedBuffs>();
	}
};
static_assert(alignof(UItemAction_AppliedBuffs) == 0x000008, "Wrong alignment on UItemAction_AppliedBuffs");
static_assert(sizeof(UItemAction_AppliedBuffs) == 0x000038, "Wrong size on UItemAction_AppliedBuffs");
static_assert(offsetof(UItemAction_AppliedBuffs, AppliedBuffs) == 0x000028, "Member 'UItemAction_AppliedBuffs::AppliedBuffs' has a wrong offset!");

// Class JP.MovementSpeedAttribute
// 0x0070 (0x00A0 - 0x0030)
class UMovementSpeedAttribute final : public UAttributeSetIW
{
public:
	struct FGameplayAttributeData                 MovementSpeed;                                     // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrouchSpeedCoefficient;                            // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SprintSpeedCoefficient;                            // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AimSpeedCoefficient;                               // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 JumpVelocity;                                      // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CrouchJumpVelocityCoefficient;                     // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AirControl;                                        // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_AimSpeedCoefficient();
	void OnRep_AirControl();
	void OnRep_CrouchJumpVelocityCoefficient();
	void OnRep_CrouchSpeedCoefficient();
	void OnRep_JumpVelocity();
	void OnRep_MovementSpeed();
	void OnRep_SprintSpeedCoefficient();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementSpeedAttribute">();
	}
	static class UMovementSpeedAttribute* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovementSpeedAttribute>();
	}
};
static_assert(alignof(UMovementSpeedAttribute) == 0x000008, "Wrong alignment on UMovementSpeedAttribute");
static_assert(sizeof(UMovementSpeedAttribute) == 0x0000A0, "Wrong size on UMovementSpeedAttribute");
static_assert(offsetof(UMovementSpeedAttribute, MovementSpeed) == 0x000030, "Member 'UMovementSpeedAttribute::MovementSpeed' has a wrong offset!");
static_assert(offsetof(UMovementSpeedAttribute, CrouchSpeedCoefficient) == 0x000040, "Member 'UMovementSpeedAttribute::CrouchSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(UMovementSpeedAttribute, SprintSpeedCoefficient) == 0x000050, "Member 'UMovementSpeedAttribute::SprintSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(UMovementSpeedAttribute, AimSpeedCoefficient) == 0x000060, "Member 'UMovementSpeedAttribute::AimSpeedCoefficient' has a wrong offset!");
static_assert(offsetof(UMovementSpeedAttribute, JumpVelocity) == 0x000070, "Member 'UMovementSpeedAttribute::JumpVelocity' has a wrong offset!");
static_assert(offsetof(UMovementSpeedAttribute, CrouchJumpVelocityCoefficient) == 0x000080, "Member 'UMovementSpeedAttribute::CrouchJumpVelocityCoefficient' has a wrong offset!");
static_assert(offsetof(UMovementSpeedAttribute, AirControl) == 0x000090, "Member 'UMovementSpeedAttribute::AirControl' has a wrong offset!");

// Class JP.ItemAction_BuyAmmoBehavior
// 0x0008 (0x0030 - 0x0028)
class UItemAction_BuyAmmoBehavior final : public UItemAction
{
public:
	class UBuyAmmoBehavior*                       BuyAmmoBehavior;                                   // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_BuyAmmoBehavior">();
	}
	static class UItemAction_BuyAmmoBehavior* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_BuyAmmoBehavior>();
	}
};
static_assert(alignof(UItemAction_BuyAmmoBehavior) == 0x000008, "Wrong alignment on UItemAction_BuyAmmoBehavior");
static_assert(sizeof(UItemAction_BuyAmmoBehavior) == 0x000030, "Wrong size on UItemAction_BuyAmmoBehavior");
static_assert(offsetof(UItemAction_BuyAmmoBehavior, BuyAmmoBehavior) == 0x000028, "Member 'UItemAction_BuyAmmoBehavior::BuyAmmoBehavior' has a wrong offset!");

// Class JP.ItemAction_DeathDurabilityChange
// 0x0008 (0x0030 - 0x0028)
class UItemAction_DeathDurabilityChange final : public UItemAction
{
public:
	class UDeathDurabilityChangeBehavior*         DeathDurabilityChangeBehavior;                     // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_DeathDurabilityChange">();
	}
	static class UItemAction_DeathDurabilityChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_DeathDurabilityChange>();
	}
};
static_assert(alignof(UItemAction_DeathDurabilityChange) == 0x000008, "Wrong alignment on UItemAction_DeathDurabilityChange");
static_assert(sizeof(UItemAction_DeathDurabilityChange) == 0x000030, "Wrong size on UItemAction_DeathDurabilityChange");
static_assert(offsetof(UItemAction_DeathDurabilityChange, DeathDurabilityChangeBehavior) == 0x000028, "Member 'UItemAction_DeathDurabilityChange::DeathDurabilityChangeBehavior' has a wrong offset!");

// Class JP.ItemAction_DeliveryActor
// 0x0008 (0x0030 - 0x0028)
class UItemAction_DeliveryActor final : public UItemAction
{
public:
	TSubclassOf<class AActor>                     DeliveredActorClass;                               // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_DeliveryActor">();
	}
	static class UItemAction_DeliveryActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_DeliveryActor>();
	}
};
static_assert(alignof(UItemAction_DeliveryActor) == 0x000008, "Wrong alignment on UItemAction_DeliveryActor");
static_assert(sizeof(UItemAction_DeliveryActor) == 0x000030, "Wrong size on UItemAction_DeliveryActor");
static_assert(offsetof(UItemAction_DeliveryActor, DeliveredActorClass) == 0x000028, "Member 'UItemAction_DeliveryActor::DeliveredActorClass' has a wrong offset!");

// Class JP.NeighborSpecialAbilitiesComponent
// 0x0008 (0x00A8 - 0x00A0)
class UNeighborSpecialAbilitiesComponent final : public UActorComponent
{
public:
	class UNeighborSpecialAbilityInstance*        GrantedAbility;                                    // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UNeighborSpecialAbilityInstance* GrantAbility(class UNeighborSpecialAbilityDefinition* Definition);
	class UNeighborSpecialAbilityInstance* ReplaceSpecialAbility(class UNeighborSpecialAbilityDefinition* NewDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSpecialAbilitiesComponent">();
	}
	static class UNeighborSpecialAbilitiesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborSpecialAbilitiesComponent>();
	}
};
static_assert(alignof(UNeighborSpecialAbilitiesComponent) == 0x000008, "Wrong alignment on UNeighborSpecialAbilitiesComponent");
static_assert(sizeof(UNeighborSpecialAbilitiesComponent) == 0x0000A8, "Wrong size on UNeighborSpecialAbilitiesComponent");
static_assert(offsetof(UNeighborSpecialAbilitiesComponent, GrantedAbility) == 0x0000A0, "Member 'UNeighborSpecialAbilitiesComponent::GrantedAbility' has a wrong offset!");

// Class JP.ItemAction_Droppable
// 0x0010 (0x0038 - 0x0028)
class UItemAction_Droppable final : public UItemAction
{
public:
	TSubclassOf<class AActor>                     DroppedActorClass;                                 // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDropBehavior*                          DropBehavior;                                      // 0x0030(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_Droppable">();
	}
	static class UItemAction_Droppable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_Droppable>();
	}
};
static_assert(alignof(UItemAction_Droppable) == 0x000008, "Wrong alignment on UItemAction_Droppable");
static_assert(sizeof(UItemAction_Droppable) == 0x000038, "Wrong size on UItemAction_Droppable");
static_assert(offsetof(UItemAction_Droppable, DroppedActorClass) == 0x000028, "Member 'UItemAction_Droppable::DroppedActorClass' has a wrong offset!");
static_assert(offsetof(UItemAction_Droppable, DropBehavior) == 0x000030, "Member 'UItemAction_Droppable::DropBehavior' has a wrong offset!");

// Class JP.OnlineServicesUserBase
// 0x0048 (0x0070 - 0x0028)
class UOnlineServicesUserBase : public UObject
{
public:
	class FString                                 DisplayName;                                       // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocalUser;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlatformID;                                        // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PUID;                                              // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineServicesUserBase">();
	}
	static class UOnlineServicesUserBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineServicesUserBase>();
	}
};
static_assert(alignof(UOnlineServicesUserBase) == 0x000008, "Wrong alignment on UOnlineServicesUserBase");
static_assert(sizeof(UOnlineServicesUserBase) == 0x000070, "Wrong size on UOnlineServicesUserBase");
static_assert(offsetof(UOnlineServicesUserBase, DisplayName) == 0x000028, "Member 'UOnlineServicesUserBase::DisplayName' has a wrong offset!");
static_assert(offsetof(UOnlineServicesUserBase, bIsLocalUser) == 0x000038, "Member 'UOnlineServicesUserBase::bIsLocalUser' has a wrong offset!");
static_assert(offsetof(UOnlineServicesUserBase, PlatformID) == 0x000040, "Member 'UOnlineServicesUserBase::PlatformID' has a wrong offset!");
static_assert(offsetof(UOnlineServicesUserBase, PUID) == 0x000050, "Member 'UOnlineServicesUserBase::PUID' has a wrong offset!");

// Class JP.OnlineServicesBlockedPlayer
// 0x0000 (0x0070 - 0x0070)
class UOnlineServicesBlockedPlayer final : public UOnlineServicesUserBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineServicesBlockedPlayer">();
	}
	static class UOnlineServicesBlockedPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineServicesBlockedPlayer>();
	}
};
static_assert(alignof(UOnlineServicesBlockedPlayer) == 0x000008, "Wrong alignment on UOnlineServicesBlockedPlayer");
static_assert(sizeof(UOnlineServicesBlockedPlayer) == 0x000070, "Wrong size on UOnlineServicesBlockedPlayer");

// Class JP.ItemAction_ItemWheel
// 0x0010 (0x0038 - 0x0028)
class UItemAction_ItemWheel final : public UItemAction
{
public:
	class UTexture2D*                             Icon;                                              // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AmountTag;                                         // 0x0030(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static struct FItemWheelInfo ConstructItemWheelInfo(class UItemInstance* Item);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_ItemWheel">();
	}
	static class UItemAction_ItemWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_ItemWheel>();
	}
};
static_assert(alignof(UItemAction_ItemWheel) == 0x000008, "Wrong alignment on UItemAction_ItemWheel");
static_assert(sizeof(UItemAction_ItemWheel) == 0x000038, "Wrong size on UItemAction_ItemWheel");
static_assert(offsetof(UItemAction_ItemWheel, Icon) == 0x000028, "Member 'UItemAction_ItemWheel::Icon' has a wrong offset!");
static_assert(offsetof(UItemAction_ItemWheel, AmountTag) == 0x000030, "Member 'UItemAction_ItemWheel::AmountTag' has a wrong offset!");

// Class JP.ItemAction_KnockedOutTips
// 0x0010 (0x0038 - 0x0028)
class UItemAction_KnockedOutTips final : public UItemAction
{
public:
	TArray<class UDataTable*>                     TipTexts;                                          // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_KnockedOutTips">();
	}
	static class UItemAction_KnockedOutTips* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_KnockedOutTips>();
	}
};
static_assert(alignof(UItemAction_KnockedOutTips) == 0x000008, "Wrong alignment on UItemAction_KnockedOutTips");
static_assert(sizeof(UItemAction_KnockedOutTips) == 0x000038, "Wrong size on UItemAction_KnockedOutTips");
static_assert(offsetof(UItemAction_KnockedOutTips, TipTexts) == 0x000028, "Member 'UItemAction_KnockedOutTips::TipTexts' has a wrong offset!");

// Class JP.ItemAction_NeighborSpecialAbility
// 0x0028 (0x0050 - 0x0028)
class UItemAction_NeighborSpecialAbility final : public UItemAction
{
public:
	TSoftObjectPtr<class UNeighborSpecialAbilityMetaData> NeighborSpecialAbilityMetaData;                    // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_NeighborSpecialAbility">();
	}
	static class UItemAction_NeighborSpecialAbility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_NeighborSpecialAbility>();
	}
};
static_assert(alignof(UItemAction_NeighborSpecialAbility) == 0x000008, "Wrong alignment on UItemAction_NeighborSpecialAbility");
static_assert(sizeof(UItemAction_NeighborSpecialAbility) == 0x000050, "Wrong size on UItemAction_NeighborSpecialAbility");
static_assert(offsetof(UItemAction_NeighborSpecialAbility, NeighborSpecialAbilityMetaData) == 0x000028, "Member 'UItemAction_NeighborSpecialAbility::NeighborSpecialAbilityMetaData' has a wrong offset!");

// Class JP.NeighborSpecialAbilityMetaData
// 0x0028 (0x0058 - 0x0030)
class UNeighborSpecialAbilityMetaData final : public UDataAsset
{
public:
	TSoftObjectPtr<class UTexture2D>              AbilityIcon;                                       // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSpecialAbilityMetaData">();
	}
	static class UNeighborSpecialAbilityMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborSpecialAbilityMetaData>();
	}
};
static_assert(alignof(UNeighborSpecialAbilityMetaData) == 0x000008, "Wrong alignment on UNeighborSpecialAbilityMetaData");
static_assert(sizeof(UNeighborSpecialAbilityMetaData) == 0x000058, "Wrong size on UNeighborSpecialAbilityMetaData");
static_assert(offsetof(UNeighborSpecialAbilityMetaData, AbilityIcon) == 0x000030, "Member 'UNeighborSpecialAbilityMetaData::AbilityIcon' has a wrong offset!");

// Class JP.ItemSkinDefinition
// 0x0070 (0x00F8 - 0x0088)
class UItemSkinDefinition final : public UPlayerRewardDataAsset
{
public:
	TArray<struct FEquipmentActorToSpawn>         ActorsToSpawn;                                     // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FEquipmentActorToSpawn>         PreviewActorsToSpawn;                              // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 SkinMesh;                                          // 0x00A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UMaterialInstance>       SkinMaterial;                                      // 0x00D0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static struct FGameplayTag GetDefaultItemSkinID(const class UItemDefinition* ItemDefinition);
	static bool TryGetItemSkinDefinition(const struct FGameplayTag& ItemSkinID, TSoftObjectPtr<class UItemSkinDefinition>* OutSoftItemSkinDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemSkinDefinition">();
	}
	static class UItemSkinDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemSkinDefinition>();
	}
};
static_assert(alignof(UItemSkinDefinition) == 0x000008, "Wrong alignment on UItemSkinDefinition");
static_assert(sizeof(UItemSkinDefinition) == 0x0000F8, "Wrong size on UItemSkinDefinition");
static_assert(offsetof(UItemSkinDefinition, ActorsToSpawn) == 0x000088, "Member 'UItemSkinDefinition::ActorsToSpawn' has a wrong offset!");
static_assert(offsetof(UItemSkinDefinition, PreviewActorsToSpawn) == 0x000098, "Member 'UItemSkinDefinition::PreviewActorsToSpawn' has a wrong offset!");
static_assert(offsetof(UItemSkinDefinition, SkinMesh) == 0x0000A8, "Member 'UItemSkinDefinition::SkinMesh' has a wrong offset!");
static_assert(offsetof(UItemSkinDefinition, SkinMaterial) == 0x0000D0, "Member 'UItemSkinDefinition::SkinMaterial' has a wrong offset!");

// Class JP.NeighborPerkSelectPopupWidget
// 0x0000 (0x0478 - 0x0478)
class UNeighborPerkSelectPopupWidget final : public UPerkSelectPopupWidgetBase
{
public:
	void BlueprintHandleEntryWidgetCreated(class UPerkSelectEntry* EntryWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborPerkSelectPopupWidget">();
	}
	static class UNeighborPerkSelectPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborPerkSelectPopupWidget>();
	}
};
static_assert(alignof(UNeighborPerkSelectPopupWidget) == 0x000008, "Wrong alignment on UNeighborPerkSelectPopupWidget");
static_assert(sizeof(UNeighborPerkSelectPopupWidget) == 0x000478, "Wrong size on UNeighborPerkSelectPopupWidget");

// Class JP.ItemTiersDefinition
// 0x0010 (0x0040 - 0x0030)
class UItemTiersDefinition final : public UDataAsset
{
public:
	TArray<struct FItemTier>                      ItemTiers;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemTiersDefinition">();
	}
	static class UItemTiersDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemTiersDefinition>();
	}
};
static_assert(alignof(UItemTiersDefinition) == 0x000008, "Wrong alignment on UItemTiersDefinition");
static_assert(sizeof(UItemTiersDefinition) == 0x000040, "Wrong size on UItemTiersDefinition");
static_assert(offsetof(UItemTiersDefinition, ItemTiers) == 0x000030, "Member 'UItemTiersDefinition::ItemTiers' has a wrong offset!");

// Class JP.JPActionWidget
// 0x0000 (0x02E0 - 0x02E0)
class UJPActionWidget : public UUserWidget
{
public:
	bool TryGetActionIcon(class UInputAction* Action, struct FSlateBrush* IconSlateBrush);
	bool TryGetActionKeyForFirstBoundKey(class UInputAction* Action, class FText* ActionKeyText);
	bool TryGetActionTextForFirstBoundKey(class UInputAction* Action, class FText* ActionKeyText);

	ECommonInputType GetCurrentInputType() const;
	TArray<struct FKey> GetKeysMappedToAction(class UInputAction* Action) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPActionWidget">();
	}
	static class UJPActionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPActionWidget>();
	}
};
static_assert(alignof(UJPActionWidget) == 0x000008, "Wrong alignment on UJPActionWidget");
static_assert(sizeof(UJPActionWidget) == 0x0002E0, "Wrong size on UJPActionWidget");

// Class JP.MMC_PlayerCombat
// 0x0000 (0x0040 - 0x0040)
class UMMC_PlayerCombat : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MMC_PlayerCombat">();
	}
	static class UMMC_PlayerCombat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMMC_PlayerCombat>();
	}
};
static_assert(alignof(UMMC_PlayerCombat) == 0x000008, "Wrong alignment on UMMC_PlayerCombat");
static_assert(sizeof(UMMC_PlayerCombat) == 0x000040, "Wrong size on UMMC_PlayerCombat");

// Class JP.MMC_PlayerCombatHealing
// 0x0000 (0x0040 - 0x0040)
class UMMC_PlayerCombatHealing final : public UMMC_PlayerCombat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MMC_PlayerCombatHealing">();
	}
	static class UMMC_PlayerCombatHealing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMMC_PlayerCombatHealing>();
	}
};
static_assert(alignof(UMMC_PlayerCombatHealing) == 0x000008, "Wrong alignment on UMMC_PlayerCombatHealing");
static_assert(sizeof(UMMC_PlayerCombatHealing) == 0x000040, "Wrong size on UMMC_PlayerCombatHealing");

// Class JP.JPCommonUIActionRouter
// 0x0000 (0x0170 - 0x0170)
class UJPCommonUIActionRouter final : public UCommonUIActionRouterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPCommonUIActionRouter">();
	}
	static class UJPCommonUIActionRouter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPCommonUIActionRouter>();
	}
};
static_assert(alignof(UJPCommonUIActionRouter) == 0x000008, "Wrong alignment on UJPCommonUIActionRouter");
static_assert(sizeof(UJPCommonUIActionRouter) == 0x000170, "Wrong size on UJPCommonUIActionRouter");

// Class JP.JPGameSettingAction
// 0x0010 (0x01A8 - 0x0198)
class UJPGameSettingAction final : public UGameSettingAction
{
public:
	uint8                                         Pad_198[0x10];                                     // 0x0198(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingAction">();
	}
	static class UJPGameSettingAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingAction>();
	}
};
static_assert(alignof(UJPGameSettingAction) == 0x000008, "Wrong alignment on UJPGameSettingAction");
static_assert(sizeof(UJPGameSettingAction) == 0x0001A8, "Wrong size on UJPGameSettingAction");

// Class JP.JPGameSettingCollection
// 0x0010 (0x0170 - 0x0160)
class UJPGameSettingCollection final : public UGameSettingCollection
{
public:
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingCollection">();
	}
	static class UJPGameSettingCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingCollection>();
	}
};
static_assert(alignof(UJPGameSettingCollection) == 0x000008, "Wrong alignment on UJPGameSettingCollection");
static_assert(sizeof(UJPGameSettingCollection) == 0x000170, "Wrong size on UJPGameSettingCollection");

// Class JP.PreconditionBase
// 0x0000 (0x0028 - 0x0028)
class UPreconditionBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreconditionBase">();
	}
	static class UPreconditionBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreconditionBase>();
	}
};
static_assert(alignof(UPreconditionBase) == 0x000008, "Wrong alignment on UPreconditionBase");
static_assert(sizeof(UPreconditionBase) == 0x000028, "Wrong size on UPreconditionBase");

// Class JP.JPGameSettingCollectionPage
// 0x0010 (0x0198 - 0x0188)
class UJPGameSettingCollectionPage final : public UGameSettingCollectionPage
{
public:
	uint8                                         Pad_188[0x10];                                     // 0x0188(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingCollectionPage">();
	}
	static class UJPGameSettingCollectionPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingCollectionPage>();
	}
};
static_assert(alignof(UJPGameSettingCollectionPage) == 0x000008, "Wrong alignment on UJPGameSettingCollectionPage");
static_assert(sizeof(UJPGameSettingCollectionPage) == 0x000198, "Wrong size on UJPGameSettingCollectionPage");

// Class JP.NeighborSpecialAbilityInstance
// 0x0010 (0x0038 - 0x0028)
class UNeighborSpecialAbilityInstance final : public UObject
{
public:
	TArray<struct FGameplaySetHandle>             GrantedGameplaySetHandles;                         // 0x0028(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSpecialAbilityInstance">();
	}
	static class UNeighborSpecialAbilityInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborSpecialAbilityInstance>();
	}
};
static_assert(alignof(UNeighborSpecialAbilityInstance) == 0x000008, "Wrong alignment on UNeighborSpecialAbilityInstance");
static_assert(sizeof(UNeighborSpecialAbilityInstance) == 0x000038, "Wrong size on UNeighborSpecialAbilityInstance");
static_assert(offsetof(UNeighborSpecialAbilityInstance, GrantedGameplaySetHandles) == 0x000028, "Member 'UNeighborSpecialAbilityInstance::GrantedGameplaySetHandles' has a wrong offset!");

// Class JP.JPGameSettingListView
// 0x0010 (0x0CE0 - 0x0CD0)
class UJPGameSettingListView final : public UGameSettingListView
{
public:
	float                                         RightPadding;                                      // 0x0CC8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LeftPadding;                                       // 0x0CCC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TopPadding;                                        // 0x0CD0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BottomPadding;                                     // 0x0CD4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CD8[0x8];                                      // 0x0CD8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingListView">();
	}
	static class UJPGameSettingListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingListView>();
	}
};
static_assert(alignof(UJPGameSettingListView) == 0x000010, "Wrong alignment on UJPGameSettingListView");
static_assert(sizeof(UJPGameSettingListView) == 0x000CE0, "Wrong size on UJPGameSettingListView");
static_assert(offsetof(UJPGameSettingListView, RightPadding) == 0x000CC8, "Member 'UJPGameSettingListView::RightPadding' has a wrong offset!");
static_assert(offsetof(UJPGameSettingListView, LeftPadding) == 0x000CCC, "Member 'UJPGameSettingListView::LeftPadding' has a wrong offset!");
static_assert(offsetof(UJPGameSettingListView, TopPadding) == 0x000CD0, "Member 'UJPGameSettingListView::TopPadding' has a wrong offset!");
static_assert(offsetof(UJPGameSettingListView, BottomPadding) == 0x000CD4, "Member 'UJPGameSettingListView::BottomPadding' has a wrong offset!");

// Class JP.LyraGameSettingRegistry
// 0x0030 (0x00E0 - 0x00B0)
class ULyraGameSettingRegistry : public UGameSettingRegistry
{
public:
	class UJPGameSettingCollection*               VideoSettings;                                     // 0x00B0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJPGameSettingCollection*               AudioSettings;                                     // 0x00B8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJPGameSettingCollection*               GameplaySettings;                                  // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJPGameSettingCollection*               MouseAndKeyboardSettings;                          // 0x00C8(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJPGameSettingCollection*               GamepadSettings;                                   // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJPGameSettingValueDiscreteDynamic_Number* SuperResolutionSetting;                            // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameSettingRegistry">();
	}
	static class ULyraGameSettingRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameSettingRegistry>();
	}
};
static_assert(alignof(ULyraGameSettingRegistry) == 0x000008, "Wrong alignment on ULyraGameSettingRegistry");
static_assert(sizeof(ULyraGameSettingRegistry) == 0x0000E0, "Wrong size on ULyraGameSettingRegistry");
static_assert(offsetof(ULyraGameSettingRegistry, VideoSettings) == 0x0000B0, "Member 'ULyraGameSettingRegistry::VideoSettings' has a wrong offset!");
static_assert(offsetof(ULyraGameSettingRegistry, AudioSettings) == 0x0000B8, "Member 'ULyraGameSettingRegistry::AudioSettings' has a wrong offset!");
static_assert(offsetof(ULyraGameSettingRegistry, GameplaySettings) == 0x0000C0, "Member 'ULyraGameSettingRegistry::GameplaySettings' has a wrong offset!");
static_assert(offsetof(ULyraGameSettingRegistry, MouseAndKeyboardSettings) == 0x0000C8, "Member 'ULyraGameSettingRegistry::MouseAndKeyboardSettings' has a wrong offset!");
static_assert(offsetof(ULyraGameSettingRegistry, GamepadSettings) == 0x0000D0, "Member 'ULyraGameSettingRegistry::GamepadSettings' has a wrong offset!");
static_assert(offsetof(ULyraGameSettingRegistry, SuperResolutionSetting) == 0x0000D8, "Member 'ULyraGameSettingRegistry::SuperResolutionSetting' has a wrong offset!");

// Class JP.JPGameSettingRegistry
// 0x0000 (0x00E0 - 0x00E0)
class UJPGameSettingRegistry final : public ULyraGameSettingRegistry
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingRegistry">();
	}
	static class UJPGameSettingRegistry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingRegistry>();
	}
};
static_assert(alignof(UJPGameSettingRegistry) == 0x000008, "Wrong alignment on UJPGameSettingRegistry");
static_assert(sizeof(UJPGameSettingRegistry) == 0x0000E0, "Wrong size on UJPGameSettingRegistry");

// Class JP.PreLobbyServerBrowserList
// 0x0118 (0x03F8 - 0x02E0)
class UPreLobbyServerBrowserList : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnEntrySelected;                                   // 0x02E0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UPreLobbyServerBrowserEntry> LobbyEntryClass;                                   // 0x02F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UVerticalBox*                           LobbyEntryList;                                    // 0x02F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NumEntriesPerPage;                                 // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_304[0x9C];                                     // 0x0304(0x009C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UPreLobbyServerBrowserEntry> SelectedEntry;                                     // 0x03A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x50];                                     // 0x03A8(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyViewModel(const struct FPreLobbyServerBrowserListViewModel& ViewModel);
	void DisplayPasswordPrompt();
	void HandleEntrySelected(class UPreLobbyServerBrowserEntry* InEntry, bool InJoin);
	void OnHandleJoinSelectedLobbyRequest();
	void OnPlayerInputPassword(const class FString& Password);
	void PopulateWithTestData();
	void SetPageIndex(int32 InPageIndex);
	void SetShowFullServers(bool bInShowFullServers);
	void SetSortMode(EPreLobbyServerBrowserListSortMode InSortMode);
	void TryJoinSelectedLobby();

	class UPreLobbyServerBrowserEntry* GetSelectedEntry() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreLobbyServerBrowserList">();
	}
	static class UPreLobbyServerBrowserList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreLobbyServerBrowserList>();
	}
};
static_assert(alignof(UPreLobbyServerBrowserList) == 0x000008, "Wrong alignment on UPreLobbyServerBrowserList");
static_assert(sizeof(UPreLobbyServerBrowserList) == 0x0003F8, "Wrong size on UPreLobbyServerBrowserList");
static_assert(offsetof(UPreLobbyServerBrowserList, OnEntrySelected) == 0x0002E0, "Member 'UPreLobbyServerBrowserList::OnEntrySelected' has a wrong offset!");
static_assert(offsetof(UPreLobbyServerBrowserList, LobbyEntryClass) == 0x0002F0, "Member 'UPreLobbyServerBrowserList::LobbyEntryClass' has a wrong offset!");
static_assert(offsetof(UPreLobbyServerBrowserList, LobbyEntryList) == 0x0002F8, "Member 'UPreLobbyServerBrowserList::LobbyEntryList' has a wrong offset!");
static_assert(offsetof(UPreLobbyServerBrowserList, NumEntriesPerPage) == 0x000300, "Member 'UPreLobbyServerBrowserList::NumEntriesPerPage' has a wrong offset!");
static_assert(offsetof(UPreLobbyServerBrowserList, SelectedEntry) == 0x0003A0, "Member 'UPreLobbyServerBrowserList::SelectedEntry' has a wrong offset!");

// Class JP.JPGameSettingValueDiscrete
// 0x0010 (0x0160 - 0x0150)
class UJPGameSettingValueDiscrete : public UGameSettingValueDiscrete
{
public:
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueDiscrete">();
	}
	static class UJPGameSettingValueDiscrete* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueDiscrete>();
	}
};
static_assert(alignof(UJPGameSettingValueDiscrete) == 0x000008, "Wrong alignment on UJPGameSettingValueDiscrete");
static_assert(sizeof(UJPGameSettingValueDiscrete) == 0x000160, "Wrong size on UJPGameSettingValueDiscrete");

// Class JP.NeighborDefinition
// 0x01A8 (0x01D8 - 0x0030)
class UNeighborDefinition final : public UPrimaryDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0040(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              IconLocked;                                        // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UpperBodyIcon;                                     // 0x0090(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              UpperBodyIconLocked;                               // 0x00B8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              LocatorIcon;                                       // 0x00E0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemDefinition>         StartingItem;                                      // 0x0108(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemDefinition>         SecondaryStartingItem;                             // 0x0130(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNeighborSpecialAbilityDefinition> SpecialAbility;                                    // 0x0158(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DefaultSkin;                                       // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UAnimMontage>> Animations;                                        // 0x0188(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	struct FGameplayTag GetStartingItemID() const;
	struct FGameplayTag TryGetStartingItemSkinID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborDefinition">();
	}
	static class UNeighborDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborDefinition>();
	}
};
static_assert(alignof(UNeighborDefinition) == 0x000008, "Wrong alignment on UNeighborDefinition");
static_assert(sizeof(UNeighborDefinition) == 0x0001D8, "Wrong size on UNeighborDefinition");
static_assert(offsetof(UNeighborDefinition, Name_0) == 0x000030, "Member 'UNeighborDefinition::Name_0' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, Icon) == 0x000040, "Member 'UNeighborDefinition::Icon' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, IconLocked) == 0x000068, "Member 'UNeighborDefinition::IconLocked' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, UpperBodyIcon) == 0x000090, "Member 'UNeighborDefinition::UpperBodyIcon' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, UpperBodyIconLocked) == 0x0000B8, "Member 'UNeighborDefinition::UpperBodyIconLocked' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, LocatorIcon) == 0x0000E0, "Member 'UNeighborDefinition::LocatorIcon' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, StartingItem) == 0x000108, "Member 'UNeighborDefinition::StartingItem' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, SecondaryStartingItem) == 0x000130, "Member 'UNeighborDefinition::SecondaryStartingItem' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, SpecialAbility) == 0x000158, "Member 'UNeighborDefinition::SpecialAbility' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, DefaultSkin) == 0x000180, "Member 'UNeighborDefinition::DefaultSkin' has a wrong offset!");
static_assert(offsetof(UNeighborDefinition, Animations) == 0x000188, "Member 'UNeighborDefinition::Animations' has a wrong offset!");

// Class JP.JPGameSettingValueDiscreteDynamic_Bool
// 0x0010 (0x01C8 - 0x01B8)
class UJPGameSettingValueDiscreteDynamic_Bool : public UGameSettingValueDiscreteDynamic_Bool
{
public:
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueDiscreteDynamic_Bool">();
	}
	static class UJPGameSettingValueDiscreteDynamic_Bool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueDiscreteDynamic_Bool>();
	}
};
static_assert(alignof(UJPGameSettingValueDiscreteDynamic_Bool) == 0x000008, "Wrong alignment on UJPGameSettingValueDiscreteDynamic_Bool");
static_assert(sizeof(UJPGameSettingValueDiscreteDynamic_Bool) == 0x0001C8, "Wrong size on UJPGameSettingValueDiscreteDynamic_Bool");

// Class JP.JPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning
// 0x0000 (0x01C8 - 0x01C8)
class UJPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning final : public UJPGameSettingValueDiscreteDynamic_Bool
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning">();
	}
	static class UJPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning>();
	}
};
static_assert(alignof(UJPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning) == 0x000008, "Wrong alignment on UJPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning");
static_assert(sizeof(UJPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning) == 0x0001C8, "Wrong size on UJPGameSettingValueDiscreteDynamic_Bool_WithRestartWarning");

// Class JP.RandomLootDefinition
// 0x0058 (0x0088 - 0x0030)
class URandomLootDefinition final : public UDataAsset
{
public:
	TMap<struct FGameplayTag, float>              LootProbabilities;                                 // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         ChanceToSpawnWeight;                               // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RandomLootDefinition">();
	}
	static class URandomLootDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<URandomLootDefinition>();
	}
};
static_assert(alignof(URandomLootDefinition) == 0x000008, "Wrong alignment on URandomLootDefinition");
static_assert(sizeof(URandomLootDefinition) == 0x000088, "Wrong size on URandomLootDefinition");
static_assert(offsetof(URandomLootDefinition, LootProbabilities) == 0x000030, "Member 'URandomLootDefinition::LootProbabilities' has a wrong offset!");
static_assert(offsetof(URandomLootDefinition, ChanceToSpawnWeight) == 0x000080, "Member 'URandomLootDefinition::ChanceToSpawnWeight' has a wrong offset!");

// Class JP.JPGameSettingValueDiscreteDynamic_Color
// 0x0010 (0x01C8 - 0x01B8)
class UJPGameSettingValueDiscreteDynamic_Color final : public UGameSettingValueDiscreteDynamic_Color
{
public:
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueDiscreteDynamic_Color">();
	}
	static class UJPGameSettingValueDiscreteDynamic_Color* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueDiscreteDynamic_Color>();
	}
};
static_assert(alignof(UJPGameSettingValueDiscreteDynamic_Color) == 0x000008, "Wrong alignment on UJPGameSettingValueDiscreteDynamic_Color");
static_assert(sizeof(UJPGameSettingValueDiscreteDynamic_Color) == 0x0001C8, "Wrong size on UJPGameSettingValueDiscreteDynamic_Color");

// Class JP.ObjectiveAction_EndTime
// 0x0008 (0x0030 - 0x0028)
class UObjectiveAction_EndTime final : public UObjectiveAction
{
public:
	class UEndTimeBase*                           EndTime;                                           // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, PersistentInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveAction_EndTime">();
	}
	static class UObjectiveAction_EndTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveAction_EndTime>();
	}
};
static_assert(alignof(UObjectiveAction_EndTime) == 0x000008, "Wrong alignment on UObjectiveAction_EndTime");
static_assert(sizeof(UObjectiveAction_EndTime) == 0x000030, "Wrong size on UObjectiveAction_EndTime");
static_assert(offsetof(UObjectiveAction_EndTime, EndTime) == 0x000028, "Member 'UObjectiveAction_EndTime::EndTime' has a wrong offset!");

// Class JP.JPGameSettingValueDiscreteDynamic_Enum
// 0x0010 (0x01C8 - 0x01B8)
class UJPGameSettingValueDiscreteDynamic_Enum final : public UGameSettingValueDiscreteDynamic_Enum
{
public:
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueDiscreteDynamic_Enum">();
	}
	static class UJPGameSettingValueDiscreteDynamic_Enum* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueDiscreteDynamic_Enum>();
	}
};
static_assert(alignof(UJPGameSettingValueDiscreteDynamic_Enum) == 0x000008, "Wrong alignment on UJPGameSettingValueDiscreteDynamic_Enum");
static_assert(sizeof(UJPGameSettingValueDiscreteDynamic_Enum) == 0x0001C8, "Wrong size on UJPGameSettingValueDiscreteDynamic_Enum");

// Class JP.JPGameSettingValueDiscreteDynamic_Number
// 0x0010 (0x01C8 - 0x01B8)
class UJPGameSettingValueDiscreteDynamic_Number final : public UGameSettingValueDiscreteDynamic_Number
{
public:
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueDiscreteDynamic_Number">();
	}
	static class UJPGameSettingValueDiscreteDynamic_Number* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueDiscreteDynamic_Number>();
	}
};
static_assert(alignof(UJPGameSettingValueDiscreteDynamic_Number) == 0x000008, "Wrong alignment on UJPGameSettingValueDiscreteDynamic_Number");
static_assert(sizeof(UJPGameSettingValueDiscreteDynamic_Number) == 0x0001C8, "Wrong size on UJPGameSettingValueDiscreteDynamic_Number");

// Class JP.JPGameSettingValueDiscreteDynamic_Vector2D
// 0x0010 (0x01C8 - 0x01B8)
class UJPGameSettingValueDiscreteDynamic_Vector2D final : public UGameSettingValueDiscreteDynamic_Vector2D
{
public:
	uint8                                         Pad_1B8[0x10];                                     // 0x01B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueDiscreteDynamic_Vector2D">();
	}
	static class UJPGameSettingValueDiscreteDynamic_Vector2D* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueDiscreteDynamic_Vector2D>();
	}
};
static_assert(alignof(UJPGameSettingValueDiscreteDynamic_Vector2D) == 0x000008, "Wrong alignment on UJPGameSettingValueDiscreteDynamic_Vector2D");
static_assert(sizeof(UJPGameSettingValueDiscreteDynamic_Vector2D) == 0x0001C8, "Wrong size on UJPGameSettingValueDiscreteDynamic_Vector2D");

// Class JP.RepairnessAttributeSetListener
// 0x0000 (0x0028 - 0x0028)
class IRepairnessAttributeSetListener final : public IInterface
{
public:
	void OnRepairnessChanged(float Repairness, float MaxRepairness);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairnessAttributeSetListener">();
	}
	static class IRepairnessAttributeSetListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IRepairnessAttributeSetListener>();
	}
};
static_assert(alignof(IRepairnessAttributeSetListener) == 0x000008, "Wrong alignment on IRepairnessAttributeSetListener");
static_assert(sizeof(IRepairnessAttributeSetListener) == 0x000028, "Wrong size on IRepairnessAttributeSetListener");

// Class JP.JPGameSettingValueScalar
// 0x0010 (0x0160 - 0x0150)
class UJPGameSettingValueScalar final : public UGameSettingValueScalar
{
public:
	uint8                                         Pad_150[0x10];                                     // 0x0150(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueScalar">();
	}
	static class UJPGameSettingValueScalar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueScalar>();
	}
};
static_assert(alignof(UJPGameSettingValueScalar) == 0x000008, "Wrong alignment on UJPGameSettingValueScalar");
static_assert(sizeof(UJPGameSettingValueScalar) == 0x000160, "Wrong size on UJPGameSettingValueScalar");

// Class JP.NeighborSelectPopupWidget
// 0x0038 (0x0468 - 0x0430)
class UNeighborSelectPopupWidget : public UCommonActivatableWidget
{
public:
	class UPanelWidget*                           PanelWidget;                                       // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UNeighborSelectEntry>       EntryWidgetClass;                                  // 0x0438(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FOnlineStoreItemData>           AvailableNeighbors;                                // 0x0440(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           LocalPlayerNeighborId;                             // 0x0450(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UNeighborSelectEntry*>           EntryWidgets;                                      // 0x0458(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void DismissPopup();
	void HandleEntryWidgetCreated(class UNeighborSelectEntry* EntryWidget);
	struct FGameplayTag SelectEntry(class UNeighborSelectEntry* EntryWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSelectPopupWidget">();
	}
	static class UNeighborSelectPopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborSelectPopupWidget>();
	}
};
static_assert(alignof(UNeighborSelectPopupWidget) == 0x000008, "Wrong alignment on UNeighborSelectPopupWidget");
static_assert(sizeof(UNeighborSelectPopupWidget) == 0x000468, "Wrong size on UNeighborSelectPopupWidget");
static_assert(offsetof(UNeighborSelectPopupWidget, PanelWidget) == 0x000430, "Member 'UNeighborSelectPopupWidget::PanelWidget' has a wrong offset!");
static_assert(offsetof(UNeighborSelectPopupWidget, EntryWidgetClass) == 0x000438, "Member 'UNeighborSelectPopupWidget::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(UNeighborSelectPopupWidget, AvailableNeighbors) == 0x000440, "Member 'UNeighborSelectPopupWidget::AvailableNeighbors' has a wrong offset!");
static_assert(offsetof(UNeighborSelectPopupWidget, LocalPlayerNeighborId) == 0x000450, "Member 'UNeighborSelectPopupWidget::LocalPlayerNeighborId' has a wrong offset!");
static_assert(offsetof(UNeighborSelectPopupWidget, EntryWidgets) == 0x000458, "Member 'UNeighborSelectPopupWidget::EntryWidgets' has a wrong offset!");

// Class JP.NeighborSelectWidgetAlwaysActive
// 0x0000 (0x0468 - 0x0468)
class UNeighborSelectWidgetAlwaysActive final : public UNeighborSelectPopupWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSelectWidgetAlwaysActive">();
	}
	static class UNeighborSelectWidgetAlwaysActive* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborSelectWidgetAlwaysActive>();
	}
};
static_assert(alignof(UNeighborSelectWidgetAlwaysActive) == 0x000008, "Wrong alignment on UNeighborSelectWidgetAlwaysActive");
static_assert(sizeof(UNeighborSelectWidgetAlwaysActive) == 0x000468, "Wrong size on UNeighborSelectWidgetAlwaysActive");

// Class JP.JPGameSettingValueScalarDynamic
// 0x0010 (0x0220 - 0x0210)
class UJPGameSettingValueScalarDynamic final : public UGameSettingValueScalarDynamic
{
public:
	uint8                                         Pad_210[0x10];                                     // 0x0210(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingValueScalarDynamic">();
	}
	static class UJPGameSettingValueScalarDynamic* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPGameSettingValueScalarDynamic>();
	}
};
static_assert(alignof(UJPGameSettingValueScalarDynamic) == 0x000008, "Wrong alignment on UJPGameSettingValueScalarDynamic");
static_assert(sizeof(UJPGameSettingValueScalarDynamic) == 0x000220, "Wrong size on UJPGameSettingValueScalarDynamic");

// Class JP.JPGameSettingWithOddEvenInterface
// 0x0000 (0x0028 - 0x0028)
class IJPGameSettingWithOddEvenInterface final : public IInterface
{
public:
	bool GetIsEven();
	void SetIsEven(bool IsEven);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPGameSettingWithOddEvenInterface">();
	}
	static class IJPGameSettingWithOddEvenInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJPGameSettingWithOddEvenInterface>();
	}
};
static_assert(alignof(IJPGameSettingWithOddEvenInterface) == 0x000008, "Wrong alignment on IJPGameSettingWithOddEvenInterface");
static_assert(sizeof(IJPGameSettingWithOddEvenInterface) == 0x000028, "Wrong size on IJPGameSettingWithOddEvenInterface");

// Class JP.OnlineCurrency
// 0x0070 (0x00A8 - 0x0038)
class UOnlineCurrency final : public UTagLookupPrimaryDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0068(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture2D>>      BuyCurrencyIcons;                                  // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	class FName                                   RichTextIdentifier;                                // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineCurrency">();
	}
	static class UOnlineCurrency* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineCurrency>();
	}
};
static_assert(alignof(UOnlineCurrency) == 0x000008, "Wrong alignment on UOnlineCurrency");
static_assert(sizeof(UOnlineCurrency) == 0x0000A8, "Wrong size on UOnlineCurrency");
static_assert(offsetof(UOnlineCurrency, Name_0) == 0x000038, "Member 'UOnlineCurrency::Name_0' has a wrong offset!");
static_assert(offsetof(UOnlineCurrency, Description) == 0x000048, "Member 'UOnlineCurrency::Description' has a wrong offset!");
static_assert(offsetof(UOnlineCurrency, Color) == 0x000058, "Member 'UOnlineCurrency::Color' has a wrong offset!");
static_assert(offsetof(UOnlineCurrency, Icon) == 0x000068, "Member 'UOnlineCurrency::Icon' has a wrong offset!");
static_assert(offsetof(UOnlineCurrency, BuyCurrencyIcons) == 0x000090, "Member 'UOnlineCurrency::BuyCurrencyIcons' has a wrong offset!");
static_assert(offsetof(UOnlineCurrency, RichTextIdentifier) == 0x0000A0, "Member 'UOnlineCurrency::RichTextIdentifier' has a wrong offset!");

// Class JP.ObjectiveManagerComponent
// 0x0010 (0x00B0 - 0x00A0)
class UObjectiveManagerComponent : public UActorComponent
{
public:
	TArray<class UObjectiveInstance*>             Objectives;                                        // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static void CreateObjectiveInstance(class UObject* WorldContextObject, class UObjectiveDefinition* ObjectiveDefinition);

	void CreateObjectiveInstanceForThisObjectiveComponent(class UObjectiveDefinition* ObjectiveDefinition, bool UseTooltipShowSetting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveManagerComponent">();
	}
	static class UObjectiveManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveManagerComponent>();
	}
};
static_assert(alignof(UObjectiveManagerComponent) == 0x000008, "Wrong alignment on UObjectiveManagerComponent");
static_assert(sizeof(UObjectiveManagerComponent) == 0x0000B0, "Wrong size on UObjectiveManagerComponent");
static_assert(offsetof(UObjectiveManagerComponent, Objectives) == 0x0000A0, "Member 'UObjectiveManagerComponent::Objectives' has a wrong offset!");

// Class JP.JPHUDWidget_Tutorial
// 0x0000 (0x0438 - 0x0438)
class UJPHUDWidget_Tutorial final : public ULyraActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPHUDWidget_Tutorial">();
	}
	static class UJPHUDWidget_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPHUDWidget_Tutorial>();
	}
};
static_assert(alignof(UJPHUDWidget_Tutorial) == 0x000008, "Wrong alignment on UJPHUDWidget_Tutorial");
static_assert(sizeof(UJPHUDWidget_Tutorial) == 0x000438, "Wrong size on UJPHUDWidget_Tutorial");

// Class JP.LyraSettingKeyboardInput
// 0x0088 (0x01D8 - 0x0150)
class ULyraSettingKeyboardInput : public UGameSettingValue
{
public:
	uint8                                         Pad_150[0x88];                                     // 0x0150(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingKeyboardInput">();
	}
	static class ULyraSettingKeyboardInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingKeyboardInput>();
	}
};
static_assert(alignof(ULyraSettingKeyboardInput) == 0x000008, "Wrong alignment on ULyraSettingKeyboardInput");
static_assert(sizeof(ULyraSettingKeyboardInput) == 0x0001D8, "Wrong size on ULyraSettingKeyboardInput");

// Class JP.JPLyraSettingKeyboardInput
// 0x0010 (0x01E8 - 0x01D8)
class UJPLyraSettingKeyboardInput final : public ULyraSettingKeyboardInput
{
public:
	uint8                                         Pad_1D8[0x10];                                     // 0x01D8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPLyraSettingKeyboardInput">();
	}
	static class UJPLyraSettingKeyboardInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPLyraSettingKeyboardInput>();
	}
};
static_assert(alignof(UJPLyraSettingKeyboardInput) == 0x000008, "Wrong alignment on UJPLyraSettingKeyboardInput");
static_assert(sizeof(UJPLyraSettingKeyboardInput) == 0x0001E8, "Wrong size on UJPLyraSettingKeyboardInput");

// Class JP.JPModularGameInstance
// 0x0000 (0x01D0 - 0x01D0)
class UJPModularGameInstance final : public UCommonGameInstance
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPModularGameInstance">();
	}
	static class UJPModularGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPModularGameInstance>();
	}
};
static_assert(alignof(UJPModularGameInstance) == 0x000008, "Wrong alignment on UJPModularGameInstance");
static_assert(sizeof(UJPModularGameInstance) == 0x0001D0, "Wrong size on UJPModularGameInstance");

// Class JP.LyraGameplayCueManager
// 0x0130 (0x03F0 - 0x02C0)
class ULyraGameplayCueManager final : public UGameplayCueManager
{
public:
	TSet<TSubclassOf<class UObject>>              PreloadedCues;                                     // 0x02C0(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x50];                                     // 0x0310(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TSet<TSubclassOf<class UObject>>              AlwaysLoadedCues;                                  // 0x0360(0x0050)(Transient, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x40];                                     // 0x03B0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameplayCueManager">();
	}
	static class ULyraGameplayCueManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameplayCueManager>();
	}
};
static_assert(alignof(ULyraGameplayCueManager) == 0x000008, "Wrong alignment on ULyraGameplayCueManager");
static_assert(sizeof(ULyraGameplayCueManager) == 0x0003F0, "Wrong size on ULyraGameplayCueManager");
static_assert(offsetof(ULyraGameplayCueManager, PreloadedCues) == 0x0002C0, "Member 'ULyraGameplayCueManager::PreloadedCues' has a wrong offset!");
static_assert(offsetof(ULyraGameplayCueManager, AlwaysLoadedCues) == 0x000360, "Member 'ULyraGameplayCueManager::AlwaysLoadedCues' has a wrong offset!");

// Class JP.JPModularWorldSettings
// 0x0010 (0x04C8 - 0x04B8)
class AJPModularWorldSettings final : public ABaseWorldSettingsIW
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UExperienceDefinition>      WorldExperience;                                   // 0x04C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPModularWorldSettings">();
	}
	static class AJPModularWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJPModularWorldSettings>();
	}
};
static_assert(alignof(AJPModularWorldSettings) == 0x000008, "Wrong alignment on AJPModularWorldSettings");
static_assert(sizeof(AJPModularWorldSettings) == 0x0004C8, "Wrong size on AJPModularWorldSettings");
static_assert(offsetof(AJPModularWorldSettings, WorldExperience) == 0x0004C0, "Member 'AJPModularWorldSettings::WorldExperience' has a wrong offset!");

// Class JP.JPPlayerAnimInstance
// 0x0020 (0x0390 - 0x0370)
class UJPPlayerAnimInstance : public UAnimInstance
{
public:
	struct FGameplayTagBlueprintPropertyMap       GameplayTagPropertyMap;                            // 0x0368(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_388[0x8];                                      // 0x0388(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPPlayerAnimInstance">();
	}
	static class UJPPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPPlayerAnimInstance>();
	}
};
static_assert(alignof(UJPPlayerAnimInstance) == 0x000010, "Wrong alignment on UJPPlayerAnimInstance");
static_assert(sizeof(UJPPlayerAnimInstance) == 0x000390, "Wrong size on UJPPlayerAnimInstance");
static_assert(offsetof(UJPPlayerAnimInstance, GameplayTagPropertyMap) == 0x000368, "Member 'UJPPlayerAnimInstance::GameplayTagPropertyMap' has a wrong offset!");

// Class JP.JPSessionManagerSubsystem
// 0x0000 (0x0030 - 0x0030)
class UJPSessionManagerSubsystem final : public UGameInstanceSubsystem
{
public:
	static class FString GetBuildConfigurationFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success);
	static struct FDateTime GetCreatedTimestampFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success);
	static class FString GetCurrentLobbyName(bool* Success);
	static bool GetIsInLobbyFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success);
	static bool GetIsInNeighbourhoodFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success);
	static class FString GetLobbyNameFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success);
	static class FString GetProjectVersionFromSession(const class UCommonSession_SearchResult* SessionSearchResult, bool* Success);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPSessionManagerSubsystem">();
	}
	static class UJPSessionManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPSessionManagerSubsystem>();
	}
};
static_assert(alignof(UJPSessionManagerSubsystem) == 0x000008, "Wrong alignment on UJPSessionManagerSubsystem");
static_assert(sizeof(UJPSessionManagerSubsystem) == 0x000030, "Wrong size on UJPSessionManagerSubsystem");

// Class JP.OnlineServicesPartyMember
// 0x0000 (0x0070 - 0x0070)
class UOnlineServicesPartyMember final : public UOnlineServicesUserBase
{
public:
	bool IsLeader() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineServicesPartyMember">();
	}
	static class UOnlineServicesPartyMember* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineServicesPartyMember>();
	}
};
static_assert(alignof(UOnlineServicesPartyMember) == 0x000008, "Wrong alignment on UOnlineServicesPartyMember");
static_assert(sizeof(UOnlineServicesPartyMember) == 0x000070, "Wrong size on UOnlineServicesPartyMember");

// Class JP.JPSettingPanel
// 0x0008 (0x02E8 - 0x02E0)
class UJPSettingPanel : public UUserWidget
{
public:
	class UNamedSlot*                             NamedSlot;                                         // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddSetting(class UJPSettingWidget* InWidget);
	void ClearHighlight();
	void HighlightSetting(const class FString& InSettingIdentifier);

	TArray<class UJPSettingWidget*> GetAllSettings() const;
	class UJPSettingWidget* GetSetting(const class FString& InSettingIdentifier) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPSettingPanel">();
	}
	static class UJPSettingPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPSettingPanel>();
	}
};
static_assert(alignof(UJPSettingPanel) == 0x000008, "Wrong alignment on UJPSettingPanel");
static_assert(sizeof(UJPSettingPanel) == 0x0002E8, "Wrong size on UJPSettingPanel");
static_assert(offsetof(UJPSettingPanel, NamedSlot) == 0x0002E0, "Member 'UJPSettingPanel::NamedSlot' has a wrong offset!");

// Class JP.CharacterMovementJPComponent
// 0x0000 (0x0F80 - 0x0F80)
class UCharacterMovementJPComponent final : public UCharacterMovementComponent
{
public:
	float                                         CurrentMaxFallVelocity;                            // 0x0F78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultMaxFallVelocity;                            // 0x0F7C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterMovementJPComponent">();
	}
	static class UCharacterMovementJPComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterMovementJPComponent>();
	}
};
static_assert(alignof(UCharacterMovementJPComponent) == 0x000010, "Wrong alignment on UCharacterMovementJPComponent");
static_assert(sizeof(UCharacterMovementJPComponent) == 0x000F80, "Wrong size on UCharacterMovementJPComponent");
static_assert(offsetof(UCharacterMovementJPComponent, CurrentMaxFallVelocity) == 0x000F78, "Member 'UCharacterMovementJPComponent::CurrentMaxFallVelocity' has a wrong offset!");
static_assert(offsetof(UCharacterMovementJPComponent, DefaultMaxFallVelocity) == 0x000F7C, "Member 'UCharacterMovementJPComponent::DefaultMaxFallVelocity' has a wrong offset!");

// Class JP.ObjectiveWorldSubsystem
// 0x00A0 (0x00D0 - 0x0030)
class UObjectiveWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnObjectiveFinished;                               // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnObjectiveDestroyed;                              // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x20];                                      // 0x00B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DestroySubObjective(class AActor* DestroyedActor);
	TArray<struct FObjectiveAndOwningPlayer> GetObjectives();
	void ObjectiveDelegate__DelegateSignature(const struct FObjectiveAndOwningPlayer& ObjectiveDefinition);
	void SubObjectiveDelegate__DelegateSignature(class ASubObjective* SubObjective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveWorldSubsystem">();
	}
	static class UObjectiveWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveWorldSubsystem>();
	}
};
static_assert(alignof(UObjectiveWorldSubsystem) == 0x000008, "Wrong alignment on UObjectiveWorldSubsystem");
static_assert(sizeof(UObjectiveWorldSubsystem) == 0x0000D0, "Wrong size on UObjectiveWorldSubsystem");
static_assert(offsetof(UObjectiveWorldSubsystem, OnObjectiveFinished) == 0x000090, "Member 'UObjectiveWorldSubsystem::OnObjectiveFinished' has a wrong offset!");
static_assert(offsetof(UObjectiveWorldSubsystem, OnObjectiveDestroyed) == 0x0000A0, "Member 'UObjectiveWorldSubsystem::OnObjectiveDestroyed' has a wrong offset!");

// Class JP.JPSettingWidget
// 0x0068 (0x0348 - 0x02E0)
class UJPSettingWidget : public UUserWidget
{
public:
	class FName                                   Identifier;                                        // 0x02E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x02E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x02F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UTexture2D>              DescriptionImage;                                  // 0x0308(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnValueChanged;                                    // 0x0310(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHovered;                                         // 0x0320(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnhovered;                                       // 0x0330(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	class UJPSettingPanel*                        Panel;                                             // 0x0340(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void SetHighlighted(bool InHovered);

	class UJPSettingPanel* GetSettingPanel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPSettingWidget">();
	}
	static class UJPSettingWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPSettingWidget>();
	}
};
static_assert(alignof(UJPSettingWidget) == 0x000008, "Wrong alignment on UJPSettingWidget");
static_assert(sizeof(UJPSettingWidget) == 0x000348, "Wrong size on UJPSettingWidget");
static_assert(offsetof(UJPSettingWidget, Identifier) == 0x0002E0, "Member 'UJPSettingWidget::Identifier' has a wrong offset!");
static_assert(offsetof(UJPSettingWidget, Title) == 0x0002E8, "Member 'UJPSettingWidget::Title' has a wrong offset!");
static_assert(offsetof(UJPSettingWidget, Description) == 0x0002F8, "Member 'UJPSettingWidget::Description' has a wrong offset!");
static_assert(offsetof(UJPSettingWidget, DescriptionImage) == 0x000308, "Member 'UJPSettingWidget::DescriptionImage' has a wrong offset!");
static_assert(offsetof(UJPSettingWidget, OnValueChanged) == 0x000310, "Member 'UJPSettingWidget::OnValueChanged' has a wrong offset!");
static_assert(offsetof(UJPSettingWidget, OnHovered) == 0x000320, "Member 'UJPSettingWidget::OnHovered' has a wrong offset!");
static_assert(offsetof(UJPSettingWidget, OnUnhovered) == 0x000330, "Member 'UJPSettingWidget::OnUnhovered' has a wrong offset!");
static_assert(offsetof(UJPSettingWidget, Panel) == 0x000340, "Member 'UJPSettingWidget::Panel' has a wrong offset!");

// Class JP.JPTabDescriptorProviderInterface
// 0x0000 (0x0028 - 0x0028)
class IJPTabDescriptorProviderInterface final : public IInterface
{
public:
	TArray<struct FLyraTabDescriptor> GetTabDescriptors(const TArray<struct FLyraTabDescriptor>& ExistingTabDescriptors) const;
	bool IsTabDisabled(const class FName TabName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPTabDescriptorProviderInterface">();
	}
	static class IJPTabDescriptorProviderInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJPTabDescriptorProviderInterface>();
	}
};
static_assert(alignof(IJPTabDescriptorProviderInterface) == 0x000008, "Wrong alignment on IJPTabDescriptorProviderInterface");
static_assert(sizeof(IJPTabDescriptorProviderInterface) == 0x000028, "Wrong size on IJPTabDescriptorProviderInterface");

// Class JP.LyraTabListWidgetBase
// 0x0088 (0x0510 - 0x0488)
class ULyraTabListWidgetBase : public UCommonTabListWidgetBase
{
public:
	FMulticastInlineDelegateProperty_             OnTabContentCreated;                               // 0x0488(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_498[0x18];                                     // 0x0498(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLyraTabDescriptor>             PreregisteredTabInfoArray;                         // 0x04B0(0x0010)(Edit, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FLyraTabDescriptor>  PendingTabLabelInfoMap;                            // 0x04C0(0x0050)(ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	bool GetPreregisteredTabInfo(const class FName TabNameID, struct FLyraTabDescriptor* OutTabInfo);
	int32 GetVisibleTabCount();
	bool IsTabVisible(class FName TabId);
	void OnTabContentCreated__DelegateSignature(class FName TabId, class UCommonUserWidget* TabWidget);
	bool RegisterDynamicTab(const struct FLyraTabDescriptor& TabDescriptor);
	void SetTabHiddenState(class FName TabNameID, bool bHidden);

	bool IsFirstTabActive() const;
	bool IsLastTabActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTabListWidgetBase">();
	}
	static class ULyraTabListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTabListWidgetBase>();
	}
};
static_assert(alignof(ULyraTabListWidgetBase) == 0x000008, "Wrong alignment on ULyraTabListWidgetBase");
static_assert(sizeof(ULyraTabListWidgetBase) == 0x000510, "Wrong size on ULyraTabListWidgetBase");
static_assert(offsetof(ULyraTabListWidgetBase, OnTabContentCreated) == 0x000488, "Member 'ULyraTabListWidgetBase::OnTabContentCreated' has a wrong offset!");
static_assert(offsetof(ULyraTabListWidgetBase, PreregisteredTabInfoArray) == 0x0004B0, "Member 'ULyraTabListWidgetBase::PreregisteredTabInfoArray' has a wrong offset!");
static_assert(offsetof(ULyraTabListWidgetBase, PendingTabLabelInfoMap) == 0x0004C0, "Member 'ULyraTabListWidgetBase::PendingTabLabelInfoMap' has a wrong offset!");

// Class JP.OnlineStoreBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOnlineStoreBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString GetTitlePlayerAccountIdFromPlayerController(const class APlayerControllerJP* PlayerController);
	static class FString GetTitlePlayerAccountIdFromPlayerState(const class APlayerStateJP* PlayerState);
	static bool TryGetCurrencyBundleDataAsset(const struct FPlatformStoreOffer& PlatformStoreOffer, TSoftObjectPtr<class UOnlineCurrencyBundleDataAsset>* CurrencyBundleDataAsset);
	static bool TryGetCurrencyFromTagIdentifier(const struct FGameplayTag& CurrencyIdentifier, TSoftObjectPtr<class UOnlineCurrency>* OutCurrency);
	static bool TryGetLoadoutStartingItemSkinID(const struct FNeighborLoadout& NeighborLoadout, struct FGameplayTag* OutTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineStoreBlueprintFunctionLibrary">();
	}
	static class UOnlineStoreBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineStoreBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UOnlineStoreBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UOnlineStoreBlueprintFunctionLibrary");
static_assert(sizeof(UOnlineStoreBlueprintFunctionLibrary) == 0x000028, "Wrong size on UOnlineStoreBlueprintFunctionLibrary");

// Class JP.JPTabListWidgetBase
// 0x0010 (0x0520 - 0x0510)
class UJPTabListWidgetBase : public ULyraTabListWidgetBase
{
public:
	TScriptInterface<class IJPTabDescriptorProviderInterface> TabDescriptorProvider;                             // 0x0510(0x0010)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPTabListWidgetBase">();
	}
	static class UJPTabListWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPTabListWidgetBase>();
	}
};
static_assert(alignof(UJPTabListWidgetBase) == 0x000008, "Wrong alignment on UJPTabListWidgetBase");
static_assert(sizeof(UJPTabListWidgetBase) == 0x000520, "Wrong size on UJPTabListWidgetBase");
static_assert(offsetof(UJPTabListWidgetBase, TabDescriptorProvider) == 0x000510, "Member 'UJPTabListWidgetBase::TabDescriptorProvider' has a wrong offset!");

// Class JP.EconomyDefinition
// 0x0010 (0x0040 - 0x0030)
class UEconomyDefinition final : public UDataAsset
{
public:
	TArray<struct FResourceData>                  Resources;                                         // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	class FText GetMoneyDisplayNameText() const;
	class FText GetPerfectnessDisplayNameText() const;
	class FText GetWoodDisplayNameText() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EconomyDefinition">();
	}
	static class UEconomyDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEconomyDefinition>();
	}
};
static_assert(alignof(UEconomyDefinition) == 0x000008, "Wrong alignment on UEconomyDefinition");
static_assert(sizeof(UEconomyDefinition) == 0x000040, "Wrong size on UEconomyDefinition");
static_assert(offsetof(UEconomyDefinition, Resources) == 0x000030, "Member 'UEconomyDefinition::Resources' has a wrong offset!");

// Class JP.ObjectiveBase
// 0x0068 (0x0090 - 0x0028)
class UObjectiveBase : public UObject
{
public:
	struct FObjectivesDataTableRow                ObjectiveData;                                     // 0x0028(0x0030)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsWinningCondition;                               // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DataTable;                                         // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DataRowName;                                       // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AGroundsKeeper*                         GroundsKeeper;                                     // 0x0070(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class AActor*>                         ManagedTasks;                                      // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	bool                                          bHasInitialized;                                   // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlushNetDormancy();
	class UObjectivesComponent* GetObjectivesComponent();
	bool HasAuthority();
	void InitializeTeamDependencies();
	void OnCreated();
	void OnRep_GroundsKeeper();
	void OnRep_ManagedTasks();
	TArray<class AActor*> SpawnTasks(TSubclassOf<class AActor> TaskType, uint8 AmountToSpawn);

	class AGroundsKeeper* GetGroundsKeeper() const;
	bool GetIsWinningCondition() const;
	const struct FMatchConfiguration GetMatchConfiguration() const;
	class FText GetProgressionText(const class FText& RowData) const;
	EObjectiveState GetState() const;
	struct FTeam GetTeam() const;
	uint8 GetTeamID() const;
	class FText GetTitle(const class FText& RowData) const;
	bool IsLocalPlayerRelated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveBase">();
	}
	static class UObjectiveBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveBase>();
	}
};
static_assert(alignof(UObjectiveBase) == 0x000008, "Wrong alignment on UObjectiveBase");
static_assert(sizeof(UObjectiveBase) == 0x000090, "Wrong size on UObjectiveBase");
static_assert(offsetof(UObjectiveBase, ObjectiveData) == 0x000028, "Member 'UObjectiveBase::ObjectiveData' has a wrong offset!");
static_assert(offsetof(UObjectiveBase, bIsWinningCondition) == 0x000058, "Member 'UObjectiveBase::bIsWinningCondition' has a wrong offset!");
static_assert(offsetof(UObjectiveBase, DataTable) == 0x000060, "Member 'UObjectiveBase::DataTable' has a wrong offset!");
static_assert(offsetof(UObjectiveBase, DataRowName) == 0x000068, "Member 'UObjectiveBase::DataRowName' has a wrong offset!");
static_assert(offsetof(UObjectiveBase, GroundsKeeper) == 0x000070, "Member 'UObjectiveBase::GroundsKeeper' has a wrong offset!");
static_assert(offsetof(UObjectiveBase, ManagedTasks) == 0x000078, "Member 'UObjectiveBase::ManagedTasks' has a wrong offset!");
static_assert(offsetof(UObjectiveBase, bHasInitialized) == 0x000088, "Member 'UObjectiveBase::bHasInitialized' has a wrong offset!");

// Class JP.JPTabPanelContent
// 0x0020 (0x0300 - 0x02E0)
class UJPTabPanelContent : public UUserWidget
{
public:
	class FString                                 Identifier;                                        // 0x02E0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FText                                   Title;                                             // 0x02F0(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void SetTabVisibility(bool InVisible, int32 InDirection);

	class FString GetIdentifier() const;
	class FText GetTitle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPTabPanelContent">();
	}
	static class UJPTabPanelContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPTabPanelContent>();
	}
};
static_assert(alignof(UJPTabPanelContent) == 0x000008, "Wrong alignment on UJPTabPanelContent");
static_assert(sizeof(UJPTabPanelContent) == 0x000300, "Wrong size on UJPTabPanelContent");
static_assert(offsetof(UJPTabPanelContent, Identifier) == 0x0002E0, "Member 'UJPTabPanelContent::Identifier' has a wrong offset!");
static_assert(offsetof(UJPTabPanelContent, Title) == 0x0002F0, "Member 'UJPTabPanelContent::Title' has a wrong offset!");

// Class JP.JPTabPanel
// 0x0038 (0x0318 - 0x02E0)
class UJPTabPanel : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnTabChanged;                                      // 0x02E0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNamedSlot*                             NamedSlot;                                         // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 SelectedTab;                                       // 0x02F8(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UJPTabPanelContent*>             CachedTabs;                                        // 0x0308(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void ApplyViewModel(const struct FJPTabPanelViewModel& InViewModel);
	void SelectDefaultTab(bool InPlayAnimation);
	void SelectNextTab();
	void SelectPreviousTab();
	void SelectTab(const class FString& InIdentifier, bool InPlayAnimation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPTabPanel">();
	}
	static class UJPTabPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPTabPanel>();
	}
};
static_assert(alignof(UJPTabPanel) == 0x000008, "Wrong alignment on UJPTabPanel");
static_assert(sizeof(UJPTabPanel) == 0x000318, "Wrong size on UJPTabPanel");
static_assert(offsetof(UJPTabPanel, OnTabChanged) == 0x0002E0, "Member 'UJPTabPanel::OnTabChanged' has a wrong offset!");
static_assert(offsetof(UJPTabPanel, NamedSlot) == 0x0002F0, "Member 'UJPTabPanel::NamedSlot' has a wrong offset!");
static_assert(offsetof(UJPTabPanel, SelectedTab) == 0x0002F8, "Member 'UJPTabPanel::SelectedTab' has a wrong offset!");
static_assert(offsetof(UJPTabPanel, CachedTabs) == 0x000308, "Member 'UJPTabPanel::CachedTabs' has a wrong offset!");

// Class JP.JPTimeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UJPTimeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class FString TimeSecondsToMinuteSeconds(float Seconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPTimeFunctionLibrary">();
	}
	static class UJPTimeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPTimeFunctionLibrary>();
	}
};
static_assert(alignof(UJPTimeFunctionLibrary) == 0x000008, "Wrong alignment on UJPTimeFunctionLibrary");
static_assert(sizeof(UJPTimeFunctionLibrary) == 0x000028, "Wrong size on UJPTimeFunctionLibrary");

// Class JP.MMC_PlayerCombatDamageOverTime
// 0x0000 (0x0040 - 0x0040)
class UMMC_PlayerCombatDamageOverTime final : public UMMC_PlayerCombat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MMC_PlayerCombatDamageOverTime">();
	}
	static class UMMC_PlayerCombatDamageOverTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMMC_PlayerCombatDamageOverTime>();
	}
};
static_assert(alignof(UMMC_PlayerCombatDamageOverTime) == 0x000008, "Wrong alignment on UMMC_PlayerCombatDamageOverTime");
static_assert(sizeof(UMMC_PlayerCombatDamageOverTime) == 0x000040, "Wrong size on UMMC_PlayerCombatDamageOverTime");

// Class JP.JPUIBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UJPUIBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void InsertPanelChildWidgetAt(class UPanelWidget* PanelWidget, int32 Index_0, class UWidget* NewChildWidget);
	static void ReplaceAllChildWidgetsWithArrayOfWidgets(class UPanelWidget* PanelWidget, const TArray<class UWidget*>& NewChildWidgets);
	static void ShiftPanelChildWidget(class UPanelWidget* PanelWidget, int32 Index_0, class UWidget* NewChildWidget);
	static void ShiftPanelChildWidgetRelative(class UPanelWidget* PanelWidget, int32 RelativeIndex, class UWidget* NewChildWidget);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPUIBlueprintFunctionLibrary">();
	}
	static class UJPUIBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPUIBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(UJPUIBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on UJPUIBlueprintFunctionLibrary");
static_assert(sizeof(UJPUIBlueprintFunctionLibrary) == 0x000028, "Wrong size on UJPUIBlueprintFunctionLibrary");

// Class JP.OnlineServicesLobbySubsystem
// 0x0178 (0x01A8 - 0x0030)
class UOnlineServicesLobbySubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xA8];                                      // 0x0030(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnQuickPlayFinishedCancelling;                     // 0x00D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuickPlayStarting;                               // 0x00E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnQuickPlayStopped;                                // 0x00F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x18];                                     // 0x0108(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UPartyOnlineServiceHandler*             PartyPtr;                                          // 0x0120(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USessionOnlineServiceHandler*           SessionHandler;                                    // 0x0128(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x78];                                     // 0x0130(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginQuickPlay();
	void CancelQuickPlay();
	void CreateLobby(const struct FLobbyConfiguration& InConfig);
	void OnPartyChanged();

	bool IsEnabled() const;
	bool IsQuickPlayMatchmakingInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineServicesLobbySubsystem">();
	}
	static class UOnlineServicesLobbySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineServicesLobbySubsystem>();
	}
};
static_assert(alignof(UOnlineServicesLobbySubsystem) == 0x000008, "Wrong alignment on UOnlineServicesLobbySubsystem");
static_assert(sizeof(UOnlineServicesLobbySubsystem) == 0x0001A8, "Wrong size on UOnlineServicesLobbySubsystem");
static_assert(offsetof(UOnlineServicesLobbySubsystem, OnQuickPlayFinishedCancelling) == 0x0000D8, "Member 'UOnlineServicesLobbySubsystem::OnQuickPlayFinishedCancelling' has a wrong offset!");
static_assert(offsetof(UOnlineServicesLobbySubsystem, OnQuickPlayStarting) == 0x0000E8, "Member 'UOnlineServicesLobbySubsystem::OnQuickPlayStarting' has a wrong offset!");
static_assert(offsetof(UOnlineServicesLobbySubsystem, OnQuickPlayStopped) == 0x0000F8, "Member 'UOnlineServicesLobbySubsystem::OnQuickPlayStopped' has a wrong offset!");
static_assert(offsetof(UOnlineServicesLobbySubsystem, PartyPtr) == 0x000120, "Member 'UOnlineServicesLobbySubsystem::PartyPtr' has a wrong offset!");
static_assert(offsetof(UOnlineServicesLobbySubsystem, SessionHandler) == 0x000128, "Member 'UOnlineServicesLobbySubsystem::SessionHandler' has a wrong offset!");

// Class JP.JPUIControllerBase
// 0x0028 (0x02B8 - 0x0290)
class AJPUIControllerBase : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShouldShowLoadingScreen;                          // 0x0298(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_299[0x7];                                      // 0x0299(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ShowLoadingScreenReason;                           // 0x02A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UEULAWidget>                EULAWidgetClass;                                   // 0x02B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void DoEULACheck();
	void OnEulaAccepted();
	void OnEulaError(const class FString& Message);
	void OnEULAWidgetShown(class UEULAWidget* EULAWidget);
	void OnPrivacyPolicyAccepted();
	void PrivacyPolicyCheck();
	void ResetUserAndSessionStateIfHardDisconnect();
	void SetShouldApplyMenuFrameRateLimit(bool InApplyLimit);
	void SetShouldShowLoadingScreen(bool InShouldShowLoadingScreen, const class FString& InReason);
	bool TryJoinRequestedSession();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPUIControllerBase">();
	}
	static class AJPUIControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJPUIControllerBase>();
	}
};
static_assert(alignof(AJPUIControllerBase) == 0x000008, "Wrong alignment on AJPUIControllerBase");
static_assert(sizeof(AJPUIControllerBase) == 0x0002B8, "Wrong size on AJPUIControllerBase");
static_assert(offsetof(AJPUIControllerBase, bShouldShowLoadingScreen) == 0x000298, "Member 'AJPUIControllerBase::bShouldShowLoadingScreen' has a wrong offset!");
static_assert(offsetof(AJPUIControllerBase, ShowLoadingScreenReason) == 0x0002A0, "Member 'AJPUIControllerBase::ShowLoadingScreenReason' has a wrong offset!");
static_assert(offsetof(AJPUIControllerBase, EULAWidgetClass) == 0x0002B0, "Member 'AJPUIControllerBase::EULAWidgetClass' has a wrong offset!");

// Class JP.KillCircumstance
// 0x0000 (0x0028 - 0x0028)
class UKillCircumstance final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillCircumstance">();
	}
	static class UKillCircumstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillCircumstance>();
	}
};
static_assert(alignof(UKillCircumstance) == 0x000008, "Wrong alignment on UKillCircumstance");
static_assert(sizeof(UKillCircumstance) == 0x000028, "Wrong size on UKillCircumstance");

// Class JP.KillTelemetry
// 0x0048 (0x00A8 - 0x0060)
class UKillTelemetry final : public UIWAnalyticsEvent
{
public:
	struct FKillTelemetryData                     KillTelemetryData;                                 // 0x0060(0x0048)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"KillTelemetry">();
	}
	static class UKillTelemetry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UKillTelemetry>();
	}
};
static_assert(alignof(UKillTelemetry) == 0x000008, "Wrong alignment on UKillTelemetry");
static_assert(sizeof(UKillTelemetry) == 0x0000A8, "Wrong size on UKillTelemetry");
static_assert(offsetof(UKillTelemetry, KillTelemetryData) == 0x000060, "Member 'UKillTelemetry::KillTelemetryData' has a wrong offset!");

// Class JP.MMC_PlayerCombatRanged
// 0x0000 (0x0040 - 0x0040)
class UMMC_PlayerCombatRanged final : public UMMC_PlayerCombat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MMC_PlayerCombatRanged">();
	}
	static class UMMC_PlayerCombatRanged* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMMC_PlayerCombatRanged>();
	}
};
static_assert(alignof(UMMC_PlayerCombatRanged) == 0x000008, "Wrong alignment on UMMC_PlayerCombatRanged");
static_assert(sizeof(UMMC_PlayerCombatRanged) == 0x000040, "Wrong size on UMMC_PlayerCombatRanged");

// Class JP.LevelVoteComponent
// 0x0138 (0x01D8 - 0x00A0)
class ULevelVoteComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnLevelVoteFinished;                               // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelSelectionChanged;                           // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLevelVotesUpdated;                               // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnLocalClientVoted;                                // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FSelectedLevelData                     SelectedLevel;                                     // 0x00E0(0x0070)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	TArray<uint8>                                 VoteOptions;                                       // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<uint8>                                 TotalVotes;                                        // 0x0160(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPublic)
	TArray<uint8>                                 CachedTotalVotes;                                  // 0x0170(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	EVoteState                                    State;                                             // 0x0180(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_181[0x7];                                      // 0x0181(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, int32>                            PlayerVotes;                                       // 0x0188(0x0050)(NativeAccessSpecifierPrivate)

public:
	static const struct FLevelVoteData GetVotingLevelFromIndex(uint8 LevelIndex);

	void FinishVotingProcess();
	void OnRep_TotalVoted();
	void StartVotingProcess();
	void VoteOnLevel(uint8 LevelIndex);

	EVoteState GetVoteState() const;
	void OnRep_SelectedLevel() const;
	void OnRep_VoteOptions() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelVoteComponent">();
	}
	static class ULevelVoteComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelVoteComponent>();
	}
};
static_assert(alignof(ULevelVoteComponent) == 0x000008, "Wrong alignment on ULevelVoteComponent");
static_assert(sizeof(ULevelVoteComponent) == 0x0001D8, "Wrong size on ULevelVoteComponent");
static_assert(offsetof(ULevelVoteComponent, OnLevelVoteFinished) == 0x0000A0, "Member 'ULevelVoteComponent::OnLevelVoteFinished' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, OnLevelSelectionChanged) == 0x0000B0, "Member 'ULevelVoteComponent::OnLevelSelectionChanged' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, OnLevelVotesUpdated) == 0x0000C0, "Member 'ULevelVoteComponent::OnLevelVotesUpdated' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, OnLocalClientVoted) == 0x0000D0, "Member 'ULevelVoteComponent::OnLocalClientVoted' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, SelectedLevel) == 0x0000E0, "Member 'ULevelVoteComponent::SelectedLevel' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, VoteOptions) == 0x000150, "Member 'ULevelVoteComponent::VoteOptions' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, TotalVotes) == 0x000160, "Member 'ULevelVoteComponent::TotalVotes' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, CachedTotalVotes) == 0x000170, "Member 'ULevelVoteComponent::CachedTotalVotes' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, State) == 0x000180, "Member 'ULevelVoteComponent::State' has a wrong offset!");
static_assert(offsetof(ULevelVoteComponent, PlayerVotes) == 0x000188, "Member 'ULevelVoteComponent::PlayerVotes' has a wrong offset!");

// Class JP.ObjectiveReward_TeamResource
// 0x0008 (0x0030 - 0x0028)
class UObjectiveReward_TeamResource final : public UObjectiveRewardBase
{
public:
	class UEconomyDefinition*                     Resource;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveReward_TeamResource">();
	}
	static class UObjectiveReward_TeamResource* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveReward_TeamResource>();
	}
};
static_assert(alignof(UObjectiveReward_TeamResource) == 0x000008, "Wrong alignment on UObjectiveReward_TeamResource");
static_assert(sizeof(UObjectiveReward_TeamResource) == 0x000030, "Wrong size on UObjectiveReward_TeamResource");
static_assert(offsetof(UObjectiveReward_TeamResource, Resource) == 0x000028, "Member 'UObjectiveReward_TeamResource::Resource' has a wrong offset!");

// Class JP.LevelVotePopupWidget
// 0x0000 (0x0430 - 0x0430)
class ULevelVotePopupWidget final : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LevelVotePopupWidget">();
	}
	static class ULevelVotePopupWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULevelVotePopupWidget>();
	}
};
static_assert(alignof(ULevelVotePopupWidget) == 0x000008, "Wrong alignment on ULevelVotePopupWidget");
static_assert(sizeof(ULevelVotePopupWidget) == 0x000430, "Wrong size on ULevelVotePopupWidget");

// Class JP.ListenServerBackfillWorldSubsystem
// 0x0070 (0x00A0 - 0x0030)
class UListenServerBackfillWorldSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x70];                                      // 0x0030(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAllPlayersReadyAndWaitingUpdated(const bool AllPlayersReadyAndWaiting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ListenServerBackfillWorldSubsystem">();
	}
	static class UListenServerBackfillWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UListenServerBackfillWorldSubsystem>();
	}
};
static_assert(alignof(UListenServerBackfillWorldSubsystem) == 0x000008, "Wrong alignment on UListenServerBackfillWorldSubsystem");
static_assert(sizeof(UListenServerBackfillWorldSubsystem) == 0x0000A0, "Wrong size on UListenServerBackfillWorldSubsystem");

// Class JP.LoadGuardButton
// 0x0038 (0x0318 - 0x02E0)
class ULoadGuardButton : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnClickedDelegate;                                 // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidget*                                LoadWidget;                                        // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraButtonBase*                        Button;                                            // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShowButton;                                       // 0x0300(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ButtonText;                                        // 0x0308(0x0010)(Edit, Protected, NativeAccessSpecifierProtected)

public:
	void EnableLoadGuard();
	void RestoreButton();
	void SetButtonText(const class FText& InButtonText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadGuardButton">();
	}
	static class ULoadGuardButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadGuardButton>();
	}
};
static_assert(alignof(ULoadGuardButton) == 0x000008, "Wrong alignment on ULoadGuardButton");
static_assert(sizeof(ULoadGuardButton) == 0x000318, "Wrong size on ULoadGuardButton");
static_assert(offsetof(ULoadGuardButton, OnClickedDelegate) == 0x0002E0, "Member 'ULoadGuardButton::OnClickedDelegate' has a wrong offset!");
static_assert(offsetof(ULoadGuardButton, LoadWidget) == 0x0002F0, "Member 'ULoadGuardButton::LoadWidget' has a wrong offset!");
static_assert(offsetof(ULoadGuardButton, Button) == 0x0002F8, "Member 'ULoadGuardButton::Button' has a wrong offset!");
static_assert(offsetof(ULoadGuardButton, bShowButton) == 0x000300, "Member 'ULoadGuardButton::bShowButton' has a wrong offset!");
static_assert(offsetof(ULoadGuardButton, ButtonText) == 0x000308, "Member 'ULoadGuardButton::ButtonText' has a wrong offset!");

// Class JP.NeighborDataContainer
// 0x0050 (0x0088 - 0x0038)
class UNeighborDataContainer final : public UTagLookupPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UNeighborDefinition>     Definition;                                        // 0x0038(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UNeighborMetaData>       MetaData;                                          // 0x0060(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborDataContainer">();
	}
	static class UNeighborDataContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborDataContainer>();
	}
};
static_assert(alignof(UNeighborDataContainer) == 0x000008, "Wrong alignment on UNeighborDataContainer");
static_assert(sizeof(UNeighborDataContainer) == 0x000088, "Wrong size on UNeighborDataContainer");
static_assert(offsetof(UNeighborDataContainer, Definition) == 0x000038, "Member 'UNeighborDataContainer::Definition' has a wrong offset!");
static_assert(offsetof(UNeighborDataContainer, MetaData) == 0x000060, "Member 'UNeighborDataContainer::MetaData' has a wrong offset!");

// Class JP.LoadoutVerificationServerComponent
// 0x0010 (0x00B0 - 0x00A0)
class ULoadoutVerificationServerComponent final : public UActorComponent
{
public:
	class USeasonPassGameInstanceSubsystem*       SeasonPassGIS;                                     // 0x00A0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULoadoutVerificationServerGameInstanceSubsystem* LoadoutVerificationGIS;                            // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnInventoryIdsChanged(class APlayerStateJP* PlayerState, const TArray<struct FGameplayTag>& InventoryIds);
	void OnMasterIdAcquired(class APlayerStateJP* PlayerState, const class FString& MasterPlayerAccountId);
	void OnPlayerXPChanged(class APlayerStateJP* PlayerState, const struct FPlayerXP& PlayerXP);
	void OnTitleIdAcquired(class APlayerStateJP* PlayerState, const class FString& TitlePlayerAccountId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutVerificationServerComponent">();
	}
	static class ULoadoutVerificationServerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutVerificationServerComponent>();
	}
};
static_assert(alignof(ULoadoutVerificationServerComponent) == 0x000008, "Wrong alignment on ULoadoutVerificationServerComponent");
static_assert(sizeof(ULoadoutVerificationServerComponent) == 0x0000B0, "Wrong size on ULoadoutVerificationServerComponent");
static_assert(offsetof(ULoadoutVerificationServerComponent, SeasonPassGIS) == 0x0000A0, "Member 'ULoadoutVerificationServerComponent::SeasonPassGIS' has a wrong offset!");
static_assert(offsetof(ULoadoutVerificationServerComponent, LoadoutVerificationGIS) == 0x0000A8, "Member 'ULoadoutVerificationServerComponent::LoadoutVerificationGIS' has a wrong offset!");

// Class JP.OnlineStoreItemDataFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UOnlineStoreItemDataFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static struct FOnlineStoreItemBattlePassRequirement MakeOnlineStoreItemBattlePassRequirementStruct(const struct FGameplayTag& BattlePassTag, const int32 LevelRequirement, const bool bIsPremium);
	static struct FOnlineStoreItemCost MakeOnlineStoreItemCostStruct(const struct FGameplayTag& CurrencyTag, const int32 Amount);
	static struct FOnlineStoreItemData MakeOnlineStoreItemData(const class FString& OnlineServicesID, const struct FGameplayTag& AssetID, const EOnlineItemUnlockRequirement UnlockRequirement, const bool bIsOwned, const struct FOnlineStoreItemCost& Cost, const struct FOnlineStoreItemBattlePassRequirement& BattlePassRequirement, const TArray<class FString>& Tags);
	static struct FOnlineStoreItemData MakeOnlineStoreItemDataBattlePassUnlock(const class FString& OnlineServicesID, const struct FGameplayTag& AssetID, const bool bIsOwned, const struct FOnlineStoreItemBattlePassRequirement& BattlePassRequirement, const TArray<class FString>& Tags);
	static struct FOnlineStoreItemData MakeOnlineStoreItemDataNoUnlock(const class FString& OnlineServicesID, const struct FGameplayTag& AssetID, const bool bIsOwned, const TArray<class FString>& Tags);
	static struct FOnlineStoreItemData MakeOnlineStoreItemDataVirtualCurrencyUnlock(const class FString& OnlineServicesID, const struct FGameplayTag& AssetID, const bool bIsOwned, const struct FOnlineStoreItemCost& Cost, const TArray<class FString>& Tags);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineStoreItemDataFunctionLibrary">();
	}
	static class UOnlineStoreItemDataFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineStoreItemDataFunctionLibrary>();
	}
};
static_assert(alignof(UOnlineStoreItemDataFunctionLibrary) == 0x000008, "Wrong alignment on UOnlineStoreItemDataFunctionLibrary");
static_assert(sizeof(UOnlineStoreItemDataFunctionLibrary) == 0x000028, "Wrong size on UOnlineStoreItemDataFunctionLibrary");

// Class JP.LoadoutVerificationServerGameInstanceSubsystem
// 0x0050 (0x0080 - 0x0030)
class ULoadoutVerificationServerGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	TMap<class FString, class USimpleInventoryItemsRequest*> InventoryRequests;                                 // 0x0030(0x0050)(NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LoadoutVerificationServerGameInstanceSubsystem">();
	}
	static class ULoadoutVerificationServerGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULoadoutVerificationServerGameInstanceSubsystem>();
	}
};
static_assert(alignof(ULoadoutVerificationServerGameInstanceSubsystem) == 0x000008, "Wrong alignment on ULoadoutVerificationServerGameInstanceSubsystem");
static_assert(sizeof(ULoadoutVerificationServerGameInstanceSubsystem) == 0x000080, "Wrong size on ULoadoutVerificationServerGameInstanceSubsystem");
static_assert(offsetof(ULoadoutVerificationServerGameInstanceSubsystem, InventoryRequests) == 0x000030, "Member 'ULoadoutVerificationServerGameInstanceSubsystem::InventoryRequests' has a wrong offset!");

// Class JP.LobbyConfigurationWidget
// 0x0038 (0x0318 - 0x02E0)
class ULobbyConfigurationWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x38];                                     // 0x02E0(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyViewModel(const struct FLobbyConfigurationViewModel& InModel);
	void OnLobbyCreationFailed();
	void OpenLobby();
	void SetBoolValue(class UJPSettingWidget* InWidget, bool InValue);
	void SetIntegerValue(class UJPSettingWidget* InWidget, int32 InValue);
	void SetStringValue(class UJPSettingWidget* InWidget, const class FString& InValue);
	void ShowCreateLobbyError();
	void ShowCreateLobbyLoading();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyConfigurationWidget">();
	}
	static class ULobbyConfigurationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyConfigurationWidget>();
	}
};
static_assert(alignof(ULobbyConfigurationWidget) == 0x000008, "Wrong alignment on ULobbyConfigurationWidget");
static_assert(sizeof(ULobbyConfigurationWidget) == 0x000318, "Wrong size on ULobbyConfigurationWidget");

// Class JP.NeighborItemsRequest
// 0x00B8 (0x00E0 - 0x0028)
class UNeighborItemsRequest final : public UObject
{
public:
	uint8                                         Pad_28[0xA8];                                      // 0x0028(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class USharedEconomyOnlineServiceHandler*     EconomyHandler;                                    // 0x00D0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTag                           NeighborID;                                        // 0x00D8(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborItemsRequest">();
	}
	static class UNeighborItemsRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborItemsRequest>();
	}
};
static_assert(alignof(UNeighborItemsRequest) == 0x000008, "Wrong alignment on UNeighborItemsRequest");
static_assert(sizeof(UNeighborItemsRequest) == 0x0000E0, "Wrong size on UNeighborItemsRequest");
static_assert(offsetof(UNeighborItemsRequest, EconomyHandler) == 0x0000D0, "Member 'UNeighborItemsRequest::EconomyHandler' has a wrong offset!");
static_assert(offsetof(UNeighborItemsRequest, NeighborID) == 0x0000D8, "Member 'UNeighborItemsRequest::NeighborID' has a wrong offset!");

// Class JP.LobbyEventsReceiverInterface
// 0x0000 (0x0028 - 0x0028)
class ILobbyEventsReceiverInterface final : public IInterface
{
public:
	void PlayerJoinedLobby(class APlayerStateJP_Lobby* PlayerState);
	void PlayerLeftLobby(class APlayerStateJP_Lobby* PlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyEventsReceiverInterface">();
	}
	static class ILobbyEventsReceiverInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILobbyEventsReceiverInterface>();
	}
};
static_assert(alignof(ILobbyEventsReceiverInterface) == 0x000008, "Wrong alignment on ILobbyEventsReceiverInterface");
static_assert(sizeof(ILobbyEventsReceiverInterface) == 0x000028, "Wrong size on ILobbyEventsReceiverInterface");

// Class JP.OnlineItemCacheSubsystem
// 0x0160 (0x0190 - 0x0030)
class UOnlineItemCacheSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x160];                                     // 0x0030(0x0160)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineItemCacheSubsystem">();
	}
	static class UOnlineItemCacheSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineItemCacheSubsystem>();
	}
};
static_assert(alignof(UOnlineItemCacheSubsystem) == 0x000008, "Wrong alignment on UOnlineItemCacheSubsystem");
static_assert(sizeof(UOnlineItemCacheSubsystem) == 0x000190, "Wrong size on UOnlineItemCacheSubsystem");

// Class JP.LobbyEventsWorldSubsystem
// 0x0050 (0x0080 - 0x0030)
class ULobbyEventsWorldSubsystem final : public UWorldSubsystem
{
public:
	TSet<TWeakObjectPtr<class UObject>>           EventReceiverObjects;                              // 0x0030(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	bool AddEventReceiver(TScriptInterface<class ILobbyEventsReceiverInterface> EventReceiver, bool AllowCatchUp);
	void HandlePlayerStateAdded(class APlayerState* AddedPlayerState);
	void HandlePlayerStateRemoved(class APlayerState* RemovedPlayerState);
	bool RemoveEventReceiver(TScriptInterface<class ILobbyEventsReceiverInterface> EventReceiver);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyEventsWorldSubsystem">();
	}
	static class ULobbyEventsWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyEventsWorldSubsystem>();
	}
};
static_assert(alignof(ULobbyEventsWorldSubsystem) == 0x000008, "Wrong alignment on ULobbyEventsWorldSubsystem");
static_assert(sizeof(ULobbyEventsWorldSubsystem) == 0x000080, "Wrong size on ULobbyEventsWorldSubsystem");
static_assert(offsetof(ULobbyEventsWorldSubsystem, EventReceiverObjects) == 0x000030, "Member 'ULobbyEventsWorldSubsystem::EventReceiverObjects' has a wrong offset!");

// Class JP.LobbyFlowControllerStateComponent
// 0x0050 (0x00F0 - 0x00A0)
class ULobbyFlowControllerStateComponent final : public UGameStateComponent
{
public:
	uint8                                         Pad_A0[0xC];                                       // 0x00A0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           UILayerTag;                                        // 0x00AC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B4[0x4];                                       // 0x00B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   LobbyScreenWidgetClass;                            // 0x00B8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnExperienceLoaded(const class UExperienceDefinition* Experience);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyFlowControllerStateComponent">();
	}
	static class ULobbyFlowControllerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyFlowControllerStateComponent>();
	}
};
static_assert(alignof(ULobbyFlowControllerStateComponent) == 0x000008, "Wrong alignment on ULobbyFlowControllerStateComponent");
static_assert(sizeof(ULobbyFlowControllerStateComponent) == 0x0000F0, "Wrong size on ULobbyFlowControllerStateComponent");
static_assert(offsetof(ULobbyFlowControllerStateComponent, UILayerTag) == 0x0000AC, "Member 'ULobbyFlowControllerStateComponent::UILayerTag' has a wrong offset!");
static_assert(offsetof(ULobbyFlowControllerStateComponent, LobbyScreenWidgetClass) == 0x0000B8, "Member 'ULobbyFlowControllerStateComponent::LobbyScreenWidgetClass' has a wrong offset!");

// Class JP.LobbyHouseSelectorWidget
// 0x0018 (0x02F8 - 0x02E0)
class ULobbyHouseSelectorWidget final : public UUserWidget
{
public:
	class ULobbyHouseVotePlayerStateWatcher*      PlayerStateWatcher;                                // 0x02E0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class APlayerStateJP_Lobby*                   LocalPlayerState;                                  // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x8];                                      // 0x02F0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyViewModel(const struct FLobbyHouseSelectorViewModel& ViewModel);
	void HandlePlayerStateHouseIdentifierVoteChanged(class APlayerStateJP_Lobby* PlayerState, const struct FGameplayTag& OldHouseIdentifier, const struct FGameplayTag& NewHouseIdentifier);
	void HandlePlayerStateTeamHousePoolChanged(class APlayerStateJP_Lobby* PlayerState);
	void HandlePlayerStateTeamIdChanged(class APlayerStateJP_Lobby* PlayerState, const uint8& OldTeamID, const uint8& NewTeamID);
	void HandlePlayerStateTracked(class APlayerState* TrackedPlayerState, bool Initial);
	void HandlePlayerStateUntracked(class APlayerState* UntrackedPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyHouseSelectorWidget">();
	}
	static class ULobbyHouseSelectorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyHouseSelectorWidget>();
	}
};
static_assert(alignof(ULobbyHouseSelectorWidget) == 0x000008, "Wrong alignment on ULobbyHouseSelectorWidget");
static_assert(sizeof(ULobbyHouseSelectorWidget) == 0x0002F8, "Wrong size on ULobbyHouseSelectorWidget");
static_assert(offsetof(ULobbyHouseSelectorWidget, PlayerStateWatcher) == 0x0002E0, "Member 'ULobbyHouseSelectorWidget::PlayerStateWatcher' has a wrong offset!");
static_assert(offsetof(ULobbyHouseSelectorWidget, LocalPlayerState) == 0x0002E8, "Member 'ULobbyHouseSelectorWidget::LocalPlayerState' has a wrong offset!");

// Class JP.PlayerEndOfMatchRewards
// 0x00A0 (0x00C8 - 0x0028)
class UPlayerEndOfMatchRewards final : public UObject
{
public:
	TMap<struct FGameplayTag, int32>              Currencies;                                        // 0x0028(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, int32>                    XP;                                                // 0x0078(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerEndOfMatchRewards">();
	}
	static class UPlayerEndOfMatchRewards* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerEndOfMatchRewards>();
	}
};
static_assert(alignof(UPlayerEndOfMatchRewards) == 0x000008, "Wrong alignment on UPlayerEndOfMatchRewards");
static_assert(sizeof(UPlayerEndOfMatchRewards) == 0x0000C8, "Wrong size on UPlayerEndOfMatchRewards");
static_assert(offsetof(UPlayerEndOfMatchRewards, Currencies) == 0x000028, "Member 'UPlayerEndOfMatchRewards::Currencies' has a wrong offset!");
static_assert(offsetof(UPlayerEndOfMatchRewards, XP) == 0x000078, "Member 'UPlayerEndOfMatchRewards::XP' has a wrong offset!");

// Class JP.LobbyHouseVotePlayerStateWatcher
// 0x0040 (0x0098 - 0x0058)
class ULobbyHouseVotePlayerStateWatcher final : public UBasePlayerStateWatcher
{
public:
	uint8                                         Pad_58[0x40];                                      // 0x0058(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePlayerStateHouseIdentifierVoteChanged(class APlayerStateJP* PlayerState, const struct FGameplayTag& OldHouseIdentifier, const struct FGameplayTag& NewHouseIdentifier);
	void HandlePlayerStateOwnedHouseChanged(class APlayerStateJP* PlayerState, const TArray<struct FGameplayTag>& NewOwnedHouses);
	void HandlePlayerStateTeamHousePoolChanged(class APlayerStateJP* PlayerState);
	void HandlePlayerStateTeamIdChanged(class APlayerStateJP* PlayerState, const uint8& TeamId);
	void HandlePlayerStateTracked(class APlayerState* TrackedPlayerState, bool Initial);
	void HandlePlayerStateUntracked(class APlayerState* UntrackedPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyHouseVotePlayerStateWatcher">();
	}
	static class ULobbyHouseVotePlayerStateWatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyHouseVotePlayerStateWatcher>();
	}
};
static_assert(alignof(ULobbyHouseVotePlayerStateWatcher) == 0x000008, "Wrong alignment on ULobbyHouseVotePlayerStateWatcher");
static_assert(sizeof(ULobbyHouseVotePlayerStateWatcher) == 0x000098, "Wrong size on ULobbyHouseVotePlayerStateWatcher");

// Class JP.PerkSelectEntry
// 0x0010 (0x02F0 - 0x02E0)
class UPerkSelectEntry final : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void ApplyViewModel(const struct FPerkSelectEntryViewModel& ViewModel);
	void Clicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkSelectEntry">();
	}
	static class UPerkSelectEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkSelectEntry>();
	}
};
static_assert(alignof(UPerkSelectEntry) == 0x000008, "Wrong alignment on UPerkSelectEntry");
static_assert(sizeof(UPerkSelectEntry) == 0x0002F0, "Wrong size on UPerkSelectEntry");
static_assert(offsetof(UPerkSelectEntry, OnClicked) == 0x0002E0, "Member 'UPerkSelectEntry::OnClicked' has a wrong offset!");

// Class JP.LobbyKickPlayerEntryWidget
// 0x0038 (0x0318 - 0x02E0)
class ULobbyKickPlayerEntryWidget final : public UUserWidget
{
public:
	class ULyraButtonBase*                        KickButton;                                        // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class APlayerStateJP_Lobby>    PlayerState;                                       // 0x02E8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_310[0x8];                                      // 0x0310(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddPlayerState(const class APlayerStateJP_Lobby* InPlayerState);
	class FText GetPlayerKickedBanReasonText();
	void OnKickButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyKickPlayerEntryWidget">();
	}
	static class ULobbyKickPlayerEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyKickPlayerEntryWidget>();
	}
};
static_assert(alignof(ULobbyKickPlayerEntryWidget) == 0x000008, "Wrong alignment on ULobbyKickPlayerEntryWidget");
static_assert(sizeof(ULobbyKickPlayerEntryWidget) == 0x000318, "Wrong size on ULobbyKickPlayerEntryWidget");
static_assert(offsetof(ULobbyKickPlayerEntryWidget, KickButton) == 0x0002E0, "Member 'ULobbyKickPlayerEntryWidget::KickButton' has a wrong offset!");
static_assert(offsetof(ULobbyKickPlayerEntryWidget, PlayerState) == 0x0002E8, "Member 'ULobbyKickPlayerEntryWidget::PlayerState' has a wrong offset!");

// Class JP.LobbyLevelVoteEntryWidget
// 0x0018 (0x02F8 - 0x02E0)
class ULobbyLevelVoteEntryWidget final : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyViewModel(const struct FLobbyLevelVoteEntryViewModel& ViewModel);
	void DisableInteractivity();
	void UpdateVoteCount(uint8 NewVoteCount);
	void VoteOnEntry();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLevelVoteEntryWidget">();
	}
	static class ULobbyLevelVoteEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyLevelVoteEntryWidget>();
	}
};
static_assert(alignof(ULobbyLevelVoteEntryWidget) == 0x000008, "Wrong alignment on ULobbyLevelVoteEntryWidget");
static_assert(sizeof(ULobbyLevelVoteEntryWidget) == 0x0002F8, "Wrong size on ULobbyLevelVoteEntryWidget");

// Class JP.LobbyLevelVoteSelectedLevelWidget
// 0x0000 (0x02E0 - 0x02E0)
class ULobbyLevelVoteSelectedLevelWidget final : public UUserWidget
{
public:
	void ApplyViewModel(const struct FLobbyLevelVoteSelectedLevelViewModel& ViewModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLevelVoteSelectedLevelWidget">();
	}
	static class ULobbyLevelVoteSelectedLevelWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyLevelVoteSelectedLevelWidget>();
	}
};
static_assert(alignof(ULobbyLevelVoteSelectedLevelWidget) == 0x000008, "Wrong alignment on ULobbyLevelVoteSelectedLevelWidget");
static_assert(sizeof(ULobbyLevelVoteSelectedLevelWidget) == 0x0002E0, "Wrong size on ULobbyLevelVoteSelectedLevelWidget");

// Class JP.PlayerMatchRecord
// 0x0050 (0x0078 - 0x0028)
class UPlayerMatchRecord final : public UObject
{
public:
	class APlayerStateJP*                         PlayerState;                                       // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0048(0x0028)(BlueprintVisible, BlueprintReadOnly, Net, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Kills;                                             // 0x0070(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Deaths;                                            // 0x0071(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Assists;                                           // 0x0072(0x0001)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_73[0x5];                                       // 0x0073(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerMatchRecord">();
	}
	static class UPlayerMatchRecord* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerMatchRecord>();
	}
};
static_assert(alignof(UPlayerMatchRecord) == 0x000008, "Wrong alignment on UPlayerMatchRecord");
static_assert(sizeof(UPlayerMatchRecord) == 0x000078, "Wrong size on UPlayerMatchRecord");
static_assert(offsetof(UPlayerMatchRecord, PlayerState) == 0x000028, "Member 'UPlayerMatchRecord::PlayerState' has a wrong offset!");
static_assert(offsetof(UPlayerMatchRecord, PlayerName) == 0x000030, "Member 'UPlayerMatchRecord::PlayerName' has a wrong offset!");
static_assert(offsetof(UPlayerMatchRecord, TeamId) == 0x000040, "Member 'UPlayerMatchRecord::TeamId' has a wrong offset!");
static_assert(offsetof(UPlayerMatchRecord, Icon) == 0x000048, "Member 'UPlayerMatchRecord::Icon' has a wrong offset!");
static_assert(offsetof(UPlayerMatchRecord, Kills) == 0x000070, "Member 'UPlayerMatchRecord::Kills' has a wrong offset!");
static_assert(offsetof(UPlayerMatchRecord, Deaths) == 0x000071, "Member 'UPlayerMatchRecord::Deaths' has a wrong offset!");
static_assert(offsetof(UPlayerMatchRecord, Assists) == 0x000072, "Member 'UPlayerMatchRecord::Assists' has a wrong offset!");

// Class JP.LobbyLevelVoteWidget
// 0x0078 (0x04A8 - 0x0430)
class ULobbyLevelVoteWidget final : public UCommonActivatableWidget
{
public:
	TSubclassOf<class ULobbyLevelVoteEntryWidget> EntryWidgetClass;                                  // 0x0430(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           OptionsLayout;                                     // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULobbyLevelVoteSelectedLevelWidget*     SelectedLevelWidget;                               // 0x0440(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       OnFinishedVotingAnim;                              // 0x0448(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULevelVoteComponent*                    VotingComponent;                                   // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<uint8, class ULobbyLevelVoteEntryWidget*> SpawnedEntries;                                    // 0x0458(0x0050)(ExportObject, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void DisableAllEntries();
	void OnLevelVotesUpdated(const uint8 UpdatedLevel, const uint8 NewVoteCount);
	void OnVotingFinished(const struct FLevelVoteData& ChosenLevel);
	void PopulateOptions();
	void VoteUpdated();

	TArray<uint8> GetTotalVotes() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLevelVoteWidget">();
	}
	static class ULobbyLevelVoteWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyLevelVoteWidget>();
	}
};
static_assert(alignof(ULobbyLevelVoteWidget) == 0x000008, "Wrong alignment on ULobbyLevelVoteWidget");
static_assert(sizeof(ULobbyLevelVoteWidget) == 0x0004A8, "Wrong size on ULobbyLevelVoteWidget");
static_assert(offsetof(ULobbyLevelVoteWidget, EntryWidgetClass) == 0x000430, "Member 'ULobbyLevelVoteWidget::EntryWidgetClass' has a wrong offset!");
static_assert(offsetof(ULobbyLevelVoteWidget, OptionsLayout) == 0x000438, "Member 'ULobbyLevelVoteWidget::OptionsLayout' has a wrong offset!");
static_assert(offsetof(ULobbyLevelVoteWidget, SelectedLevelWidget) == 0x000440, "Member 'ULobbyLevelVoteWidget::SelectedLevelWidget' has a wrong offset!");
static_assert(offsetof(ULobbyLevelVoteWidget, OnFinishedVotingAnim) == 0x000448, "Member 'ULobbyLevelVoteWidget::OnFinishedVotingAnim' has a wrong offset!");
static_assert(offsetof(ULobbyLevelVoteWidget, VotingComponent) == 0x000450, "Member 'ULobbyLevelVoteWidget::VotingComponent' has a wrong offset!");
static_assert(offsetof(ULobbyLevelVoteWidget, SpawnedEntries) == 0x000458, "Member 'ULobbyLevelVoteWidget::SpawnedEntries' has a wrong offset!");

// Class JP.SeasonPassRewardContent_CurrencyInterface
// 0x0000 (0x0028 - 0x0028)
class ISeasonPassRewardContent_CurrencyInterface final : public IInterface
{
public:
	void ApplyCurrencyViewModel(const struct FSeasonPassRewardContent_CurrencyViewModel& ViewModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassRewardContent_CurrencyInterface">();
	}
	static class ISeasonPassRewardContent_CurrencyInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISeasonPassRewardContent_CurrencyInterface>();
	}
};
static_assert(alignof(ISeasonPassRewardContent_CurrencyInterface) == 0x000008, "Wrong alignment on ISeasonPassRewardContent_CurrencyInterface");
static_assert(sizeof(ISeasonPassRewardContent_CurrencyInterface) == 0x000028, "Wrong size on ISeasonPassRewardContent_CurrencyInterface");

// Class JP.LobbyLocalPlayerSwitchTeamWidget
// 0x0000 (0x02E0 - 0x02E0)
class ULobbyLocalPlayerSwitchTeamWidget final : public UUserWidget
{
public:
	void ApplyViewModel(const struct FLobbyLocalPlayerSwitchTeamViewModel& ViewModel);
	void HandleLocalPlayerStateSet(class UCommonLocalPlayer* CommonLocalPlayer, class APlayerState* PlayerState);
	void HandleTeamIdChanged(class APlayerStateJP* PlayerState, const uint8& TeamId);
	void SwitchTeam();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyLocalPlayerSwitchTeamWidget">();
	}
	static class ULobbyLocalPlayerSwitchTeamWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyLocalPlayerSwitchTeamWidget>();
	}
};
static_assert(alignof(ULobbyLocalPlayerSwitchTeamWidget) == 0x000008, "Wrong alignment on ULobbyLocalPlayerSwitchTeamWidget");
static_assert(sizeof(ULobbyLocalPlayerSwitchTeamWidget) == 0x0002E0, "Wrong size on ULobbyLocalPlayerSwitchTeamWidget");

// Class JP.LobbyNeighborSelectorWidget
// 0x0000 (0x02E0 - 0x02E0)
class ULobbyNeighborSelectorWidget final : public UUserWidget
{
public:
	void ApplyViewModel(const struct FLobbyNeighborSelectorViewModel& ViewModel);
	void HandleNeighborIdChanged(class APlayerStateJP* PlayerState, const struct FGameplayTag& NeighborIdentifier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyNeighborSelectorWidget">();
	}
	static class ULobbyNeighborSelectorWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyNeighborSelectorWidget>();
	}
};
static_assert(alignof(ULobbyNeighborSelectorWidget) == 0x000008, "Wrong alignment on ULobbyNeighborSelectorWidget");
static_assert(sizeof(ULobbyNeighborSelectorWidget) == 0x0002E0, "Wrong size on ULobbyNeighborSelectorWidget");

// Class JP.PlayerStartTutorial
// 0x0000 (0x02C0 - 0x02C0)
class APlayerStartTutorial final : public APlayerStart
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStartTutorial">();
	}
	static class APlayerStartTutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStartTutorial>();
	}
};
static_assert(alignof(APlayerStartTutorial) == 0x000008, "Wrong alignment on APlayerStartTutorial");
static_assert(sizeof(APlayerStartTutorial) == 0x0002C0, "Wrong size on APlayerStartTutorial");

// Class JP.LobbyPlayerWidget
// 0x0030 (0x15F0 - 0x15C0)
class ULobbyPlayerWidget : public ULyraButtonBase
{
public:
	class UCommonButtonBase*                      KickButton;                                        // 0x15B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15C0[0x8];                                     // 0x15C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class APlayerStateJP_Lobby>    PlayerState;                                       // 0x15C8(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ApplyViewModel(const struct FLobbyPlayerAvatarViewModel& ViewModel);
	class FText GetPlayerKickedBanReasonText();
	void OnKickButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyPlayerWidget">();
	}
	static class ULobbyPlayerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyPlayerWidget>();
	}
};
static_assert(alignof(ULobbyPlayerWidget) == 0x000010, "Wrong alignment on ULobbyPlayerWidget");
static_assert(sizeof(ULobbyPlayerWidget) == 0x0015F0, "Wrong size on ULobbyPlayerWidget");
static_assert(offsetof(ULobbyPlayerWidget, KickButton) == 0x0015B8, "Member 'ULobbyPlayerWidget::KickButton' has a wrong offset!");
static_assert(offsetof(ULobbyPlayerWidget, PlayerState) == 0x0015C8, "Member 'ULobbyPlayerWidget::PlayerState' has a wrong offset!");

// Class JP.PlayerControllerJP_MatchComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPlayerControllerJP_MatchComponent : public UActorComponent
{
public:
	void K2_OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);
	void OnPossessedPawnChanged(class APawn* OldPawn, class APawn* NewPawn);

	class APawn* GetControlledPawn() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerJP_MatchComponent">();
	}
	static class UPlayerControllerJP_MatchComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerControllerJP_MatchComponent>();
	}
};
static_assert(alignof(UPlayerControllerJP_MatchComponent) == 0x000008, "Wrong alignment on UPlayerControllerJP_MatchComponent");
static_assert(sizeof(UPlayerControllerJP_MatchComponent) == 0x0000A0, "Wrong size on UPlayerControllerJP_MatchComponent");

// Class JP.LobbyReadyComponent
// 0x0018 (0x00B8 - 0x00A0)
class ULobbyReadyComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnAllPlayersReadyAndWaiting;                       // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAllPlayersReadyAndWaiting;                        // 0x00B0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_bAllPlayersReadyAndWaiting();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyReadyComponent">();
	}
	static class ULobbyReadyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyReadyComponent>();
	}
};
static_assert(alignof(ULobbyReadyComponent) == 0x000008, "Wrong alignment on ULobbyReadyComponent");
static_assert(sizeof(ULobbyReadyComponent) == 0x0000B8, "Wrong size on ULobbyReadyComponent");
static_assert(offsetof(ULobbyReadyComponent, OnAllPlayersReadyAndWaiting) == 0x0000A0, "Member 'ULobbyReadyComponent::OnAllPlayersReadyAndWaiting' has a wrong offset!");
static_assert(offsetof(ULobbyReadyComponent, bAllPlayersReadyAndWaiting) == 0x0000B0, "Member 'ULobbyReadyComponent::bAllPlayersReadyAndWaiting' has a wrong offset!");

// Class JP.LobbyReadyStateWidget
// 0x0010 (0x02F0 - 0x02E0)
class ULobbyReadyStateWidget final : public UUserWidget
{
public:
	TSubclassOf<class UCommonActivatableWidget>   CountdownWidgetClass;                              // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULobbyTravelCountdownWidget*            CountdownWidget;                                   // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ApplyViewModel(const struct FLobbyReadyStateViewModel& InViewModel);
	void ForceTravel();
	void HandleAbortCountdown();
	void HandleStartCountdown(float InDesiredTravelTimestamp);
	void OnReadyChanged(class APlayerStateJP_Lobby* InPS, bool InReady);
	void ReadyUp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyReadyStateWidget">();
	}
	static class ULobbyReadyStateWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyReadyStateWidget>();
	}
};
static_assert(alignof(ULobbyReadyStateWidget) == 0x000008, "Wrong alignment on ULobbyReadyStateWidget");
static_assert(sizeof(ULobbyReadyStateWidget) == 0x0002F0, "Wrong size on ULobbyReadyStateWidget");
static_assert(offsetof(ULobbyReadyStateWidget, CountdownWidgetClass) == 0x0002E0, "Member 'ULobbyReadyStateWidget::CountdownWidgetClass' has a wrong offset!");
static_assert(offsetof(ULobbyReadyStateWidget, CountdownWidget) == 0x0002E8, "Member 'ULobbyReadyStateWidget::CountdownWidget' has a wrong offset!");

// Class JP.LobbyTeamManagerWidget
// 0x0020 (0x0300 - 0x02E0)
class ULobbyTeamManagerWidget final : public UUserWidget
{
public:
	TArray<class ALobbyTeamWorldSlotManagerActor*> WorldSlotManagers;                                 // 0x02E0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class APlayerStateJP_Lobby*>           TrackedPlayerStates;                               // 0x02F0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void DisconnectLocalPlayer();
	void HandleIsInPartyChanged(class APlayerStateJP* PlayerState, bool bIsInParty);
	void HandleJoinStatusChanged(class APlayerState* PlayerState, const EPlayerStateJoinStatus JoinStatus);
	void HandleNeighborIdChanged(class APlayerStateJP* PlayerState, const struct FGameplayTag& NeighborIdentifier);
	void HandlePlayerLoadoutChanged(class APlayerStateJP* PlayerState, const struct FPlayerLoadout& NewLoadout);
	void HandlePlayerNameChanged(class APlayerStateJP* PlayerState, const class FString& Name_0);
	void HandlePlayerStateAdded(class APlayerState* AddedPlayerState);
	void HandlePlayerStateRemoved(class APlayerState* RemovedPlayerState);
	void HandleReadyAndWaitingChanged(class APlayerStateJP_Lobby* PlayerState, const bool bReadyAndWaiting);
	void HandleSlotRelocation(class APlayerStateJP_Lobby* InPlayerState);
	void HandleTeamIdChanged(class APlayerStateJP* PlayerState, const uint8& TeamId);
	void HandleUserAvatarChanged(class APlayerStateJP* PlayerState, TSoftObjectPtr<class UTexture2D> NewAvatar);
	void PushConfirmPlayWithBlockedPlayerPrompt(const class APlayerStateJP_Lobby* PlayerState);
	void SetAllSlotsVisibility(bool InVisibility);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyTeamManagerWidget">();
	}
	static class ULobbyTeamManagerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyTeamManagerWidget>();
	}
};
static_assert(alignof(ULobbyTeamManagerWidget) == 0x000008, "Wrong alignment on ULobbyTeamManagerWidget");
static_assert(sizeof(ULobbyTeamManagerWidget) == 0x000300, "Wrong size on ULobbyTeamManagerWidget");
static_assert(offsetof(ULobbyTeamManagerWidget, WorldSlotManagers) == 0x0002E0, "Member 'ULobbyTeamManagerWidget::WorldSlotManagers' has a wrong offset!");
static_assert(offsetof(ULobbyTeamManagerWidget, TrackedPlayerStates) == 0x0002F0, "Member 'ULobbyTeamManagerWidget::TrackedPlayerStates' has a wrong offset!");

// Class JP.PlayerStateJP_ReplicationMonitorComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPlayerStateJP_ReplicationMonitorComponent final : public UPlayerStateComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePawnSet(class APlayerState* Player, class APawn* NewPawn, class APawn* OldPawn);

	bool IsFullyReplicatedForHUD() const;
	void LogReplicationStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateJP_ReplicationMonitorComponent">();
	}
	static class UPlayerStateJP_ReplicationMonitorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateJP_ReplicationMonitorComponent>();
	}
};
static_assert(alignof(UPlayerStateJP_ReplicationMonitorComponent) == 0x000008, "Wrong alignment on UPlayerStateJP_ReplicationMonitorComponent");
static_assert(sizeof(UPlayerStateJP_ReplicationMonitorComponent) == 0x0000A8, "Wrong size on UPlayerStateJP_ReplicationMonitorComponent");

// Class JP.LobbyTeamPlayerWorldSlotActor
// 0x0098 (0x0328 - 0x0290)
class ALobbyTeamPlayerWorldSlotActor : public AActor
{
public:
	class UWidgetComponent*                       WidgetComponent;                                   // 0x0290(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetComponent*                       LoadingWidget;                                     // 0x0298(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UStaticMeshComponent*                   QuestionMarkMesh;                                  // 0x02A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WidgetSnapDist;                                    // 0x02A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WidgetInterpSpeed;                                 // 0x02AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WidgetHeightOffset;                                // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WidgetAttachedBone;                                // 0x02B4(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           PreviewAnimContext;                                // 0x02BC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuestionMarkBobHeight;                             // 0x02C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuestionMarkBobSpeed;                              // 0x02C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuestionMarkRotSpeed;                              // 0x02CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         QuestionMarkMaxRot;                                // 0x02D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANeighborPreviewActor*                  PreviewActor;                                      // 0x02D8(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2E0[0x48];                                     // 0x02E0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandlePreviewClassLoaded(TSoftClassPtr<class UClass> InPreviewClass);
	void HandleSkinLoaded(TSoftObjectPtr<class UNeighborSkinDefinition> InNeighborSkinDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyTeamPlayerWorldSlotActor">();
	}
	static class ALobbyTeamPlayerWorldSlotActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyTeamPlayerWorldSlotActor>();
	}
};
static_assert(alignof(ALobbyTeamPlayerWorldSlotActor) == 0x000008, "Wrong alignment on ALobbyTeamPlayerWorldSlotActor");
static_assert(sizeof(ALobbyTeamPlayerWorldSlotActor) == 0x000328, "Wrong size on ALobbyTeamPlayerWorldSlotActor");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, WidgetComponent) == 0x000290, "Member 'ALobbyTeamPlayerWorldSlotActor::WidgetComponent' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, LoadingWidget) == 0x000298, "Member 'ALobbyTeamPlayerWorldSlotActor::LoadingWidget' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, QuestionMarkMesh) == 0x0002A0, "Member 'ALobbyTeamPlayerWorldSlotActor::QuestionMarkMesh' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, WidgetSnapDist) == 0x0002A8, "Member 'ALobbyTeamPlayerWorldSlotActor::WidgetSnapDist' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, WidgetInterpSpeed) == 0x0002AC, "Member 'ALobbyTeamPlayerWorldSlotActor::WidgetInterpSpeed' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, WidgetHeightOffset) == 0x0002B0, "Member 'ALobbyTeamPlayerWorldSlotActor::WidgetHeightOffset' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, WidgetAttachedBone) == 0x0002B4, "Member 'ALobbyTeamPlayerWorldSlotActor::WidgetAttachedBone' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, PreviewAnimContext) == 0x0002BC, "Member 'ALobbyTeamPlayerWorldSlotActor::PreviewAnimContext' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, QuestionMarkBobHeight) == 0x0002C4, "Member 'ALobbyTeamPlayerWorldSlotActor::QuestionMarkBobHeight' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, QuestionMarkBobSpeed) == 0x0002C8, "Member 'ALobbyTeamPlayerWorldSlotActor::QuestionMarkBobSpeed' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, QuestionMarkRotSpeed) == 0x0002CC, "Member 'ALobbyTeamPlayerWorldSlotActor::QuestionMarkRotSpeed' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, QuestionMarkMaxRot) == 0x0002D0, "Member 'ALobbyTeamPlayerWorldSlotActor::QuestionMarkMaxRot' has a wrong offset!");
static_assert(offsetof(ALobbyTeamPlayerWorldSlotActor, PreviewActor) == 0x0002D8, "Member 'ALobbyTeamPlayerWorldSlotActor::PreviewActor' has a wrong offset!");

// Class JP.PerkAction
// 0x0000 (0x0028 - 0x0028)
class UPerkAction : public UObject
{
public:
	class UPerkDefinition* GetDefinition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkAction">();
	}
	static class UPerkAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkAction>();
	}
};
static_assert(alignof(UPerkAction) == 0x000008, "Wrong alignment on UPerkAction");
static_assert(sizeof(UPerkAction) == 0x000028, "Wrong size on UPerkAction");

// Class JP.PerkAction_AbilityActivatedBase
// 0x0040 (0x0068 - 0x0028)
class UPerkAction_AbilityActivatedBase final : public UPerkAction
{
public:
	struct FGameplayTagContainer                  HasAllAbilityFilter;                               // 0x0028(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTagContainer                  HasAnyAbilityFilter;                               // 0x0048(0x0020)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void OnAbilityActivated(const struct FGameplayAbilitySpecHandle& Handle, class UGameplayAbility* Ability);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkAction_AbilityActivatedBase">();
	}
	static class UPerkAction_AbilityActivatedBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkAction_AbilityActivatedBase>();
	}
};
static_assert(alignof(UPerkAction_AbilityActivatedBase) == 0x000008, "Wrong alignment on UPerkAction_AbilityActivatedBase");
static_assert(sizeof(UPerkAction_AbilityActivatedBase) == 0x000068, "Wrong size on UPerkAction_AbilityActivatedBase");
static_assert(offsetof(UPerkAction_AbilityActivatedBase, HasAllAbilityFilter) == 0x000028, "Member 'UPerkAction_AbilityActivatedBase::HasAllAbilityFilter' has a wrong offset!");
static_assert(offsetof(UPerkAction_AbilityActivatedBase, HasAnyAbilityFilter) == 0x000048, "Member 'UPerkAction_AbilityActivatedBase::HasAnyAbilityFilter' has a wrong offset!");

// Class JP.LobbyTeamWorldSlotManagerActor
// 0x00D8 (0x0368 - 0x0290)
class ALobbyTeamWorldSlotManagerActor final : public AActor
{
public:
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         TeamId;                                            // 0x02A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class ALobbyTeamPlayerWorldSlotActor>> PlayerSlots;                                       // 0x02A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B8[0xB0];                                     // 0x02B8(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyTeamWorldSlotManagerActor">();
	}
	static class ALobbyTeamWorldSlotManagerActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALobbyTeamWorldSlotManagerActor>();
	}
};
static_assert(alignof(ALobbyTeamWorldSlotManagerActor) == 0x000008, "Wrong alignment on ALobbyTeamWorldSlotManagerActor");
static_assert(sizeof(ALobbyTeamWorldSlotManagerActor) == 0x000368, "Wrong size on ALobbyTeamWorldSlotManagerActor");
static_assert(offsetof(ALobbyTeamWorldSlotManagerActor, TeamId) == 0x0002A0, "Member 'ALobbyTeamWorldSlotManagerActor::TeamId' has a wrong offset!");
static_assert(offsetof(ALobbyTeamWorldSlotManagerActor, PlayerSlots) == 0x0002A8, "Member 'ALobbyTeamWorldSlotManagerActor::PlayerSlots' has a wrong offset!");

// Class JP.LobbyTravelComponent
// 0x0038 (0x00D8 - 0x00A0)
class ULobbyTravelComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CountdownTime;                                     // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DesiredTravelTimestamp;                            // 0x00C4(0x0004)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x10];                                      // 0x00C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleAllPlayersReadyAndWaiting(bool bInReadyAndWaitingState);
	void OnRep_ServerTravelTimestamp();
	void Server_AbortTravel();
	void Server_QueueTravel(bool bInDoCountdown, bool bInAllowAbort);
	void Travel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyTravelComponent">();
	}
	static class ULobbyTravelComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyTravelComponent>();
	}
};
static_assert(alignof(ULobbyTravelComponent) == 0x000008, "Wrong alignment on ULobbyTravelComponent");
static_assert(sizeof(ULobbyTravelComponent) == 0x0000D8, "Wrong size on ULobbyTravelComponent");
static_assert(offsetof(ULobbyTravelComponent, CountdownTime) == 0x0000C0, "Member 'ULobbyTravelComponent::CountdownTime' has a wrong offset!");
static_assert(offsetof(ULobbyTravelComponent, DesiredTravelTimestamp) == 0x0000C4, "Member 'ULobbyTravelComponent::DesiredTravelTimestamp' has a wrong offset!");

// Class JP.LobbyTravelCountdownWidget
// 0x0000 (0x0430 - 0x0430)
class ULobbyTravelCountdownWidget final : public UCommonActivatableWidget
{
public:
	void ApplyViewModel(const struct FLobbyCountdownViewModel& InModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LobbyTravelCountdownWidget">();
	}
	static class ULobbyTravelCountdownWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULobbyTravelCountdownWidget>();
	}
};
static_assert(alignof(ULobbyTravelCountdownWidget) == 0x000008, "Wrong alignment on ULobbyTravelCountdownWidget");
static_assert(sizeof(ULobbyTravelCountdownWidget) == 0x000430, "Wrong size on ULobbyTravelCountdownWidget");

// Class JP.SocialPartyInvitesListWidget
// 0x0010 (0x02F0 - 0x02E0)
class USocialPartyInvitesListWidget : public UUserWidget
{
public:
	class ULyraListView*                          InviteListView;                                    // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x02E8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void UpdatePartyInvitesList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialPartyInvitesListWidget">();
	}
	static class USocialPartyInvitesListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialPartyInvitesListWidget>();
	}
};
static_assert(alignof(USocialPartyInvitesListWidget) == 0x000008, "Wrong alignment on USocialPartyInvitesListWidget");
static_assert(sizeof(USocialPartyInvitesListWidget) == 0x0002F0, "Wrong size on USocialPartyInvitesListWidget");
static_assert(offsetof(USocialPartyInvitesListWidget, InviteListView) == 0x0002E0, "Member 'USocialPartyInvitesListWidget::InviteListView' has a wrong offset!");
static_assert(offsetof(USocialPartyInvitesListWidget, SocialGIS) == 0x0002E8, "Member 'USocialPartyInvitesListWidget::SocialGIS' has a wrong offset!");

// Class JP.LocalRotationRateMeasurer
// 0x0038 (0x00D8 - 0x00A0)
class ULocalRotationRateMeasurer final : public UActorComponent
{
public:
	float                                         InterpolationSpeed;                                // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A4[0x24];                                      // 0x00A4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnRotationRateUpdated;                             // 0x00C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	void SetSceneComponentToMeasure(class USceneComponent* SceneComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalRotationRateMeasurer">();
	}
	static class ULocalRotationRateMeasurer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalRotationRateMeasurer>();
	}
};
static_assert(alignof(ULocalRotationRateMeasurer) == 0x000008, "Wrong alignment on ULocalRotationRateMeasurer");
static_assert(sizeof(ULocalRotationRateMeasurer) == 0x0000D8, "Wrong size on ULocalRotationRateMeasurer");
static_assert(offsetof(ULocalRotationRateMeasurer, InterpolationSpeed) == 0x0000A0, "Member 'ULocalRotationRateMeasurer::InterpolationSpeed' has a wrong offset!");
static_assert(offsetof(ULocalRotationRateMeasurer, OnRotationRateUpdated) == 0x0000C8, "Member 'ULocalRotationRateMeasurer::OnRotationRateUpdated' has a wrong offset!");

// Class JP.PlayerProgressionFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UPlayerProgressionFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static int32 GetProfileLevel(const int32 ProfileXP);
	static float GetProgressBetweenProfileLevels(const int32 ProfileXP, const int32 FromProfileLevelInclusive, const int32 ToProfileLevelInclusive);
	static float GetProgressTowardNextProfileLevel(const int32 ProfileXP);
	static int32 GetTotalXPRequirementForProfileLevel(const int32 Level);
	static int32 GetXPRequirementForNextProfileLevel(const int32 CurrentLevel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerProgressionFunctionLibrary">();
	}
	static class UPlayerProgressionFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerProgressionFunctionLibrary>();
	}
};
static_assert(alignof(UPlayerProgressionFunctionLibrary) == 0x000008, "Wrong alignment on UPlayerProgressionFunctionLibrary");
static_assert(sizeof(UPlayerProgressionFunctionLibrary) == 0x000028, "Wrong size on UPlayerProgressionFunctionLibrary");

// Class JP.LocalUserOnlineServicesGameInstanceSubsystem
// 0x0278 (0x02A8 - 0x0030)
class ULocalUserOnlineServicesGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x48];                                      // 0x0030(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCurrencyCacheUpdated;                            // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_88[0x1C0];                                     // 0x0088(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             UserAvatar;                                        // 0x0248(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_250[0x58];                                     // 0x0250(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetDisplayName();
	void HandleShutdown();
	void PushEndOfPlaytestWidget();
	void SavePlayerLoadout();
	void SetDefaultNeighborID(const struct FGameplayTag& NeighborID);
	void SetHouseID(const struct FGameplayTag& HouseID);
	void SetItemSkin(const struct FGameplayTag& NeighborID, const struct FGameplayTag& ItemId, const struct FGameplayTag& SkinID);
	void SetNeighborLoadout(const struct FGameplayTag& NeighborID, const struct FNeighborLoadout& NeighborLoadout);
	void SetNeighborSkin(const struct FGameplayTag& NeighborID, const struct FGameplayTag& SkinID);

	int32 GetCharacterXP(const struct FGameplayTag& NeighborID) const;
	struct FGameplayTag GetDefaultNeighborID() const;
	struct FGameplayTag GetHouseID() const;
	struct FNeighborLoadout GetNeighborLoadout(const struct FGameplayTag& NeighborID) const;
	struct FPlayerLoadout GetPlayerLoadout() const;
	void GetPlaytestTimeLeftString(int32* DaysLeft, int32* HoursLeft, int32* MinutesLeft, int32* SecondsLeft) const;
	int32 GetProfileXP() const;
	class UTexture2D* GetUserAvatar() const;
	bool HasPlaytestEnded() const;
	bool IsPlaytestInProgress() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LocalUserOnlineServicesGameInstanceSubsystem">();
	}
	static class ULocalUserOnlineServicesGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULocalUserOnlineServicesGameInstanceSubsystem>();
	}
};
static_assert(alignof(ULocalUserOnlineServicesGameInstanceSubsystem) == 0x000008, "Wrong alignment on ULocalUserOnlineServicesGameInstanceSubsystem");
static_assert(sizeof(ULocalUserOnlineServicesGameInstanceSubsystem) == 0x0002A8, "Wrong size on ULocalUserOnlineServicesGameInstanceSubsystem");
static_assert(offsetof(ULocalUserOnlineServicesGameInstanceSubsystem, OnCurrencyCacheUpdated) == 0x000078, "Member 'ULocalUserOnlineServicesGameInstanceSubsystem::OnCurrencyCacheUpdated' has a wrong offset!");
static_assert(offsetof(ULocalUserOnlineServicesGameInstanceSubsystem, UserAvatar) == 0x000248, "Member 'ULocalUserOnlineServicesGameInstanceSubsystem::UserAvatar' has a wrong offset!");

// Class JP.LyraAimSensitivityData
// 0x0050 (0x0080 - 0x0030)
class ULyraAimSensitivityData final : public UPrimaryDataAsset
{
public:
	TMap<ELyraGamepadSensitivity, float>          SensitivityMap;                                    // 0x0030(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAimSensitivityData">();
	}
	static class ULyraAimSensitivityData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAimSensitivityData>();
	}
};
static_assert(alignof(ULyraAimSensitivityData) == 0x000008, "Wrong alignment on ULyraAimSensitivityData");
static_assert(sizeof(ULyraAimSensitivityData) == 0x000080, "Wrong size on ULyraAimSensitivityData");
static_assert(offsetof(ULyraAimSensitivityData, SensitivityMap) == 0x000030, "Member 'ULyraAimSensitivityData::SensitivityMap' has a wrong offset!");

// Class JP.SocialPartyMemberEntryWidget
// 0x0070 (0x0350 - 0x02E0)
class USocialPartyMemberEntryWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x50];                                     // 0x02E0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialUserEntryWidget*                 UserEntryWidget;                                   // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialPartyMemberInteractionWidget*    InteractionWidget;                                 // 0x0338(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 LeaderIcon;                                        // 0x0340(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPartyMemberEntryViewModel*             ViewModel;                                         // 0x0348(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void GetLocalizedStatusInfo(class FText* StatusText, struct FLinearColor* Color);
	void SetStatus();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialPartyMemberEntryWidget">();
	}
	static class USocialPartyMemberEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialPartyMemberEntryWidget>();
	}
};
static_assert(alignof(USocialPartyMemberEntryWidget) == 0x000008, "Wrong alignment on USocialPartyMemberEntryWidget");
static_assert(sizeof(USocialPartyMemberEntryWidget) == 0x000350, "Wrong size on USocialPartyMemberEntryWidget");
static_assert(offsetof(USocialPartyMemberEntryWidget, UserEntryWidget) == 0x000330, "Member 'USocialPartyMemberEntryWidget::UserEntryWidget' has a wrong offset!");
static_assert(offsetof(USocialPartyMemberEntryWidget, InteractionWidget) == 0x000338, "Member 'USocialPartyMemberEntryWidget::InteractionWidget' has a wrong offset!");
static_assert(offsetof(USocialPartyMemberEntryWidget, LeaderIcon) == 0x000340, "Member 'USocialPartyMemberEntryWidget::LeaderIcon' has a wrong offset!");
static_assert(offsetof(USocialPartyMemberEntryWidget, ViewModel) == 0x000348, "Member 'USocialPartyMemberEntryWidget::ViewModel' has a wrong offset!");

// Class JP.PlayerAdmissionComponent
// 0x0020 (0x00C0 - 0x00A0)
class UPlayerAdmissionComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerAdmissionComponent">();
	}
	static class UPlayerAdmissionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerAdmissionComponent>();
	}
};
static_assert(alignof(UPlayerAdmissionComponent) == 0x000008, "Wrong alignment on UPlayerAdmissionComponent");
static_assert(sizeof(UPlayerAdmissionComponent) == 0x0000C0, "Wrong size on UPlayerAdmissionComponent");
static_assert(offsetof(UPlayerAdmissionComponent, SocialGIS) == 0x0000A8, "Member 'UPlayerAdmissionComponent::SocialGIS' has a wrong offset!");

// Class JP.LyraSettingBasedScalar
// 0x0058 (0x0080 - 0x0028)
class ULyraSettingBasedScalar final : public UInputModifier
{
public:
	class FName                                   XAxisScalarSettingName;                            // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   YAxisScalarSettingName;                            // 0x0030(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ZAxisScalarSettingName;                            // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MaxValueClamp;                                     // 0x0040(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MinValueClamp;                                     // 0x0058(0x0018)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingBasedScalar">();
	}
	static class ULyraSettingBasedScalar* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingBasedScalar>();
	}
};
static_assert(alignof(ULyraSettingBasedScalar) == 0x000008, "Wrong alignment on ULyraSettingBasedScalar");
static_assert(sizeof(ULyraSettingBasedScalar) == 0x000080, "Wrong size on ULyraSettingBasedScalar");
static_assert(offsetof(ULyraSettingBasedScalar, XAxisScalarSettingName) == 0x000028, "Member 'ULyraSettingBasedScalar::XAxisScalarSettingName' has a wrong offset!");
static_assert(offsetof(ULyraSettingBasedScalar, YAxisScalarSettingName) == 0x000030, "Member 'ULyraSettingBasedScalar::YAxisScalarSettingName' has a wrong offset!");
static_assert(offsetof(ULyraSettingBasedScalar, ZAxisScalarSettingName) == 0x000038, "Member 'ULyraSettingBasedScalar::ZAxisScalarSettingName' has a wrong offset!");
static_assert(offsetof(ULyraSettingBasedScalar, MaxValueClamp) == 0x000040, "Member 'ULyraSettingBasedScalar::MaxValueClamp' has a wrong offset!");
static_assert(offsetof(ULyraSettingBasedScalar, MinValueClamp) == 0x000058, "Member 'ULyraSettingBasedScalar::MinValueClamp' has a wrong offset!");

// Class JP.LyraInputModifierDeadZone
// 0x0010 (0x0038 - 0x0028)
class ULyraInputModifierDeadZone final : public UInputModifier
{
public:
	EDeadZoneType                                 Type;                                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UpperThreshold;                                    // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDeadzoneStick                                DeadzoneStick;                                     // 0x0030(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputModifierDeadZone">();
	}
	static class ULyraInputModifierDeadZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputModifierDeadZone>();
	}
};
static_assert(alignof(ULyraInputModifierDeadZone) == 0x000008, "Wrong alignment on ULyraInputModifierDeadZone");
static_assert(sizeof(ULyraInputModifierDeadZone) == 0x000038, "Wrong size on ULyraInputModifierDeadZone");
static_assert(offsetof(ULyraInputModifierDeadZone, Type) == 0x000028, "Member 'ULyraInputModifierDeadZone::Type' has a wrong offset!");
static_assert(offsetof(ULyraInputModifierDeadZone, UpperThreshold) == 0x00002C, "Member 'ULyraInputModifierDeadZone::UpperThreshold' has a wrong offset!");
static_assert(offsetof(ULyraInputModifierDeadZone, DeadzoneStick) == 0x000030, "Member 'ULyraInputModifierDeadZone::DeadzoneStick' has a wrong offset!");

// Class JP.LyraInputModifierGamepadSensitivity
// 0x0010 (0x0038 - 0x0028)
class ULyraInputModifierGamepadSensitivity final : public UInputModifier
{
public:
	ELyraTargetingType                            TargetingType;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraAimSensitivityData*                SensitivityLevelTable;                             // 0x0030(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputModifierGamepadSensitivity">();
	}
	static class ULyraInputModifierGamepadSensitivity* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputModifierGamepadSensitivity>();
	}
};
static_assert(alignof(ULyraInputModifierGamepadSensitivity) == 0x000008, "Wrong alignment on ULyraInputModifierGamepadSensitivity");
static_assert(sizeof(ULyraInputModifierGamepadSensitivity) == 0x000038, "Wrong size on ULyraInputModifierGamepadSensitivity");
static_assert(offsetof(ULyraInputModifierGamepadSensitivity, TargetingType) == 0x000028, "Member 'ULyraInputModifierGamepadSensitivity::TargetingType' has a wrong offset!");
static_assert(offsetof(ULyraInputModifierGamepadSensitivity, SensitivityLevelTable) == 0x000030, "Member 'ULyraInputModifierGamepadSensitivity::SensitivityLevelTable' has a wrong offset!");

// Class JP.SocialRecentPlayerEntryWidget
// 0x0038 (0x0318 - 0x02E0)
class USocialRecentPlayerEntryWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x20];                                     // 0x02E0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialUserEntryWidget*                 UserEntryWidget;                                   // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialRecentPlayerInteractionWidget*   InteractionWidget;                                 // 0x0308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class URecentPlayerEntryViewModel*            ViewModel;                                         // 0x0310(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FText GetFormattedLastSeenTimeSpan(const struct FTimespan& LastSeenTimespan);
	void SetLastSeen(const struct FDateTime& LastSeen);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialRecentPlayerEntryWidget">();
	}
	static class USocialRecentPlayerEntryWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialRecentPlayerEntryWidget>();
	}
};
static_assert(alignof(USocialRecentPlayerEntryWidget) == 0x000008, "Wrong alignment on USocialRecentPlayerEntryWidget");
static_assert(sizeof(USocialRecentPlayerEntryWidget) == 0x000318, "Wrong size on USocialRecentPlayerEntryWidget");
static_assert(offsetof(USocialRecentPlayerEntryWidget, UserEntryWidget) == 0x000300, "Member 'USocialRecentPlayerEntryWidget::UserEntryWidget' has a wrong offset!");
static_assert(offsetof(USocialRecentPlayerEntryWidget, InteractionWidget) == 0x000308, "Member 'USocialRecentPlayerEntryWidget::InteractionWidget' has a wrong offset!");
static_assert(offsetof(USocialRecentPlayerEntryWidget, ViewModel) == 0x000310, "Member 'USocialRecentPlayerEntryWidget::ViewModel' has a wrong offset!");

// Class JP.LyraInputModifierAimInversion
// 0x0000 (0x0028 - 0x0028)
class ULyraInputModifierAimInversion final : public UInputModifier
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputModifierAimInversion">();
	}
	static class ULyraInputModifierAimInversion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputModifierAimInversion>();
	}
};
static_assert(alignof(ULyraInputModifierAimInversion) == 0x000008, "Wrong alignment on ULyraInputModifierAimInversion");
static_assert(sizeof(ULyraInputModifierAimInversion) == 0x000028, "Wrong size on ULyraInputModifierAimInversion");

// Class JP.PlayFabEnvironmentSettings
// 0x0010 (0x0048 - 0x0038)
class UPlayFabEnvironmentSettings final : public UDeveloperSettings
{
public:
	TArray<struct FEnvironmentDefinition>         AvailableTitles;                                   // 0x0038(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayFabEnvironmentSettings">();
	}
	static class UPlayFabEnvironmentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayFabEnvironmentSettings>();
	}
};
static_assert(alignof(UPlayFabEnvironmentSettings) == 0x000008, "Wrong alignment on UPlayFabEnvironmentSettings");
static_assert(sizeof(UPlayFabEnvironmentSettings) == 0x000048, "Wrong size on UPlayFabEnvironmentSettings");
static_assert(offsetof(UPlayFabEnvironmentSettings, AvailableTitles) == 0x000038, "Member 'UPlayFabEnvironmentSettings::AvailableTitles' has a wrong offset!");

// Class JP.LyraInputModifierAimInversionSpecificAxis
// 0x0008 (0x0030 - 0x0028)
class ULyraInputModifierAimInversionSpecificAxis final : public UInputModifier
{
public:
	bool                                          YAxis;                                             // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputModifierAimInversionSpecificAxis">();
	}
	static class ULyraInputModifierAimInversionSpecificAxis* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputModifierAimInversionSpecificAxis>();
	}
};
static_assert(alignof(ULyraInputModifierAimInversionSpecificAxis) == 0x000008, "Wrong alignment on ULyraInputModifierAimInversionSpecificAxis");
static_assert(sizeof(ULyraInputModifierAimInversionSpecificAxis) == 0x000030, "Wrong size on ULyraInputModifierAimInversionSpecificAxis");
static_assert(offsetof(ULyraInputModifierAimInversionSpecificAxis, YAxis) == 0x000028, "Member 'ULyraInputModifierAimInversionSpecificAxis::YAxis' has a wrong offset!");

// Class JP.LyraInputModifierAimInversionSpecificAxisMouse
// 0x0008 (0x0030 - 0x0028)
class ULyraInputModifierAimInversionSpecificAxisMouse final : public UInputModifier
{
public:
	bool                                          YAxis;                                             // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraInputModifierAimInversionSpecificAxisMouse">();
	}
	static class ULyraInputModifierAimInversionSpecificAxisMouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraInputModifierAimInversionSpecificAxisMouse>();
	}
};
static_assert(alignof(ULyraInputModifierAimInversionSpecificAxisMouse) == 0x000008, "Wrong alignment on ULyraInputModifierAimInversionSpecificAxisMouse");
static_assert(sizeof(ULyraInputModifierAimInversionSpecificAxisMouse) == 0x000030, "Wrong size on ULyraInputModifierAimInversionSpecificAxisMouse");
static_assert(offsetof(ULyraInputModifierAimInversionSpecificAxisMouse, YAxis) == 0x000028, "Member 'ULyraInputModifierAimInversionSpecificAxisMouse::YAxis' has a wrong offset!");

// Class JP.LyraSettingBasedCrouchToggleEnabled
// 0x0008 (0x0030 - 0x0028)
class ULyraSettingBasedCrouchToggleEnabled final : public UInputModifier
{
public:
	bool                                          InvertSetting;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingBasedCrouchToggleEnabled">();
	}
	static class ULyraSettingBasedCrouchToggleEnabled* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingBasedCrouchToggleEnabled>();
	}
};
static_assert(alignof(ULyraSettingBasedCrouchToggleEnabled) == 0x000008, "Wrong alignment on ULyraSettingBasedCrouchToggleEnabled");
static_assert(sizeof(ULyraSettingBasedCrouchToggleEnabled) == 0x000030, "Wrong size on ULyraSettingBasedCrouchToggleEnabled");
static_assert(offsetof(ULyraSettingBasedCrouchToggleEnabled, InvertSetting) == 0x000028, "Member 'ULyraSettingBasedCrouchToggleEnabled::InvertSetting' has a wrong offset!");

// Class JP.SocialWidget
// 0x0070 (0x0350 - 0x02E0)
class USocialWidget : public UUserWidget
{
public:
	class USocialPartyInvitesListWidget*          PartyInvitesList;                                  // 0x02E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialPartyMembersListWidget*          PartyMembersList;                                  // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialFriendsListWidget*               FriendsList;                                       // 0x02F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialRecentPlayersListWidget*         RecentPlayersList;                                 // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialBlockedPlayersListWidget*        BlockedPlayersList;                                // 0x0300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UBorder*                                HidableWidgetsContainer;                           // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetAnimation*                       ShowHidableWidgetsAnimation;                       // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x0318(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_320[0x30];                                     // 0x0320(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void HandleOnHostGoToNewLobbyPrompted();
	void OnFailedToJoinPartyCallback();
	void ToggleHidableWidgets();
	void ToggleSocialListState(class UUserWidget* ToggledWidget);

	void OnHostAcceptLeaveLobbyPrompt() const;
	void OnHostDeclineLeaveLobbyPrompt() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialWidget">();
	}
	static class USocialWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialWidget>();
	}
};
static_assert(alignof(USocialWidget) == 0x000008, "Wrong alignment on USocialWidget");
static_assert(sizeof(USocialWidget) == 0x000350, "Wrong size on USocialWidget");
static_assert(offsetof(USocialWidget, PartyInvitesList) == 0x0002E0, "Member 'USocialWidget::PartyInvitesList' has a wrong offset!");
static_assert(offsetof(USocialWidget, PartyMembersList) == 0x0002E8, "Member 'USocialWidget::PartyMembersList' has a wrong offset!");
static_assert(offsetof(USocialWidget, FriendsList) == 0x0002F0, "Member 'USocialWidget::FriendsList' has a wrong offset!");
static_assert(offsetof(USocialWidget, RecentPlayersList) == 0x0002F8, "Member 'USocialWidget::RecentPlayersList' has a wrong offset!");
static_assert(offsetof(USocialWidget, BlockedPlayersList) == 0x000300, "Member 'USocialWidget::BlockedPlayersList' has a wrong offset!");
static_assert(offsetof(USocialWidget, HidableWidgetsContainer) == 0x000308, "Member 'USocialWidget::HidableWidgetsContainer' has a wrong offset!");
static_assert(offsetof(USocialWidget, ShowHidableWidgetsAnimation) == 0x000310, "Member 'USocialWidget::ShowHidableWidgetsAnimation' has a wrong offset!");
static_assert(offsetof(USocialWidget, SocialGIS) == 0x000318, "Member 'USocialWidget::SocialGIS' has a wrong offset!");

// Class JP.LyraSettingBasedSprintToggleEnabled
// 0x0008 (0x0030 - 0x0028)
class ULyraSettingBasedSprintToggleEnabled final : public UInputModifier
{
public:
	bool                                          InvertSetting;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingBasedSprintToggleEnabled">();
	}
	static class ULyraSettingBasedSprintToggleEnabled* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingBasedSprintToggleEnabled>();
	}
};
static_assert(alignof(ULyraSettingBasedSprintToggleEnabled) == 0x000008, "Wrong alignment on ULyraSettingBasedSprintToggleEnabled");
static_assert(sizeof(ULyraSettingBasedSprintToggleEnabled) == 0x000030, "Wrong size on ULyraSettingBasedSprintToggleEnabled");
static_assert(offsetof(ULyraSettingBasedSprintToggleEnabled, InvertSetting) == 0x000028, "Member 'ULyraSettingBasedSprintToggleEnabled::InvertSetting' has a wrong offset!");

// Class JP.PlayerJoinHandshakePlayerControllerComponent
// 0x0020 (0x00C0 - 0x00A0)
class UPlayerJoinHandshakePlayerControllerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Server_ChangeSelectedNeighborIdentifier(const struct FGameplayTag& NewNeighborIdentifier);
	void Server_ResolveRandomNeighborSelection();
	void Server_SetBlockedList(const TArray<class FString>& SerializedBlockedIDs);
	void Server_SetConfirmedJoin();
	void Server_SetPlayerLoadout(const struct FPlayerLoadout& NewLoadout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerJoinHandshakePlayerControllerComponent">();
	}
	static class UPlayerJoinHandshakePlayerControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerJoinHandshakePlayerControllerComponent>();
	}
};
static_assert(alignof(UPlayerJoinHandshakePlayerControllerComponent) == 0x000008, "Wrong alignment on UPlayerJoinHandshakePlayerControllerComponent");
static_assert(sizeof(UPlayerJoinHandshakePlayerControllerComponent) == 0x0000C0, "Wrong size on UPlayerJoinHandshakePlayerControllerComponent");

// Class JP.LyraSettingBasedSprintToggleEnabledController
// 0x0008 (0x0030 - 0x0028)
class ULyraSettingBasedSprintToggleEnabledController final : public UInputModifier
{
public:
	bool                                          InvertSetting;                                     // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingBasedSprintToggleEnabledController">();
	}
	static class ULyraSettingBasedSprintToggleEnabledController* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingBasedSprintToggleEnabledController>();
	}
};
static_assert(alignof(ULyraSettingBasedSprintToggleEnabledController) == 0x000008, "Wrong alignment on ULyraSettingBasedSprintToggleEnabledController");
static_assert(sizeof(ULyraSettingBasedSprintToggleEnabledController) == 0x000030, "Wrong size on ULyraSettingBasedSprintToggleEnabledController");
static_assert(offsetof(ULyraSettingBasedSprintToggleEnabledController, InvertSetting) == 0x000028, "Member 'ULyraSettingBasedSprintToggleEnabledController::InvertSetting' has a wrong offset!");

// Class JP.LyraPlaystationDirectionalPad
// 0x0008 (0x0030 - 0x0028)
class ULyraPlaystationDirectionalPad final : public UInputModifier
{
public:
	ELyraPlaystationDPadButton                    DirectionalPadButton;                              // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlaystationDirectionalPad">();
	}
	static class ULyraPlaystationDirectionalPad* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPlaystationDirectionalPad>();
	}
};
static_assert(alignof(ULyraPlaystationDirectionalPad) == 0x000008, "Wrong alignment on ULyraPlaystationDirectionalPad");
static_assert(sizeof(ULyraPlaystationDirectionalPad) == 0x000030, "Wrong size on ULyraPlaystationDirectionalPad");
static_assert(offsetof(ULyraPlaystationDirectionalPad, DirectionalPadButton) == 0x000028, "Member 'ULyraPlaystationDirectionalPad::DirectionalPadButton' has a wrong offset!");

// Class JP.AimAssistInputModifier
// 0x0010 (0x0038 - 0x0028)
class UAimAssistInputModifier final : public UInputModifier
{
public:
	bool                                          bYawInverted;                                      // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPitchInverted;                                    // 0x0029(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAAInputIntegratorComponent*            AimAssistIntegrator;                               // 0x0030(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AimAssistInputModifier">();
	}
	static class UAimAssistInputModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAimAssistInputModifier>();
	}
};
static_assert(alignof(UAimAssistInputModifier) == 0x000008, "Wrong alignment on UAimAssistInputModifier");
static_assert(sizeof(UAimAssistInputModifier) == 0x000038, "Wrong size on UAimAssistInputModifier");
static_assert(offsetof(UAimAssistInputModifier, bYawInverted) == 0x000028, "Member 'UAimAssistInputModifier::bYawInverted' has a wrong offset!");
static_assert(offsetof(UAimAssistInputModifier, bPitchInverted) == 0x000029, "Member 'UAimAssistInputModifier::bPitchInverted' has a wrong offset!");
static_assert(offsetof(UAimAssistInputModifier, AimAssistIntegrator) == 0x000030, "Member 'UAimAssistInputModifier::AimAssistIntegrator' has a wrong offset!");

// Class JP.RoomControllerComponent
// 0x0000 (0x00A0 - 0x00A0)
class URoomControllerComponent final : public UActorComponent
{
public:
	void ServerUpgradeRoom(const class ARoomManager* RoomManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomControllerComponent">();
	}
	static class URoomControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<URoomControllerComponent>();
	}
};
static_assert(alignof(URoomControllerComponent) == 0x000008, "Wrong alignment on URoomControllerComponent");
static_assert(sizeof(URoomControllerComponent) == 0x0000A0, "Wrong size on URoomControllerComponent");

// Class JP.LyraPlatformEmulationSettings
// 0x0058 (0x0090 - 0x0038)
class ULyraPlatformEmulationSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	struct FGameplayTagContainer                  AdditionalPlatformTraitsToEnable;                  // 0x0038(0x0020)(Edit, Config, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  AdditionalPlatformTraitsToSuppress;                // 0x0058(0x0020)(Edit, Config, NativeAccessSpecifierPrivate)
	class FName                                   PretendPlatform;                                   // 0x0078(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   PretendBaseDeviceProfile;                          // 0x0080(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyFrameRateSettingsInPIE;                      // 0x0088(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyFrontEndPerformanceOptionsInPIE;             // 0x0089(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bApplyDeviceProfilesInPIE;                         // 0x008A(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_8B[0x5];                                       // 0x008B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FName> GetKnownDeviceProfiles() const;
	TArray<class FName> GetKnownPlatformIds() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPlatformEmulationSettings">();
	}
	static class ULyraPlatformEmulationSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPlatformEmulationSettings>();
	}
};
static_assert(alignof(ULyraPlatformEmulationSettings) == 0x000008, "Wrong alignment on ULyraPlatformEmulationSettings");
static_assert(sizeof(ULyraPlatformEmulationSettings) == 0x000090, "Wrong size on ULyraPlatformEmulationSettings");
static_assert(offsetof(ULyraPlatformEmulationSettings, AdditionalPlatformTraitsToEnable) == 0x000038, "Member 'ULyraPlatformEmulationSettings::AdditionalPlatformTraitsToEnable' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, AdditionalPlatformTraitsToSuppress) == 0x000058, "Member 'ULyraPlatformEmulationSettings::AdditionalPlatformTraitsToSuppress' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, PretendPlatform) == 0x000078, "Member 'ULyraPlatformEmulationSettings::PretendPlatform' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, PretendBaseDeviceProfile) == 0x000080, "Member 'ULyraPlatformEmulationSettings::PretendBaseDeviceProfile' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, bApplyFrameRateSettingsInPIE) == 0x000088, "Member 'ULyraPlatformEmulationSettings::bApplyFrameRateSettingsInPIE' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, bApplyFrontEndPerformanceOptionsInPIE) == 0x000089, "Member 'ULyraPlatformEmulationSettings::bApplyFrontEndPerformanceOptionsInPIE' has a wrong offset!");
static_assert(offsetof(ULyraPlatformEmulationSettings, bApplyDeviceProfilesInPIE) == 0x00008A, "Member 'ULyraPlatformEmulationSettings::bApplyDeviceProfilesInPIE' has a wrong offset!");

// Class JP.ProjectSettingsJP
// 0x0588 (0x05B0 - 0x0028)
class UProjectSettingsJP final : public UObject
{
public:
	struct FPlayerLoadout                         DefaultLoadout;                                    // 0x0028(0x0028)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   RandomNeighborSelection;                           // 0x0050(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FMatchConfiguration                    DefaultMatchConfig;                                // 0x0060(0x0058)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              GameplayMaskToStencilValue;                        // 0x00B8(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<class FString, EVerbosity>               MinimumVerbosityLevel;                             // 0x0108(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSubclassOf<class UTweakableData>             TweakableDataType;                                 // 0x0158(0x0008)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UPerkManagerComponent>      PerkManagerComponent;                              // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxAmountOfPerks;                                  // 0x0168(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class UDataTable>              SelectablePerks;                                   // 0x0170(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmptyServerTimeoutDuration;                        // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19C[0x4];                                      // 0x019C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   SpecialAbilityInitialCooldownDefinition;           // 0x01A0(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HomeDamageReduction;                               // 0x01C8(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TrespassingDamageMultiplication;                   // 0x01CC(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CritChancePercentage;                              // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDamageMultiplier;                          // 0x01D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DurabilityTag;                                     // 0x01D8(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           BlockDurabilityDrainTag;                           // 0x01E0(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PlayerCombatDamageTag;                             // 0x01E8(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  LobbyLevel;                                        // 0x01F0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  MainMenuLevel;                                     // 0x0218(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  NeighbourhoodLevel;                                // 0x0240(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLevelVoteData>                 LevelVoteData;                                     // 0x0268(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         VoteOptionsAmount;                                 // 0x0278(0x0001)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_279[0x3];                                      // 0x0279(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PostLevelVoteCountdown;                            // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UWorld>                  PerformanceBenchmarkLevel;                         // 0x0280(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PerformanceBenchmarkGameModeClass;                 // 0x02A8(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FProjectValidatorSettings              ProjectValidatorSettings;                          // 0x02D0(0x0002)(Edit, Config, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D2[0x6];                                      // 0x02D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSoftObjectPath                        CharacterRoleTable;                                // 0x02D8(0x0020)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<EPerkCategories, struct FColor>          PerkCategoryColors;                                // 0x02F8(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UDataTable>              CharacterStatsTable;                               // 0x0348(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              CharacterSpeakerIcon;                              // 0x0370(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterSpeakerIconLocationOffset;                // 0x0398(0x0018)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CharacterSpeakerIconSize;                          // 0x03B0(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumTimeBeforeGameDataUpdate;                   // 0x03B4(0x0004)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerProfileXPStatCode;                           // 0x03B8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UOnlineCurrency>         Harmonies;                                         // 0x03C8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   FirstTimeLoginInventory;                           // 0x03F0(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              FirstTimeLoginCurrency;                            // 0x0400(0x0050)(Edit, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FString                                 DefaultCharacterSettingsKey;                       // 0x0450(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerLoadoutUserDataKey;                          // 0x0460(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CompletedTooltipsUserDataKey;                      // 0x0470(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   EndOfPlaytestWidget;                               // 0x0480(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndOfMatchRewardURL;                               // 0x04A8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PartyFollowLeaderPasswordMenuClass;                // 0x04B8(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostMatchLeaderLeftCountdownDuration;              // 0x04E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         SettingsDefaultMaxPlayers;                         // 0x04E4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E5[0x3];                                      // 0x04E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SettingsDefaultMatchTime;                          // 0x04E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SettingsMinMatchTime;                              // 0x04EC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SettingsMaxMatchTime;                              // 0x04F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F4[0x4];                                      // 0x04F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SettingsGameModeString;                            // 0x04F8(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SettingsNextMapString;                             // 0x0508(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SettingsMaxPlayersString;                          // 0x0518(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SettingsIsLanMatchString;                          // 0x0528(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SettingsMatchTimeString;                           // 0x0538(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SettingsServerNameString;                          // 0x0548(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                FallbackPlayerStartLocation;                       // 0x0558(0x0018)(Edit, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UBattlePassConfigurationAsset> BattlePassConfiguration;                           // 0x0570(0x0028)(Edit, Config, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DefaultHouseIdentifier;                            // 0x0598(0x0008)(Edit, Config, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FGameplayTag>                   DefaultHouseCollection;                            // 0x05A0(0x0010)(Edit, ZeroConstructor, Config, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UProjectSettingsJP* GetProjectSettings();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectSettingsJP">();
	}
	static class UProjectSettingsJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectSettingsJP>();
	}
};
static_assert(alignof(UProjectSettingsJP) == 0x000008, "Wrong alignment on UProjectSettingsJP");
static_assert(sizeof(UProjectSettingsJP) == 0x0005B0, "Wrong size on UProjectSettingsJP");
static_assert(offsetof(UProjectSettingsJP, DefaultLoadout) == 0x000028, "Member 'UProjectSettingsJP::DefaultLoadout' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, RandomNeighborSelection) == 0x000050, "Member 'UProjectSettingsJP::RandomNeighborSelection' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, DefaultMatchConfig) == 0x000060, "Member 'UProjectSettingsJP::DefaultMatchConfig' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, GameplayMaskToStencilValue) == 0x0000B8, "Member 'UProjectSettingsJP::GameplayMaskToStencilValue' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, MinimumVerbosityLevel) == 0x000108, "Member 'UProjectSettingsJP::MinimumVerbosityLevel' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, TweakableDataType) == 0x000158, "Member 'UProjectSettingsJP::TweakableDataType' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PerkManagerComponent) == 0x000160, "Member 'UProjectSettingsJP::PerkManagerComponent' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, MaxAmountOfPerks) == 0x000168, "Member 'UProjectSettingsJP::MaxAmountOfPerks' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SelectablePerks) == 0x000170, "Member 'UProjectSettingsJP::SelectablePerks' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, EmptyServerTimeoutDuration) == 0x000198, "Member 'UProjectSettingsJP::EmptyServerTimeoutDuration' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SpecialAbilityInitialCooldownDefinition) == 0x0001A0, "Member 'UProjectSettingsJP::SpecialAbilityInitialCooldownDefinition' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, HomeDamageReduction) == 0x0001C8, "Member 'UProjectSettingsJP::HomeDamageReduction' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, TrespassingDamageMultiplication) == 0x0001CC, "Member 'UProjectSettingsJP::TrespassingDamageMultiplication' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, CritChancePercentage) == 0x0001D0, "Member 'UProjectSettingsJP::CritChancePercentage' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, CriticalDamageMultiplier) == 0x0001D4, "Member 'UProjectSettingsJP::CriticalDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, DurabilityTag) == 0x0001D8, "Member 'UProjectSettingsJP::DurabilityTag' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, BlockDurabilityDrainTag) == 0x0001E0, "Member 'UProjectSettingsJP::BlockDurabilityDrainTag' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PlayerCombatDamageTag) == 0x0001E8, "Member 'UProjectSettingsJP::PlayerCombatDamageTag' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, LobbyLevel) == 0x0001F0, "Member 'UProjectSettingsJP::LobbyLevel' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, MainMenuLevel) == 0x000218, "Member 'UProjectSettingsJP::MainMenuLevel' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, NeighbourhoodLevel) == 0x000240, "Member 'UProjectSettingsJP::NeighbourhoodLevel' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, LevelVoteData) == 0x000268, "Member 'UProjectSettingsJP::LevelVoteData' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, VoteOptionsAmount) == 0x000278, "Member 'UProjectSettingsJP::VoteOptionsAmount' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PostLevelVoteCountdown) == 0x00027C, "Member 'UProjectSettingsJP::PostLevelVoteCountdown' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PerformanceBenchmarkLevel) == 0x000280, "Member 'UProjectSettingsJP::PerformanceBenchmarkLevel' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PerformanceBenchmarkGameModeClass) == 0x0002A8, "Member 'UProjectSettingsJP::PerformanceBenchmarkGameModeClass' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, ProjectValidatorSettings) == 0x0002D0, "Member 'UProjectSettingsJP::ProjectValidatorSettings' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, CharacterRoleTable) == 0x0002D8, "Member 'UProjectSettingsJP::CharacterRoleTable' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PerkCategoryColors) == 0x0002F8, "Member 'UProjectSettingsJP::PerkCategoryColors' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, CharacterStatsTable) == 0x000348, "Member 'UProjectSettingsJP::CharacterStatsTable' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, CharacterSpeakerIcon) == 0x000370, "Member 'UProjectSettingsJP::CharacterSpeakerIcon' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, CharacterSpeakerIconLocationOffset) == 0x000398, "Member 'UProjectSettingsJP::CharacterSpeakerIconLocationOffset' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, CharacterSpeakerIconSize) == 0x0003B0, "Member 'UProjectSettingsJP::CharacterSpeakerIconSize' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, MinimumTimeBeforeGameDataUpdate) == 0x0003B4, "Member 'UProjectSettingsJP::MinimumTimeBeforeGameDataUpdate' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PlayerProfileXPStatCode) == 0x0003B8, "Member 'UProjectSettingsJP::PlayerProfileXPStatCode' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, Harmonies) == 0x0003C8, "Member 'UProjectSettingsJP::Harmonies' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, FirstTimeLoginInventory) == 0x0003F0, "Member 'UProjectSettingsJP::FirstTimeLoginInventory' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, FirstTimeLoginCurrency) == 0x000400, "Member 'UProjectSettingsJP::FirstTimeLoginCurrency' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, DefaultCharacterSettingsKey) == 0x000450, "Member 'UProjectSettingsJP::DefaultCharacterSettingsKey' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PlayerLoadoutUserDataKey) == 0x000460, "Member 'UProjectSettingsJP::PlayerLoadoutUserDataKey' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, CompletedTooltipsUserDataKey) == 0x000470, "Member 'UProjectSettingsJP::CompletedTooltipsUserDataKey' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, EndOfPlaytestWidget) == 0x000480, "Member 'UProjectSettingsJP::EndOfPlaytestWidget' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, EndOfMatchRewardURL) == 0x0004A8, "Member 'UProjectSettingsJP::EndOfMatchRewardURL' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PartyFollowLeaderPasswordMenuClass) == 0x0004B8, "Member 'UProjectSettingsJP::PartyFollowLeaderPasswordMenuClass' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, PostMatchLeaderLeftCountdownDuration) == 0x0004E0, "Member 'UProjectSettingsJP::PostMatchLeaderLeftCountdownDuration' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsDefaultMaxPlayers) == 0x0004E4, "Member 'UProjectSettingsJP::SettingsDefaultMaxPlayers' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsDefaultMatchTime) == 0x0004E8, "Member 'UProjectSettingsJP::SettingsDefaultMatchTime' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsMinMatchTime) == 0x0004EC, "Member 'UProjectSettingsJP::SettingsMinMatchTime' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsMaxMatchTime) == 0x0004F0, "Member 'UProjectSettingsJP::SettingsMaxMatchTime' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsGameModeString) == 0x0004F8, "Member 'UProjectSettingsJP::SettingsGameModeString' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsNextMapString) == 0x000508, "Member 'UProjectSettingsJP::SettingsNextMapString' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsMaxPlayersString) == 0x000518, "Member 'UProjectSettingsJP::SettingsMaxPlayersString' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsIsLanMatchString) == 0x000528, "Member 'UProjectSettingsJP::SettingsIsLanMatchString' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsMatchTimeString) == 0x000538, "Member 'UProjectSettingsJP::SettingsMatchTimeString' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, SettingsServerNameString) == 0x000548, "Member 'UProjectSettingsJP::SettingsServerNameString' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, FallbackPlayerStartLocation) == 0x000558, "Member 'UProjectSettingsJP::FallbackPlayerStartLocation' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, BattlePassConfiguration) == 0x000570, "Member 'UProjectSettingsJP::BattlePassConfiguration' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, DefaultHouseIdentifier) == 0x000598, "Member 'UProjectSettingsJP::DefaultHouseIdentifier' has a wrong offset!");
static_assert(offsetof(UProjectSettingsJP, DefaultHouseCollection) == 0x0005A0, "Member 'UProjectSettingsJP::DefaultHouseCollection' has a wrong offset!");

// Class JP.LyraSafeZoneEditor
// 0x0050 (0x0480 - 0x0430)
class ULyraSafeZoneEditor final : public UCommonActivatableWidget
{
public:
	uint8                                         Pad_430[0x20];                                     // 0x0430(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanCancel;                                        // 0x0450(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0xF];                                      // 0x0451(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetSwitcher*                        Switcher_SafeZoneMessage;                          // 0x0460(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonRichTextBlock*                   RichText_Default;                                  // 0x0468(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      Button_Back;                                       // 0x0470(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCommonButtonBase*                      Button_Done;                                       // 0x0478(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void HandleBackClicked();
	void HandleDoneClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSafeZoneEditor">();
	}
	static class ULyraSafeZoneEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSafeZoneEditor>();
	}
};
static_assert(alignof(ULyraSafeZoneEditor) == 0x000008, "Wrong alignment on ULyraSafeZoneEditor");
static_assert(sizeof(ULyraSafeZoneEditor) == 0x000480, "Wrong size on ULyraSafeZoneEditor");
static_assert(offsetof(ULyraSafeZoneEditor, bCanCancel) == 0x000450, "Member 'ULyraSafeZoneEditor::bCanCancel' has a wrong offset!");
static_assert(offsetof(ULyraSafeZoneEditor, Switcher_SafeZoneMessage) == 0x000460, "Member 'ULyraSafeZoneEditor::Switcher_SafeZoneMessage' has a wrong offset!");
static_assert(offsetof(ULyraSafeZoneEditor, RichText_Default) == 0x000468, "Member 'ULyraSafeZoneEditor::RichText_Default' has a wrong offset!");
static_assert(offsetof(ULyraSafeZoneEditor, Button_Back) == 0x000470, "Member 'ULyraSafeZoneEditor::Button_Back' has a wrong offset!");
static_assert(offsetof(ULyraSafeZoneEditor, Button_Done) == 0x000478, "Member 'ULyraSafeZoneEditor::Button_Done' has a wrong offset!");

// Class JP.LyraSettingAction_SafeZoneEditor
// 0x0008 (0x01A0 - 0x0198)
class ULyraSettingAction_SafeZoneEditor final : public UGameSettingAction
{
public:
	class ULyraSettingValueScalarDynamic_SafeZoneValue* SafeZoneValueSetting;                              // 0x0198(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingAction_SafeZoneEditor">();
	}
	static class ULyraSettingAction_SafeZoneEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingAction_SafeZoneEditor>();
	}
};
static_assert(alignof(ULyraSettingAction_SafeZoneEditor) == 0x000008, "Wrong alignment on ULyraSettingAction_SafeZoneEditor");
static_assert(sizeof(ULyraSettingAction_SafeZoneEditor) == 0x0001A0, "Wrong size on ULyraSettingAction_SafeZoneEditor");
static_assert(offsetof(ULyraSettingAction_SafeZoneEditor, SafeZoneValueSetting) == 0x000198, "Member 'ULyraSettingAction_SafeZoneEditor::SafeZoneValueSetting' has a wrong offset!");

// Class JP.SeasonPassContainerWidgetBase
// 0x0040 (0x0320 - 0x02E0)
class USeasonPassContainerWidgetBase : public UUserWidget
{
public:
	class FString                                 SeasonPassName;                                    // 0x02E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F0[0x30];                                     // 0x02F0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyViewModel(const struct FSeasonPassContainerViewModel& ViewModel);
	bool SeasonPassIsAvailable();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassContainerWidgetBase">();
	}
	static class USeasonPassContainerWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassContainerWidgetBase>();
	}
};
static_assert(alignof(USeasonPassContainerWidgetBase) == 0x000008, "Wrong alignment on USeasonPassContainerWidgetBase");
static_assert(sizeof(USeasonPassContainerWidgetBase) == 0x000320, "Wrong size on USeasonPassContainerWidgetBase");
static_assert(offsetof(USeasonPassContainerWidgetBase, SeasonPassName) == 0x0002E0, "Member 'USeasonPassContainerWidgetBase::SeasonPassName' has a wrong offset!");

// Class JP.LyraSettingsListEntrySetting_KeyboardInput
// 0x0050 (0x0390 - 0x0340)
class ULyraSettingsListEntrySetting_KeyboardInput : public UGameSettingListEntry_Setting
{
public:
	class ULyraSettingKeyboardInput*              KeyboardInputSetting;                              // 0x0340(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UGameSettingPressAnyKey>    PressAnyKeyPanelClass;                             // 0x0348(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UKeyAlreadyBoundWarning>    KeyAlreadyBoundWarningPanelClass;                  // 0x0350(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKey                                   OriginalKeyToBind;                                 // 0x0358(0x0018)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraButtonBase*                        Button_PrimaryKey;                                 // 0x0370(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraButtonBase*                        Button_SecondaryKey;                               // 0x0378(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraButtonBase*                        Button_Clear;                                      // 0x0380(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class ULyraButtonBase*                        Button_ResetToDefault;                             // 0x0388(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingsListEntrySetting_KeyboardInput">();
	}
	static class ULyraSettingsListEntrySetting_KeyboardInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingsListEntrySetting_KeyboardInput>();
	}
};
static_assert(alignof(ULyraSettingsListEntrySetting_KeyboardInput) == 0x000008, "Wrong alignment on ULyraSettingsListEntrySetting_KeyboardInput");
static_assert(sizeof(ULyraSettingsListEntrySetting_KeyboardInput) == 0x000390, "Wrong size on ULyraSettingsListEntrySetting_KeyboardInput");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, KeyboardInputSetting) == 0x000340, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::KeyboardInputSetting' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, PressAnyKeyPanelClass) == 0x000348, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::PressAnyKeyPanelClass' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, KeyAlreadyBoundWarningPanelClass) == 0x000350, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::KeyAlreadyBoundWarningPanelClass' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, OriginalKeyToBind) == 0x000358, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::OriginalKeyToBind' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, Button_PrimaryKey) == 0x000370, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::Button_PrimaryKey' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, Button_SecondaryKey) == 0x000378, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::Button_SecondaryKey' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, Button_Clear) == 0x000380, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::Button_Clear' has a wrong offset!");
static_assert(offsetof(ULyraSettingsListEntrySetting_KeyboardInput, Button_ResetToDefault) == 0x000388, "Member 'ULyraSettingsListEntrySetting_KeyboardInput::Button_ResetToDefault' has a wrong offset!");

// Class JP.NeighborSpecialAbilityWidgetProvider
// 0x0000 (0x0028 - 0x0028)
class INeighborSpecialAbilityWidgetProvider final : public IInterface
{
public:
	TArray<TSubclassOf<class UUserWidget>> GetWidgetTypes();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSpecialAbilityWidgetProvider">();
	}
	static class INeighborSpecialAbilityWidgetProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<INeighborSpecialAbilityWidgetProvider>();
	}
};
static_assert(alignof(INeighborSpecialAbilityWidgetProvider) == 0x000008, "Wrong alignment on INeighborSpecialAbilityWidgetProvider");
static_assert(sizeof(INeighborSpecialAbilityWidgetProvider) == 0x000028, "Wrong size on INeighborSpecialAbilityWidgetProvider");

// Class JP.LyraSettingsLocal
// 0x02F8 (0x0440 - 0x0148)
class ULyraSettingsLocal final : public UGameUserSettings
{
public:
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ELyraDisplayablePerformanceStat, ELyraStatDisplayMode> DisplayStatList;                                   // 0x0150(0x0050)(Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A0[0x18];                                     // 0x01A0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayGamma;                                      // 0x01B8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          MotionBlurEnabled;                                 // 0x01BC(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          HighContrastEnabled;                               // 0x01BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BE[0x2];                                      // 0x01BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnHighContrastEnabledChanged;                      // 0x01C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          AimAssistEnabled;                                  // 0x01D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D1[0x7];                                      // 0x01D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnAimAssistEnabled;                                // 0x01D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         SuperResolutionQualityMode;                        // 0x01E8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AAAndSuperResolutionSetting;                       // 0x01EC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ScreenPercentage;                                  // 0x01F0(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MSAASampleCount;                                   // 0x01F4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         FXAAQuality;                                       // 0x01F8(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FrameRateLimit_OnBattery;                          // 0x01FC(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FrameRateLimit_InMenu;                             // 0x0200(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FrameRateLimit_WhenBackgrounded;                   // 0x0204(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MobileFrameRateLimit;                              // 0x0208(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_20C[0x6C];                                     // 0x020C(0x006C)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DesiredUserChosenDeviceProfileSuffix;              // 0x0278(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 CurrentAppliedDeviceProfileOverrideSuffix;         // 0x0288(0x0010)(ZeroConstructor, Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 UserChosenDeviceProfileSuffix;                     // 0x0298(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2A8[0x30];                                     // 0x02A8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDesiredHeadphoneMode;                             // 0x02D8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHeadphoneMode;                                 // 0x02D9(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bActivateMicrophoneUponDeath;                      // 0x02DA(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseHDRAudioMode;                                  // 0x02DB(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AudioOutputDeviceId;                               // 0x02E0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 AudioInputDeviceId;                                // 0x02F0(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnMicrophoneTestStarted;                           // 0x0300(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnHidePlayerNamesChanged;                          // 0x0310(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCommunicationEnabledChanged;                     // 0x0320(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         OverallVolume;                                     // 0x0330(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MusicVolume;                                       // 0x0334(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SoundFXVolume;                                     // 0x0338(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DialogueVolume;                                    // 0x033C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         VoiceChatVolume;                                   // 0x0340(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MicrophoneVolume;                                  // 0x0344(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleCrouch;                                     // 0x0348(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleVoiceChat;                                  // 0x0349(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bTestingMicrophone;                                // 0x034A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowTooltips;                                     // 0x034B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHidePlayerNames;                                  // 0x034C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCommunicationEnabled;                             // 0x034D(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_34E[0x2];                                      // 0x034E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	ERegionOverride                               RegionOverrideSetting;                             // 0x0350(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleSprint;                                     // 0x0354(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bToggleSprintController;                           // 0x0355(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_356[0x2];                                      // 0x0356(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class USoundControlBus*>    ControlBusMap;                                     // 0x0358(0x0050)(Transient, NativeAccessSpecifierPrivate)
	class USoundControlBusMix*                    ControlBusMix;                                     // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSoundControlBusMixLoaded;                         // 0x03B0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SafeZoneScale;                                     // 0x03B4(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ControllerPlatform;                                // 0x03B8(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ControllerPreset;                                  // 0x03C0(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   InputConfigName;                                   // 0x03C8(0x0008)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FLoadedMappableConfigPair>      RegisteredInputConfigs;                            // 0x03D0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TMap<class FName, struct FKey>                CustomKeyboardConfig;                              // 0x03E0(0x0050)(Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraLocalPlayer*                       OwningPlayer;                                      // 0x0438(0x0008)(ZeroConstructor, Transient, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void BoolSettingChanged__DelegateSignature(bool IsEnabled);
	bool IsHighContrastEnabled();
	bool IsMotionBlurEnabled();
	void RunAutoBenchmark(bool bSaveImmediately);
	void SetActivateVoiceChatUponDeathEnabled(bool bEnabled);
	void SetAimAssist(bool IsEnabled);
	void SetAudioInputDeviceId(const class FString& InAudioInputDeviceId);
	void SetAudioOutputDeviceId(const class FString& InAudioOutputDeviceId);
	void SetCommunicationEnabled(bool NewValue);
	void SetControllerPlatform(const class FName InControllerPlatform);
	void SetCrouchToggle(bool NewValue);
	void SetDesiredDeviceProfileQualitySuffix(const class FString& InDesiredSuffix);
	void SetDialogueVolume(float InVolume);
	void SetDisplayGamma(float InGamma);
	void SetFrameRateLimit_Always(float NewLimitFPS);
	void SetFrameRateLimit_InMenu(float NewLimitFPS);
	void SetFrameRateLimit_OnBattery(float NewLimitFPS);
	void SetFrameRateLimit_WhenBackgrounded(float NewLimitFPS);
	void SetFXAAQuality(int32 Quality);
	void SetHDRAudioModeEnabled(bool bEnabled);
	void SetHeadphoneModeEnabled(bool bEnabled);
	void SetHidePlayerNames(bool NewValue);
	void SetHighContrast(bool IsEnabled);
	void SetIsTestingMicrophone(bool NewValue);
	void SetMicrophoneVolume(float InVolume);
	void SetMotionBlur(bool IsEnabled);
	void SetMSAASampleCount(int32 Samples);
	void SetMusicVolume(float InVolume);
	void SetOverallVolume(float InVolume);
	void SetRegionOverride(ERegionOverride NewValue);
	void SetSafeZone(float Value);
	void SetScreenPercentage(int32 Percentage);
	void SetShowTooltips(bool NewValue);
	void SetSoundFXVolume(float InVolume);
	void SetSprintToggle(bool NewValue);
	void SetSprintToggleController(bool NewValue);
	void SetSuperResolutionMode(int32 SuperSamplingMode);
	void SetSuperResolutionQualityMode(int32 QualityMode);
	void SetVoiceChatToggle(bool NewValue);
	void SetVoiceChatVolume(float InVolume);

	bool CanModifyHeadphoneModeEnabled() const;
	bool CanRunAutoBenchmark() const;
	class FString GetAudioInputDeviceId() const;
	class FString GetAudioOutputDeviceId() const;
	bool GetCommunicationEnabled() const;
	class FName GetControllerPlatform() const;
	bool GetCrouchToggle() const;
	class FString GetDesiredDeviceProfileQualitySuffix() const;
	float GetDialogueVolume() const;
	float GetDisplayGamma() const;
	float GetFrameRateLimit_Always() const;
	float GetFrameRateLimit_InMenu() const;
	float GetFrameRateLimit_OnBattery() const;
	float GetFrameRateLimit_WhenBackgrounded() const;
	int32 GetFXAAQuality() const;
	bool GetHidePlayerNames() const;
	bool GetIsTestingMicrophone() const;
	float GetMicrophoneVolume() const;
	int32 GetMSAASampleCount() const;
	float GetMusicVolume() const;
	float GetOverallVolume() const;
	ERegionOverride GetRegionOverride() const;
	float GetSafeZone() const;
	int32 GetScreenPercentage() const;
	bool GetShowTooltips() const;
	float GetSoundFXVolume() const;
	bool GetSprintToggle() const;
	bool GetSprintToggleController() const;
	int32 GetSuperResolutionMode() const;
	int32 GetSuperResolutionQualityMode() const;
	bool GetVoiceChatToggle() const;
	float GetVoiceChatVolume() const;
	bool IsActivateVoiceChatUponDeathEnabled() const;
	bool IsAimAssistEnabled() const;
	bool IsHDRAudioModeEnabled() const;
	bool IsHeadphoneModeEnabled() const;
	bool IsSafeZoneSet() const;
	bool ShouldRunAutoBenchmarkAtStartup() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingsLocal">();
	}
	static class ULyraSettingsLocal* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingsLocal>();
	}
};
static_assert(alignof(ULyraSettingsLocal) == 0x000008, "Wrong alignment on ULyraSettingsLocal");
static_assert(sizeof(ULyraSettingsLocal) == 0x000440, "Wrong size on ULyraSettingsLocal");
static_assert(offsetof(ULyraSettingsLocal, DisplayStatList) == 0x000150, "Member 'ULyraSettingsLocal::DisplayStatList' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, DisplayGamma) == 0x0001B8, "Member 'ULyraSettingsLocal::DisplayGamma' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, MotionBlurEnabled) == 0x0001BC, "Member 'ULyraSettingsLocal::MotionBlurEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, HighContrastEnabled) == 0x0001BD, "Member 'ULyraSettingsLocal::HighContrastEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OnHighContrastEnabledChanged) == 0x0001C0, "Member 'ULyraSettingsLocal::OnHighContrastEnabledChanged' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, AimAssistEnabled) == 0x0001D0, "Member 'ULyraSettingsLocal::AimAssistEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OnAimAssistEnabled) == 0x0001D8, "Member 'ULyraSettingsLocal::OnAimAssistEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, SuperResolutionQualityMode) == 0x0001E8, "Member 'ULyraSettingsLocal::SuperResolutionQualityMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, AAAndSuperResolutionSetting) == 0x0001EC, "Member 'ULyraSettingsLocal::AAAndSuperResolutionSetting' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ScreenPercentage) == 0x0001F0, "Member 'ULyraSettingsLocal::ScreenPercentage' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, MSAASampleCount) == 0x0001F4, "Member 'ULyraSettingsLocal::MSAASampleCount' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, FXAAQuality) == 0x0001F8, "Member 'ULyraSettingsLocal::FXAAQuality' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, FrameRateLimit_OnBattery) == 0x0001FC, "Member 'ULyraSettingsLocal::FrameRateLimit_OnBattery' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, FrameRateLimit_InMenu) == 0x000200, "Member 'ULyraSettingsLocal::FrameRateLimit_InMenu' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, FrameRateLimit_WhenBackgrounded) == 0x000204, "Member 'ULyraSettingsLocal::FrameRateLimit_WhenBackgrounded' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, MobileFrameRateLimit) == 0x000208, "Member 'ULyraSettingsLocal::MobileFrameRateLimit' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, DesiredUserChosenDeviceProfileSuffix) == 0x000278, "Member 'ULyraSettingsLocal::DesiredUserChosenDeviceProfileSuffix' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, CurrentAppliedDeviceProfileOverrideSuffix) == 0x000288, "Member 'ULyraSettingsLocal::CurrentAppliedDeviceProfileOverrideSuffix' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, UserChosenDeviceProfileSuffix) == 0x000298, "Member 'ULyraSettingsLocal::UserChosenDeviceProfileSuffix' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bDesiredHeadphoneMode) == 0x0002D8, "Member 'ULyraSettingsLocal::bDesiredHeadphoneMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bUseHeadphoneMode) == 0x0002D9, "Member 'ULyraSettingsLocal::bUseHeadphoneMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bActivateMicrophoneUponDeath) == 0x0002DA, "Member 'ULyraSettingsLocal::bActivateMicrophoneUponDeath' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bUseHDRAudioMode) == 0x0002DB, "Member 'ULyraSettingsLocal::bUseHDRAudioMode' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, AudioOutputDeviceId) == 0x0002E0, "Member 'ULyraSettingsLocal::AudioOutputDeviceId' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, AudioInputDeviceId) == 0x0002F0, "Member 'ULyraSettingsLocal::AudioInputDeviceId' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OnMicrophoneTestStarted) == 0x000300, "Member 'ULyraSettingsLocal::OnMicrophoneTestStarted' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OnHidePlayerNamesChanged) == 0x000310, "Member 'ULyraSettingsLocal::OnHidePlayerNamesChanged' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OnCommunicationEnabledChanged) == 0x000320, "Member 'ULyraSettingsLocal::OnCommunicationEnabledChanged' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OverallVolume) == 0x000330, "Member 'ULyraSettingsLocal::OverallVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, MusicVolume) == 0x000334, "Member 'ULyraSettingsLocal::MusicVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, SoundFXVolume) == 0x000338, "Member 'ULyraSettingsLocal::SoundFXVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, DialogueVolume) == 0x00033C, "Member 'ULyraSettingsLocal::DialogueVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, VoiceChatVolume) == 0x000340, "Member 'ULyraSettingsLocal::VoiceChatVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, MicrophoneVolume) == 0x000344, "Member 'ULyraSettingsLocal::MicrophoneVolume' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bToggleCrouch) == 0x000348, "Member 'ULyraSettingsLocal::bToggleCrouch' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bToggleVoiceChat) == 0x000349, "Member 'ULyraSettingsLocal::bToggleVoiceChat' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bTestingMicrophone) == 0x00034A, "Member 'ULyraSettingsLocal::bTestingMicrophone' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bShowTooltips) == 0x00034B, "Member 'ULyraSettingsLocal::bShowTooltips' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bHidePlayerNames) == 0x00034C, "Member 'ULyraSettingsLocal::bHidePlayerNames' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bCommunicationEnabled) == 0x00034D, "Member 'ULyraSettingsLocal::bCommunicationEnabled' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, RegionOverrideSetting) == 0x000350, "Member 'ULyraSettingsLocal::RegionOverrideSetting' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bToggleSprint) == 0x000354, "Member 'ULyraSettingsLocal::bToggleSprint' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bToggleSprintController) == 0x000355, "Member 'ULyraSettingsLocal::bToggleSprintController' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ControlBusMap) == 0x000358, "Member 'ULyraSettingsLocal::ControlBusMap' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ControlBusMix) == 0x0003A8, "Member 'ULyraSettingsLocal::ControlBusMix' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, bSoundControlBusMixLoaded) == 0x0003B0, "Member 'ULyraSettingsLocal::bSoundControlBusMixLoaded' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, SafeZoneScale) == 0x0003B4, "Member 'ULyraSettingsLocal::SafeZoneScale' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ControllerPlatform) == 0x0003B8, "Member 'ULyraSettingsLocal::ControllerPlatform' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, ControllerPreset) == 0x0003C0, "Member 'ULyraSettingsLocal::ControllerPreset' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, InputConfigName) == 0x0003C8, "Member 'ULyraSettingsLocal::InputConfigName' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, RegisteredInputConfigs) == 0x0003D0, "Member 'ULyraSettingsLocal::RegisteredInputConfigs' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, CustomKeyboardConfig) == 0x0003E0, "Member 'ULyraSettingsLocal::CustomKeyboardConfig' has a wrong offset!");
static_assert(offsetof(ULyraSettingsLocal, OwningPlayer) == 0x000438, "Member 'ULyraSettingsLocal::OwningPlayer' has a wrong offset!");

// Class JP.LyraSettingValueDiscreteDynamic_AudioInputDevice
// 0x0048 (0x0210 - 0x01C8)
class ULyraSettingValueDiscreteDynamic_AudioInputDevice final : public UJPGameSettingValueDiscreteDynamic
{
public:
	uint8                                         Pad_1C8[0x48];                                     // 0x01C8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeviceAddedOrRemoved(const class FString& DeviceID);
	void OnAudioInputDevicesObtained(const TArray<struct FAudioInputDeviceInfo>& AvailableDevices);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscreteDynamic_AudioInputDevice">();
	}
	static class ULyraSettingValueDiscreteDynamic_AudioInputDevice* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscreteDynamic_AudioInputDevice>();
	}
};
static_assert(alignof(ULyraSettingValueDiscreteDynamic_AudioInputDevice) == 0x000008, "Wrong alignment on ULyraSettingValueDiscreteDynamic_AudioInputDevice");
static_assert(sizeof(ULyraSettingValueDiscreteDynamic_AudioInputDevice) == 0x000210, "Wrong size on ULyraSettingValueDiscreteDynamic_AudioInputDevice");

// Class JP.SeasonPassGameInstanceSubsystem
// 0x00B0 (0x00E0 - 0x0030)
class USeasonPassGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0xB0];                                      // 0x0030(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetProgressTowardNextNeighborLevel(const struct FGameplayTag& NeighborID);

	int32 GetNeighborLevel(const struct FGameplayTag& NeighborID) const;
	int32 GetNeighborLevelForXP(const struct FGameplayTag& NeighborID, const int32 NeighborXP) const;
	TMap<int32, struct FGameplayTag> GetNeighborPerkRewardsByLevel(const struct FGameplayTag& NeighborID) const;
	int32 GetTotalXPRequirementForNeighborLevel(const struct FGameplayTag& NeighborID, int32 Level) const;
	int32 GetXPRequirementForNextNeighborLevel(const struct FGameplayTag& NeighborID, int32 CurrentLevel) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassGameInstanceSubsystem">();
	}
	static class USeasonPassGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassGameInstanceSubsystem>();
	}
};
static_assert(alignof(USeasonPassGameInstanceSubsystem) == 0x000008, "Wrong alignment on USeasonPassGameInstanceSubsystem");
static_assert(sizeof(USeasonPassGameInstanceSubsystem) == 0x0000E0, "Wrong size on USeasonPassGameInstanceSubsystem");

// Class JP.ReplicatedProjectileActor
// 0x0010 (0x02A0 - 0x0290)
class AReplicatedProjectileActor final : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UProjectileMovementComponent*           ProjectileMovementComponent;                       // 0x0298(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReplicatedProjectileActor">();
	}
	static class AReplicatedProjectileActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AReplicatedProjectileActor>();
	}
};
static_assert(alignof(AReplicatedProjectileActor) == 0x000008, "Wrong alignment on AReplicatedProjectileActor");
static_assert(sizeof(AReplicatedProjectileActor) == 0x0002A0, "Wrong size on AReplicatedProjectileActor");
static_assert(offsetof(AReplicatedProjectileActor, ProjectileMovementComponent) == 0x000298, "Member 'AReplicatedProjectileActor::ProjectileMovementComponent' has a wrong offset!");

// Class JP.LyraSettingValueDiscrete_Language
// 0x0010 (0x0170 - 0x0160)
class ULyraSettingValueDiscrete_Language final : public UJPGameSettingValueDiscrete
{
public:
	uint8                                         Pad_160[0x10];                                     // 0x0160(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_Language">();
	}
	static class ULyraSettingValueDiscrete_Language* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_Language>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_Language) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_Language");
static_assert(sizeof(ULyraSettingValueDiscrete_Language) == 0x000170, "Wrong size on ULyraSettingValueDiscrete_Language");

// Class JP.LyraSettingValueDiscrete_MobileFPSType
// 0x0018 (0x0178 - 0x0160)
class ULyraSettingValueDiscrete_MobileFPSType final : public UJPGameSettingValueDiscrete
{
public:
	uint8                                         Pad_160[0x18];                                     // 0x0160(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_MobileFPSType">();
	}
	static class ULyraSettingValueDiscrete_MobileFPSType* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_MobileFPSType>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_MobileFPSType) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_MobileFPSType");
static_assert(sizeof(ULyraSettingValueDiscrete_MobileFPSType) == 0x000178, "Wrong size on ULyraSettingValueDiscrete_MobileFPSType");

// Class JP.LyraSettingValueDiscrete_OverallQuality
// 0x0020 (0x0180 - 0x0160)
class ULyraSettingValueDiscrete_OverallQuality final : public UJPGameSettingValueDiscrete
{
public:
	uint8                                         Pad_160[0x20];                                     // 0x0160(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_OverallQuality">();
	}
	static class ULyraSettingValueDiscrete_OverallQuality* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_OverallQuality>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_OverallQuality) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_OverallQuality");
static_assert(sizeof(ULyraSettingValueDiscrete_OverallQuality) == 0x000180, "Wrong size on ULyraSettingValueDiscrete_OverallQuality");

// Class JP.SeasonPassRewardContent_NeighborSkinInterface
// 0x0000 (0x0028 - 0x0028)
class ISeasonPassRewardContent_NeighborSkinInterface final : public IInterface
{
public:
	void ApplyNeighborSkinViewModel(const struct FSeasonPassRewardContent_NeighborSkinViewModel& ViewModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassRewardContent_NeighborSkinInterface">();
	}
	static class ISeasonPassRewardContent_NeighborSkinInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISeasonPassRewardContent_NeighborSkinInterface>();
	}
};
static_assert(alignof(ISeasonPassRewardContent_NeighborSkinInterface) == 0x000008, "Wrong alignment on ISeasonPassRewardContent_NeighborSkinInterface");
static_assert(sizeof(ISeasonPassRewardContent_NeighborSkinInterface) == 0x000028, "Wrong size on ISeasonPassRewardContent_NeighborSkinInterface");

// Class JP.LyraSettingValueDiscrete_PerfStat
// 0x0028 (0x0188 - 0x0160)
class ULyraSettingValueDiscrete_PerfStat final : public UJPGameSettingValueDiscrete
{
public:
	uint8                                         Pad_160[0x28];                                     // 0x0160(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_PerfStat">();
	}
	static class ULyraSettingValueDiscrete_PerfStat* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_PerfStat>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_PerfStat) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_PerfStat");
static_assert(sizeof(ULyraSettingValueDiscrete_PerfStat) == 0x000188, "Wrong size on ULyraSettingValueDiscrete_PerfStat");

// Class JP.PreLobbyScreen
// 0x0000 (0x0430 - 0x0430)
class UPreLobbyScreen : public UCommonActivatableWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreLobbyScreen">();
	}
	static class UPreLobbyScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreLobbyScreen>();
	}
};
static_assert(alignof(UPreLobbyScreen) == 0x000008, "Wrong alignment on UPreLobbyScreen");
static_assert(sizeof(UPreLobbyScreen) == 0x000430, "Wrong size on UPreLobbyScreen");

// Class JP.LyraSettingValueDiscrete_Resolution
// 0x0048 (0x01A8 - 0x0160)
class ULyraSettingValueDiscrete_Resolution final : public UJPGameSettingValueDiscrete
{
public:
	uint8                                         Pad_160[0x48];                                     // 0x0160(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingValueDiscrete_Resolution">();
	}
	static class ULyraSettingValueDiscrete_Resolution* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingValueDiscrete_Resolution>();
	}
};
static_assert(alignof(ULyraSettingValueDiscrete_Resolution) == 0x000008, "Wrong alignment on ULyraSettingValueDiscrete_Resolution");
static_assert(sizeof(ULyraSettingValueDiscrete_Resolution) == 0x0001A8, "Wrong size on ULyraSettingValueDiscrete_Resolution");

// Class JP.LyraTeamAgentInterface
// 0x0000 (0x0028 - 0x0028)
class ILyraTeamAgentInterface final : public IGenericTeamAgentInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTeamAgentInterface">();
	}
	static class ILyraTeamAgentInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILyraTeamAgentInterface>();
	}
};
static_assert(alignof(ILyraTeamAgentInterface) == 0x000008, "Wrong alignment on ILyraTeamAgentInterface");
static_assert(sizeof(ILyraTeamAgentInterface) == 0x000028, "Wrong size on ILyraTeamAgentInterface");

// Class JP.LyraUIBlueprintFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class ULyraUIBlueprintFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void FindAndRemoveWidgetFromAllLayers(const class UObject* WorldContextObject, class UCommonActivatableWidget* ActivatableWidget, class UPrimaryGameLayout* PrimaryGameLayout);
	static class UCommonActivatableWidgetContainerBase* GetLayerWidget(const class UObject* WorldContextObject, const struct FGameplayTag& LayerName, class UPrimaryGameLayout* PrimaryGameLayout);
	static class UPrimaryGameLayout* GetPrimaryGameLayoutForPrimaryPlayer(const class UObject* WorldContextObject);
	static class UCommonActivatableWidget* PushNonPooledWidgetToLayerStack(const class UObject* WorldContextObject, const struct FGameplayTag& LayerName, TSubclassOf<class UCommonActivatableWidget> ActivatableWidgetClass, class UPrimaryGameLayout* PrimaryGameLayout);
	static class UCommonActivatableWidget* PushWidgetToLayerStack(const class UObject* WorldContextObject, const struct FGameplayTag& LayerName, TSubclassOf<class UCommonActivatableWidget> ActivatableWidgetClass, class UPrimaryGameLayout* PrimaryGameLayout);
	static void RemoveAllWidgetsOutsideRootLayout(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraUIBlueprintFunctionLibrary">();
	}
	static class ULyraUIBlueprintFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraUIBlueprintFunctionLibrary>();
	}
};
static_assert(alignof(ULyraUIBlueprintFunctionLibrary) == 0x000008, "Wrong alignment on ULyraUIBlueprintFunctionLibrary");
static_assert(sizeof(ULyraUIBlueprintFunctionLibrary) == 0x000028, "Wrong size on ULyraUIBlueprintFunctionLibrary");

// Class JP.PawnDefinitionJP
// 0x0000 (0x0060 - 0x0060)
class UPawnDefinitionJP final : public UPawnDefinition
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PawnDefinitionJP">();
	}
	static class UPawnDefinitionJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPawnDefinitionJP>();
	}
};
static_assert(alignof(UPawnDefinitionJP) == 0x000008, "Wrong alignment on UPawnDefinitionJP");
static_assert(sizeof(UPawnDefinitionJP) == 0x000060, "Wrong size on UPawnDefinitionJP");

// Class JP.SeasonPassPreviewContainerWidget
// 0x0018 (0x0338 - 0x0320)
class USeasonPassPreviewContainerWidget : public USeasonPassContainerWidgetBase
{
public:
	int32                                         TiersToShow;                                       // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScrollBox*                             ScrollBox;                                         // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USeasonPassTierWidget>      TierWidget;                                        // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CreateTierWidget(const struct FSeasonPassTierViewModel& ViewModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassPreviewContainerWidget">();
	}
	static class USeasonPassPreviewContainerWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassPreviewContainerWidget>();
	}
};
static_assert(alignof(USeasonPassPreviewContainerWidget) == 0x000008, "Wrong alignment on USeasonPassPreviewContainerWidget");
static_assert(sizeof(USeasonPassPreviewContainerWidget) == 0x000338, "Wrong size on USeasonPassPreviewContainerWidget");
static_assert(offsetof(USeasonPassPreviewContainerWidget, TiersToShow) == 0x000320, "Member 'USeasonPassPreviewContainerWidget::TiersToShow' has a wrong offset!");
static_assert(offsetof(USeasonPassPreviewContainerWidget, ScrollBox) == 0x000328, "Member 'USeasonPassPreviewContainerWidget::ScrollBox' has a wrong offset!");
static_assert(offsetof(USeasonPassPreviewContainerWidget, TierWidget) == 0x000330, "Member 'USeasonPassPreviewContainerWidget::TierWidget' has a wrong offset!");

// Class JP.MainMenuInitializationStep_CleanupAvatarCache
// 0x0000 (0x0080 - 0x0080)
class UMainMenuInitializationStep_CleanupAvatarCache final : public UMainMenuInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStep_CleanupAvatarCache">();
	}
	static class UMainMenuInitializationStep_CleanupAvatarCache* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStep_CleanupAvatarCache>();
	}
};
static_assert(alignof(UMainMenuInitializationStep_CleanupAvatarCache) == 0x000008, "Wrong alignment on UMainMenuInitializationStep_CleanupAvatarCache");
static_assert(sizeof(UMainMenuInitializationStep_CleanupAvatarCache) == 0x000080, "Wrong size on UMainMenuInitializationStep_CleanupAvatarCache");

// Class JP.MainMenuInitializationStep_CreateParty
// 0x0018 (0x0098 - 0x0080)
class UMainMenuInitializationStep_CreateParty final : public UMainMenuInitializationStepBase
{
public:
	class UPartyOnlineServiceHandler*             PartyPtr;                                          // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStep_CreateParty">();
	}
	static class UMainMenuInitializationStep_CreateParty* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStep_CreateParty>();
	}
};
static_assert(alignof(UMainMenuInitializationStep_CreateParty) == 0x000008, "Wrong alignment on UMainMenuInitializationStep_CreateParty");
static_assert(sizeof(UMainMenuInitializationStep_CreateParty) == 0x000098, "Wrong size on UMainMenuInitializationStep_CreateParty");
static_assert(offsetof(UMainMenuInitializationStep_CreateParty, PartyPtr) == 0x000080, "Member 'UMainMenuInitializationStep_CreateParty::PartyPtr' has a wrong offset!");

// Class JP.MainMenuInitializationStep_LoadingScreen
// 0x0000 (0x0080 - 0x0080)
class UMainMenuInitializationStep_LoadingScreen final : public UMainMenuInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStep_LoadingScreen">();
	}
	static class UMainMenuInitializationStep_LoadingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStep_LoadingScreen>();
	}
};
static_assert(alignof(UMainMenuInitializationStep_LoadingScreen) == 0x000008, "Wrong alignment on UMainMenuInitializationStep_LoadingScreen");
static_assert(sizeof(UMainMenuInitializationStep_LoadingScreen) == 0x000080, "Wrong size on UMainMenuInitializationStep_LoadingScreen");

// Class JP.PerkDefinition
// 0x0080 (0x00B8 - 0x0038)
class UPerkDefinition final : public UTagLookupPrimaryDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0038(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0048(0x0028)(Edit, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FText                                   Description;                                       // 0x0070(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   BuffDescription;                                   // 0x0080(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class FText                                   DebuffDescription;                                 // 0x0090(0x0010)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<class UPerkAction*>                    Actions;                                           // 0x00A0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	EPerkCategories                               Category;                                          // 0x00B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool TryGetPerkDefinition(const struct FGameplayTag& PerkID, TSoftObjectPtr<class UPerkDefinition>* OutSoftPerkDefinition);

	class FText GetBuffDescription() const;
	EPerkCategories GetCategory() const;
	struct FColor GetColor() const;
	class FText GetDebuffDescription() const;
	class FText GetDescription() const;
	TSoftObjectPtr<class UTexture2D> GetIcon() const;
	class FText GetPerkName() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkDefinition">();
	}
	static class UPerkDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkDefinition>();
	}
};
static_assert(alignof(UPerkDefinition) == 0x000008, "Wrong alignment on UPerkDefinition");
static_assert(sizeof(UPerkDefinition) == 0x0000B8, "Wrong size on UPerkDefinition");
static_assert(offsetof(UPerkDefinition, Name_0) == 0x000038, "Member 'UPerkDefinition::Name_0' has a wrong offset!");
static_assert(offsetof(UPerkDefinition, Icon) == 0x000048, "Member 'UPerkDefinition::Icon' has a wrong offset!");
static_assert(offsetof(UPerkDefinition, Description) == 0x000070, "Member 'UPerkDefinition::Description' has a wrong offset!");
static_assert(offsetof(UPerkDefinition, BuffDescription) == 0x000080, "Member 'UPerkDefinition::BuffDescription' has a wrong offset!");
static_assert(offsetof(UPerkDefinition, DebuffDescription) == 0x000090, "Member 'UPerkDefinition::DebuffDescription' has a wrong offset!");
static_assert(offsetof(UPerkDefinition, Actions) == 0x0000A0, "Member 'UPerkDefinition::Actions' has a wrong offset!");
static_assert(offsetof(UPerkDefinition, Category) == 0x0000B0, "Member 'UPerkDefinition::Category' has a wrong offset!");

// Class JP.MainMenuInitializationStep_PartyHandleEnteringMainMenu
// 0x0010 (0x0090 - 0x0080)
class UMainMenuInitializationStep_PartyHandleEnteringMainMenu final : public UMainMenuInitializationStepBase
{
public:
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x8];                                       // 0x0088(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStep_PartyHandleEnteringMainMenu">();
	}
	static class UMainMenuInitializationStep_PartyHandleEnteringMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStep_PartyHandleEnteringMainMenu>();
	}
};
static_assert(alignof(UMainMenuInitializationStep_PartyHandleEnteringMainMenu) == 0x000008, "Wrong alignment on UMainMenuInitializationStep_PartyHandleEnteringMainMenu");
static_assert(sizeof(UMainMenuInitializationStep_PartyHandleEnteringMainMenu) == 0x000090, "Wrong size on UMainMenuInitializationStep_PartyHandleEnteringMainMenu");
static_assert(offsetof(UMainMenuInitializationStep_PartyHandleEnteringMainMenu, SocialGIS) == 0x000080, "Member 'UMainMenuInitializationStep_PartyHandleEnteringMainMenu::SocialGIS' has a wrong offset!");

// Class JP.Rarity
// 0x0028 (0x0058 - 0x0030)
class URarity final : public UDataAsset
{
public:
	uint8                                         Tier;                                              // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_0;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Rarity">();
	}
	static class URarity* GetDefaultObj()
	{
		return GetDefaultObjImpl<URarity>();
	}
};
static_assert(alignof(URarity) == 0x000008, "Wrong alignment on URarity");
static_assert(sizeof(URarity) == 0x000058, "Wrong size on URarity");
static_assert(offsetof(URarity, Tier) == 0x000030, "Member 'URarity::Tier' has a wrong offset!");
static_assert(offsetof(URarity, Name_0) == 0x000038, "Member 'URarity::Name_0' has a wrong offset!");
static_assert(offsetof(URarity, Color) == 0x000048, "Member 'URarity::Color' has a wrong offset!");

// Class JP.MainMenuInitializationStep_ReadBlockedPlayers
// 0x0018 (0x0098 - 0x0080)
class UMainMenuInitializationStep_ReadBlockedPlayers final : public UMainMenuInitializationStepBase
{
public:
	class UBlockedPlayersOnlineServiceHandler*    BlockedPlayersPtr;                                 // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStep_ReadBlockedPlayers">();
	}
	static class UMainMenuInitializationStep_ReadBlockedPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStep_ReadBlockedPlayers>();
	}
};
static_assert(alignof(UMainMenuInitializationStep_ReadBlockedPlayers) == 0x000008, "Wrong alignment on UMainMenuInitializationStep_ReadBlockedPlayers");
static_assert(sizeof(UMainMenuInitializationStep_ReadBlockedPlayers) == 0x000098, "Wrong size on UMainMenuInitializationStep_ReadBlockedPlayers");
static_assert(offsetof(UMainMenuInitializationStep_ReadBlockedPlayers, BlockedPlayersPtr) == 0x000080, "Member 'UMainMenuInitializationStep_ReadBlockedPlayers::BlockedPlayersPtr' has a wrong offset!");

// Class JP.MainMenuInitializationStep_ReadRecentPlayers
// 0x0018 (0x0098 - 0x0080)
class UMainMenuInitializationStep_ReadRecentPlayers final : public UMainMenuInitializationStepBase
{
public:
	class URecentPlayersOnlineServiceHandler*     RecentPlayersPtr;                                  // 0x0080(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_88[0x10];                                      // 0x0088(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStep_ReadRecentPlayers">();
	}
	static class UMainMenuInitializationStep_ReadRecentPlayers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStep_ReadRecentPlayers>();
	}
};
static_assert(alignof(UMainMenuInitializationStep_ReadRecentPlayers) == 0x000008, "Wrong alignment on UMainMenuInitializationStep_ReadRecentPlayers");
static_assert(sizeof(UMainMenuInitializationStep_ReadRecentPlayers) == 0x000098, "Wrong size on UMainMenuInitializationStep_ReadRecentPlayers");
static_assert(offsetof(UMainMenuInitializationStep_ReadRecentPlayers, RecentPlayersPtr) == 0x000080, "Member 'UMainMenuInitializationStep_ReadRecentPlayers::RecentPlayersPtr' has a wrong offset!");

// Class JP.PingControllerComponent
// 0x0178 (0x0218 - 0x00A0)
class UPingControllerComponent : public UActorComponent
{
public:
	float                                         TraceDistance;                                     // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepRadius;                                       // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OverlapRadius;                                     // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GlobalPingMinDot;                                  // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoubleTapLocationMaxDistance;                      // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DoubleTapTime;                                     // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxActivePingActors;                               // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPingData                              DefaultPingData;                                   // 0x00C0(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FPingData                              WarningPingData;                                   // 0x0150(0x0090)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x01E0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             OverlapChannel;                                    // 0x01E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E2[0x6];                                      // 0x01E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class APingVisualizationActor*>        CurrentActivePings;                                // 0x01E8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F8[0x20];                                     // 0x01F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UPingableComponent*> GetGloballyPingableObjects();
	void Server_RequestPing(const struct FVector& InViewLocation, const struct FRotator& InViewRotation, class APlayerControllerJP_Match* InPC);
	void Server_RequestPingComponent(class UPingableComponent* InPingableComponent, const struct FVector& InLocationOverride, class APlayerControllerJP_Match* InPC);
	void TryPing();
	void TryPingComponent(class UPingableComponent* InPingableComponent, const struct FVector& InLocationOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingControllerComponent">();
	}
	static class UPingControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingControllerComponent>();
	}
};
static_assert(alignof(UPingControllerComponent) == 0x000008, "Wrong alignment on UPingControllerComponent");
static_assert(sizeof(UPingControllerComponent) == 0x000218, "Wrong size on UPingControllerComponent");
static_assert(offsetof(UPingControllerComponent, TraceDistance) == 0x0000A0, "Member 'UPingControllerComponent::TraceDistance' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, SweepRadius) == 0x0000A4, "Member 'UPingControllerComponent::SweepRadius' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, OverlapRadius) == 0x0000A8, "Member 'UPingControllerComponent::OverlapRadius' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, GlobalPingMinDot) == 0x0000AC, "Member 'UPingControllerComponent::GlobalPingMinDot' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, DoubleTapLocationMaxDistance) == 0x0000B0, "Member 'UPingControllerComponent::DoubleTapLocationMaxDistance' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, DoubleTapTime) == 0x0000B4, "Member 'UPingControllerComponent::DoubleTapTime' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, MaxActivePingActors) == 0x0000B8, "Member 'UPingControllerComponent::MaxActivePingActors' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, DefaultPingData) == 0x0000C0, "Member 'UPingControllerComponent::DefaultPingData' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, WarningPingData) == 0x000150, "Member 'UPingControllerComponent::WarningPingData' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, TraceChannel) == 0x0001E0, "Member 'UPingControllerComponent::TraceChannel' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, OverlapChannel) == 0x0001E1, "Member 'UPingControllerComponent::OverlapChannel' has a wrong offset!");
static_assert(offsetof(UPingControllerComponent, CurrentActivePings) == 0x0001E8, "Member 'UPingControllerComponent::CurrentActivePings' has a wrong offset!");

// Class JP.MainMenuInitializationStep_SoftUpdateGameData
// 0x0000 (0x0080 - 0x0080)
class UMainMenuInitializationStep_SoftUpdateGameData final : public UMainMenuInitializationStepBase
{
public:
	void OnUpdateFinished();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationStep_SoftUpdateGameData">();
	}
	static class UMainMenuInitializationStep_SoftUpdateGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationStep_SoftUpdateGameData>();
	}
};
static_assert(alignof(UMainMenuInitializationStep_SoftUpdateGameData) == 0x000008, "Wrong alignment on UMainMenuInitializationStep_SoftUpdateGameData");
static_assert(sizeof(UMainMenuInitializationStep_SoftUpdateGameData) == 0x000080, "Wrong size on UMainMenuInitializationStep_SoftUpdateGameData");

// Class JP.SeasonPassRewardOperation
// 0x0000 (0x0028 - 0x0028)
class USeasonPassRewardOperation final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassRewardOperation">();
	}
	static class USeasonPassRewardOperation* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassRewardOperation>();
	}
};
static_assert(alignof(USeasonPassRewardOperation) == 0x000008, "Wrong alignment on USeasonPassRewardOperation");
static_assert(sizeof(USeasonPassRewardOperation) == 0x000028, "Wrong size on USeasonPassRewardOperation");

// Class JP.MainMenuInitializationWorldSubsystem
// 0x0008 (0x0038 - 0x0030)
class UMainMenuInitializationWorldSubsystem final : public UWorldSubsystem
{
public:
	class UInitializationFlowComponent*           FlowComponent;                                     // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitializationWorldSubsystem">();
	}
	static class UMainMenuInitializationWorldSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitializationWorldSubsystem>();
	}
};
static_assert(alignof(UMainMenuInitializationWorldSubsystem) == 0x000008, "Wrong alignment on UMainMenuInitializationWorldSubsystem");
static_assert(sizeof(UMainMenuInitializationWorldSubsystem) == 0x000038, "Wrong size on UMainMenuInitializationWorldSubsystem");
static_assert(offsetof(UMainMenuInitializationWorldSubsystem, FlowComponent) == 0x000030, "Member 'UMainMenuInitializationWorldSubsystem::FlowComponent' has a wrong offset!");

// Class JP.MainMenuInitialization_ClearGameSessions
// 0x0000 (0x0080 - 0x0080)
class UMainMenuInitialization_ClearGameSessions final : public UMainMenuInitializationStepBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuInitialization_ClearGameSessions">();
	}
	static class UMainMenuInitialization_ClearGameSessions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuInitialization_ClearGameSessions>();
	}
};
static_assert(alignof(UMainMenuInitialization_ClearGameSessions) == 0x000008, "Wrong alignment on UMainMenuInitialization_ClearGameSessions");
static_assert(sizeof(UMainMenuInitialization_ClearGameSessions) == 0x000080, "Wrong size on UMainMenuInitialization_ClearGameSessions");

// Class JP.MatchConfigurationSubsystem
// 0x0068 (0x0098 - 0x0030)
class UMatchConfigurationSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMatchConfiguration                    CurrentConfig;                                     // 0x0040(0x0058)(NativeAccessSpecifierPrivate)

public:
	static const struct FMatchConfiguration GetMatchConfiguration(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchConfigurationSubsystem">();
	}
	static class UMatchConfigurationSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchConfigurationSubsystem>();
	}
};
static_assert(alignof(UMatchConfigurationSubsystem) == 0x000008, "Wrong alignment on UMatchConfigurationSubsystem");
static_assert(sizeof(UMatchConfigurationSubsystem) == 0x000098, "Wrong size on UMatchConfigurationSubsystem");
static_assert(offsetof(UMatchConfigurationSubsystem, CurrentConfig) == 0x000040, "Member 'UMatchConfigurationSubsystem::CurrentConfig' has a wrong offset!");

// Class JP.PlayerControllerJP_Lobby
// 0x0020 (0x08C8 - 0x08A8)
class APlayerControllerJP_Lobby final : public APlayerControllerJP
{
public:
	FMulticastInlineDelegateProperty_             OnLobbyPlayerGetDefaultCharacterSettings;          // 0x08A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsDefaultCharacterSettingsApplied;                // 0x08B8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B9[0x3];                                      // 0x08B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDefaultCharacterSettings              DefaultCharacterSettings;                          // 0x08BC(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C4[0x4];                                      // 0x08C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnGetDefaultCharacterSettingsError(const int32 Code, const class FString& Message);
	void Server_SetConfirmedJoin();
	void Server_SetReadyAndWaiting(const bool ReadyAndWaiting);

	void Server_VoteOnLevel(int32 LevelIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerControllerJP_Lobby">();
	}
	static class APlayerControllerJP_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerControllerJP_Lobby>();
	}
};
static_assert(alignof(APlayerControllerJP_Lobby) == 0x000008, "Wrong alignment on APlayerControllerJP_Lobby");
static_assert(sizeof(APlayerControllerJP_Lobby) == 0x0008C8, "Wrong size on APlayerControllerJP_Lobby");
static_assert(offsetof(APlayerControllerJP_Lobby, OnLobbyPlayerGetDefaultCharacterSettings) == 0x0008A8, "Member 'APlayerControllerJP_Lobby::OnLobbyPlayerGetDefaultCharacterSettings' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Lobby, bIsDefaultCharacterSettingsApplied) == 0x0008B8, "Member 'APlayerControllerJP_Lobby::bIsDefaultCharacterSettingsApplied' has a wrong offset!");
static_assert(offsetof(APlayerControllerJP_Lobby, DefaultCharacterSettings) == 0x0008BC, "Member 'APlayerControllerJP_Lobby::DefaultCharacterSettings' has a wrong offset!");

// Class JP.MatchConfigurationWidget
// 0x0008 (0x0438 - 0x0430)
class UMatchConfigurationWidget : public UCommonActivatableWidget
{
public:
	class UDataTable*                             ShopItemDataTable;                                 // 0x0430(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ApplyViewModel(const struct FMatchConfigurationViewModel& InViewModel);
	void HandleConfigurationChanged();
	void SetBoolValue(class UJPSettingWidget* InWidget, bool InValue);
	void SetFloatValue(class UJPSettingWidget* InWidget, float InValue);
	void SetIntegerValue(class UJPSettingWidget* InWidget, int32 InValue);
	void SetItemEnabled(const struct FGameplayTag& InItemTag, bool InEnabled);
	void SetStringValue(class UJPSettingWidget* InWidget, const class FString& InValue);
	void TryResetConfiguration();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchConfigurationWidget">();
	}
	static class UMatchConfigurationWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchConfigurationWidget>();
	}
};
static_assert(alignof(UMatchConfigurationWidget) == 0x000008, "Wrong alignment on UMatchConfigurationWidget");
static_assert(sizeof(UMatchConfigurationWidget) == 0x000438, "Wrong size on UMatchConfigurationWidget");
static_assert(offsetof(UMatchConfigurationWidget, ShopItemDataTable) == 0x000430, "Member 'UMatchConfigurationWidget::ShopItemDataTable' has a wrong offset!");

// Class JP.TeamableActor
// 0x0020 (0x02B0 - 0x0290)
class ATeamableActor : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          RecalculateWhenMoving;                             // 0x0298(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_299[0x3];                                      // 0x0299(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AGroundsKeeper>          GroundsKeeperOverride;                             // 0x029C(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AGroundsKeeper>          GroundsKeeperAutoFound;                            // 0x02A4(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RecalculateGroundsKeeperOwner();

	class AGroundsKeeper* GetCachedGroundsKeeper() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamableActor">();
	}
	static class ATeamableActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamableActor>();
	}
};
static_assert(alignof(ATeamableActor) == 0x000008, "Wrong alignment on ATeamableActor");
static_assert(sizeof(ATeamableActor) == 0x0002B0, "Wrong size on ATeamableActor");
static_assert(offsetof(ATeamableActor, RecalculateWhenMoving) == 0x000298, "Member 'ATeamableActor::RecalculateWhenMoving' has a wrong offset!");
static_assert(offsetof(ATeamableActor, GroundsKeeperOverride) == 0x00029C, "Member 'ATeamableActor::GroundsKeeperOverride' has a wrong offset!");
static_assert(offsetof(ATeamableActor, GroundsKeeperAutoFound) == 0x0002A4, "Member 'ATeamableActor::GroundsKeeperAutoFound' has a wrong offset!");

// Class JP.RoomManager
// 0x0010 (0x02C0 - 0x02B0)
class ARoomManager : public ATeamableActor
{
public:
	FMulticastInlineDelegateProperty_             OnRoomUpgradeApproved;                             // 0x02B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void HandleRoomUpgradeApproved(class APlayerState* Player);
	void K2_RoomUpgradeApproved(class APlayerState* InstigatingPlayer);

	bool CanUpgradeRoom(class APlayerState* InstigatingPlayer) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomManager">();
	}
	static class ARoomManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoomManager>();
	}
};
static_assert(alignof(ARoomManager) == 0x000008, "Wrong alignment on ARoomManager");
static_assert(sizeof(ARoomManager) == 0x0002C0, "Wrong size on ARoomManager");
static_assert(offsetof(ARoomManager, OnRoomUpgradeApproved) == 0x0002B0, "Member 'ARoomManager::OnRoomUpgradeApproved' has a wrong offset!");

// Class JP.MatchmakingStateVisualizer
// 0x0000 (0x0030 - 0x0030)
class UMatchmakingStateVisualizer final : public UWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MatchmakingStateVisualizer">();
	}
	static class UMatchmakingStateVisualizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMatchmakingStateVisualizer>();
	}
};
static_assert(alignof(UMatchmakingStateVisualizer) == 0x000008, "Wrong alignment on UMatchmakingStateVisualizer");
static_assert(sizeof(UMatchmakingStateVisualizer) == 0x000030, "Wrong size on UMatchmakingStateVisualizer");

// Class JP.MC_BaseDamage
// 0x0000 (0x0040 - 0x0040)
class UMC_BaseDamage final : public UGameplayModMagnitudeCalculation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MC_BaseDamage">();
	}
	static class UMC_BaseDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMC_BaseDamage>();
	}
};
static_assert(alignof(UMC_BaseDamage) == 0x000008, "Wrong alignment on UMC_BaseDamage");
static_assert(sizeof(UMC_BaseDamage) == 0x000040, "Wrong size on UMC_BaseDamage");

// Class JP.MMC_PlayerCombatDeployable
// 0x0000 (0x0040 - 0x0040)
class UMMC_PlayerCombatDeployable final : public UMMC_PlayerCombat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MMC_PlayerCombatDeployable">();
	}
	static class UMMC_PlayerCombatDeployable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMMC_PlayerCombatDeployable>();
	}
};
static_assert(alignof(UMMC_PlayerCombatDeployable) == 0x000008, "Wrong alignment on UMMC_PlayerCombatDeployable");
static_assert(sizeof(UMMC_PlayerCombatDeployable) == 0x000040, "Wrong size on UMMC_PlayerCombatDeployable");

// Class JP.MMC_PlayerCombatMelee
// 0x0000 (0x0040 - 0x0040)
class UMMC_PlayerCombatMelee final : public UMMC_PlayerCombat
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MMC_PlayerCombatMelee">();
	}
	static class UMMC_PlayerCombatMelee* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMMC_PlayerCombatMelee>();
	}
};
static_assert(alignof(UMMC_PlayerCombatMelee) == 0x000008, "Wrong alignment on UMMC_PlayerCombatMelee");
static_assert(sizeof(UMMC_PlayerCombatMelee) == 0x000040, "Wrong size on UMMC_PlayerCombatMelee");

// Class JP.MovementSpeedAttributeSetListener
// 0x0000 (0x0028 - 0x0028)
class IMovementSpeedAttributeSetListener final : public IInterface
{
public:
	void OnAimSpeedCoefficientChanged(float SprintSpeed);
	void OnAirControlChanged(float AirControl);
	void OnCrouchJumpVelocityCoefficientChanged(float CrouchJumpVelocityCoefficient);
	void OnCrouchSpeedCoefficientChanged(float CrouchSpeed);
	void OnJumpVelocityChanged(float JumpVelocity);
	void OnMovementSpeedChanged(float MovementSpeed);
	void OnSprintSpeedCoefficientChanged(float SprintSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovementSpeedAttributeSetListener">();
	}
	static class IMovementSpeedAttributeSetListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IMovementSpeedAttributeSetListener>();
	}
};
static_assert(alignof(IMovementSpeedAttributeSetListener) == 0x000008, "Wrong alignment on IMovementSpeedAttributeSetListener");
static_assert(sizeof(IMovementSpeedAttributeSetListener) == 0x000028, "Wrong size on IMovementSpeedAttributeSetListener");

// Class JP.MusicManagerComponent
// 0x0008 (0x00A8 - 0x00A0)
class UMusicManagerComponent : public UActorComponent
{
public:
	EMusicStates                                  CurrentMusicState;                                 // 0x00A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMusicStateChanged(EMusicStates NewState);
	void SetMusicState(EMusicStates NewState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MusicManagerComponent">();
	}
	static class UMusicManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMusicManagerComponent>();
	}
};
static_assert(alignof(UMusicManagerComponent) == 0x000008, "Wrong alignment on UMusicManagerComponent");
static_assert(sizeof(UMusicManagerComponent) == 0x0000A8, "Wrong size on UMusicManagerComponent");
static_assert(offsetof(UMusicManagerComponent, CurrentMusicState) == 0x0000A0, "Member 'UMusicManagerComponent::CurrentMusicState' has a wrong offset!");

// Class JP.NeighborDataGameInstanceSubsystem
// 0x0000 (0x0030 - 0x0030)
class UNeighborDataGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	static TSoftObjectPtr<class UNeighborDefinition> TryGetNeighborDefinition(const struct FGameplayTag& NeighborID, bool* Succeeded);
	static TSoftObjectPtr<class UNeighborMetaData> TryGetNeighborMetaData(const struct FGameplayTag& NeighborID, bool* Succeeded);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborDataGameInstanceSubsystem">();
	}
	static class UNeighborDataGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborDataGameInstanceSubsystem>();
	}
};
static_assert(alignof(UNeighborDataGameInstanceSubsystem) == 0x000008, "Wrong alignment on UNeighborDataGameInstanceSubsystem");
static_assert(sizeof(UNeighborDataGameInstanceSubsystem) == 0x000030, "Wrong size on UNeighborDataGameInstanceSubsystem");

// Class JP.NeighborFavoriteOrUnlockWidget
// 0x0060 (0x0340 - 0x02E0)
class UNeighborFavoriteOrUnlockWidget : public UUserWidget
{
public:
	class UCommonButtonBase*                      FavoriteButton;                                    // 0x02E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCommonButtonBase*                      UnlockButton;                                      // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidgetSwitcher*                        UnlockRequirementView;                             // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F8[0x48];                                     // 0x02F8(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyViewModel(const struct FOnlineStoreItemData& OnlineStoreItem);
	void ApplyViewModelEditorPreview(const struct FOnlineStoreItemData& OnlineStoreItem, const struct FGameplayTag& DefaultNeighborID);
	void HandleInsufficientFunds();
	void HandleUnlockCancel();
	void HandleUnlockError(const class FString& ErrorMessage);
	void HandleUnlockSuccess();
	void OnUnlockConfirm();
	void OnUnlockSuccess();
	void PushSpinnerModal();
	void PushUnlockConfirmationModal();
	void SetBattlePassInfo(const struct FOnlineStoreItemBattlePassRequirement& BattlePassInfo);
	void SetVirtualCurrencyInfo(const struct FOnlineStoreItemCost& ItemCost);

	const struct FOnlineStoreItemData GetCurrentNeighborAsStoreItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborFavoriteOrUnlockWidget">();
	}
	static class UNeighborFavoriteOrUnlockWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborFavoriteOrUnlockWidget>();
	}
};
static_assert(alignof(UNeighborFavoriteOrUnlockWidget) == 0x000008, "Wrong alignment on UNeighborFavoriteOrUnlockWidget");
static_assert(sizeof(UNeighborFavoriteOrUnlockWidget) == 0x000340, "Wrong size on UNeighborFavoriteOrUnlockWidget");
static_assert(offsetof(UNeighborFavoriteOrUnlockWidget, FavoriteButton) == 0x0002E0, "Member 'UNeighborFavoriteOrUnlockWidget::FavoriteButton' has a wrong offset!");
static_assert(offsetof(UNeighborFavoriteOrUnlockWidget, UnlockButton) == 0x0002E8, "Member 'UNeighborFavoriteOrUnlockWidget::UnlockButton' has a wrong offset!");
static_assert(offsetof(UNeighborFavoriteOrUnlockWidget, UnlockRequirementView) == 0x0002F0, "Member 'UNeighborFavoriteOrUnlockWidget::UnlockRequirementView' has a wrong offset!");

// Class JP.NeighborMetaData
// 0x0040 (0x0070 - 0x0030)
class UNeighborMetaData final : public UPrimaryDataAsset
{
public:
	class FText                                   Subtitle;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Personality;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Backstory;                                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Playstyle;                                         // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborMetaData">();
	}
	static class UNeighborMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborMetaData>();
	}
};
static_assert(alignof(UNeighborMetaData) == 0x000008, "Wrong alignment on UNeighborMetaData");
static_assert(sizeof(UNeighborMetaData) == 0x000070, "Wrong size on UNeighborMetaData");
static_assert(offsetof(UNeighborMetaData, Subtitle) == 0x000030, "Member 'UNeighborMetaData::Subtitle' has a wrong offset!");
static_assert(offsetof(UNeighborMetaData, Personality) == 0x000040, "Member 'UNeighborMetaData::Personality' has a wrong offset!");
static_assert(offsetof(UNeighborMetaData, Backstory) == 0x000050, "Member 'UNeighborMetaData::Backstory' has a wrong offset!");
static_assert(offsetof(UNeighborMetaData, Playstyle) == 0x000060, "Member 'UNeighborMetaData::Playstyle' has a wrong offset!");

// Class JP.NeighborPreviewActor
// 0x0000 (0x0290 - 0x0290)
class ANeighborPreviewActor : public AActor
{
public:
	void InitializeItem(const TSoftObjectPtr<class UItemSkinDefinition>& InDefinition);
	void PlayAnimationFromContext(const struct FGameplayTag& NeighborID, const struct FGameplayTag& SkinID, const struct FGameplayTag& AnimationContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborPreviewActor">();
	}
	static class ANeighborPreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ANeighborPreviewActor>();
	}
};
static_assert(alignof(ANeighborPreviewActor) == 0x000008, "Wrong alignment on ANeighborPreviewActor");
static_assert(sizeof(ANeighborPreviewActor) == 0x000290, "Wrong size on ANeighborPreviewActor");

// Class JP.NeighborSkinDefinition
// 0x00A0 (0x0128 - 0x0088)
class UNeighborSkinDefinition final : public UPlayerRewardDataAsset
{
public:
	TSoftClassPtr<class UClass>                   NeighborSkin;                                      // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PreviewActor;                                      // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, TSoftObjectPtr<class UAnimMontage>> AnimationOverrides;                                // 0x00D8(0x0050)(Edit, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static bool TryGetNeighborSkinDefinition(const struct FGameplayTag& NeighborSkinID, TSoftObjectPtr<class UNeighborSkinDefinition>* OutSoftNeighborSkinDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSkinDefinition">();
	}
	static class UNeighborSkinDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborSkinDefinition>();
	}
};
static_assert(alignof(UNeighborSkinDefinition) == 0x000008, "Wrong alignment on UNeighborSkinDefinition");
static_assert(sizeof(UNeighborSkinDefinition) == 0x000128, "Wrong size on UNeighborSkinDefinition");
static_assert(offsetof(UNeighborSkinDefinition, NeighborSkin) == 0x000088, "Member 'UNeighborSkinDefinition::NeighborSkin' has a wrong offset!");
static_assert(offsetof(UNeighborSkinDefinition, PreviewActor) == 0x0000B0, "Member 'UNeighborSkinDefinition::PreviewActor' has a wrong offset!");
static_assert(offsetof(UNeighborSkinDefinition, AnimationOverrides) == 0x0000D8, "Member 'UNeighborSkinDefinition::AnimationOverrides' has a wrong offset!");

// Class JP.NeighborSpecialAbilityDefinition
// 0x0058 (0x0088 - 0x0030)
class UNeighborSpecialAbilityDefinition final : public UPrimaryDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0050(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UGameplaySet>>    GameplaySets;                                      // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSpecialAbilityDefinition">();
	}
	static class UNeighborSpecialAbilityDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNeighborSpecialAbilityDefinition>();
	}
};
static_assert(alignof(UNeighborSpecialAbilityDefinition) == 0x000008, "Wrong alignment on UNeighborSpecialAbilityDefinition");
static_assert(sizeof(UNeighborSpecialAbilityDefinition) == 0x000088, "Wrong size on UNeighborSpecialAbilityDefinition");
static_assert(offsetof(UNeighborSpecialAbilityDefinition, Name_0) == 0x000030, "Member 'UNeighborSpecialAbilityDefinition::Name_0' has a wrong offset!");
static_assert(offsetof(UNeighborSpecialAbilityDefinition, Description) == 0x000040, "Member 'UNeighborSpecialAbilityDefinition::Description' has a wrong offset!");
static_assert(offsetof(UNeighborSpecialAbilityDefinition, Icon) == 0x000050, "Member 'UNeighborSpecialAbilityDefinition::Icon' has a wrong offset!");
static_assert(offsetof(UNeighborSpecialAbilityDefinition, GameplaySets) == 0x000078, "Member 'UNeighborSpecialAbilityDefinition::GameplaySets' has a wrong offset!");

// Class JP.NeighborSpecialAbilityInterface
// 0x0000 (0x0028 - 0x0028)
class INeighborSpecialAbilityInterface final : public IInterface
{
public:
	void OnSpecialAbilityGranted();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSpecialAbilityInterface">();
	}
	static class INeighborSpecialAbilityInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<INeighborSpecialAbilityInterface>();
	}
};
static_assert(alignof(INeighborSpecialAbilityInterface) == 0x000008, "Wrong alignment on INeighborSpecialAbilityInterface");
static_assert(sizeof(INeighborSpecialAbilityInterface) == 0x000028, "Wrong size on INeighborSpecialAbilityInterface");

// Class JP.NeighborSpecialAbilityWidget
// 0x0000 (0x0028 - 0x0028)
class INeighborSpecialAbilityWidget final : public IInterface
{
public:
	void SetSourceAbility(class UGameplayAbilityIW* Source);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NeighborSpecialAbilityWidget">();
	}
	static class INeighborSpecialAbilityWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<INeighborSpecialAbilityWidget>();
	}
};
static_assert(alignof(INeighborSpecialAbilityWidget) == 0x000008, "Wrong alignment on INeighborSpecialAbilityWidget");
static_assert(sizeof(INeighborSpecialAbilityWidget) == 0x000028, "Wrong size on INeighborSpecialAbilityWidget");

// Class JP.NetworkFailureDescriptorProvider
// 0x0000 (0x0028 - 0x0028)
class UNetworkFailureDescriptorProvider final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"NetworkFailureDescriptorProvider">();
	}
	static class UNetworkFailureDescriptorProvider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UNetworkFailureDescriptorProvider>();
	}
};
static_assert(alignof(UNetworkFailureDescriptorProvider) == 0x000008, "Wrong alignment on UNetworkFailureDescriptorProvider");
static_assert(sizeof(UNetworkFailureDescriptorProvider) == 0x000028, "Wrong size on UNetworkFailureDescriptorProvider");

// Class JP.ObjectiveAction_Description
// 0x0038 (0x0060 - 0x0028)
class UObjectiveAction_Description final : public UObjectiveAction
{
public:
	class FText                                   ObjectiveName;                                     // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              TooltipImage;                                      // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveAction_Description">();
	}
	static class UObjectiveAction_Description* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveAction_Description>();
	}
};
static_assert(alignof(UObjectiveAction_Description) == 0x000008, "Wrong alignment on UObjectiveAction_Description");
static_assert(sizeof(UObjectiveAction_Description) == 0x000060, "Wrong size on UObjectiveAction_Description");
static_assert(offsetof(UObjectiveAction_Description, ObjectiveName) == 0x000028, "Member 'UObjectiveAction_Description::ObjectiveName' has a wrong offset!");
static_assert(offsetof(UObjectiveAction_Description, TooltipImage) == 0x000038, "Member 'UObjectiveAction_Description::TooltipImage' has a wrong offset!");

// Class JP.ObjectiveAction_ItemName
// 0x0008 (0x0030 - 0x0028)
class UObjectiveAction_ItemName final : public UObjectiveAction
{
public:
	class FName                                   ItemName;                                          // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveAction_ItemName">();
	}
	static class UObjectiveAction_ItemName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveAction_ItemName>();
	}
};
static_assert(alignof(UObjectiveAction_ItemName) == 0x000008, "Wrong alignment on UObjectiveAction_ItemName");
static_assert(sizeof(UObjectiveAction_ItemName) == 0x000030, "Wrong size on UObjectiveAction_ItemName");
static_assert(offsetof(UObjectiveAction_ItemName, ItemName) == 0x000028, "Member 'UObjectiveAction_ItemName::ItemName' has a wrong offset!");

// Class JP.ObjectiveAction_SetupVisualsForTutorialObjective
// 0x0000 (0x0028 - 0x0028)
class UObjectiveAction_SetupVisualsForTutorialObjective final : public UObjectiveAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveAction_SetupVisualsForTutorialObjective">();
	}
	static class UObjectiveAction_SetupVisualsForTutorialObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveAction_SetupVisualsForTutorialObjective>();
	}
};
static_assert(alignof(UObjectiveAction_SetupVisualsForTutorialObjective) == 0x000008, "Wrong alignment on UObjectiveAction_SetupVisualsForTutorialObjective");
static_assert(sizeof(UObjectiveAction_SetupVisualsForTutorialObjective) == 0x000028, "Wrong size on UObjectiveAction_SetupVisualsForTutorialObjective");

// Class JP.ObjectiveCollection
// 0x0018 (0x0048 - 0x0030)
class UObjectiveCollection final : public UDataAsset
{
public:
	TArray<class UDataAsset*>                     Objectives;                                        // 0x0030(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         ObjectivesPerSpawn;                                // 0x0040(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UObjectiveDefinition*> GetObjectives();
	uint8 GetObjectivesPerSpawn();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveCollection">();
	}
	static class UObjectiveCollection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveCollection>();
	}
};
static_assert(alignof(UObjectiveCollection) == 0x000008, "Wrong alignment on UObjectiveCollection");
static_assert(sizeof(UObjectiveCollection) == 0x000048, "Wrong size on UObjectiveCollection");
static_assert(offsetof(UObjectiveCollection, Objectives) == 0x000030, "Member 'UObjectiveCollection::Objectives' has a wrong offset!");
static_assert(offsetof(UObjectiveCollection, ObjectivesPerSpawn) == 0x000040, "Member 'UObjectiveCollection::ObjectivesPerSpawn' has a wrong offset!");

// Class JP.ObjectiveInstance
// 0x0058 (0x0080 - 0x0028)
class UObjectiveInstance final : public UObject
{
public:
	class UObjectiveDefinition*                   ObjectiveDefinition;                               // 0x0028(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateJP_Match*                   OwningPlayerState;                                 // 0x0038(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectiveManagerComponent*             ObjectivesComponent;                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class ASubObjective*>                  SubObjectives;                                     // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	EObjectiveState                               CurrentState;                                      // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x27];                                      // 0x0059(0x0027)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ReceiveObjectiveEndMessageGameplayEvent(const struct FGameplayTag& InChannel, const struct FObjectiveGameplayMessage& InMessage);
	void ReceiveObjectiveEndMessageTimer(const struct FGameplayTag& InChannel, const struct FObjectiveEndMessage& InMessage);
	void ReceiveSubObjectiveCompleted(class ASubObjective* SubObjective);
	void RegisterEndTimes();
	void SubObjectiveCompleted(class APlayerStateJP* Player);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveInstance">();
	}
	static class UObjectiveInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveInstance>();
	}
};
static_assert(alignof(UObjectiveInstance) == 0x000008, "Wrong alignment on UObjectiveInstance");
static_assert(sizeof(UObjectiveInstance) == 0x000080, "Wrong size on UObjectiveInstance");
static_assert(offsetof(UObjectiveInstance, ObjectiveDefinition) == 0x000028, "Member 'UObjectiveInstance::ObjectiveDefinition' has a wrong offset!");
static_assert(offsetof(UObjectiveInstance, OwningPlayerState) == 0x000038, "Member 'UObjectiveInstance::OwningPlayerState' has a wrong offset!");
static_assert(offsetof(UObjectiveInstance, ObjectivesComponent) == 0x000040, "Member 'UObjectiveInstance::ObjectivesComponent' has a wrong offset!");
static_assert(offsetof(UObjectiveInstance, SubObjectives) == 0x000048, "Member 'UObjectiveInstance::SubObjectives' has a wrong offset!");
static_assert(offsetof(UObjectiveInstance, CurrentState) == 0x000058, "Member 'UObjectiveInstance::CurrentState' has a wrong offset!");

// Class JP.ObjectiveManagerTutorialComponent
// 0x0000 (0x00B0 - 0x00B0)
class UObjectiveManagerTutorialComponent final : public UObjectiveManagerComponent
{
public:
	void CreateTutorialObjectiveInstanceForThisObjectiveComponent(class UObjectiveDefinition* ObjectiveDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveManagerTutorialComponent">();
	}
	static class UObjectiveManagerTutorialComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveManagerTutorialComponent>();
	}
};
static_assert(alignof(UObjectiveManagerTutorialComponent) == 0x000008, "Wrong alignment on UObjectiveManagerTutorialComponent");
static_assert(sizeof(UObjectiveManagerTutorialComponent) == 0x0000B0, "Wrong size on UObjectiveManagerTutorialComponent");

// Class JP.ObjectiveReward_ItemDelivery
// 0x0008 (0x0030 - 0x0028)
class UObjectiveReward_ItemDelivery final : public UObjectiveRewardBase
{
public:
	class UDataAsset*                             ActorToDeliver;                                    // 0x0028(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveReward_ItemDelivery">();
	}
	static class UObjectiveReward_ItemDelivery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveReward_ItemDelivery>();
	}
};
static_assert(alignof(UObjectiveReward_ItemDelivery) == 0x000008, "Wrong alignment on UObjectiveReward_ItemDelivery");
static_assert(sizeof(UObjectiveReward_ItemDelivery) == 0x000030, "Wrong size on UObjectiveReward_ItemDelivery");
static_assert(offsetof(UObjectiveReward_ItemDelivery, ActorToDeliver) == 0x000028, "Member 'UObjectiveReward_ItemDelivery::ActorToDeliver' has a wrong offset!");

// Class JP.ObjectivesComponent
// 0x0030 (0x00D0 - 0x00A0)
class UObjectivesComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnObjectiveAdded;                                  // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UObjectiveBase*>                 ActiveObjectives;                                  // 0x00B0(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TArray<TSoftObjectPtr<class ATaskSpawner>>    TaskSpawners;                                      // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	static TArray<class UObjectiveBase*> CreateObjective(class UObject* WorldContextObject, const class UObjectiveBase* ObjectiveTemplate);

	void OnRep_ActiveObjectives();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectivesComponent">();
	}
	static class UObjectivesComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectivesComponent>();
	}
};
static_assert(alignof(UObjectivesComponent) == 0x000008, "Wrong alignment on UObjectivesComponent");
static_assert(sizeof(UObjectivesComponent) == 0x0000D0, "Wrong size on UObjectivesComponent");
static_assert(offsetof(UObjectivesComponent, OnObjectiveAdded) == 0x0000A0, "Member 'UObjectivesComponent::OnObjectiveAdded' has a wrong offset!");
static_assert(offsetof(UObjectivesComponent, ActiveObjectives) == 0x0000B0, "Member 'UObjectivesComponent::ActiveObjectives' has a wrong offset!");
static_assert(offsetof(UObjectivesComponent, TaskSpawners) == 0x0000C0, "Member 'UObjectivesComponent::TaskSpawners' has a wrong offset!");

// Class JP.ObjectiveWidget
// 0x0000 (0x02E0 - 0x02E0)
class UObjectiveWidget : public UUserWidget
{
public:
	void CreateObjectiveWidget(const struct FObjectiveAndOwningPlayer& Objective);
	void CreateSubObjectiveWidget(class ASubObjective* SubObjective);
	void ObjectiveFinished(const struct FObjectiveAndOwningPlayer& Objective);
	void RegenerateObjectiveTrackerWidgets(const TArray<struct FObjectiveTracker>& ObjectiveTrackers);
	void RemoveObjectiveWidget(const struct FObjectiveAndOwningPlayer& Objective);
	void RemoveSubObjectiveWidget(class ASubObjective* SubObjective);
	void UpdateSubObjectiveWidget(class ASubObjective* SubObjective);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectiveWidget">();
	}
	static class UObjectiveWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectiveWidget>();
	}
};
static_assert(alignof(UObjectiveWidget) == 0x000008, "Wrong alignment on UObjectiveWidget");
static_assert(sizeof(UObjectiveWidget) == 0x0002E0, "Wrong size on UObjectiveWidget");

// Class JP.ObjectPoolingSubsystem
// 0x0050 (0x0080 - 0x0030)
class UObjectPoolingSubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x50];                                      // 0x0030(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class APooledActor* GetInactiveObjectOfClass(TSubclassOf<class APooledActor> Class_0, class APawn* Instigator);
	void PooledObjectDestroyed(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ObjectPoolingSubsystem">();
	}
	static class UObjectPoolingSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UObjectPoolingSubsystem>();
	}
};
static_assert(alignof(UObjectPoolingSubsystem) == 0x000008, "Wrong alignment on UObjectPoolingSubsystem");
static_assert(sizeof(UObjectPoolingSubsystem) == 0x000080, "Wrong size on UObjectPoolingSubsystem");

// Class JP.OnlineCurrencyBundleDataAsset
// 0x0040 (0x0078 - 0x0038)
class UOnlineCurrencyBundleDataAsset final : public UTagLookupPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateColor                            Color;                                             // 0x0060(0x0014)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool TryGetCurrencyBundleDataAsset(const struct FGameplayTag& CurrencyBundleDataAssetID, TSoftObjectPtr<class UOnlineCurrencyBundleDataAsset>* OutSoftCurrencyBundleDataAsset);

	class FText GetDiscountDescription(const class FText& Format, const int32 OwnPrice, const int32 OwnAmount, const int32 PriceToCompare, const int32 AmountToCompare) const;
	class FText GetPriceTag(int32 Price, const class FString& CurrencyCode) const;
	class FString GetTitle(const int32 Amount) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineCurrencyBundleDataAsset">();
	}
	static class UOnlineCurrencyBundleDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineCurrencyBundleDataAsset>();
	}
};
static_assert(alignof(UOnlineCurrencyBundleDataAsset) == 0x000008, "Wrong alignment on UOnlineCurrencyBundleDataAsset");
static_assert(sizeof(UOnlineCurrencyBundleDataAsset) == 0x000078, "Wrong size on UOnlineCurrencyBundleDataAsset");
static_assert(offsetof(UOnlineCurrencyBundleDataAsset, Icon) == 0x000038, "Member 'UOnlineCurrencyBundleDataAsset::Icon' has a wrong offset!");
static_assert(offsetof(UOnlineCurrencyBundleDataAsset, Color) == 0x000060, "Member 'UOnlineCurrencyBundleDataAsset::Color' has a wrong offset!");

// Class JP.OnlineServicesBlueprintFunctionLibraryJP
// 0x0000 (0x0028 - 0x0028)
class UOnlineServicesBlueprintFunctionLibraryJP final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineServicesBlueprintFunctionLibraryJP">();
	}
	static class UOnlineServicesBlueprintFunctionLibraryJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineServicesBlueprintFunctionLibraryJP>();
	}
};
static_assert(alignof(UOnlineServicesBlueprintFunctionLibraryJP) == 0x000008, "Wrong alignment on UOnlineServicesBlueprintFunctionLibraryJP");
static_assert(sizeof(UOnlineServicesBlueprintFunctionLibraryJP) == 0x000028, "Wrong size on UOnlineServicesBlueprintFunctionLibraryJP");

// Class JP.OnlineServicesFriend
// 0x0008 (0x0078 - 0x0070)
class UOnlineServicesFriend final : public UOnlineServicesUserBase
{
public:
	EOnlineServicesFriendStatus                   Status;                                            // 0x0070(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class UOnlineServicesFriend*> GetFriends(class UObject* WorldContextObject, int32 Page, int32 EntriesPerPage);
	static int32 GetNumFriendsPlayingJP(class UObject* WorldContextObject);
	static int32 GetNumOnlineFriends(class UObject* WorldContextObject);
	static int32 GetTotalFriends(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineServicesFriend">();
	}
	static class UOnlineServicesFriend* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineServicesFriend>();
	}
};
static_assert(alignof(UOnlineServicesFriend) == 0x000008, "Wrong alignment on UOnlineServicesFriend");
static_assert(sizeof(UOnlineServicesFriend) == 0x000078, "Wrong size on UOnlineServicesFriend");
static_assert(offsetof(UOnlineServicesFriend, Status) == 0x000070, "Member 'UOnlineServicesFriend::Status' has a wrong offset!");

// Class JP.OnlineServicesPIEAutoLogin
// 0x0000 (0x0290 - 0x0290)
class AOnlineServicesPIEAutoLogin final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineServicesPIEAutoLogin">();
	}
	static class AOnlineServicesPIEAutoLogin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AOnlineServicesPIEAutoLogin>();
	}
};
static_assert(alignof(AOnlineServicesPIEAutoLogin) == 0x000008, "Wrong alignment on AOnlineServicesPIEAutoLogin");
static_assert(sizeof(AOnlineServicesPIEAutoLogin) == 0x000290, "Wrong size on AOnlineServicesPIEAutoLogin");

// Class JP.OnlineServicesRecentPlayer
// 0x0008 (0x0078 - 0x0070)
class UOnlineServicesRecentPlayer final : public UOnlineServicesUserBase
{
public:
	uint8                                         Pad_70[0x8];                                       // 0x0070(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineServicesRecentPlayer">();
	}
	static class UOnlineServicesRecentPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineServicesRecentPlayer>();
	}
};
static_assert(alignof(UOnlineServicesRecentPlayer) == 0x000008, "Wrong alignment on UOnlineServicesRecentPlayer");
static_assert(sizeof(UOnlineServicesRecentPlayer) == 0x000078, "Wrong size on UOnlineServicesRecentPlayer");

// Class JP.OnlineSessionJP
// 0x0000 (0x0028 - 0x0028)
class UOnlineSessionJP final : public UOnlineSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineSessionJP">();
	}
	static class UOnlineSessionJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineSessionJP>();
	}
};
static_assert(alignof(UOnlineSessionJP) == 0x000008, "Wrong alignment on UOnlineSessionJP");
static_assert(sizeof(UOnlineSessionJP) == 0x000028, "Wrong size on UOnlineSessionJP");

// Class JP.OnlineStoreGameInstanceSubsystem
// 0x0188 (0x01B8 - 0x0030)
class UOnlineStoreGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x60];                                      // 0x0030(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnCurrencyUpdated;                                 // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A0[0xA0];                                      // 0x00A0(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryItemsRequest*                 InventoryItemsRequest;                             // 0x0140(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBattlePassItemsRequest*                BattlePassItemsRequest;                            // 0x0148(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<struct FGameplayTag, class UNeighborItemsRequest*> NeighborItemsRequests;                             // 0x0150(0x0050)(NativeAccessSpecifierPrivate)
	class UPlayerItemsRequest*                    NeighborsRequest;                                  // 0x01A0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPlayerItemsRequest*                    HousesRequest;                                     // 0x01A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UItemUnlockRequest*                     UnlockRequest;                                     // 0x01B0(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AddCurrencyAmount(const struct FGameplayTag& CurrencyTag, const int32 AmountToAdd);
	int32 GetCurrencyAmount(const struct FGameplayTag& CurrencyTag);
	void GetHouses(const TDelegate<void(TArray<struct FOnlineStoreItemData>& OwnedItems, TArray<struct FOnlineStoreItemData>& UnownedItems)>& OnGetPlayerItems);
	void GetNeighborItems(const struct FGameplayTag& NeighborID, const TDelegate<void(struct FGameplayTag& NeighborID, struct FCosmeticsOnlineServicesDataContainer& RewardsContainer)>& OnGetNeighborItems);
	void GetNeighbors(const TDelegate<void(TArray<struct FOnlineStoreItemData>& OwnedItems, TArray<struct FOnlineStoreItemData>& UnownedItems)>& OnGetPlayerItems);
	bool IsCurrencySupported(const struct FGameplayTag& CurrencyTag);
	void OnNeighborsInitialized(const TArray<struct FOnlineStoreItemData>& OwnedItems, const TArray<struct FOnlineStoreItemData>& UnownedItems);
	void RequestNeighborItems(const struct FGameplayTag& NeighborID);
	void SetCurrencyAmount(const struct FGameplayTag& CurrencyTag, const int32 Amount);
	void SubtractCurrencyAmount(const struct FGameplayTag& CurrencyTag, const int32 AmountToSubtract);
	bool TryGetStoreItemDataForNeighborID(const struct FGameplayTag& NeighborID, struct FOnlineStoreItemData* OutStoreItemData);
	bool TryUnlockLocalBattlePassItem(const struct FGameplayTag& AssetID, const struct FGameplayTag& AssociatedNeighborID);
	void UnlockHouse(const struct FOnlineStoreItemData& ItemData, const TDelegate<void()>& OnSuccess, const TDelegate<void(const class FString& ErrorMessage)>& OnError);
	void UnlockNeighbor(const struct FOnlineStoreItemData& ItemData, const TDelegate<void()>& OnSuccess, const TDelegate<void(const class FString& ErrorMessage)>& OnError);
	void UnlockNeighborItem(const struct FGameplayTag& NeighborID, const struct FOnlineStoreItemData& ItemData, const TDelegate<void()>& OnSuccess, const TDelegate<void(const class FString& ErrorMessage)>& OnError);

	TArray<struct FOnlineStoreItemData> GetNeighborsFilteredByActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"OnlineStoreGameInstanceSubsystem">();
	}
	static class UOnlineStoreGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UOnlineStoreGameInstanceSubsystem>();
	}
};
static_assert(alignof(UOnlineStoreGameInstanceSubsystem) == 0x000008, "Wrong alignment on UOnlineStoreGameInstanceSubsystem");
static_assert(sizeof(UOnlineStoreGameInstanceSubsystem) == 0x0001B8, "Wrong size on UOnlineStoreGameInstanceSubsystem");
static_assert(offsetof(UOnlineStoreGameInstanceSubsystem, OnCurrencyUpdated) == 0x000090, "Member 'UOnlineStoreGameInstanceSubsystem::OnCurrencyUpdated' has a wrong offset!");
static_assert(offsetof(UOnlineStoreGameInstanceSubsystem, InventoryItemsRequest) == 0x000140, "Member 'UOnlineStoreGameInstanceSubsystem::InventoryItemsRequest' has a wrong offset!");
static_assert(offsetof(UOnlineStoreGameInstanceSubsystem, BattlePassItemsRequest) == 0x000148, "Member 'UOnlineStoreGameInstanceSubsystem::BattlePassItemsRequest' has a wrong offset!");
static_assert(offsetof(UOnlineStoreGameInstanceSubsystem, NeighborItemsRequests) == 0x000150, "Member 'UOnlineStoreGameInstanceSubsystem::NeighborItemsRequests' has a wrong offset!");
static_assert(offsetof(UOnlineStoreGameInstanceSubsystem, NeighborsRequest) == 0x0001A0, "Member 'UOnlineStoreGameInstanceSubsystem::NeighborsRequest' has a wrong offset!");
static_assert(offsetof(UOnlineStoreGameInstanceSubsystem, HousesRequest) == 0x0001A8, "Member 'UOnlineStoreGameInstanceSubsystem::HousesRequest' has a wrong offset!");
static_assert(offsetof(UOnlineStoreGameInstanceSubsystem, UnlockRequest) == 0x0001B0, "Member 'UOnlineStoreGameInstanceSubsystem::UnlockRequest' has a wrong offset!");

// Class JP.PartyMemberCustomizationActor
// 0x00C0 (0x0350 - 0x0290)
class APartyMemberCustomizationActor final : public AActor
{
public:
	TWeakObjectPtr<class ALobbyTeamPlayerWorldSlotActor> LocalSlot;                                         // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class ALobbyTeamPlayerWorldSlotActor>> RemoteSlots;                                       // 0x0298(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	class UPartyOnlineServiceHandler*             PartyPtr;                                          // 0x02A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2B0[0xA0];                                     // 0x02B0(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PartyMemberCustomizationActor">();
	}
	static class APartyMemberCustomizationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APartyMemberCustomizationActor>();
	}
};
static_assert(alignof(APartyMemberCustomizationActor) == 0x000008, "Wrong alignment on APartyMemberCustomizationActor");
static_assert(sizeof(APartyMemberCustomizationActor) == 0x000350, "Wrong size on APartyMemberCustomizationActor");
static_assert(offsetof(APartyMemberCustomizationActor, LocalSlot) == 0x000290, "Member 'APartyMemberCustomizationActor::LocalSlot' has a wrong offset!");
static_assert(offsetof(APartyMemberCustomizationActor, RemoteSlots) == 0x000298, "Member 'APartyMemberCustomizationActor::RemoteSlots' has a wrong offset!");
static_assert(offsetof(APartyMemberCustomizationActor, PartyPtr) == 0x0002A8, "Member 'APartyMemberCustomizationActor::PartyPtr' has a wrong offset!");

// Class JP.PerkAction_ModifyDamageBasedOnLocation
// 0x0010 (0x0038 - 0x0028)
class UPerkAction_ModifyDamageBasedOnLocation final : public UPerkAction
{
public:
	float                                         DamageMultiplier;                                  // 0x0028(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           AssociatedTag;                                     // 0x002C(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkAction_ModifyDamageBasedOnLocation">();
	}
	static class UPerkAction_ModifyDamageBasedOnLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkAction_ModifyDamageBasedOnLocation>();
	}
};
static_assert(alignof(UPerkAction_ModifyDamageBasedOnLocation) == 0x000008, "Wrong alignment on UPerkAction_ModifyDamageBasedOnLocation");
static_assert(sizeof(UPerkAction_ModifyDamageBasedOnLocation) == 0x000038, "Wrong size on UPerkAction_ModifyDamageBasedOnLocation");
static_assert(offsetof(UPerkAction_ModifyDamageBasedOnLocation, DamageMultiplier) == 0x000028, "Member 'UPerkAction_ModifyDamageBasedOnLocation::DamageMultiplier' has a wrong offset!");
static_assert(offsetof(UPerkAction_ModifyDamageBasedOnLocation, AssociatedTag) == 0x00002C, "Member 'UPerkAction_ModifyDamageBasedOnLocation::AssociatedTag' has a wrong offset!");

// Class JP.PerkManagerComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPerkManagerComponent : public UActorComponent
{
public:
	static class UPerkManagerComponent* GetPerkManagerComponentFromController(class AController* Target);
	static class UPerkManagerComponent* GetPerkManagerComponentFromPawn(class APawn* Target);
	static class UPerkManagerComponent* GetPerkManagerComponentFromPlayerState(class APlayerState* Target);

	TArray<class UPerkAction*> K2_GetAllActionsOfType(TSubclassOf<class UPerkAction> ActionType);
	class UPerkAction* K2_GetFirstActionOfType(TSubclassOf<class UPerkAction> ActionType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PerkManagerComponent">();
	}
	static class UPerkManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPerkManagerComponent>();
	}
};
static_assert(alignof(UPerkManagerComponent) == 0x000008, "Wrong alignment on UPerkManagerComponent");
static_assert(sizeof(UPerkManagerComponent) == 0x0000A0, "Wrong size on UPerkManagerComponent");

// Class JP.PingableComponent
// 0x0090 (0x02C0 - 0x0230)
class UPingableComponent : public USceneComponent
{
public:
	struct FPingData                              PingData;                                          // 0x0230(0x0090)(Edit, BlueprintVisible, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	struct FPingData GetPingDataBP(class APlayerControllerJP_Match* InPC);

	struct FPingData GetPingData(class APlayerControllerJP_Match* InPC) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingableComponent">();
	}
	static class UPingableComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPingableComponent>();
	}
};
static_assert(alignof(UPingableComponent) == 0x000010, "Wrong alignment on UPingableComponent");
static_assert(sizeof(UPingableComponent) == 0x0002C0, "Wrong size on UPingableComponent");
static_assert(offsetof(UPingableComponent, PingData) == 0x000230, "Member 'UPingableComponent::PingData' has a wrong offset!");

// Class JP.PingVisualizationActor
// 0x0090 (0x0320 - 0x0290)
class APingVisualizationActor final : public AActor
{
public:
	struct FPingData                              PingData;                                          // 0x0290(0x0090)(BlueprintVisible, Net, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PingVisualizationActor">();
	}
	static class APingVisualizationActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APingVisualizationActor>();
	}
};
static_assert(alignof(APingVisualizationActor) == 0x000008, "Wrong alignment on APingVisualizationActor");
static_assert(sizeof(APingVisualizationActor) == 0x000320, "Wrong size on APingVisualizationActor");
static_assert(offsetof(APingVisualizationActor, PingData) == 0x000290, "Member 'APingVisualizationActor::PingData' has a wrong offset!");

// Class JP.PlayerItemsRequest
// 0x0088 (0x00B0 - 0x0028)
class UPlayerItemsRequest final : public UObject
{
public:
	uint8                                         Pad_28[0x80];                                      // 0x0028(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class USharedEconomyOnlineServiceHandler*     EconomyHandler;                                    // 0x00A8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerItemsRequest">();
	}
	static class UPlayerItemsRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerItemsRequest>();
	}
};
static_assert(alignof(UPlayerItemsRequest) == 0x000008, "Wrong alignment on UPlayerItemsRequest");
static_assert(sizeof(UPlayerItemsRequest) == 0x0000B0, "Wrong size on UPlayerItemsRequest");
static_assert(offsetof(UPlayerItemsRequest, EconomyHandler) == 0x0000A8, "Member 'UPlayerItemsRequest::EconomyHandler' has a wrong offset!");

// Class JP.PlayerOnlineSummary
// 0x0058 (0x00B8 - 0x0060)
class UPlayerOnlineSummary final : public UIWAnalyticsEvent
{
public:
	struct FPlayerOnlineSummaryData               PlayerOnlineSummary;                               // 0x0060(0x0058)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerOnlineSummary">();
	}
	static class UPlayerOnlineSummary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerOnlineSummary>();
	}
};
static_assert(alignof(UPlayerOnlineSummary) == 0x000008, "Wrong alignment on UPlayerOnlineSummary");
static_assert(sizeof(UPlayerOnlineSummary) == 0x0000B8, "Wrong size on UPlayerOnlineSummary");
static_assert(offsetof(UPlayerOnlineSummary, PlayerOnlineSummary) == 0x000060, "Member 'UPlayerOnlineSummary::PlayerOnlineSummary' has a wrong offset!");

// Class JP.PlayerStateJP_Lobby
// 0x0038 (0x06D8 - 0x06A0)
class APlayerStateJP_Lobby : public APlayerStateJP
{
public:
	FMulticastInlineDelegateProperty_             OnReadyAndWaitingChanged;                          // 0x06A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnIsHostChanged;                                   // 0x06B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_6C0[0x8];                                      // 0x06C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPlayerJoinHandShakePlayerStateComponent* PlayerJoinHandShakeComponent;                      // 0x06C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          ReadyAndWaiting;                                   // 0x06D0(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsHost;                                            // 0x06D1(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D2[0x6];                                      // 0x06D2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnRep_IsHost();
	void OnRep_ReadyAndWaiting();

	bool GetIsHost() const;
	bool GetReadyAndWaiting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateJP_Lobby">();
	}
	static class APlayerStateJP_Lobby* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStateJP_Lobby>();
	}
};
static_assert(alignof(APlayerStateJP_Lobby) == 0x000008, "Wrong alignment on APlayerStateJP_Lobby");
static_assert(sizeof(APlayerStateJP_Lobby) == 0x0006D8, "Wrong size on APlayerStateJP_Lobby");
static_assert(offsetof(APlayerStateJP_Lobby, OnReadyAndWaitingChanged) == 0x0006A0, "Member 'APlayerStateJP_Lobby::OnReadyAndWaitingChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Lobby, OnIsHostChanged) == 0x0006B0, "Member 'APlayerStateJP_Lobby::OnIsHostChanged' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Lobby, PlayerJoinHandShakeComponent) == 0x0006C8, "Member 'APlayerStateJP_Lobby::PlayerJoinHandShakeComponent' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Lobby, ReadyAndWaiting) == 0x0006D0, "Member 'APlayerStateJP_Lobby::ReadyAndWaiting' has a wrong offset!");
static_assert(offsetof(APlayerStateJP_Lobby, IsHost) == 0x0006D1, "Member 'APlayerStateJP_Lobby::IsHost' has a wrong offset!");

// Class JP.PlayerStateJP_Tutorial
// 0x0030 (0x0888 - 0x0858)
class APlayerStateJP_Tutorial final : public APlayerStateJP_Match
{
public:
	uint8                                         Pad_858[0x30];                                     // 0x0858(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetNeighborLoadoutOverride(const struct FNeighborLoadout& LoadoutOverride);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateJP_Tutorial">();
	}
	static class APlayerStateJP_Tutorial* GetDefaultObj()
	{
		return GetDefaultObjImpl<APlayerStateJP_Tutorial>();
	}
};
static_assert(alignof(APlayerStateJP_Tutorial) == 0x000008, "Wrong alignment on APlayerStateJP_Tutorial");
static_assert(sizeof(APlayerStateJP_Tutorial) == 0x000888, "Wrong size on APlayerStateJP_Tutorial");

// Class JP.PooledActor
// 0x0008 (0x0298 - 0x0290)
class APooledActor : public AActor
{
public:
	uint8                                         Pad_290[0x8];                                      // 0x0290(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallPooledBeginPlay();
	void DeactivatePooledActor();
	void PooledBeginPlay();

	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PooledActor">();
	}
	static class APooledActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<APooledActor>();
	}
};
static_assert(alignof(APooledActor) == 0x000008, "Wrong alignment on APooledActor");
static_assert(sizeof(APooledActor) == 0x000298, "Wrong size on APooledActor");

// Class JP.PreconditionSubObjectiveCompleted
// 0x0020 (0x0048 - 0x0028)
class UPreconditionSubObjectiveCompleted final : public UPreconditionBase
{
public:
	struct FGameplayTagContainer                  RequiredSubObjectives;                             // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreconditionSubObjectiveCompleted">();
	}
	static class UPreconditionSubObjectiveCompleted* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreconditionSubObjectiveCompleted>();
	}
};
static_assert(alignof(UPreconditionSubObjectiveCompleted) == 0x000008, "Wrong alignment on UPreconditionSubObjectiveCompleted");
static_assert(sizeof(UPreconditionSubObjectiveCompleted) == 0x000048, "Wrong size on UPreconditionSubObjectiveCompleted");
static_assert(offsetof(UPreconditionSubObjectiveCompleted, RequiredSubObjectives) == 0x000028, "Member 'UPreconditionSubObjectiveCompleted::RequiredSubObjectives' has a wrong offset!");

// Class JP.PreLobbyServerBrowserEntry
// 0x0010 (0x02F0 - 0x02E0)
class UPreLobbyServerBrowserEntry : public UUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnClicked;                                         // 0x02E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintCallable, NativeAccessSpecifierPublic)

public:
	void ApplyViewModel(const struct FPreLobbyServerBrowserEntryViewModel& InViewModel);
	void OnDeselected();
	void OnSelected();

	struct FPreLobbyServerBrowserEntryViewModel GetViewModel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreLobbyServerBrowserEntry">();
	}
	static class UPreLobbyServerBrowserEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreLobbyServerBrowserEntry>();
	}
};
static_assert(alignof(UPreLobbyServerBrowserEntry) == 0x000008, "Wrong alignment on UPreLobbyServerBrowserEntry");
static_assert(sizeof(UPreLobbyServerBrowserEntry) == 0x0002F0, "Wrong size on UPreLobbyServerBrowserEntry");
static_assert(offsetof(UPreLobbyServerBrowserEntry, OnClicked) == 0x0002E0, "Member 'UPreLobbyServerBrowserEntry::OnClicked' has a wrong offset!");

// Class JP.PreLobbyServerBrowserWidget
// 0x0080 (0x0360 - 0x02E0)
class UPreLobbyServerBrowserWidget : public UUserWidget
{
public:
	class UPreLobbyServerBrowserList*             LobbyList;                                         // 0x02E0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E8[0x78];                                     // 0x02E8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyViewModel(const struct FPreLobbyServerBrowserViewModel& InViewModel);
	void RequestLobbies(bool bInDoBackendRequest);
	void SetBoolValue(class UJPSettingWidget* InWidget, bool InValue, bool bInDoBackendRequest);
	void SetIntegerValue(class UJPSettingWidget* InWidget, int32 InValue, bool bInDoBackendRequest);
	void SetMultiChoiceValue(class UJPSettingWidget* InWidget, const TSet<int32>& InValue, bool bInDoBackendRequest);
	void SetScalarValue(class UJPSettingWidget* InWidget, float InValue, bool bInDoBackendRequest);
	void SetStringValue(class UJPSettingWidget* InWidget, const class FString& InValue, bool bInDoBackendRequest);
	void TryJoinLobby();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PreLobbyServerBrowserWidget">();
	}
	static class UPreLobbyServerBrowserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPreLobbyServerBrowserWidget>();
	}
};
static_assert(alignof(UPreLobbyServerBrowserWidget) == 0x000008, "Wrong alignment on UPreLobbyServerBrowserWidget");
static_assert(sizeof(UPreLobbyServerBrowserWidget) == 0x000360, "Wrong size on UPreLobbyServerBrowserWidget");
static_assert(offsetof(UPreLobbyServerBrowserWidget, LobbyList) == 0x0002E0, "Member 'UPreLobbyServerBrowserWidget::LobbyList' has a wrong offset!");

// Class JP.ProjectValidatorSubsystem
// 0x0000 (0x0030 - 0x0030)
class UProjectValidatorSubsystem final : public UWorldSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ProjectValidatorSubsystem">();
	}
	static class UProjectValidatorSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UProjectValidatorSubsystem>();
	}
};
static_assert(alignof(UProjectValidatorSubsystem) == 0x000008, "Wrong alignment on UProjectValidatorSubsystem");
static_assert(sizeof(UProjectValidatorSubsystem) == 0x000030, "Wrong size on UProjectValidatorSubsystem");

// Class JP.RandomLootSpawner
// 0x0008 (0x0298 - 0x0290)
class ARandomLootSpawner : public AActor
{
public:
	class URandomLootDefinition*                  LootDefinition;                                    // 0x0290(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	struct FGameplayTag GetRandomLootTagBasedOnProbability(TMap<struct FGameplayTag, float>& LootProbabilities);
	void SetNewLootDefinition(class URandomLootDefinition* Definition);
	struct FGameplayTag TriggerLootSelection();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RandomLootSpawner">();
	}
	static class ARandomLootSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARandomLootSpawner>();
	}
};
static_assert(alignof(ARandomLootSpawner) == 0x000008, "Wrong alignment on ARandomLootSpawner");
static_assert(sizeof(ARandomLootSpawner) == 0x000298, "Wrong size on ARandomLootSpawner");
static_assert(offsetof(ARandomLootSpawner, LootDefinition) == 0x000290, "Member 'ARandomLootSpawner::LootDefinition' has a wrong offset!");

// Class JP.ReceptacleComponent
// 0x0000 (0x0560 - 0x0560)
class UReceptacleComponent : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ReceptacleComponent">();
	}
	static class UReceptacleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UReceptacleComponent>();
	}
};
static_assert(alignof(UReceptacleComponent) == 0x000010, "Wrong alignment on UReceptacleComponent");
static_assert(sizeof(UReceptacleComponent) == 0x000560, "Wrong size on UReceptacleComponent");

// Class JP.RepairnessAttributeSet
// 0x0040 (0x0070 - 0x0030)
class URepairnessAttributeSet final : public UAttributeSetIW
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEmpty;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Repairness;                                        // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxRepairness;                                     // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_MaxRepairness();
	void OnRep_Repairness();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RepairnessAttributeSet">();
	}
	static class URepairnessAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<URepairnessAttributeSet>();
	}
};
static_assert(alignof(URepairnessAttributeSet) == 0x000008, "Wrong alignment on URepairnessAttributeSet");
static_assert(sizeof(URepairnessAttributeSet) == 0x000070, "Wrong size on URepairnessAttributeSet");
static_assert(offsetof(URepairnessAttributeSet, OnChanged) == 0x000030, "Member 'URepairnessAttributeSet::OnChanged' has a wrong offset!");
static_assert(offsetof(URepairnessAttributeSet, OnEmpty) == 0x000040, "Member 'URepairnessAttributeSet::OnEmpty' has a wrong offset!");
static_assert(offsetof(URepairnessAttributeSet, Repairness) == 0x000050, "Member 'URepairnessAttributeSet::Repairness' has a wrong offset!");
static_assert(offsetof(URepairnessAttributeSet, MaxRepairness) == 0x000060, "Member 'URepairnessAttributeSet::MaxRepairness' has a wrong offset!");

// Class JP.RichTextBlockInputImageDecorator
// 0x0018 (0x0048 - 0x0030)
class URichTextBlockInputImageDecorator : public URichTextBlockImageDecorator
{
public:
	class UDataTable*                             ImageSetXbox;                                      // 0x0030(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ImageSetPS4;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ImageSetPS5;                                       // 0x0040(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool HasImageBrushForTag(class FName TagOrId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RichTextBlockInputImageDecorator">();
	}
	static class URichTextBlockInputImageDecorator* GetDefaultObj()
	{
		return GetDefaultObjImpl<URichTextBlockInputImageDecorator>();
	}
};
static_assert(alignof(URichTextBlockInputImageDecorator) == 0x000008, "Wrong alignment on URichTextBlockInputImageDecorator");
static_assert(sizeof(URichTextBlockInputImageDecorator) == 0x000048, "Wrong size on URichTextBlockInputImageDecorator");
static_assert(offsetof(URichTextBlockInputImageDecorator, ImageSetXbox) == 0x000030, "Member 'URichTextBlockInputImageDecorator::ImageSetXbox' has a wrong offset!");
static_assert(offsetof(URichTextBlockInputImageDecorator, ImageSetPS4) == 0x000038, "Member 'URichTextBlockInputImageDecorator::ImageSetPS4' has a wrong offset!");
static_assert(offsetof(URichTextBlockInputImageDecorator, ImageSetPS5) == 0x000040, "Member 'URichTextBlockInputImageDecorator::ImageSetPS5' has a wrong offset!");

// Class JP.RoomVolume
// 0x0018 (0x02E0 - 0x02C8)
class ARoomVolume final : public AVolume
{
public:
	class UStaticMeshComponent*                   Visualizer;                                        // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AActor>>          TrackedActors;                                     // 0x02D0(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	TArray<class AActor*> GetAllTrackedActors();
	TArray<class AActor*> GetAllTrackedActorsOfType(TSubclassOf<class AActor> Type);
	void TrackActor(class AActor* Actor);
	void UntrackActor(class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RoomVolume">();
	}
	static class ARoomVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<ARoomVolume>();
	}
};
static_assert(alignof(ARoomVolume) == 0x000008, "Wrong alignment on ARoomVolume");
static_assert(sizeof(ARoomVolume) == 0x0002E0, "Wrong size on ARoomVolume");
static_assert(offsetof(ARoomVolume, Visualizer) == 0x0002C8, "Member 'ARoomVolume::Visualizer' has a wrong offset!");
static_assert(offsetof(ARoomVolume, TrackedActors) == 0x0002D0, "Member 'ARoomVolume::TrackedActors' has a wrong offset!");

// Class JP.SeasonPassContainerWidgetFull
// 0x0018 (0x0338 - 0x0320)
class USeasonPassContainerWidgetFull : public USeasonPassContainerWidgetBase
{
public:
	int32                                         TiersToShow;                                       // 0x0320(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_324[0x4];                                      // 0x0324(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UScrollBox*                             ScrollBox;                                         // 0x0328(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class USeasonPassTierWidget>      TierWidget;                                        // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void CreateTierWidget(const struct FSeasonPassTierViewModel& ViewModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassContainerWidgetFull">();
	}
	static class USeasonPassContainerWidgetFull* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassContainerWidgetFull>();
	}
};
static_assert(alignof(USeasonPassContainerWidgetFull) == 0x000008, "Wrong alignment on USeasonPassContainerWidgetFull");
static_assert(sizeof(USeasonPassContainerWidgetFull) == 0x000338, "Wrong size on USeasonPassContainerWidgetFull");
static_assert(offsetof(USeasonPassContainerWidgetFull, TiersToShow) == 0x000320, "Member 'USeasonPassContainerWidgetFull::TiersToShow' has a wrong offset!");
static_assert(offsetof(USeasonPassContainerWidgetFull, ScrollBox) == 0x000328, "Member 'USeasonPassContainerWidgetFull::ScrollBox' has a wrong offset!");
static_assert(offsetof(USeasonPassContainerWidgetFull, TierWidget) == 0x000330, "Member 'USeasonPassContainerWidgetFull::TierWidget' has a wrong offset!");

// Class JP.SeasonPassContainerWidgetWinscreen_V2
// 0x0000 (0x0338 - 0x0338)
class USeasonPassContainerWidgetWinscreen_V2 : public USeasonPassPreviewContainerWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassContainerWidgetWinscreen_V2">();
	}
	static class USeasonPassContainerWidgetWinscreen_V2* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassContainerWidgetWinscreen_V2>();
	}
};
static_assert(alignof(USeasonPassContainerWidgetWinscreen_V2) == 0x000008, "Wrong alignment on USeasonPassContainerWidgetWinscreen_V2");
static_assert(sizeof(USeasonPassContainerWidgetWinscreen_V2) == 0x000338, "Wrong size on USeasonPassContainerWidgetWinscreen_V2");

// Class JP.SeasonPassPreviewContainerWinscreen
// 0x0000 (0x0338 - 0x0338)
class USeasonPassPreviewContainerWinscreen final : public USeasonPassPreviewContainerWidget
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassPreviewContainerWinscreen">();
	}
	static class USeasonPassPreviewContainerWinscreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassPreviewContainerWinscreen>();
	}
};
static_assert(alignof(USeasonPassPreviewContainerWinscreen) == 0x000008, "Wrong alignment on USeasonPassPreviewContainerWinscreen");
static_assert(sizeof(USeasonPassPreviewContainerWinscreen) == 0x000338, "Wrong size on USeasonPassPreviewContainerWinscreen");

// Class JP.SeasonPassRewardContent_NeighborInterface
// 0x0000 (0x0028 - 0x0028)
class ISeasonPassRewardContent_NeighborInterface final : public IInterface
{
public:
	void ApplyNeighborViewModel(const struct FSeasonPassRewardContent_NeighborViewModel& ViewModel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassRewardContent_NeighborInterface">();
	}
	static class ISeasonPassRewardContent_NeighborInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISeasonPassRewardContent_NeighborInterface>();
	}
};
static_assert(alignof(ISeasonPassRewardContent_NeighborInterface) == 0x000008, "Wrong alignment on ISeasonPassRewardContent_NeighborInterface");
static_assert(sizeof(ISeasonPassRewardContent_NeighborInterface) == 0x000028, "Wrong size on ISeasonPassRewardContent_NeighborInterface");

// Class JP.CatalogItemRewardContentFactory
// 0x0018 (0x0040 - 0x0028)
class UCatalogItemRewardContentFactory : public UObject
{
public:
	TSubclassOf<class UUserWidget>                CurrencyWidget;                                    // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                NeighborWidget;                                    // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UUserWidget>                NeighborSkinWidget;                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CatalogItemRewardContentFactory">();
	}
	static class UCatalogItemRewardContentFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCatalogItemRewardContentFactory>();
	}
};
static_assert(alignof(UCatalogItemRewardContentFactory) == 0x000008, "Wrong alignment on UCatalogItemRewardContentFactory");
static_assert(sizeof(UCatalogItemRewardContentFactory) == 0x000040, "Wrong size on UCatalogItemRewardContentFactory");
static_assert(offsetof(UCatalogItemRewardContentFactory, CurrencyWidget) == 0x000028, "Member 'UCatalogItemRewardContentFactory::CurrencyWidget' has a wrong offset!");
static_assert(offsetof(UCatalogItemRewardContentFactory, NeighborWidget) == 0x000030, "Member 'UCatalogItemRewardContentFactory::NeighborWidget' has a wrong offset!");
static_assert(offsetof(UCatalogItemRewardContentFactory, NeighborSkinWidget) == 0x000038, "Member 'UCatalogItemRewardContentFactory::NeighborSkinWidget' has a wrong offset!");

// Class JP.RewardContentFactory
// 0x0010 (0x0038 - 0x0028)
class URewardContentFactory : public UObject
{
public:
	TSubclassOf<class UUserWidget>                CatalogItemWidget;                                 // 0x0028(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UUserWidget>                PerkWidget;                                        // 0x0030(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TSubclassOf<class UUserWidget> GetContentFromRewardType(ESeasonPassRewardType RewardType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RewardContentFactory">();
	}
	static class URewardContentFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<URewardContentFactory>();
	}
};
static_assert(alignof(URewardContentFactory) == 0x000008, "Wrong alignment on URewardContentFactory");
static_assert(sizeof(URewardContentFactory) == 0x000038, "Wrong size on URewardContentFactory");
static_assert(offsetof(URewardContentFactory, CatalogItemWidget) == 0x000028, "Member 'URewardContentFactory::CatalogItemWidget' has a wrong offset!");
static_assert(offsetof(URewardContentFactory, PerkWidget) == 0x000030, "Member 'URewardContentFactory::PerkWidget' has a wrong offset!");

// Class JP.SeasonPassTierWidget
// 0x0028 (0x0308 - 0x02E0)
class USeasonPassTierWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x28];                                     // 0x02E0(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyViewModel(const struct FSeasonPassTierViewModel& InViewModel);
	void CreateSingleRewardWidget(class UPanelWidget* Parent, const bool bIsPremium, TSubclassOf<class USeasonPassRewardEntryWidgetBase> WidgetType);
	void K2_ApplyViewModel(const struct FSeasonPassTierViewModel& ViewModel);
	bool TryGetFirstReward(bool bIsPremium, struct FSeasonPassReward& OutReward);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SeasonPassTierWidget">();
	}
	static class USeasonPassTierWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USeasonPassTierWidget>();
	}
};
static_assert(alignof(USeasonPassTierWidget) == 0x000008, "Wrong alignment on USeasonPassTierWidget");
static_assert(sizeof(USeasonPassTierWidget) == 0x000308, "Wrong size on USeasonPassTierWidget");

// Class JP.ServerTravelStorageGameInstanceSubsystem
// 0x0018 (0x0048 - 0x0030)
class UServerTravelStorageGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	uint8                                         Pad_30[0x18];                                      // 0x0030(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServerTravelStorageGameInstanceSubsystem">();
	}
	static class UServerTravelStorageGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServerTravelStorageGameInstanceSubsystem>();
	}
};
static_assert(alignof(UServerTravelStorageGameInstanceSubsystem) == 0x000008, "Wrong alignment on UServerTravelStorageGameInstanceSubsystem");
static_assert(sizeof(UServerTravelStorageGameInstanceSubsystem) == 0x000048, "Wrong size on UServerTravelStorageGameInstanceSubsystem");

// Class JP.ServiceMessageHandler
// 0x0030 (0x0058 - 0x0028)
class UServiceMessageHandler final : public UObject
{
public:
	TArray<class UServiceMessage*>                AllServiceMessages;                                // 0x0028(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class FString                                 SMEndPoint;                                        // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             FServiceMessagesLoaded;                            // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	TArray<class UServiceMessage*> GetAllServiceMessages();
	void LoadAllServiceMessages();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ServiceMessageHandler">();
	}
	static class UServiceMessageHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UServiceMessageHandler>();
	}
};
static_assert(alignof(UServiceMessageHandler) == 0x000008, "Wrong alignment on UServiceMessageHandler");
static_assert(sizeof(UServiceMessageHandler) == 0x000058, "Wrong size on UServiceMessageHandler");
static_assert(offsetof(UServiceMessageHandler, AllServiceMessages) == 0x000028, "Member 'UServiceMessageHandler::AllServiceMessages' has a wrong offset!");
static_assert(offsetof(UServiceMessageHandler, SMEndPoint) == 0x000038, "Member 'UServiceMessageHandler::SMEndPoint' has a wrong offset!");
static_assert(offsetof(UServiceMessageHandler, FServiceMessagesLoaded) == 0x000048, "Member 'UServiceMessageHandler::FServiceMessagesLoaded' has a wrong offset!");

// Class JP.SessionSearchResultViewModel
// 0x0018 (0x0040 - 0x0028)
class USessionSearchResultViewModel final : public UObject
{
public:
	class UCommonSession_SearchSessionRequest*    Original;                                          // 0x0028(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USessionResultViewModel*>        Results;                                           // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class USessionSearchResultViewModel* CreateViewModel(class UCommonSession_SearchSessionRequest* Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SessionSearchResultViewModel">();
	}
	static class USessionSearchResultViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<USessionSearchResultViewModel>();
	}
};
static_assert(alignof(USessionSearchResultViewModel) == 0x000008, "Wrong alignment on USessionSearchResultViewModel");
static_assert(sizeof(USessionSearchResultViewModel) == 0x000040, "Wrong size on USessionSearchResultViewModel");
static_assert(offsetof(USessionSearchResultViewModel, Original) == 0x000028, "Member 'USessionSearchResultViewModel::Original' has a wrong offset!");
static_assert(offsetof(USessionSearchResultViewModel, Results) == 0x000030, "Member 'USessionSearchResultViewModel::Results' has a wrong offset!");

// Class JP.ShopInteractionComponent
// 0x0018 (0x00B8 - 0x00A0)
class UShopInteractionComponent : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UInventoryComponent*                    Inventory;                                         // 0x00A8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UShopManagerComponent*                  ShopManagerComponent;                              // 0x00B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	bool AddAmmo(class UItemDefinition* ItemDefinition, const struct FShopItemViewModel& ShopItemViewModel);
	bool AttemptItemPurchase(class UItemDefinition* ItemDefinition, class UItemInstance* OptionalItemToDropFromInventory, bool DeliveryOrderConfirmed);
	bool CanAddAmmo(class UItemDefinition* ItemDefinition);
	bool CanPurchaseItem(class UItemDefinition* ItemDefinition);
	void DropItem(class UItemInstance* ItemToDropFromInventory);
	uint8 ModifyItemAmountFromPerks(class UItemDefinition* ItemDefinition);
	void OrderDelivery(TSubclassOf<class AActor> Actor, const struct FShopItemViewModel& ShopItemViewModel);
	class UItemInstance* PurchaseItem(class UItemDefinition* ItemDefinition, const struct FShopItemViewModel& ShopItemViewModel, uint8 Amount);
	void Server_RequestPurchase(const struct FGameplayTag& ItemDefinitionTag, class UItemInstance* OptionalItemToDropFromInventory, bool DeliveryOrderConfirmed);
	bool SetInventory();
	void ShowDeliveryConfirmationPrompt(class UItemDefinition* ItemDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopInteractionComponent">();
	}
	static class UShopInteractionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopInteractionComponent>();
	}
};
static_assert(alignof(UShopInteractionComponent) == 0x000008, "Wrong alignment on UShopInteractionComponent");
static_assert(sizeof(UShopInteractionComponent) == 0x0000B8, "Wrong size on UShopInteractionComponent");
static_assert(offsetof(UShopInteractionComponent, Inventory) == 0x0000A8, "Member 'UShopInteractionComponent::Inventory' has a wrong offset!");
static_assert(offsetof(UShopInteractionComponent, ShopManagerComponent) == 0x0000B0, "Member 'UShopInteractionComponent::ShopManagerComponent' has a wrong offset!");

// Class JP.ShopItemDataAsset
// 0x00B0 (0x00E0 - 0x0030)
class UShopItemDataAsset final : public UDataAsset
{
public:
	class FText                                   Name_0;                                            // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             Icon;                                              // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UEconomyDefinition*                     Cost;                                              // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShopItemCategory                             Category;                                          // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           RequiredShopLevel;                                 // 0x0054(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<struct FGameplayTag, int32>              GameplayTagStacks;                                 // 0x0060(0x0050)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UItemDefinition>         ItemDefinition;                                    // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableInShop;                                    // 0x00D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x7];                                       // 0x00D9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopItemDataAsset">();
	}
	static class UShopItemDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopItemDataAsset>();
	}
};
static_assert(alignof(UShopItemDataAsset) == 0x000008, "Wrong alignment on UShopItemDataAsset");
static_assert(sizeof(UShopItemDataAsset) == 0x0000E0, "Wrong size on UShopItemDataAsset");
static_assert(offsetof(UShopItemDataAsset, Name_0) == 0x000030, "Member 'UShopItemDataAsset::Name_0' has a wrong offset!");
static_assert(offsetof(UShopItemDataAsset, Icon) == 0x000040, "Member 'UShopItemDataAsset::Icon' has a wrong offset!");
static_assert(offsetof(UShopItemDataAsset, Cost) == 0x000048, "Member 'UShopItemDataAsset::Cost' has a wrong offset!");
static_assert(offsetof(UShopItemDataAsset, Category) == 0x000050, "Member 'UShopItemDataAsset::Category' has a wrong offset!");
static_assert(offsetof(UShopItemDataAsset, RequiredShopLevel) == 0x000054, "Member 'UShopItemDataAsset::RequiredShopLevel' has a wrong offset!");
static_assert(offsetof(UShopItemDataAsset, GameplayTagStacks) == 0x000060, "Member 'UShopItemDataAsset::GameplayTagStacks' has a wrong offset!");
static_assert(offsetof(UShopItemDataAsset, ItemDefinition) == 0x0000B0, "Member 'UShopItemDataAsset::ItemDefinition' has a wrong offset!");
static_assert(offsetof(UShopItemDataAsset, bDisableInShop) == 0x0000D8, "Member 'UShopItemDataAsset::bDisableInShop' has a wrong offset!");

// Class JP.ShopManagerComponent
// 0x02B0 (0x0350 - 0x00A0)
class UShopManagerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_A0[0x10];                                      // 0x00A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             ShopChanged;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UDataTable*                             ShopItemDataTable;                                 // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FShopViewModel                         ShopViewModel;                                     // 0x00C8(0x0028)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FShopItemFastArray                     Team1Items;                                        // 0x00F0(0x0130)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	struct FShopItemFastArray                     Team2Items;                                        // 0x0220(0x0130)(Net, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	const struct FShopItemViewModel GetShopItemViewModel(const TSoftObjectPtr<class UItemDefinition>& ItemDefinition, uint8 TeamId);
	const TArray<struct FShopItemViewModel> GetTeamShopItems(uint8 TeamId);
	void ReactToShopItemChangeTeam1(const struct FShopItemViewModel& ShopItemViewModel);
	void ReactToShopItemChangeTeam2(const struct FShopItemViewModel& ShopItemViewModel);
	void TutorialChangeAllItemsEnabled(bool IsEnabled, uint8 TeamId);
	void TutorialChangeItemEnabled(const TSoftObjectPtr<class UItemDefinition>& ItemDefinition, bool IsEnabled, uint8 TeamId);
	void TutorialChangeUpgradeEnabled(bool IsEnabled, EShopItemCategory Category);
	void UpdateShopViewModelGarageTier(uint8 GarageTier);
	void UpdateShopViewModelHouseLevel(uint8 HouseLevel);
	void UpdateShopViewModelKitchenTier(uint8 KitchenTier);
	void UpdateShopViewModelPottingBenchTier(uint8 PottingBenchTier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopManagerComponent">();
	}
	static class UShopManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopManagerComponent>();
	}
};
static_assert(alignof(UShopManagerComponent) == 0x000008, "Wrong alignment on UShopManagerComponent");
static_assert(sizeof(UShopManagerComponent) == 0x000350, "Wrong size on UShopManagerComponent");
static_assert(offsetof(UShopManagerComponent, ShopChanged) == 0x0000B0, "Member 'UShopManagerComponent::ShopChanged' has a wrong offset!");
static_assert(offsetof(UShopManagerComponent, ShopItemDataTable) == 0x0000C0, "Member 'UShopManagerComponent::ShopItemDataTable' has a wrong offset!");
static_assert(offsetof(UShopManagerComponent, ShopViewModel) == 0x0000C8, "Member 'UShopManagerComponent::ShopViewModel' has a wrong offset!");
static_assert(offsetof(UShopManagerComponent, Team1Items) == 0x0000F0, "Member 'UShopManagerComponent::Team1Items' has a wrong offset!");
static_assert(offsetof(UShopManagerComponent, Team2Items) == 0x000220, "Member 'UShopManagerComponent::Team2Items' has a wrong offset!");

// Class JP.ShopWidgetItemEntry
// 0x0080 (0x0360 - 0x02E0)
class UShopWidgetItemEntry : public UUserWidget
{
public:
	struct FShopItemViewModel                     ShopItemViewModel;                                 // 0x02E0(0x0080)(BlueprintVisible, BlueprintReadOnly, ExposeOnSpawn, NativeAccessSpecifierPublic)

public:
	class UButton* GetButton();
	void OnShopItemUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopWidgetItemEntry">();
	}
	static class UShopWidgetItemEntry* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopWidgetItemEntry>();
	}
};
static_assert(alignof(UShopWidgetItemEntry) == 0x000008, "Wrong alignment on UShopWidgetItemEntry");
static_assert(sizeof(UShopWidgetItemEntry) == 0x000360, "Wrong size on UShopWidgetItemEntry");
static_assert(offsetof(UShopWidgetItemEntry, ShopItemViewModel) == 0x0002E0, "Member 'UShopWidgetItemEntry::ShopItemViewModel' has a wrong offset!");

// Class JP.ShopWidgetTier
// 0x0008 (0x02E8 - 0x02E0)
class UShopWidgetTier : public UUserWidget
{
public:
	EShopItemCategory                             Category;                                          // 0x02E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         ShopTier;                                          // 0x02E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E2[0x6];                                      // 0x02E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeWidget(EShopItemCategory InCategory, uint8 InShopTier);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ShopWidgetTier">();
	}
	static class UShopWidgetTier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UShopWidgetTier>();
	}
};
static_assert(alignof(UShopWidgetTier) == 0x000008, "Wrong alignment on UShopWidgetTier");
static_assert(sizeof(UShopWidgetTier) == 0x0002E8, "Wrong size on UShopWidgetTier");
static_assert(offsetof(UShopWidgetTier, Category) == 0x0002E0, "Member 'UShopWidgetTier::Category' has a wrong offset!");
static_assert(offsetof(UShopWidgetTier, ShopTier) == 0x0002E1, "Member 'UShopWidgetTier::ShopTier' has a wrong offset!");

// Class JP.BlockedPlayerEntryViewModel
// 0x0008 (0x0030 - 0x0028)
class UBlockedPlayerEntryViewModel final : public UObject
{
public:
	class UOnlineServicesBlockedPlayer*           BlockedPlayer;                                     // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlockedPlayerEntryViewModel">();
	}
	static class UBlockedPlayerEntryViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlockedPlayerEntryViewModel>();
	}
};
static_assert(alignof(UBlockedPlayerEntryViewModel) == 0x000008, "Wrong alignment on UBlockedPlayerEntryViewModel");
static_assert(sizeof(UBlockedPlayerEntryViewModel) == 0x000030, "Wrong size on UBlockedPlayerEntryViewModel");
static_assert(offsetof(UBlockedPlayerEntryViewModel, BlockedPlayer) == 0x000028, "Member 'UBlockedPlayerEntryViewModel::BlockedPlayer' has a wrong offset!");

// Class JP.SocialBlockedPlayerInteractionWidget
// 0x0020 (0x0300 - 0x02E0)
class USocialBlockedPlayerInteractionWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadGuardButton*                       UnblockButton;                                     // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnUnblockButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialBlockedPlayerInteractionWidget">();
	}
	static class USocialBlockedPlayerInteractionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialBlockedPlayerInteractionWidget>();
	}
};
static_assert(alignof(USocialBlockedPlayerInteractionWidget) == 0x000008, "Wrong alignment on USocialBlockedPlayerInteractionWidget");
static_assert(sizeof(USocialBlockedPlayerInteractionWidget) == 0x000300, "Wrong size on USocialBlockedPlayerInteractionWidget");
static_assert(offsetof(USocialBlockedPlayerInteractionWidget, UnblockButton) == 0x0002F8, "Member 'USocialBlockedPlayerInteractionWidget::UnblockButton' has a wrong offset!");

// Class JP.FriendEntryViewModel
// 0x0010 (0x0038 - 0x0028)
class UFriendEntryViewModel final : public UObject
{
public:
	class UOnlineServicesFriend*                  Friend;                                            // 0x0028(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FriendEntryViewModel">();
	}
	static class UFriendEntryViewModel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFriendEntryViewModel>();
	}
};
static_assert(alignof(UFriendEntryViewModel) == 0x000008, "Wrong alignment on UFriendEntryViewModel");
static_assert(sizeof(UFriendEntryViewModel) == 0x000038, "Wrong size on UFriendEntryViewModel");
static_assert(offsetof(UFriendEntryViewModel, Friend) == 0x000028, "Member 'UFriendEntryViewModel::Friend' has a wrong offset!");

// Class JP.SocialFriendInteractionWidget
// 0x0020 (0x0300 - 0x02E0)
class USocialFriendInteractionWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x18];                                     // 0x02E0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadGuardButton*                       InviteButton;                                      // 0x02F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnInviteButtonClicked();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialFriendInteractionWidget">();
	}
	static class USocialFriendInteractionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialFriendInteractionWidget>();
	}
};
static_assert(alignof(USocialFriendInteractionWidget) == 0x000008, "Wrong alignment on USocialFriendInteractionWidget");
static_assert(sizeof(USocialFriendInteractionWidget) == 0x000300, "Wrong size on USocialFriendInteractionWidget");
static_assert(offsetof(USocialFriendInteractionWidget, InviteButton) == 0x0002F8, "Member 'USocialFriendInteractionWidget::InviteButton' has a wrong offset!");

// Class JP.SocialGameInstanceSubsystem
// 0x01F0 (0x0220 - 0x0030)
class USocialGameInstanceSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnPostMatchLeaderLeftCountdownStarted;             // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnFriendsUpdated;                                  // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyInvitesUpdated;                             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x30];                                      // 0x0060(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	FMulticastInlineDelegateProperty_             OnPartyChanged;                                    // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnPartyLeaderChanged;                              // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_B0[0x80];                                      // 0x00B0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UPartyOnlineServiceHandler*             PartyPtr;                                          // 0x0130(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UFriendsOnlineServiceHandler*           FriendsPtr;                                        // 0x0138(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class URecentPlayersOnlineServiceHandler*     RecentPlayersPtr;                                  // 0x0140(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBlockedPlayersOnlineServiceHandler*    BlockedPlayersPtr;                                 // 0x0148(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOnlineServicesLobbySubsystem*          LobbySubsystem;                                    // 0x0150(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, TSoftObjectPtr<class UTexture>>   CachedAvatars;                                     // 0x0158(0x0050)(UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A8[0x78];                                     // 0x01A8(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcceptPartyInvite(const struct FPartyInvite& InviteToAccept);
	void BlockPlayer(const class UOnlineServicesUserBase* User);
	bool CanUseSocials();
	void ClearCachedNetworkFailure();
	void DeclinePartyInvite(const struct FPartyInvite& Invite);
	TArray<class UOnlineServicesBlockedPlayer*> GetBlockedPlayers();
	TArray<class UOnlineServicesFriend*> GetFriends();
	int32 GetMaxNumPartyMembers();
	int32 GetNumFriendsPlayingJP();
	int32 GetNumOnlineFriends();
	TArray<class UOnlineServicesPartyMember*> GetPartyMembers();
	TArray<class UOnlineServicesRecentPlayer*> GetRecentPlayers();
	void GetSourceUserAvatar(const struct FPartyInvite& PartyInvite, TDelegate<void(TSoftObjectPtr<class UTexture> Avatar)> Callback);
	void GetUserAvatar(const class UOnlineServicesUserBase* User, TDelegate<void(TSoftObjectPtr<class UTexture> Avatar)> Callback);
	bool HasPostMatchLeaderLeftCountdownStarted();
	void InviteToParty(const class UOnlineServicesUserBase* User);
	bool IsPartyFull();
	bool IsPartyLeaderWithMembers();
	void KickPartyMember(const class UOnlineServicesPartyMember* PartyMember);
	void LeaveParty();
	void PromotePartyMember(const class UOnlineServicesPartyMember* PartyMember);
	void UnblockPlayer(const class UOnlineServicesUserBase* User);

	class FString GetCachedNetworkFailureAsString() const;
	TArray<struct FPartyInvite> GetExistingPartyInvites() const;
	float GetPostMatchLeaderLeftLeaveTime() const;
	bool HasCachedNetworkFailure() const;
	bool IsInParty() const;
	bool IsLocalUserPartyLeader() const;
	bool IsPartyMemberLeader(const class UOnlineServicesPartyMember* PartyMember) const;
	bool TryGetCachedNetworkFailureAsTag(struct FGameplayTag* NetworkFailureTag) const;
	bool TryGetFollowLeaderNetworkFailureDescriptor(const class FString& FailureString, class UCommonGameDialogDescriptor** Descriptor) const;
	bool TryGetNetworkFailureTagDescriptor(const struct FGameplayTag& FailureTag, class UCommonGameDialogDescriptor** Descriptor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialGameInstanceSubsystem">();
	}
	static class USocialGameInstanceSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialGameInstanceSubsystem>();
	}
};
static_assert(alignof(USocialGameInstanceSubsystem) == 0x000008, "Wrong alignment on USocialGameInstanceSubsystem");
static_assert(sizeof(USocialGameInstanceSubsystem) == 0x000220, "Wrong size on USocialGameInstanceSubsystem");
static_assert(offsetof(USocialGameInstanceSubsystem, OnPostMatchLeaderLeftCountdownStarted) == 0x000030, "Member 'USocialGameInstanceSubsystem::OnPostMatchLeaderLeftCountdownStarted' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, OnFriendsUpdated) == 0x000040, "Member 'USocialGameInstanceSubsystem::OnFriendsUpdated' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, OnPartyInvitesUpdated) == 0x000050, "Member 'USocialGameInstanceSubsystem::OnPartyInvitesUpdated' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, OnPartyChanged) == 0x000090, "Member 'USocialGameInstanceSubsystem::OnPartyChanged' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, OnPartyLeaderChanged) == 0x0000A0, "Member 'USocialGameInstanceSubsystem::OnPartyLeaderChanged' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, PartyPtr) == 0x000130, "Member 'USocialGameInstanceSubsystem::PartyPtr' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, FriendsPtr) == 0x000138, "Member 'USocialGameInstanceSubsystem::FriendsPtr' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, RecentPlayersPtr) == 0x000140, "Member 'USocialGameInstanceSubsystem::RecentPlayersPtr' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, BlockedPlayersPtr) == 0x000148, "Member 'USocialGameInstanceSubsystem::BlockedPlayersPtr' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, LobbySubsystem) == 0x000150, "Member 'USocialGameInstanceSubsystem::LobbySubsystem' has a wrong offset!");
static_assert(offsetof(USocialGameInstanceSubsystem, CachedAvatars) == 0x000158, "Member 'USocialGameInstanceSubsystem::CachedAvatars' has a wrong offset!");

// Class JP.SocialPartyInviteWidget
// 0x00B0 (0x0390 - 0x02E0)
class USocialPartyInviteWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x38];                                     // 0x02E0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UCommonTextBlock*                       InviterNameText;                                   // 0x0318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadGuardButton*                       AcceptButton;                                      // 0x0320(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadGuardButton*                       DeclineButton;                                     // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftObjectPtr<class UTexture>                Avatar;                                            // 0x0330(0x0028)(BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_358[0x30];                                     // 0x0358(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x0388(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ApplyAvatar();
	void OnAcceptButtonClicked();
	void OnDeclineButtonClicked();
	void SetAvatar(TSoftObjectPtr<class UTexture> InAvatar);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialPartyInviteWidget">();
	}
	static class USocialPartyInviteWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialPartyInviteWidget>();
	}
};
static_assert(alignof(USocialPartyInviteWidget) == 0x000008, "Wrong alignment on USocialPartyInviteWidget");
static_assert(sizeof(USocialPartyInviteWidget) == 0x000390, "Wrong size on USocialPartyInviteWidget");
static_assert(offsetof(USocialPartyInviteWidget, InviterNameText) == 0x000318, "Member 'USocialPartyInviteWidget::InviterNameText' has a wrong offset!");
static_assert(offsetof(USocialPartyInviteWidget, AcceptButton) == 0x000320, "Member 'USocialPartyInviteWidget::AcceptButton' has a wrong offset!");
static_assert(offsetof(USocialPartyInviteWidget, DeclineButton) == 0x000328, "Member 'USocialPartyInviteWidget::DeclineButton' has a wrong offset!");
static_assert(offsetof(USocialPartyInviteWidget, Avatar) == 0x000330, "Member 'USocialPartyInviteWidget::Avatar' has a wrong offset!");
static_assert(offsetof(USocialPartyInviteWidget, SocialGIS) == 0x000388, "Member 'USocialPartyInviteWidget::SocialGIS' has a wrong offset!");

// Class JP.SocialPartyMemberInteractionWidget
// 0x0060 (0x0340 - 0x02E0)
class USocialPartyMemberInteractionWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x48];                                     // 0x02E0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	class ULoadGuardButton*                       KickButton;                                        // 0x0328(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadGuardButton*                       PromoteButton;                                     // 0x0330(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULoadGuardButton*                       LeavePartyButton;                                  // 0x0338(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnKickButtonClicked();
	void OnLeavePartyButtonClicked();
	void OnPromoteButtonClicked();
	void SetPartyInfo(const bool bIsPartyOfOne, const bool bIsLocalUser, const bool bIsLocalUserPartyLeader);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialPartyMemberInteractionWidget">();
	}
	static class USocialPartyMemberInteractionWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialPartyMemberInteractionWidget>();
	}
};
static_assert(alignof(USocialPartyMemberInteractionWidget) == 0x000008, "Wrong alignment on USocialPartyMemberInteractionWidget");
static_assert(sizeof(USocialPartyMemberInteractionWidget) == 0x000340, "Wrong size on USocialPartyMemberInteractionWidget");
static_assert(offsetof(USocialPartyMemberInteractionWidget, KickButton) == 0x000328, "Member 'USocialPartyMemberInteractionWidget::KickButton' has a wrong offset!");
static_assert(offsetof(USocialPartyMemberInteractionWidget, PromoteButton) == 0x000330, "Member 'USocialPartyMemberInteractionWidget::PromoteButton' has a wrong offset!");
static_assert(offsetof(USocialPartyMemberInteractionWidget, LeavePartyButton) == 0x000338, "Member 'USocialPartyMemberInteractionWidget::LeavePartyButton' has a wrong offset!");

// Class JP.SocialPartyMembersListWidget
// 0x0038 (0x0318 - 0x02E0)
class USocialPartyMembersListWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialListWidget*                      BaseWidget;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraListView*                          ListView;                                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UPartyMemberEntryViewModel*>     PartyMembersList;                                  // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void UpdatePartyMembersList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialPartyMembersListWidget">();
	}
	static class USocialPartyMembersListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialPartyMembersListWidget>();
	}
};
static_assert(alignof(USocialPartyMembersListWidget) == 0x000008, "Wrong alignment on USocialPartyMembersListWidget");
static_assert(sizeof(USocialPartyMembersListWidget) == 0x000318, "Wrong size on USocialPartyMembersListWidget");
static_assert(offsetof(USocialPartyMembersListWidget, BaseWidget) == 0x0002E8, "Member 'USocialPartyMembersListWidget::BaseWidget' has a wrong offset!");
static_assert(offsetof(USocialPartyMembersListWidget, ListView) == 0x0002F0, "Member 'USocialPartyMembersListWidget::ListView' has a wrong offset!");
static_assert(offsetof(USocialPartyMembersListWidget, SocialGIS) == 0x0002F8, "Member 'USocialPartyMembersListWidget::SocialGIS' has a wrong offset!");
static_assert(offsetof(USocialPartyMembersListWidget, PartyMembersList) == 0x000308, "Member 'USocialPartyMembersListWidget::PartyMembersList' has a wrong offset!");

// Class JP.SocialRecentPlayersListWidget
// 0x0038 (0x0318 - 0x02E0)
class USocialRecentPlayersListWidget : public UUserWidget
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USocialListWidget*                      BaseWidget;                                        // 0x02E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ULyraListView*                          ListView;                                          // 0x02F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USocialGameInstanceSubsystem*           SocialGIS;                                         // 0x02F8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class URecentPlayerEntryViewModel*>    RecentPlayersList;                                 // 0x0308(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void BlueprintOnBlockPlayerFailed();
	void UpdateRecentPlayersList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SocialRecentPlayersListWidget">();
	}
	static class USocialRecentPlayersListWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<USocialRecentPlayersListWidget>();
	}
};
static_assert(alignof(USocialRecentPlayersListWidget) == 0x000008, "Wrong alignment on USocialRecentPlayersListWidget");
static_assert(sizeof(USocialRecentPlayersListWidget) == 0x000318, "Wrong size on USocialRecentPlayersListWidget");
static_assert(offsetof(USocialRecentPlayersListWidget, BaseWidget) == 0x0002E8, "Member 'USocialRecentPlayersListWidget::BaseWidget' has a wrong offset!");
static_assert(offsetof(USocialRecentPlayersListWidget, ListView) == 0x0002F0, "Member 'USocialRecentPlayersListWidget::ListView' has a wrong offset!");
static_assert(offsetof(USocialRecentPlayersListWidget, SocialGIS) == 0x0002F8, "Member 'USocialRecentPlayersListWidget::SocialGIS' has a wrong offset!");
static_assert(offsetof(USocialRecentPlayersListWidget, RecentPlayersList) == 0x000308, "Member 'USocialRecentPlayersListWidget::RecentPlayersList' has a wrong offset!");

// Class JP.SprintGA
// 0x0010 (0x03C8 - 0x03B8)
class USprintGA final : public UGameplayAbilityJP
{
public:
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnStaminaEmpty();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SprintGA">();
	}
	static class USprintGA* GetDefaultObj()
	{
		return GetDefaultObjImpl<USprintGA>();
	}
};
static_assert(alignof(USprintGA) == 0x000008, "Wrong alignment on USprintGA");
static_assert(sizeof(USprintGA) == 0x0003C8, "Wrong size on USprintGA");

// Class JP.StaminaAttributeSetListener
// 0x0000 (0x0028 - 0x0028)
class IStaminaAttributeSetListener final : public IInterface
{
public:
	void OnStaminaChanged(float Stamina, float MaxStamina);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaminaAttributeSetListener">();
	}
	static class IStaminaAttributeSetListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStaminaAttributeSetListener>();
	}
};
static_assert(alignof(IStaminaAttributeSetListener) == 0x000008, "Wrong alignment on IStaminaAttributeSetListener");
static_assert(sizeof(IStaminaAttributeSetListener) == 0x000028, "Wrong size on IStaminaAttributeSetListener");

// Class JP.StaminaAttributeSet
// 0x0040 (0x0070 - 0x0030)
class UStaminaAttributeSet final : public UAttributeSetIW
{
public:
	FMulticastInlineDelegateProperty_             OnChanged;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEmpty;                                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Stamina;                                           // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MaxStamina;                                        // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)

public:
	void OnRep_MaxStamina();
	void OnRep_Stamina();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StaminaAttributeSet">();
	}
	static class UStaminaAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStaminaAttributeSet>();
	}
};
static_assert(alignof(UStaminaAttributeSet) == 0x000008, "Wrong alignment on UStaminaAttributeSet");
static_assert(sizeof(UStaminaAttributeSet) == 0x000070, "Wrong size on UStaminaAttributeSet");
static_assert(offsetof(UStaminaAttributeSet, OnChanged) == 0x000030, "Member 'UStaminaAttributeSet::OnChanged' has a wrong offset!");
static_assert(offsetof(UStaminaAttributeSet, OnEmpty) == 0x000040, "Member 'UStaminaAttributeSet::OnEmpty' has a wrong offset!");
static_assert(offsetof(UStaminaAttributeSet, Stamina) == 0x000050, "Member 'UStaminaAttributeSet::Stamina' has a wrong offset!");
static_assert(offsetof(UStaminaAttributeSet, MaxStamina) == 0x000060, "Member 'UStaminaAttributeSet::MaxStamina' has a wrong offset!");

// Class JP.StatsAttributeSetListener
// 0x0000 (0x0028 - 0x0028)
class IStatsAttributeSetListener final : public IInterface
{
public:
	void OnAgilityChanged(float Agility);
	void OnAgilityModifierChanged(float Agility);
	void OnArmorModifierChanged(float Armor);
	void OnCritChanceChanged(float CritChance);
	void OnCritMultiplierChanged(float CritMultiplier);
	void OnEnduranceChanged(float Endurance);
	void OnEnduranceModifierChanged(float Endurance);
	void OnHealthChanged(float Health);
	void OnHealthModifierChanged(float Health);
	void OnLevelDamageModifierChanged(float LevelDamageModifier);
	void OnMeleeDamageModifierChanged(float MeleeDamageModifier);
	void OnPlayerDamageMultiplierChanged(float PlayerDamage);
	void OnRangedDamageModifierChanged(float RangedDamageModifier);
	void OnStrengthChanged(float Strength);
	void OnStrengthModifierChanged(float Strength);
	void OnSubtletyChanged(float Subtlety);
	void OnSubtletyModifierChanged(float Subtlety);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsAttributeSetListener">();
	}
	static class IStatsAttributeSetListener* GetDefaultObj()
	{
		return GetDefaultObjImpl<IStatsAttributeSetListener>();
	}
};
static_assert(alignof(IStatsAttributeSetListener) == 0x000008, "Wrong alignment on IStatsAttributeSetListener");
static_assert(sizeof(IStatsAttributeSetListener) == 0x000028, "Wrong size on IStatsAttributeSetListener");

// Class JP.StatsAttributeSet
// 0x0120 (0x0150 - 0x0030)
class UStatsAttributeSet final : public UAttributeSetIW
{
public:
	struct FGameplayAttributeData                 Health;                                            // 0x0030(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 HealthModifier;                                    // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Strength;                                          // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 StrengthModifier;                                  // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 LevelDamageModifier;                               // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 PlayerDamageMultiplier;                            // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Endurance;                                         // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 EnduranceModifier;                                 // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Agility;                                           // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 AgilityModifier;                                   // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 Subtlety;                                          // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 SubtletyModifier;                                  // 0x00E0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ArmorModifier;                                     // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 RangedDamageModifier;                              // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 MeleeDamageModifier;                               // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CritMultiplier;                                    // 0x0120(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 CritChance;                                        // 0x0130(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, RepNotify, NativeAccessSpecifierPublic)
	struct FGameplayAttributeData                 ActiveEffectDuration;                              // 0x0140(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnRep_Agility();
	void OnRep_AgilityModifier();
	void OnRep_ArmorModifier();
	void OnRep_CritChance();
	void OnRep_CritMultiplier();
	void OnRep_Endurance();
	void OnRep_EnduranceModifier();
	void OnRep_Health();
	void OnRep_HealthModifier();
	void OnRep_LevelDamageModifier();
	void OnRep_MeleeDamageModifier();
	void OnRep_PlayerDamageMultiplier();
	void OnRep_RangedDamageModifier();
	void OnRep_Strength();
	void OnRep_StrengthModifier();
	void OnRep_Subtlety();
	void OnRep_SubtletyModifier();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StatsAttributeSet">();
	}
	static class UStatsAttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStatsAttributeSet>();
	}
};
static_assert(alignof(UStatsAttributeSet) == 0x000008, "Wrong alignment on UStatsAttributeSet");
static_assert(sizeof(UStatsAttributeSet) == 0x000150, "Wrong size on UStatsAttributeSet");
static_assert(offsetof(UStatsAttributeSet, Health) == 0x000030, "Member 'UStatsAttributeSet::Health' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, HealthModifier) == 0x000040, "Member 'UStatsAttributeSet::HealthModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, Strength) == 0x000050, "Member 'UStatsAttributeSet::Strength' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, StrengthModifier) == 0x000060, "Member 'UStatsAttributeSet::StrengthModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, LevelDamageModifier) == 0x000070, "Member 'UStatsAttributeSet::LevelDamageModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, PlayerDamageMultiplier) == 0x000080, "Member 'UStatsAttributeSet::PlayerDamageMultiplier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, Endurance) == 0x000090, "Member 'UStatsAttributeSet::Endurance' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, EnduranceModifier) == 0x0000A0, "Member 'UStatsAttributeSet::EnduranceModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, Agility) == 0x0000B0, "Member 'UStatsAttributeSet::Agility' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, AgilityModifier) == 0x0000C0, "Member 'UStatsAttributeSet::AgilityModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, Subtlety) == 0x0000D0, "Member 'UStatsAttributeSet::Subtlety' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, SubtletyModifier) == 0x0000E0, "Member 'UStatsAttributeSet::SubtletyModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, ArmorModifier) == 0x0000F0, "Member 'UStatsAttributeSet::ArmorModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, RangedDamageModifier) == 0x000100, "Member 'UStatsAttributeSet::RangedDamageModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, MeleeDamageModifier) == 0x000110, "Member 'UStatsAttributeSet::MeleeDamageModifier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, CritMultiplier) == 0x000120, "Member 'UStatsAttributeSet::CritMultiplier' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, CritChance) == 0x000130, "Member 'UStatsAttributeSet::CritChance' has a wrong offset!");
static_assert(offsetof(UStatsAttributeSet, ActiveEffectDuration) == 0x000140, "Member 'UStatsAttributeSet::ActiveEffectDuration' has a wrong offset!");

// Class JP.SubObjective
// 0x0040 (0x02D0 - 0x0290)
class ASubObjective : public AInfo
{
public:
	class USubObjectiveDefinition*                SubObjectiveDefinition;                            // 0x0290(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObjectiveDefinition*                   ObjectiveDefinition;                               // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, Net, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamId;                                            // 0x02A0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x7];                                      // 0x02A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerStateJP_Match*                   OwningPlayerState;                                 // 0x02A8(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ObjectiveCreatedTime;                              // 0x02B0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UInputAction*>                   InputActionsForTooltip;                            // 0x02B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsCompleted;                                      // 0x02C8(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCreated;                                        // 0x02C9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsUnlocked;                                       // 0x02CA(0x0001)(Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2CB[0x5];                                      // 0x02CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetIsCompleted();
	bool GetIsUnlocked();
	class FText GetText();
	void OnRep_bIsCompleted();
	void OnRep_bIsUnlocked();
	void OwningObjectiveDestroyed(const struct FObjectiveAndOwningPlayer& Objective);
	void SetIsUnlocked(bool IsUnlocked);
	void SubObjectiveCompleted();
	void UpdateIsUnlocked();
	void UpdateUI();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SubObjective">();
	}
	static class ASubObjective* GetDefaultObj()
	{
		return GetDefaultObjImpl<ASubObjective>();
	}
};
static_assert(alignof(ASubObjective) == 0x000008, "Wrong alignment on ASubObjective");
static_assert(sizeof(ASubObjective) == 0x0002D0, "Wrong size on ASubObjective");
static_assert(offsetof(ASubObjective, SubObjectiveDefinition) == 0x000290, "Member 'ASubObjective::SubObjectiveDefinition' has a wrong offset!");
static_assert(offsetof(ASubObjective, ObjectiveDefinition) == 0x000298, "Member 'ASubObjective::ObjectiveDefinition' has a wrong offset!");
static_assert(offsetof(ASubObjective, TeamId) == 0x0002A0, "Member 'ASubObjective::TeamId' has a wrong offset!");
static_assert(offsetof(ASubObjective, OwningPlayerState) == 0x0002A8, "Member 'ASubObjective::OwningPlayerState' has a wrong offset!");
static_assert(offsetof(ASubObjective, ObjectiveCreatedTime) == 0x0002B0, "Member 'ASubObjective::ObjectiveCreatedTime' has a wrong offset!");
static_assert(offsetof(ASubObjective, InputActionsForTooltip) == 0x0002B8, "Member 'ASubObjective::InputActionsForTooltip' has a wrong offset!");
static_assert(offsetof(ASubObjective, bIsCompleted) == 0x0002C8, "Member 'ASubObjective::bIsCompleted' has a wrong offset!");
static_assert(offsetof(ASubObjective, bIsCreated) == 0x0002C9, "Member 'ASubObjective::bIsCreated' has a wrong offset!");
static_assert(offsetof(ASubObjective, bIsUnlocked) == 0x0002CA, "Member 'ASubObjective::bIsUnlocked' has a wrong offset!");

// Class JP.Tags
// 0x0000 (0x0028 - 0x0028)
class UTags final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Tags">();
	}
	static class UTags* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTags>();
	}
};
static_assert(alignof(UTags) == 0x000008, "Wrong alignment on UTags");
static_assert(sizeof(UTags) == 0x000028, "Wrong size on UTags");

// Class JP.TargetingSortTask_ActorType
// 0x0010 (0x0040 - 0x0030)
class UTargetingSortTask_ActorType final : public UTargetingSortTask_Base
{
public:
	TArray<TSubclassOf<class UObject>>            ActorClassPriorityList;                            // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TargetingSortTask_ActorType">();
	}
	static class UTargetingSortTask_ActorType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTargetingSortTask_ActorType>();
	}
};
static_assert(alignof(UTargetingSortTask_ActorType) == 0x000008, "Wrong alignment on UTargetingSortTask_ActorType");
static_assert(sizeof(UTargetingSortTask_ActorType) == 0x000040, "Wrong size on UTargetingSortTask_ActorType");
static_assert(offsetof(UTargetingSortTask_ActorType, ActorClassPriorityList) == 0x000030, "Member 'UTargetingSortTask_ActorType::ActorClassPriorityList' has a wrong offset!");

// Class JP.TaskSpawner
// 0x0040 (0x02D0 - 0x0290)
class ATaskSpawner : public AActor
{
public:
	bool                                          bInUse;                                            // 0x0290(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_291[0x7];                                      // 0x0291(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 SpawnedTaskActor;                                  // 0x0298(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UArrowComponent*                        Arrow;                                             // 0x02A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UBoxComponent*                          Box;                                               // 0x02A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UGroundskeeperReference*                GroundskeeperReference;                            // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             SupportedTypesToSpawn;                             // 0x02B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2C8[0x8];                                      // 0x02C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class AActor*> GetAllSpawnersSupportingTypes(const TArray<TSubclassOf<class AActor>>& SupportingTypes, class UObject* WorldContextObject);

	bool CanSpawnType(TSubclassOf<class AActor> TaskType);
	void ClaimSpawner(class AActor* SpawnedActor);
	TSubclassOf<class AActor> GetFirstSpawnableType(TSubclassOf<class AActor> ParentType);
	void OnGroundsKeeperChanged(class AGroundsKeeper* OldGroundsKeeper, class AGroundsKeeper* NewGroundskeeper);
	void ReleaseSpawner(class AActor* DestroyedActor);
	class AActor* SpawnTask(TSubclassOf<class AActor> TaskType);

	struct FTransform GetTaskTransform() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TaskSpawner">();
	}
	static class ATaskSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATaskSpawner>();
	}
};
static_assert(alignof(ATaskSpawner) == 0x000008, "Wrong alignment on ATaskSpawner");
static_assert(sizeof(ATaskSpawner) == 0x0002D0, "Wrong size on ATaskSpawner");
static_assert(offsetof(ATaskSpawner, bInUse) == 0x000290, "Member 'ATaskSpawner::bInUse' has a wrong offset!");
static_assert(offsetof(ATaskSpawner, SpawnedTaskActor) == 0x000298, "Member 'ATaskSpawner::SpawnedTaskActor' has a wrong offset!");
static_assert(offsetof(ATaskSpawner, Arrow) == 0x0002A0, "Member 'ATaskSpawner::Arrow' has a wrong offset!");
static_assert(offsetof(ATaskSpawner, Box) == 0x0002A8, "Member 'ATaskSpawner::Box' has a wrong offset!");
static_assert(offsetof(ATaskSpawner, GroundskeeperReference) == 0x0002B0, "Member 'ATaskSpawner::GroundskeeperReference' has a wrong offset!");
static_assert(offsetof(ATaskSpawner, SupportedTypesToSpawn) == 0x0002B8, "Member 'ATaskSpawner::SupportedTypesToSpawn' has a wrong offset!");

// Class JP.TeamAssignableInterface
// 0x0000 (0x0028 - 0x0028)
class ITeamAssignableInterface final : public IInterface
{
public:
	void SetTeamType(const ETeamType TeamType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamAssignableInterface">();
	}
	static class ITeamAssignableInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITeamAssignableInterface>();
	}
};
static_assert(alignof(ITeamAssignableInterface) == 0x000008, "Wrong alignment on ITeamAssignableInterface");
static_assert(sizeof(ITeamAssignableInterface) == 0x000028, "Wrong size on ITeamAssignableInterface");

// Class JP.TeamColoredStaticMeshActor
// 0x0068 (0x0308 - 0x02A0)
class ATeamColoredStaticMeshActor final : public AStaticMeshActor
{
public:
	uint8                                         Pad_2A0[0x8];                                      // 0x02A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         MaterialIndex;                                     // 0x02A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A9[0x7];                                      // 0x02A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<ETeamType, TSoftObjectPtr<class UMaterialInstanceConstant>> TeamColorConfigs;                                  // 0x02B0(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	ETeamType                                     CurrentTeamType;                                   // 0x0300(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_301[0x7];                                      // 0x0301(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTeam(const struct FTeam& Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamColoredStaticMeshActor">();
	}
	static class ATeamColoredStaticMeshActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<ATeamColoredStaticMeshActor>();
	}
};
static_assert(alignof(ATeamColoredStaticMeshActor) == 0x000008, "Wrong alignment on ATeamColoredStaticMeshActor");
static_assert(sizeof(ATeamColoredStaticMeshActor) == 0x000308, "Wrong size on ATeamColoredStaticMeshActor");
static_assert(offsetof(ATeamColoredStaticMeshActor, MaterialIndex) == 0x0002A8, "Member 'ATeamColoredStaticMeshActor::MaterialIndex' has a wrong offset!");
static_assert(offsetof(ATeamColoredStaticMeshActor, TeamColorConfigs) == 0x0002B0, "Member 'ATeamColoredStaticMeshActor::TeamColorConfigs' has a wrong offset!");
static_assert(offsetof(ATeamColoredStaticMeshActor, CurrentTeamType) == 0x000300, "Member 'ATeamColoredStaticMeshActor::CurrentTeamType' has a wrong offset!");

// Class JP.TeamScoreInterface
// 0x0000 (0x0028 - 0x0028)
class ITeamScoreInterface final : public IInterface
{
public:
	void AddScore(int32 Score);
	void SubtractScore(int32 Score);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamScoreInterface">();
	}
	static class ITeamScoreInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITeamScoreInterface>();
	}
};
static_assert(alignof(ITeamScoreInterface) == 0x000008, "Wrong alignment on ITeamScoreInterface");
static_assert(sizeof(ITeamScoreInterface) == 0x000028, "Wrong size on ITeamScoreInterface");

// Class JP.TeamUtilityLibrary
// 0x0000 (0x0028 - 0x0028)
class UTeamUtilityLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool DoAllTeamsExist(const class UObject* WorldContextObject);
	static bool DoesTeamExist(const uint8 TeamId, const class UObject* WorldContextObject);
	static class AGroundsKeeper* GetGroundsKeeperAtPoint(const class UObject* WorldContextObject, const struct FVector& Point, bool* bFoundTeam, TArray<class ATeamVolume*>* OverlappingTeamVolumes);
	static class AGroundsKeeper* GetGroundsKeeperByTeamId(const class UObject* WorldContextObject, uint8 TeamId);
	static uint8 GetMinimumTeamID();
	static uint8 GetNextTeamID(uint8 TeamId);
	static uint8 GetNumberOfActiveTeams(const class UObject* WorldContextObject);
	static TArray<class APlayerControllerJP*> GetPlayerControllersOfTeam(const class UObject* WorldContextObject, uint8 TeamId);
	static TArray<class APlayerStateJP*> GetPlayersOfTeam(const class UObject* WorldContextObject, uint8 TeamId);
	static const struct FTeam GetTeam(uint8 TeamId, const class UObject* WorldContextObject);
	static const struct FTeam GetTeamAtPoint(const class UObject* WorldContextObject, const struct FVector& Point, bool* bFoundTeam, struct FGameplayTag* TeamVolumeGameplayTag);
	static TArray<struct FTeam> GetTeams(const class UObject* WorldContextObject);
	static uint8 GetTeamWithLeastPlayersID(const class UObject* WorldContextObject);
	static bool IsTeamIDValid(uint8 TeamId);
	static bool IsTeamValid(const struct FTeam& Team);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TeamUtilityLibrary">();
	}
	static class UTeamUtilityLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTeamUtilityLibrary>();
	}
};
static_assert(alignof(UTeamUtilityLibrary) == 0x000008, "Wrong alignment on UTeamUtilityLibrary");
static_assert(sizeof(UTeamUtilityLibrary) == 0x000028, "Wrong size on UTeamUtilityLibrary");

// Class JP.TimeoutHandler
// 0x0038 (0x0060 - 0x0028)
class UTimeoutHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x38];                                      // 0x0028(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TimeoutHandler">();
	}
	static class UTimeoutHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTimeoutHandler>();
	}
};
static_assert(alignof(UTimeoutHandler) == 0x000008, "Wrong alignment on UTimeoutHandler");
static_assert(sizeof(UTimeoutHandler) == 0x000060, "Wrong size on UTimeoutHandler");

// Class JP.TurretFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UTurretFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static TArray<class AActor*> GetOverlappingActorsWithInterface(class UPrimitiveComponent* OverlapComponent, TSubclassOf<class IInterface> InterfaceClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TurretFunctionLibrary">();
	}
	static class UTurretFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTurretFunctionLibrary>();
	}
};
static_assert(alignof(UTurretFunctionLibrary) == 0x000008, "Wrong alignment on UTurretFunctionLibrary");
static_assert(sizeof(UTurretFunctionLibrary) == 0x000028, "Wrong size on UTurretFunctionLibrary");

// Class JP.TweakableData
// 0x0180 (0x01A8 - 0x0028)
class UTweakableData : public UObject
{
public:
	float                                         AtHomeRespawnMultiplier;                           // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TeamAmount;                                        // 0x002C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FLinearColor>                   TeamColors;                                        // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         PaintableMaxScore;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRuntimeFloatCurve                     IncomeCurve;                                       // 0x0048(0x0088)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         LobbyCountdownDuration;                            // 0x00D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     IncomeNotificationToUse;                           // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UEconomyDefinition*>             StartingEconomyOptions;                            // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         PassiveIncomeTickInterval;                         // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 PassiveIncomeStartingAmount;                       // 0x00F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         PassiveIncomeStatInterval;                         // 0x0108(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FKillReward>                    KillRewards;                                       // 0x0110(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         TheoreticalPerfectness;                            // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoneyIncreaseHigh;                                 // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoneyIncreaseMedium;                               // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoneyIncreaseLow;                                  // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoneyDecreaseLow;                                  // 0x0130(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoneyDecreaseMedium;                               // 0x0134(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoneyDecreaseHigh;                                 // 0x0138(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WoodIncreaseHigh;                                  // 0x013C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WoodIncreaseMedium;                                // 0x0140(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WoodIncreaseLow;                                   // 0x0144(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WoodDecreaseLow;                                   // 0x0148(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WoodDecreaseMedium;                                // 0x014C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WoodDecreaseHigh;                                  // 0x0150(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_154[0x4];                                      // 0x0154(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EShopItemCategory, struct FLinearColor>  ShopCategoryColors;                                // 0x0158(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TweakableData">();
	}
	static class UTweakableData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UTweakableData>();
	}
};
static_assert(alignof(UTweakableData) == 0x000008, "Wrong alignment on UTweakableData");
static_assert(sizeof(UTweakableData) == 0x0001A8, "Wrong size on UTweakableData");
static_assert(offsetof(UTweakableData, AtHomeRespawnMultiplier) == 0x000028, "Member 'UTweakableData::AtHomeRespawnMultiplier' has a wrong offset!");
static_assert(offsetof(UTweakableData, TeamAmount) == 0x00002C, "Member 'UTweakableData::TeamAmount' has a wrong offset!");
static_assert(offsetof(UTweakableData, TeamColors) == 0x000030, "Member 'UTweakableData::TeamColors' has a wrong offset!");
static_assert(offsetof(UTweakableData, PaintableMaxScore) == 0x000040, "Member 'UTweakableData::PaintableMaxScore' has a wrong offset!");
static_assert(offsetof(UTweakableData, IncomeCurve) == 0x000048, "Member 'UTweakableData::IncomeCurve' has a wrong offset!");
static_assert(offsetof(UTweakableData, LobbyCountdownDuration) == 0x0000D0, "Member 'UTweakableData::LobbyCountdownDuration' has a wrong offset!");
static_assert(offsetof(UTweakableData, IncomeNotificationToUse) == 0x0000D8, "Member 'UTweakableData::IncomeNotificationToUse' has a wrong offset!");
static_assert(offsetof(UTweakableData, StartingEconomyOptions) == 0x0000E0, "Member 'UTweakableData::StartingEconomyOptions' has a wrong offset!");
static_assert(offsetof(UTweakableData, PassiveIncomeTickInterval) == 0x0000F0, "Member 'UTweakableData::PassiveIncomeTickInterval' has a wrong offset!");
static_assert(offsetof(UTweakableData, PassiveIncomeStartingAmount) == 0x0000F8, "Member 'UTweakableData::PassiveIncomeStartingAmount' has a wrong offset!");
static_assert(offsetof(UTweakableData, PassiveIncomeStatInterval) == 0x000108, "Member 'UTweakableData::PassiveIncomeStatInterval' has a wrong offset!");
static_assert(offsetof(UTweakableData, KillRewards) == 0x000110, "Member 'UTweakableData::KillRewards' has a wrong offset!");
static_assert(offsetof(UTweakableData, TheoreticalPerfectness) == 0x000120, "Member 'UTweakableData::TheoreticalPerfectness' has a wrong offset!");
static_assert(offsetof(UTweakableData, MoneyIncreaseHigh) == 0x000124, "Member 'UTweakableData::MoneyIncreaseHigh' has a wrong offset!");
static_assert(offsetof(UTweakableData, MoneyIncreaseMedium) == 0x000128, "Member 'UTweakableData::MoneyIncreaseMedium' has a wrong offset!");
static_assert(offsetof(UTweakableData, MoneyIncreaseLow) == 0x00012C, "Member 'UTweakableData::MoneyIncreaseLow' has a wrong offset!");
static_assert(offsetof(UTweakableData, MoneyDecreaseLow) == 0x000130, "Member 'UTweakableData::MoneyDecreaseLow' has a wrong offset!");
static_assert(offsetof(UTweakableData, MoneyDecreaseMedium) == 0x000134, "Member 'UTweakableData::MoneyDecreaseMedium' has a wrong offset!");
static_assert(offsetof(UTweakableData, MoneyDecreaseHigh) == 0x000138, "Member 'UTweakableData::MoneyDecreaseHigh' has a wrong offset!");
static_assert(offsetof(UTweakableData, WoodIncreaseHigh) == 0x00013C, "Member 'UTweakableData::WoodIncreaseHigh' has a wrong offset!");
static_assert(offsetof(UTweakableData, WoodIncreaseMedium) == 0x000140, "Member 'UTweakableData::WoodIncreaseMedium' has a wrong offset!");
static_assert(offsetof(UTweakableData, WoodIncreaseLow) == 0x000144, "Member 'UTweakableData::WoodIncreaseLow' has a wrong offset!");
static_assert(offsetof(UTweakableData, WoodDecreaseLow) == 0x000148, "Member 'UTweakableData::WoodDecreaseLow' has a wrong offset!");
static_assert(offsetof(UTweakableData, WoodDecreaseMedium) == 0x00014C, "Member 'UTweakableData::WoodDecreaseMedium' has a wrong offset!");
static_assert(offsetof(UTweakableData, WoodDecreaseHigh) == 0x000150, "Member 'UTweakableData::WoodDecreaseHigh' has a wrong offset!");
static_assert(offsetof(UTweakableData, ShopCategoryColors) == 0x000158, "Member 'UTweakableData::ShopCategoryColors' has a wrong offset!");

// Class JP.JPEngineSubsystem
// 0x0000 (0x0030 - 0x0030)
class UJPEngineSubsystem final : public UEngineSubsystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JPEngineSubsystem">();
	}
	static class UJPEngineSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJPEngineSubsystem>();
	}
};
static_assert(alignof(UJPEngineSubsystem) == 0x000008, "Wrong alignment on UJPEngineSubsystem");
static_assert(sizeof(UJPEngineSubsystem) == 0x000030, "Wrong size on UJPEngineSubsystem");

// Class JP.WidgetTransformRandomizer
// 0x0068 (0x0348 - 0x02E0)
class UWidgetTransformRandomizer final : public UUserWidget
{
public:
	struct FFloatRange                            AngleRange;                                        // 0x02E0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            XRange;                                            // 0x02F0(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            YRange;                                            // 0x0300(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            XScaleRange;                                       // 0x0310(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            YScaleRange;                                       // 0x0320(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FFloatRange                            ShearRange;                                        // 0x0330(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          AffectChildren;                                    // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WidgetTransformRandomizer">();
	}
	static class UWidgetTransformRandomizer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UWidgetTransformRandomizer>();
	}
};
static_assert(alignof(UWidgetTransformRandomizer) == 0x000008, "Wrong alignment on UWidgetTransformRandomizer");
static_assert(sizeof(UWidgetTransformRandomizer) == 0x000348, "Wrong size on UWidgetTransformRandomizer");
static_assert(offsetof(UWidgetTransformRandomizer, AngleRange) == 0x0002E0, "Member 'UWidgetTransformRandomizer::AngleRange' has a wrong offset!");
static_assert(offsetof(UWidgetTransformRandomizer, XRange) == 0x0002F0, "Member 'UWidgetTransformRandomizer::XRange' has a wrong offset!");
static_assert(offsetof(UWidgetTransformRandomizer, YRange) == 0x000300, "Member 'UWidgetTransformRandomizer::YRange' has a wrong offset!");
static_assert(offsetof(UWidgetTransformRandomizer, XScaleRange) == 0x000310, "Member 'UWidgetTransformRandomizer::XScaleRange' has a wrong offset!");
static_assert(offsetof(UWidgetTransformRandomizer, YScaleRange) == 0x000320, "Member 'UWidgetTransformRandomizer::YScaleRange' has a wrong offset!");
static_assert(offsetof(UWidgetTransformRandomizer, ShearRange) == 0x000330, "Member 'UWidgetTransformRandomizer::ShearRange' has a wrong offset!");
static_assert(offsetof(UWidgetTransformRandomizer, AffectChildren) == 0x000340, "Member 'UWidgetTransformRandomizer::AffectChildren' has a wrong offset!");

// Class JP.WorldSettingsJP
// 0x0010 (0x04C8 - 0x04B8)
class AWorldSettingsJP final : public ABaseWorldSettingsIW
{
public:
	uint8                                         Pad_4B8[0x8];                                      // 0x04B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UExperienceDefinition>      WorldExperience;                                   // 0x04C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"WorldSettingsJP">();
	}
	static class AWorldSettingsJP* GetDefaultObj()
	{
		return GetDefaultObjImpl<AWorldSettingsJP>();
	}
};
static_assert(alignof(AWorldSettingsJP) == 0x000008, "Wrong alignment on AWorldSettingsJP");
static_assert(sizeof(AWorldSettingsJP) == 0x0004C8, "Wrong size on AWorldSettingsJP");
static_assert(offsetof(AWorldSettingsJP, WorldExperience) == 0x0004C0, "Member 'AWorldSettingsJP::WorldExperience' has a wrong offset!");

// Class JP.LyraAudioMixEffectsSubsystem
// 0x0068 (0x0098 - 0x0030)
class ULyraAudioMixEffectsSubsystem final : public UWorldSubsystem
{
public:
	class USoundControlBusMix*                    DefaultBaseMix;                                    // 0x0030(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBusMix*                    LoadingScreenMix;                                  // 0x0038(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBusMix*                    UserMix;                                           // 0x0040(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       OverallControlBus;                                 // 0x0048(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       MusicControlBus;                                   // 0x0050(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       SoundFXControlBus;                                 // 0x0058(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       DialogueControlBus;                                // 0x0060(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundControlBus*                       VoiceChatControlBus;                               // 0x0068(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FLyraAudioSubmixEffectsChain>   HDRSubmixEffectChain;                              // 0x0070(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TArray<struct FLyraAudioSubmixEffectsChain>   LDRSubmixEffectChain;                              // 0x0080(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_90[0x8];                                       // 0x0090(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraAudioMixEffectsSubsystem">();
	}
	static class ULyraAudioMixEffectsSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraAudioMixEffectsSubsystem>();
	}
};
static_assert(alignof(ULyraAudioMixEffectsSubsystem) == 0x000008, "Wrong alignment on ULyraAudioMixEffectsSubsystem");
static_assert(sizeof(ULyraAudioMixEffectsSubsystem) == 0x000098, "Wrong size on ULyraAudioMixEffectsSubsystem");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, DefaultBaseMix) == 0x000030, "Member 'ULyraAudioMixEffectsSubsystem::DefaultBaseMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, LoadingScreenMix) == 0x000038, "Member 'ULyraAudioMixEffectsSubsystem::LoadingScreenMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, UserMix) == 0x000040, "Member 'ULyraAudioMixEffectsSubsystem::UserMix' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, OverallControlBus) == 0x000048, "Member 'ULyraAudioMixEffectsSubsystem::OverallControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, MusicControlBus) == 0x000050, "Member 'ULyraAudioMixEffectsSubsystem::MusicControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, SoundFXControlBus) == 0x000058, "Member 'ULyraAudioMixEffectsSubsystem::SoundFXControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, DialogueControlBus) == 0x000060, "Member 'ULyraAudioMixEffectsSubsystem::DialogueControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, VoiceChatControlBus) == 0x000068, "Member 'ULyraAudioMixEffectsSubsystem::VoiceChatControlBus' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, HDRSubmixEffectChain) == 0x000070, "Member 'ULyraAudioMixEffectsSubsystem::HDRSubmixEffectChain' has a wrong offset!");
static_assert(offsetof(ULyraAudioMixEffectsSubsystem, LDRSubmixEffectChain) == 0x000080, "Member 'ULyraAudioMixEffectsSubsystem::LDRSubmixEffectChain' has a wrong offset!");

// Class JP.CharacterInitializationStepComponent
// 0x0008 (0x00A8 - 0x00A0)
class UCharacterInitializationStepComponent : public UGameFrameworkComponent
{
public:
	class ACharacterJP*                           OwningCharacter;                                   // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void ReceivePlayerStateChanged(bool ValidPlayerState);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInitializationStepComponent">();
	}
	static class UCharacterInitializationStepComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInitializationStepComponent>();
	}
};
static_assert(alignof(UCharacterInitializationStepComponent) == 0x000008, "Wrong alignment on UCharacterInitializationStepComponent");
static_assert(sizeof(UCharacterInitializationStepComponent) == 0x0000A8, "Wrong size on UCharacterInitializationStepComponent");
static_assert(offsetof(UCharacterInitializationStepComponent, OwningCharacter) == 0x0000A0, "Member 'UCharacterInitializationStepComponent::OwningCharacter' has a wrong offset!");

// Class JP.CharacterInitializationStepComponent_EliminationGamePlay
// 0x0000 (0x00A8 - 0x00A8)
class UCharacterInitializationStepComponent_EliminationGamePlay final : public UCharacterInitializationStepComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"CharacterInitializationStepComponent_EliminationGamePlay">();
	}
	static class UCharacterInitializationStepComponent_EliminationGamePlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UCharacterInitializationStepComponent_EliminationGamePlay>();
	}
};
static_assert(alignof(UCharacterInitializationStepComponent_EliminationGamePlay) == 0x000008, "Wrong alignment on UCharacterInitializationStepComponent_EliminationGamePlay");
static_assert(sizeof(UCharacterInitializationStepComponent_EliminationGamePlay) == 0x0000A8, "Wrong size on UCharacterInitializationStepComponent_EliminationGamePlay");

// Class JP.PlayerStateJPExtensionComponent
// 0x0000 (0x00A0 - 0x00A0)
class UPlayerStateJPExtensionComponent final : public UPlayerStateExtensionComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerStateJPExtensionComponent">();
	}
	static class UPlayerStateJPExtensionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerStateJPExtensionComponent>();
	}
};
static_assert(alignof(UPlayerStateJPExtensionComponent) == 0x000008, "Wrong alignment on UPlayerStateJPExtensionComponent");
static_assert(sizeof(UPlayerStateJPExtensionComponent) == 0x0000A0, "Wrong size on UPlayerStateJPExtensionComponent");

// Class JP.EconomySubsystem
// 0x0010 (0x0040 - 0x0030)
class UEconomySubsystem final : public UWorldSubsystem
{
public:
	uint8                                         Pad_30[0x10];                                      // 0x0030(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginPlayerEconomy(class AActor* RecipientActor);
	void BeginPlayerEconomyLateJoin(class AActor* RecipientActor);
	bool CanAfford(class UEconomyDefinition* EconomyToTest, class AActor* EconomyOwner);
	void DepositEconomy(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToAdd, class AActor* RecipientActor);
	void DepositEconomyToTeam(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToAdd, const int32 TeamId);
	void DepositEconomyToTeamAtPoint(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToAdd, const struct FVector& Position);
	void EndPlayerEconomy(class AActor* RecipientActor);
	float GetPassiveIncomePerTick(class AActor* RecipientActor);
	float GetPassiveIncomeStat(class AActor* RecipientActor);
	void GrantKillReward(const struct FKillReward& KillReward, const struct FKillInfo& Info);
	void SetPassiveIncomePerTick(const class AActor* RecipientActor, float NewValue);
	bool WithdrawEconomy(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToRemove, class AActor* GiverActor);
	bool WithdrawEconomyFromTeam(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToRemove, const int32 TeamId);
	bool WithdrawEconomyFromTeamAtPoint(const class UObject* WorldContextObject, class UEconomyDefinition* EconomyToRemove, const struct FVector& Position);

	bool CanAffordResourceType(EResourceType Type, const class AActor* Owner, class UEconomyDefinition* EconomyToTest) const;
	void GetPlayerEconomy(class APlayerController* PlayerController, struct FResourceData* Money, struct FResourceData* Wood, struct FResourceData* Perfectness, struct FResourceData* PassiveIncome) const;
	void GetPlayerEconomyAsText(class FText* Money, class FText* Wood, class FText* Perfectness, class FText* PerfectnessNormalised) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EconomySubsystem">();
	}
	static class UEconomySubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEconomySubsystem>();
	}
};
static_assert(alignof(UEconomySubsystem) == 0x000008, "Wrong alignment on UEconomySubsystem");
static_assert(sizeof(UEconomySubsystem) == 0x000040, "Wrong size on UEconomySubsystem");

// Class JP.PlayerEconomyComponent
// 0x0008 (0x00A8 - 0x00A0)
class UPlayerEconomyComponent final : public UActorComponent
{
public:
	class UPlayerEconomy*                         PlayerEconomy;                                     // 0x00A0(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnRep_PlayerEconomy();
	void ServerAddMoneyCheat(float Amount);
	void ServerAddPassiveIncome(float Amount);
	void ServerAddWoodCheat(float Amount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayerEconomyComponent">();
	}
	static class UPlayerEconomyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayerEconomyComponent>();
	}
};
static_assert(alignof(UPlayerEconomyComponent) == 0x000008, "Wrong alignment on UPlayerEconomyComponent");
static_assert(sizeof(UPlayerEconomyComponent) == 0x0000A8, "Wrong size on UPlayerEconomyComponent");
static_assert(offsetof(UPlayerEconomyComponent, PlayerEconomy) == 0x0000A0, "Member 'UPlayerEconomyComponent::PlayerEconomy' has a wrong offset!");

// Class JP.RejoinSaveGame
// 0x0020 (0x0048 - 0x0028)
class URejoinSaveGame final : public USaveGame
{
public:
	struct FRejoinSaveGameData                    RejoinSaveGameData;                                // 0x0028(0x0020)(NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RejoinSaveGame">();
	}
	static class URejoinSaveGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<URejoinSaveGame>();
	}
};
static_assert(alignof(URejoinSaveGame) == 0x000008, "Wrong alignment on URejoinSaveGame");
static_assert(sizeof(URejoinSaveGame) == 0x000048, "Wrong size on URejoinSaveGame");
static_assert(offsetof(URejoinSaveGame, RejoinSaveGameData) == 0x000028, "Member 'URejoinSaveGame::RejoinSaveGameData' has a wrong offset!");

// Class JP.LyraPerformanceSettings
// 0x0040 (0x0078 - 0x0038)
class ULyraPerformanceSettings final : public UDeveloperSettingsBackedByCVars
{
public:
	struct FPerPlatformSettings                   PerPlatformSettings;                               // 0x0038(0x0010)(Edit, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<int32>                                 DesktopFrameRateLimits;                            // 0x0048(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<int32>                                 DesktopLowFrameRateLimits;                         // 0x0058(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	TArray<struct FLyraPerformanceStatGroup>      UserFacingPerformanceStats;                        // 0x0068(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPerformanceSettings">();
	}
	static class ULyraPerformanceSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPerformanceSettings>();
	}
};
static_assert(alignof(ULyraPerformanceSettings) == 0x000008, "Wrong alignment on ULyraPerformanceSettings");
static_assert(sizeof(ULyraPerformanceSettings) == 0x000078, "Wrong size on ULyraPerformanceSettings");
static_assert(offsetof(ULyraPerformanceSettings, PerPlatformSettings) == 0x000038, "Member 'ULyraPerformanceSettings::PerPlatformSettings' has a wrong offset!");
static_assert(offsetof(ULyraPerformanceSettings, DesktopFrameRateLimits) == 0x000048, "Member 'ULyraPerformanceSettings::DesktopFrameRateLimits' has a wrong offset!");
static_assert(offsetof(ULyraPerformanceSettings, DesktopLowFrameRateLimits) == 0x000058, "Member 'ULyraPerformanceSettings::DesktopLowFrameRateLimits' has a wrong offset!");
static_assert(offsetof(ULyraPerformanceSettings, UserFacingPerformanceStats) == 0x000068, "Member 'ULyraPerformanceSettings::UserFacingPerformanceStats' has a wrong offset!");

// Class JP.LyraLocalPlayer
// 0x0030 (0x0330 - 0x0300)
class ULyraLocalPlayer final : public UCommonLocalPlayer
{
public:
	uint8                                         Pad_300[0x8];                                      // 0x0300(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class ULyraSettingsShared*                    SharedSettings;                                    // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UInputMappingContext*                   InputMappingContext;                               // 0x0310(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnTeamChangedDelegate;                             // 0x0318(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class APlayerController>       LastBoundPC;                                       // 0x0328(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnCompletedAudioDeviceSwap(const struct FSwapAudioOutputResult& SwapResult);
	void OnControllerChangedTeam(class UObject* TeamAgent, int32 OldTeam, int32 NewTeam);

	class ULyraSettingsLocal* GetLocalSettings() const;
	class ULyraSettingsShared* GetSharedSettings() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraLocalPlayer">();
	}
	static class ULyraLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraLocalPlayer>();
	}
};
static_assert(alignof(ULyraLocalPlayer) == 0x000008, "Wrong alignment on ULyraLocalPlayer");
static_assert(sizeof(ULyraLocalPlayer) == 0x000330, "Wrong size on ULyraLocalPlayer");
static_assert(offsetof(ULyraLocalPlayer, SharedSettings) == 0x000308, "Member 'ULyraLocalPlayer::SharedSettings' has a wrong offset!");
static_assert(offsetof(ULyraLocalPlayer, InputMappingContext) == 0x000310, "Member 'ULyraLocalPlayer::InputMappingContext' has a wrong offset!");
static_assert(offsetof(ULyraLocalPlayer, OnTeamChangedDelegate) == 0x000318, "Member 'ULyraLocalPlayer::OnTeamChangedDelegate' has a wrong offset!");
static_assert(offsetof(ULyraLocalPlayer, LastBoundPC) == 0x000328, "Member 'ULyraLocalPlayer::LastBoundPC' has a wrong offset!");

// Class JP.LyraGameData
// 0x0078 (0x00A8 - 0x0030)
class ULyraGameData final : public UPrimaryDataAsset
{
public:
	TSoftClassPtr<class UClass>                   DamageGameplayEffect_SetByCaller;                  // 0x0030(0x0028)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   HealGameplayEffect_SetByCaller;                    // 0x0058(0x0028)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   DynamicTagGameplayEffect;                          // 0x0080(0x0028)(Edit, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameData">();
	}
	static class ULyraGameData* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameData>();
	}
};
static_assert(alignof(ULyraGameData) == 0x000008, "Wrong alignment on ULyraGameData");
static_assert(sizeof(ULyraGameData) == 0x0000A8, "Wrong size on ULyraGameData");
static_assert(offsetof(ULyraGameData, DamageGameplayEffect_SetByCaller) == 0x000030, "Member 'ULyraGameData::DamageGameplayEffect_SetByCaller' has a wrong offset!");
static_assert(offsetof(ULyraGameData, HealGameplayEffect_SetByCaller) == 0x000058, "Member 'ULyraGameData::HealGameplayEffect_SetByCaller' has a wrong offset!");
static_assert(offsetof(ULyraGameData, DynamicTagGameplayEffect) == 0x000080, "Member 'ULyraGameData::DynamicTagGameplayEffect' has a wrong offset!");

// Class JP.MaterialProgressBar
// 0x00B0 (0x03B8 - 0x0308)
class UMaterialProgressBar final : public UCommonUserWidget
{
public:
	FMulticastInlineDelegateProperty_             OnFillAnimationFinished;                           // 0x0308(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bOverrideDefaultColorA;                            // 0x0318(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CachedColorA;                                      // 0x031C(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultColorB;                            // 0x032C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_32D[0x3];                                      // 0x032D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CachedColorB;                                      // 0x0330(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultColorBackground;                   // 0x0340(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_341[0x3];                                      // 0x0341(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           CachedColorBackground;                             // 0x0344(0x0010)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultSegments;                          // 0x0354(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Segments;                                          // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultSegmentEdge;                       // 0x035C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_35D[0x3];                                      // 0x035D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SegmentEdge;                                       // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultFillEdgeSoftness;                  // 0x0364(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_365[0x3];                                      // 0x0365(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FillEdgeSoftness;                                  // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultGlowEdge;                          // 0x036C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlowEdge;                                          // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultGlowSoftness;                      // 0x0374(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GlowSoftness;                                      // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideDefaultOutlineScale;                      // 0x037C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutlineScale;                                      // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseStroke;                                        // 0x0384(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_385[0x3];                                      // 0x0385(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     StrokeMaterial;                                    // 0x0388(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInterface*                     NoStrokeMaterial;                                  // 0x0390(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UImage*                                 Image_Bar;                                         // 0x0398(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UWidgetAnimation*                       BoundAnim_FillBar;                                 // 0x03A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UMaterialInstanceDynamic*               CachedMID;                                         // 0x03A8(0x0008)(ZeroConstructor, Transient, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AnimateProgressFromCurrent(float End, float AnimSpeed);
	void AnimateProgressFromStart(float Start, float End, float AnimSpeed);
	void OnFillAnimationFinished__DelegateSignature();
	void SetColorA(const struct FLinearColor& ColorA);
	void SetColorB(const struct FLinearColor& ColorB);
	void SetColorBackground(const struct FLinearColor& ColorBackground);
	void SetProgress(float Progress);
	void SetStartProgress(float StartProgress);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MaterialProgressBar">();
	}
	static class UMaterialProgressBar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMaterialProgressBar>();
	}
};
static_assert(alignof(UMaterialProgressBar) == 0x000008, "Wrong alignment on UMaterialProgressBar");
static_assert(sizeof(UMaterialProgressBar) == 0x0003B8, "Wrong size on UMaterialProgressBar");
static_assert(offsetof(UMaterialProgressBar, OnFillAnimationFinished) == 0x000308, "Member 'UMaterialProgressBar::OnFillAnimationFinished' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultColorA) == 0x000318, "Member 'UMaterialProgressBar::bOverrideDefaultColorA' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, CachedColorA) == 0x00031C, "Member 'UMaterialProgressBar::CachedColorA' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultColorB) == 0x00032C, "Member 'UMaterialProgressBar::bOverrideDefaultColorB' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, CachedColorB) == 0x000330, "Member 'UMaterialProgressBar::CachedColorB' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultColorBackground) == 0x000340, "Member 'UMaterialProgressBar::bOverrideDefaultColorBackground' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, CachedColorBackground) == 0x000344, "Member 'UMaterialProgressBar::CachedColorBackground' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultSegments) == 0x000354, "Member 'UMaterialProgressBar::bOverrideDefaultSegments' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, Segments) == 0x000358, "Member 'UMaterialProgressBar::Segments' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultSegmentEdge) == 0x00035C, "Member 'UMaterialProgressBar::bOverrideDefaultSegmentEdge' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, SegmentEdge) == 0x000360, "Member 'UMaterialProgressBar::SegmentEdge' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultFillEdgeSoftness) == 0x000364, "Member 'UMaterialProgressBar::bOverrideDefaultFillEdgeSoftness' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, FillEdgeSoftness) == 0x000368, "Member 'UMaterialProgressBar::FillEdgeSoftness' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultGlowEdge) == 0x00036C, "Member 'UMaterialProgressBar::bOverrideDefaultGlowEdge' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, GlowEdge) == 0x000370, "Member 'UMaterialProgressBar::GlowEdge' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultGlowSoftness) == 0x000374, "Member 'UMaterialProgressBar::bOverrideDefaultGlowSoftness' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, GlowSoftness) == 0x000378, "Member 'UMaterialProgressBar::GlowSoftness' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bOverrideDefaultOutlineScale) == 0x00037C, "Member 'UMaterialProgressBar::bOverrideDefaultOutlineScale' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, OutlineScale) == 0x000380, "Member 'UMaterialProgressBar::OutlineScale' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, bUseStroke) == 0x000384, "Member 'UMaterialProgressBar::bUseStroke' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, StrokeMaterial) == 0x000388, "Member 'UMaterialProgressBar::StrokeMaterial' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, NoStrokeMaterial) == 0x000390, "Member 'UMaterialProgressBar::NoStrokeMaterial' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, Image_Bar) == 0x000398, "Member 'UMaterialProgressBar::Image_Bar' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, BoundAnim_FillBar) == 0x0003A0, "Member 'UMaterialProgressBar::BoundAnim_FillBar' has a wrong offset!");
static_assert(offsetof(UMaterialProgressBar, CachedMID) == 0x0003A8, "Member 'UMaterialProgressBar::CachedMID' has a wrong offset!");

// Class JP.LyraBoundActionButton
// 0x0010 (0x15D0 - 0x15C0)
class ULyraBoundActionButton : public UCommonBoundActionButton
{
public:
	TSubclassOf<class UCommonButtonStyle>         KeyboardStyle;                                     // 0x15B8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommonButtonStyle>         GamepadStyle;                                      // 0x15C0(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommonButtonStyle>         TouchStyle;                                        // 0x15C8(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraBoundActionButton">();
	}
	static class ULyraBoundActionButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraBoundActionButton>();
	}
};
static_assert(alignof(ULyraBoundActionButton) == 0x000010, "Wrong alignment on ULyraBoundActionButton");
static_assert(sizeof(ULyraBoundActionButton) == 0x0015D0, "Wrong size on ULyraBoundActionButton");
static_assert(offsetof(ULyraBoundActionButton, KeyboardStyle) == 0x0015B8, "Member 'ULyraBoundActionButton::KeyboardStyle' has a wrong offset!");
static_assert(offsetof(ULyraBoundActionButton, GamepadStyle) == 0x0015C0, "Member 'ULyraBoundActionButton::GamepadStyle' has a wrong offset!");
static_assert(offsetof(ULyraBoundActionButton, TouchStyle) == 0x0015C8, "Member 'ULyraBoundActionButton::TouchStyle' has a wrong offset!");

// Class JP.LyraListView
// 0x0010 (0x0C80 - 0x0C70)
class ULyraListView final : public UCommonListView
{
public:
	TArray<class ULyraWidgetFactory*>             FactoryRules;                                      // 0x0C70(0x0010)(Edit, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraListView">();
	}
	static class ULyraListView* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraListView>();
	}
};
static_assert(alignof(ULyraListView) == 0x000010, "Wrong alignment on ULyraListView");
static_assert(sizeof(ULyraListView) == 0x000C80, "Wrong size on ULyraListView");
static_assert(offsetof(ULyraListView, FactoryRules) == 0x000C70, "Member 'ULyraListView::FactoryRules' has a wrong offset!");

// Class JP.LyraTabButtonInterface
// 0x0000 (0x0028 - 0x0028)
class ILyraTabButtonInterface final : public IInterface
{
public:
	void SetTabLabelInfo(const struct FLyraTabDescriptor& TabDescriptor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTabButtonInterface">();
	}
	static class ILyraTabButtonInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ILyraTabButtonInterface>();
	}
};
static_assert(alignof(ILyraTabButtonInterface) == 0x000008, "Wrong alignment on ILyraTabButtonInterface");
static_assert(sizeof(ILyraTabButtonInterface) == 0x000028, "Wrong size on ILyraTabButtonInterface");

// Class JP.LyraWidgetFactory
// 0x0000 (0x0028 - 0x0028)
class ULyraWidgetFactory : public UObject
{
public:
	TSubclassOf<class UUserWidget> FindWidgetClassForData(const class UObject* Data) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWidgetFactory">();
	}
	static class ULyraWidgetFactory* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWidgetFactory>();
	}
};
static_assert(alignof(ULyraWidgetFactory) == 0x000008, "Wrong alignment on ULyraWidgetFactory");
static_assert(sizeof(ULyraWidgetFactory) == 0x000028, "Wrong size on ULyraWidgetFactory");

// Class JP.LyraWidgetFactory_Class
// 0x0050 (0x0078 - 0x0028)
class ULyraWidgetFactory_Class final : public ULyraWidgetFactory
{
public:
	TMap<TSoftClassPtr<class UClass>, TSubclassOf<class UUserWidget>> EntryWidgetForClass;                               // 0x0028(0x0050)(Edit, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraWidgetFactory_Class">();
	}
	static class ULyraWidgetFactory_Class* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraWidgetFactory_Class>();
	}
};
static_assert(alignof(ULyraWidgetFactory_Class) == 0x000008, "Wrong alignment on ULyraWidgetFactory_Class");
static_assert(sizeof(ULyraWidgetFactory_Class) == 0x000078, "Wrong size on ULyraWidgetFactory_Class");
static_assert(offsetof(ULyraWidgetFactory_Class, EntryWidgetForClass) == 0x000028, "Member 'ULyraWidgetFactory_Class::EntryWidgetForClass' has a wrong offset!");

// Class JP.LyraControllerDisconnectedScreen
// 0x0008 (0x0438 - 0x0430)
class ULyraControllerDisconnectedScreen final : public UCommonActivatableWidget
{
public:
	class UHorizontalBox*                         HBox_SwitchUser;                                   // 0x0430(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraControllerDisconnectedScreen">();
	}
	static class ULyraControllerDisconnectedScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraControllerDisconnectedScreen>();
	}
};
static_assert(alignof(ULyraControllerDisconnectedScreen) == 0x000008, "Wrong alignment on ULyraControllerDisconnectedScreen");
static_assert(sizeof(ULyraControllerDisconnectedScreen) == 0x000438, "Wrong size on ULyraControllerDisconnectedScreen");
static_assert(offsetof(ULyraControllerDisconnectedScreen, HBox_SwitchUser) == 0x000430, "Member 'ULyraControllerDisconnectedScreen::HBox_SwitchUser' has a wrong offset!");

// Class JP.LyraLoadingScreenSubsystem
// 0x0018 (0x0048 - 0x0030)
class ULyraLoadingScreenSubsystem final : public UGameInstanceSubsystem
{
public:
	FMulticastInlineDelegateProperty_             OnLoadingScreenWidgetChanged;                      // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	TSubclassOf<class UUserWidget>                LoadingScreenWidgetClass;                          // 0x0040(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetLoadingScreenContentWidget(TSubclassOf<class UUserWidget> NewWidgetClass);

	TSubclassOf<class UUserWidget> GetLoadingScreenContentWidget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraLoadingScreenSubsystem">();
	}
	static class ULyraLoadingScreenSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraLoadingScreenSubsystem>();
	}
};
static_assert(alignof(ULyraLoadingScreenSubsystem) == 0x000008, "Wrong alignment on ULyraLoadingScreenSubsystem");
static_assert(sizeof(ULyraLoadingScreenSubsystem) == 0x000048, "Wrong size on ULyraLoadingScreenSubsystem");
static_assert(offsetof(ULyraLoadingScreenSubsystem, OnLoadingScreenWidgetChanged) == 0x000030, "Member 'ULyraLoadingScreenSubsystem::OnLoadingScreenWidgetChanged' has a wrong offset!");
static_assert(offsetof(ULyraLoadingScreenSubsystem, LoadingScreenWidgetClass) == 0x000040, "Member 'ULyraLoadingScreenSubsystem::LoadingScreenWidgetClass' has a wrong offset!");

// Class JP.ApplyFrontendPerfSettingsAction
// 0x0000 (0x0028 - 0x0028)
class UApplyFrontendPerfSettingsAction final : public UGameFeatureAction
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ApplyFrontendPerfSettingsAction">();
	}
	static class UApplyFrontendPerfSettingsAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UApplyFrontendPerfSettingsAction>();
	}
};
static_assert(alignof(UApplyFrontendPerfSettingsAction) == 0x000008, "Wrong alignment on UApplyFrontendPerfSettingsAction");
static_assert(sizeof(UApplyFrontendPerfSettingsAction) == 0x000028, "Wrong size on UApplyFrontendPerfSettingsAction");

// Class JP.LyraLobbyBackground
// 0x0028 (0x0058 - 0x0030)
class ULyraLobbyBackground final : public UPrimaryDataAsset
{
public:
	TSoftObjectPtr<class UWorld>                  BackgroundLevel;                                   // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraLobbyBackground">();
	}
	static class ULyraLobbyBackground* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraLobbyBackground>();
	}
};
static_assert(alignof(ULyraLobbyBackground) == 0x000008, "Wrong alignment on ULyraLobbyBackground");
static_assert(sizeof(ULyraLobbyBackground) == 0x000058, "Wrong size on ULyraLobbyBackground");
static_assert(offsetof(ULyraLobbyBackground, BackgroundLevel) == 0x000030, "Member 'ULyraLobbyBackground::BackgroundLevel' has a wrong offset!");

// Class JP.IndicatorDescriptor
// 0x00C0 (0x00E8 - 0x0028)
class UIndicatorDescriptor final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bVisible;                                          // 0x0030(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bClampToScreen;                                    // 0x0031(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowClampToScreenArrow;                           // 0x0032(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideScreenPosition;                           // 0x0033(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoRemoveWhenIndicatorComponentIsNull;           // 0x0034(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EActorCanvasProjectionMode                    ProjectionMode;                                    // 0x0035(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EHorizontalAlignment                          HAlignment;                                        // 0x0036(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EVerticalAlignment                            VAlignment;                                        // 0x0037(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         Priority;                                          // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BoundingBoxAnchor;                                 // 0x0040(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              ScreenSpaceOffset;                                 // 0x0058(0x0010)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                WorldPositionOffset;                               // 0x0068(0x0018)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UObject*                                DataObject;                                        // 0x0080(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USceneComponent*                        Component;                                         // 0x0088(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   ComponentSocketName;                               // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   IndicatorWidgetClass;                              // 0x0098(0x0028)(UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class ULyraIndicatorManagerComponent> ManagerPtr;                                        // 0x00C0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C8[0x20];                                      // 0x00C8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAutoRemoveWhenIndicatorComponentIsNull(bool CanAutomaticallyRemove);
	void SetBoundingBoxAnchor(const struct FVector& InBoundingBoxAnchor);
	void SetClampToScreen(bool bValue);
	void SetComponentSocketName(class FName SocketName);
	void SetDataObject(class UObject* InDataObject);
	void SetDesiredVisibility(bool InVisible);
	void SetHAlign(EHorizontalAlignment InHAlignment);
	void SetIndicatorClass(TSoftClassPtr<class UClass> InIndicatorWidgetClass);
	void SetPriority(int32 InPriority);
	void SetProjectionMode(EActorCanvasProjectionMode InProjectionMode);
	void SetSceneComponent(class USceneComponent* InComponent);
	void SetScreenSpaceOffset(const struct FVector2D& Offset);
	void SetShowClampToScreenArrow(bool bValue);
	void SetVAlign(EVerticalAlignment InVAlignment);
	void SetWorldPositionOffset(const struct FVector& Offset);
	void UnregisterIndicator();

	bool GetAutoRemoveWhenIndicatorComponentIsNull() const;
	struct FVector GetBoundingBoxAnchor() const;
	bool GetClampToScreen() const;
	class FName GetComponentSocketName() const;
	class UObject* GetDataObject() const;
	EHorizontalAlignment GetHAlign() const;
	TSoftClassPtr<class UClass> GetIndicatorClass() const;
	bool GetIsVisible() const;
	int32 GetPriority() const;
	EActorCanvasProjectionMode GetProjectionMode() const;
	class USceneComponent* GetSceneComponent() const;
	struct FVector2D GetScreenSpaceOffset() const;
	bool GetShowClampToScreenArrow() const;
	EVerticalAlignment GetVAlign() const;
	struct FVector GetWorldPositionOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndicatorDescriptor">();
	}
	static class UIndicatorDescriptor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIndicatorDescriptor>();
	}
};
static_assert(alignof(UIndicatorDescriptor) == 0x000008, "Wrong alignment on UIndicatorDescriptor");
static_assert(sizeof(UIndicatorDescriptor) == 0x0000E8, "Wrong size on UIndicatorDescriptor");
static_assert(offsetof(UIndicatorDescriptor, bVisible) == 0x000030, "Member 'UIndicatorDescriptor::bVisible' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, bClampToScreen) == 0x000031, "Member 'UIndicatorDescriptor::bClampToScreen' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, bShowClampToScreenArrow) == 0x000032, "Member 'UIndicatorDescriptor::bShowClampToScreenArrow' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, bOverrideScreenPosition) == 0x000033, "Member 'UIndicatorDescriptor::bOverrideScreenPosition' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, bAutoRemoveWhenIndicatorComponentIsNull) == 0x000034, "Member 'UIndicatorDescriptor::bAutoRemoveWhenIndicatorComponentIsNull' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, ProjectionMode) == 0x000035, "Member 'UIndicatorDescriptor::ProjectionMode' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, HAlignment) == 0x000036, "Member 'UIndicatorDescriptor::HAlignment' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, VAlignment) == 0x000037, "Member 'UIndicatorDescriptor::VAlignment' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, Priority) == 0x000038, "Member 'UIndicatorDescriptor::Priority' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, BoundingBoxAnchor) == 0x000040, "Member 'UIndicatorDescriptor::BoundingBoxAnchor' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, ScreenSpaceOffset) == 0x000058, "Member 'UIndicatorDescriptor::ScreenSpaceOffset' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, WorldPositionOffset) == 0x000068, "Member 'UIndicatorDescriptor::WorldPositionOffset' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, DataObject) == 0x000080, "Member 'UIndicatorDescriptor::DataObject' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, Component) == 0x000088, "Member 'UIndicatorDescriptor::Component' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, ComponentSocketName) == 0x000090, "Member 'UIndicatorDescriptor::ComponentSocketName' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, IndicatorWidgetClass) == 0x000098, "Member 'UIndicatorDescriptor::IndicatorWidgetClass' has a wrong offset!");
static_assert(offsetof(UIndicatorDescriptor, ManagerPtr) == 0x0000C0, "Member 'UIndicatorDescriptor::ManagerPtr' has a wrong offset!");

// Class JP.IndicatorLayer
// 0x00E8 (0x0260 - 0x0178)
class UIndicatorLayer final : public UWidget
{
public:
	uint8                                         Pad_178[0x8];                                      // 0x0178(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateBrush                            ArrowBrush;                                        // 0x0180(0x00D0)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"IndicatorLayer">();
	}
	static class UIndicatorLayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UIndicatorLayer>();
	}
};
static_assert(alignof(UIndicatorLayer) == 0x000010, "Wrong alignment on UIndicatorLayer");
static_assert(sizeof(UIndicatorLayer) == 0x000260, "Wrong size on UIndicatorLayer");
static_assert(offsetof(UIndicatorLayer, ArrowBrush) == 0x000180, "Member 'UIndicatorLayer::ArrowBrush' has a wrong offset!");

// Class JP.LyraIndicatorManagerComponent
// 0x0040 (0x00E0 - 0x00A0)
class ULyraIndicatorManagerComponent final : public UControllerComponent
{
public:
	uint8                                         Pad_A0[0x30];                                      // 0x00A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UIndicatorDescriptor*>           Indicators;                                        // 0x00D0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	void AddIndicator(class UIndicatorDescriptor* IndicatorDescriptor);
	void RemoveIndicator(class UIndicatorDescriptor* IndicatorDescriptor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraIndicatorManagerComponent">();
	}
	static class ULyraIndicatorManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraIndicatorManagerComponent>();
	}
};
static_assert(alignof(ULyraIndicatorManagerComponent) == 0x000008, "Wrong alignment on ULyraIndicatorManagerComponent");
static_assert(sizeof(ULyraIndicatorManagerComponent) == 0x0000E0, "Wrong size on ULyraIndicatorManagerComponent");
static_assert(offsetof(ULyraIndicatorManagerComponent, Indicators) == 0x0000D0, "Member 'ULyraIndicatorManagerComponent::Indicators' has a wrong offset!");

// Class JP.LyraGameViewportClient
// 0x0000 (0x03F0 - 0x03F0)
class ULyraGameViewportClient final : public UCommonGameViewportClient
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraGameViewportClient">();
	}
	static class ULyraGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraGameViewportClient>();
	}
};
static_assert(alignof(ULyraGameViewportClient) == 0x000008, "Wrong alignment on ULyraGameViewportClient");
static_assert(sizeof(ULyraGameViewportClient) == 0x0003F0, "Wrong size on ULyraGameViewportClient");

// Class JP.LyraHUD
// 0x0000 (0x0380 - 0x0380)
class ALyraHUD final : public AHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraHUD">();
	}
	static class ALyraHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<ALyraHUD>();
	}
};
static_assert(alignof(ALyraHUD) == 0x000008, "Wrong alignment on ALyraHUD");
static_assert(sizeof(ALyraHUD) == 0x000380, "Wrong size on ALyraHUD");

// Class JP.LyraSimulatedInputWidget
// 0x0040 (0x0348 - 0x0308)
class ULyraSimulatedInputWidget : public UCommonUserWidget
{
public:
	class UCommonHardwareVisibilityBorder*        CommonVisibilityBorder;                            // 0x0308(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           AssociatedAction;                                  // 0x0310(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FKey                                   FallbackBindingKey;                                // 0x0318(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_330[0x18];                                     // 0x0330(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FlushSimulatedInput();
	void InputKeyValue(const struct FVector& Value);
	void InputKeyValue2D(const struct FVector2D& Value);

	const class UInputAction* GetAssociatedAction() const;
	class UEnhancedInputLocalPlayerSubsystem* GetEnhancedInputSubsystem() const;
	struct FKey GetSimulatedKey() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSimulatedInputWidget">();
	}
	static class ULyraSimulatedInputWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSimulatedInputWidget>();
	}
};
static_assert(alignof(ULyraSimulatedInputWidget) == 0x000008, "Wrong alignment on ULyraSimulatedInputWidget");
static_assert(sizeof(ULyraSimulatedInputWidget) == 0x000348, "Wrong size on ULyraSimulatedInputWidget");
static_assert(offsetof(ULyraSimulatedInputWidget, CommonVisibilityBorder) == 0x000308, "Member 'ULyraSimulatedInputWidget::CommonVisibilityBorder' has a wrong offset!");
static_assert(offsetof(ULyraSimulatedInputWidget, AssociatedAction) == 0x000310, "Member 'ULyraSimulatedInputWidget::AssociatedAction' has a wrong offset!");
static_assert(offsetof(ULyraSimulatedInputWidget, FallbackBindingKey) == 0x000318, "Member 'ULyraSimulatedInputWidget::FallbackBindingKey' has a wrong offset!");

// Class JP.LyraJoystickWidget
// 0x0040 (0x0388 - 0x0348)
class ULyraJoystickWidget final : public ULyraSimulatedInputWidget
{
public:
	float                                         StickRange;                                        // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34C[0x4];                                      // 0x034C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 JoystickBackground;                                // 0x0350(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 JoystickForeground;                                // 0x0358(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNegateYAxis;                                      // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              TouchOrigin;                                       // 0x0368(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              StickVector;                                       // 0x0378(0x0010)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraJoystickWidget">();
	}
	static class ULyraJoystickWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraJoystickWidget>();
	}
};
static_assert(alignof(ULyraJoystickWidget) == 0x000008, "Wrong alignment on ULyraJoystickWidget");
static_assert(sizeof(ULyraJoystickWidget) == 0x000388, "Wrong size on ULyraJoystickWidget");
static_assert(offsetof(ULyraJoystickWidget, StickRange) == 0x000348, "Member 'ULyraJoystickWidget::StickRange' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, JoystickBackground) == 0x000350, "Member 'ULyraJoystickWidget::JoystickBackground' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, JoystickForeground) == 0x000358, "Member 'ULyraJoystickWidget::JoystickForeground' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, bNegateYAxis) == 0x000360, "Member 'ULyraJoystickWidget::bNegateYAxis' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, TouchOrigin) == 0x000368, "Member 'ULyraJoystickWidget::TouchOrigin' has a wrong offset!");
static_assert(offsetof(ULyraJoystickWidget, StickVector) == 0x000378, "Member 'ULyraJoystickWidget::StickVector' has a wrong offset!");

// Class JP.LyraSettingScreen
// 0x0060 (0x0500 - 0x04A0)
class ULyraSettingScreen : public UGameSettingScreen
{
public:
	class ULyraTabListWidgetBase*                 TopSettingsTabs;                                   // 0x04A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    BackInputActionData;                               // 0x04A8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    ApplyInputActionData;                              // 0x04B8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FDataTableRowHandle                    CancelChangesInputActionData;                      // 0x04C8(0x0010)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D8[0x10];                                     // 0x04D8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UInputAction*                           BackEnhancedInputAction;                           // 0x04E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           ApplyEnhancedInputAction;                          // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UInputAction*                           CancelEnhancedInputAction;                         // 0x04F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraSettingScreen">();
	}
	static class ULyraSettingScreen* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraSettingScreen>();
	}
};
static_assert(alignof(ULyraSettingScreen) == 0x000008, "Wrong alignment on ULyraSettingScreen");
static_assert(sizeof(ULyraSettingScreen) == 0x000500, "Wrong size on ULyraSettingScreen");
static_assert(offsetof(ULyraSettingScreen, TopSettingsTabs) == 0x0004A0, "Member 'ULyraSettingScreen::TopSettingsTabs' has a wrong offset!");
static_assert(offsetof(ULyraSettingScreen, BackInputActionData) == 0x0004A8, "Member 'ULyraSettingScreen::BackInputActionData' has a wrong offset!");
static_assert(offsetof(ULyraSettingScreen, ApplyInputActionData) == 0x0004B8, "Member 'ULyraSettingScreen::ApplyInputActionData' has a wrong offset!");
static_assert(offsetof(ULyraSettingScreen, CancelChangesInputActionData) == 0x0004C8, "Member 'ULyraSettingScreen::CancelChangesInputActionData' has a wrong offset!");
static_assert(offsetof(ULyraSettingScreen, BackEnhancedInputAction) == 0x0004E8, "Member 'ULyraSettingScreen::BackEnhancedInputAction' has a wrong offset!");
static_assert(offsetof(ULyraSettingScreen, ApplyEnhancedInputAction) == 0x0004F0, "Member 'ULyraSettingScreen::ApplyEnhancedInputAction' has a wrong offset!");
static_assert(offsetof(ULyraSettingScreen, CancelEnhancedInputAction) == 0x0004F8, "Member 'ULyraSettingScreen::CancelEnhancedInputAction' has a wrong offset!");

// Class JP.LyraTaggedWidget
// 0x0028 (0x0330 - 0x0308)
class ULyraTaggedWidget final : public UCommonUserWidget
{
public:
	struct FGameplayTagContainer                  HiddenByTags;                                      // 0x0308(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	ESlateVisibility                              ShownVisibility;                                   // 0x0328(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ESlateVisibility                              HiddenVisibility;                                  // 0x0329(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_32A[0x6];                                      // 0x032A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTaggedWidget">();
	}
	static class ULyraTaggedWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTaggedWidget>();
	}
};
static_assert(alignof(ULyraTaggedWidget) == 0x000008, "Wrong alignment on ULyraTaggedWidget");
static_assert(sizeof(ULyraTaggedWidget) == 0x000330, "Wrong size on ULyraTaggedWidget");
static_assert(offsetof(ULyraTaggedWidget, HiddenByTags) == 0x000308, "Member 'ULyraTaggedWidget::HiddenByTags' has a wrong offset!");
static_assert(offsetof(ULyraTaggedWidget, ShownVisibility) == 0x000328, "Member 'ULyraTaggedWidget::ShownVisibility' has a wrong offset!");
static_assert(offsetof(ULyraTaggedWidget, HiddenVisibility) == 0x000329, "Member 'ULyraTaggedWidget::HiddenVisibility' has a wrong offset!");

// Class JP.LyraTouchRegion
// 0x0008 (0x0350 - 0x0348)
class ULyraTouchRegion final : public ULyraSimulatedInputWidget
{
public:
	uint8                                         Pad_348[0x8];                                      // 0x0348(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ShouldSimulateInput() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraTouchRegion">();
	}
	static class ULyraTouchRegion* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraTouchRegion>();
	}
};
static_assert(alignof(ULyraTouchRegion) == 0x000008, "Wrong alignment on ULyraTouchRegion");
static_assert(sizeof(ULyraTouchRegion) == 0x000350, "Wrong size on ULyraTouchRegion");

// Class JP.LyraPerfStatContainerBase
// 0x0008 (0x0310 - 0x0308)
class ULyraPerfStatContainerBase final : public UCommonUserWidget
{
public:
	ELyraStatDisplayMode                          StatDisplayModeFilter;                             // 0x0308(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_309[0x7];                                      // 0x0309(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateVisibilityOfChildren();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPerfStatContainerBase">();
	}
	static class ULyraPerfStatContainerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPerfStatContainerBase>();
	}
};
static_assert(alignof(ULyraPerfStatContainerBase) == 0x000008, "Wrong alignment on ULyraPerfStatContainerBase");
static_assert(sizeof(ULyraPerfStatContainerBase) == 0x000310, "Wrong size on ULyraPerfStatContainerBase");
static_assert(offsetof(ULyraPerfStatContainerBase, StatDisplayModeFilter) == 0x000308, "Member 'ULyraPerfStatContainerBase::StatDisplayModeFilter' has a wrong offset!");

// Class JP.LyraPerfStatWidgetBase
// 0x0010 (0x0318 - 0x0308)
class ULyraPerfStatWidgetBase final : public UCommonUserWidget
{
public:
	class ULyraPerformanceStatSubsystem*          CachedStatSubsystem;                               // 0x0308(0x0008)(ZeroConstructor, Transient, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ELyraDisplayablePerformanceStat               StatToDisplay;                                     // 0x0310(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_311[0x7];                                      // 0x0311(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	double FetchStatValue();

	ELyraDisplayablePerformanceStat GetStatToDisplay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraPerfStatWidgetBase">();
	}
	static class ULyraPerfStatWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraPerfStatWidgetBase>();
	}
};
static_assert(alignof(ULyraPerfStatWidgetBase) == 0x000008, "Wrong alignment on ULyraPerfStatWidgetBase");
static_assert(sizeof(ULyraPerfStatWidgetBase) == 0x000318, "Wrong size on ULyraPerfStatWidgetBase");
static_assert(offsetof(ULyraPerfStatWidgetBase, CachedStatSubsystem) == 0x000308, "Member 'ULyraPerfStatWidgetBase::CachedStatSubsystem' has a wrong offset!");
static_assert(offsetof(ULyraPerfStatWidgetBase, StatToDisplay) == 0x000310, "Member 'ULyraPerfStatWidgetBase::StatToDisplay' has a wrong offset!");

// Class JP.LyraUIManagerSubsystem
// 0x0010 (0x0070 - 0x0060)
class ULyraUIManagerSubsystem final : public UGameUIManagerSubsystem
{
public:
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraUIManagerSubsystem">();
	}
	static class ULyraUIManagerSubsystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraUIManagerSubsystem>();
	}
};
static_assert(alignof(ULyraUIManagerSubsystem) == 0x000008, "Wrong alignment on ULyraUIManagerSubsystem");
static_assert(sizeof(ULyraUIManagerSubsystem) == 0x000070, "Wrong size on ULyraUIManagerSubsystem");

// Class JP.LyraUIMessaging
// 0x0060 (0x0090 - 0x0030)
class ULyraUIMessaging final : public UCommonMessagingSubsystem
{
public:
	TSubclassOf<class UCommonGameDialog>          ConfirmationDialogClassPtr;                        // 0x0030(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSubclassOf<class UCommonGameDialog>          ErrorDialogClassPtr;                               // 0x0038(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ConfirmationDialogClass;                           // 0x0040(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   ErrorDialogClass;                                  // 0x0068(0x0028)(Config, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"LyraUIMessaging">();
	}
	static class ULyraUIMessaging* GetDefaultObj()
	{
		return GetDefaultObjImpl<ULyraUIMessaging>();
	}
};
static_assert(alignof(ULyraUIMessaging) == 0x000008, "Wrong alignment on ULyraUIMessaging");
static_assert(sizeof(ULyraUIMessaging) == 0x000090, "Wrong size on ULyraUIMessaging");
static_assert(offsetof(ULyraUIMessaging, ConfirmationDialogClassPtr) == 0x000030, "Member 'ULyraUIMessaging::ConfirmationDialogClassPtr' has a wrong offset!");
static_assert(offsetof(ULyraUIMessaging, ErrorDialogClassPtr) == 0x000038, "Member 'ULyraUIMessaging::ErrorDialogClassPtr' has a wrong offset!");
static_assert(offsetof(ULyraUIMessaging, ConfirmationDialogClass) == 0x000040, "Member 'ULyraUIMessaging::ConfirmationDialogClass' has a wrong offset!");
static_assert(offsetof(ULyraUIMessaging, ErrorDialogClass) == 0x000068, "Member 'ULyraUIMessaging::ErrorDialogClass' has a wrong offset!");

// Class JP.MainMenuFlowControllerStateComponent
// 0x00A0 (0x0140 - 0x00A0)
class UMainMenuFlowControllerStateComponent final : public UGameStateComponent
{
public:
	uint8                                         Pad_A0[0xC];                                       // 0x00A0(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           UILayerTag;                                        // 0x00AC(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FPrimaryAssetId                        MainMenuMapToCreateSessionIn;                      // 0x00B4(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftClassPtr<class UClass>                   PressStartScreenWidgetClass;                       // 0x00C8(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   MainMenuScreenWidgetClass;                         // 0x00F0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_118[0x28];                                     // 0x0118(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnExperienceLoaded(const class UExperienceDefinition* Experience);
	void OnUserInitialized(const class UCommonUserInfo* UserInfo, bool bSuccess, const class FText& Error, ECommonUserPrivilege RequestedPrivilege, ECommonUserOnlineContext OnlineContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MainMenuFlowControllerStateComponent">();
	}
	static class UMainMenuFlowControllerStateComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMainMenuFlowControllerStateComponent>();
	}
};
static_assert(alignof(UMainMenuFlowControllerStateComponent) == 0x000008, "Wrong alignment on UMainMenuFlowControllerStateComponent");
static_assert(sizeof(UMainMenuFlowControllerStateComponent) == 0x000140, "Wrong size on UMainMenuFlowControllerStateComponent");
static_assert(offsetof(UMainMenuFlowControllerStateComponent, UILayerTag) == 0x0000AC, "Member 'UMainMenuFlowControllerStateComponent::UILayerTag' has a wrong offset!");
static_assert(offsetof(UMainMenuFlowControllerStateComponent, MainMenuMapToCreateSessionIn) == 0x0000B4, "Member 'UMainMenuFlowControllerStateComponent::MainMenuMapToCreateSessionIn' has a wrong offset!");
static_assert(offsetof(UMainMenuFlowControllerStateComponent, PressStartScreenWidgetClass) == 0x0000C8, "Member 'UMainMenuFlowControllerStateComponent::PressStartScreenWidgetClass' has a wrong offset!");
static_assert(offsetof(UMainMenuFlowControllerStateComponent, MainMenuScreenWidgetClass) == 0x0000F0, "Member 'UMainMenuFlowControllerStateComponent::MainMenuScreenWidgetClass' has a wrong offset!");

}

