#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: GASIW

#include "Basic.hpp"

#include "GameplayTags_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "GameplayAbilities_structs.hpp"
#include "GameplayAbilities_classes.hpp"
#include "GASIW_structs.hpp"
#include "Engine_classes.hpp"
#include "Inventory_classes.hpp"


namespace SDK
{

// Class GASIW.AbilityCostBase
// 0x0000 (0x0028 - 0x0028)
class UAbilityCostBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityCostBase">();
	}
	static class UAbilityCostBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityCostBase>();
	}
};
static_assert(alignof(UAbilityCostBase) == 0x000008, "Wrong alignment on UAbilityCostBase");
static_assert(sizeof(UAbilityCostBase) == 0x000028, "Wrong size on UAbilityCostBase");

// Class GASIW.AbilityCost_AttributeSet
// 0x00D0 (0x00F8 - 0x0028)
class UAbilityCost_AttributeSet final : public UAbilityCostBase
{
public:
	bool                                          bIsItem;                                           // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           Tag;                                               // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         Quantity;                                          // 0x0038(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	bool                                          bCanFail;                                          // 0x0060(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayAttribute                     AffectedAttribute;                                 // 0x0068(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAttribute                     AttributeModifier;                                 // 0x00A0(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           FailureTag;                                        // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bModifyWithTags;                                   // 0x00E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ModifyingTag;                                      // 0x00E4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           ModifyingTagMax;                                   // 0x00EC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityCost_AttributeSet">();
	}
	static class UAbilityCost_AttributeSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityCost_AttributeSet>();
	}
};
static_assert(alignof(UAbilityCost_AttributeSet) == 0x000008, "Wrong alignment on UAbilityCost_AttributeSet");
static_assert(sizeof(UAbilityCost_AttributeSet) == 0x0000F8, "Wrong size on UAbilityCost_AttributeSet");
static_assert(offsetof(UAbilityCost_AttributeSet, bIsItem) == 0x000028, "Member 'UAbilityCost_AttributeSet::bIsItem' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, Tag) == 0x00002C, "Member 'UAbilityCost_AttributeSet::Tag' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, Quantity) == 0x000038, "Member 'UAbilityCost_AttributeSet::Quantity' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, bCanFail) == 0x000060, "Member 'UAbilityCost_AttributeSet::bCanFail' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, AffectedAttribute) == 0x000068, "Member 'UAbilityCost_AttributeSet::AffectedAttribute' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, AttributeModifier) == 0x0000A0, "Member 'UAbilityCost_AttributeSet::AttributeModifier' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, FailureTag) == 0x0000D8, "Member 'UAbilityCost_AttributeSet::FailureTag' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, bModifyWithTags) == 0x0000E0, "Member 'UAbilityCost_AttributeSet::bModifyWithTags' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, ModifyingTag) == 0x0000E4, "Member 'UAbilityCost_AttributeSet::ModifyingTag' has a wrong offset!");
static_assert(offsetof(UAbilityCost_AttributeSet, ModifyingTagMax) == 0x0000EC, "Member 'UAbilityCost_AttributeSet::ModifyingTagMax' has a wrong offset!");

// Class GASIW.GameplayEffectIW
// 0x0060 (0x0AD0 - 0x0A70)
class UGameplayEffectIW : public UGameplayEffect
{
public:
	struct FInheritedTagContainer                 InheritableApplicationHasAnyTagRequirements;       // 0x0A70(0x0060)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEffectIW">();
	}
	static class UGameplayEffectIW* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectIW>();
	}
};
static_assert(alignof(UGameplayEffectIW) == 0x000008, "Wrong alignment on UGameplayEffectIW");
static_assert(sizeof(UGameplayEffectIW) == 0x000AD0, "Wrong size on UGameplayEffectIW");
static_assert(offsetof(UGameplayEffectIW, InheritableApplicationHasAnyTagRequirements) == 0x000A70, "Member 'UGameplayEffectIW::InheritableApplicationHasAnyTagRequirements' has a wrong offset!");

// Class GASIW.AbilityCost_ItemTagStack
// 0x0058 (0x0080 - 0x0028)
class UAbilityCost_ItemTagStack final : public UAbilityCostBase
{
public:
	bool                                          bClearAllStacks;                                   // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           CostTag;                                           // 0x002C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Tag;                                               // 0x0034(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanFail;                                          // 0x003C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           FailureTag;                                        // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FGameplayAttribute                     StatModifier;                                      // 0x0048(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityCost_ItemTagStack">();
	}
	static class UAbilityCost_ItemTagStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityCost_ItemTagStack>();
	}
};
static_assert(alignof(UAbilityCost_ItemTagStack) == 0x000008, "Wrong alignment on UAbilityCost_ItemTagStack");
static_assert(sizeof(UAbilityCost_ItemTagStack) == 0x000080, "Wrong size on UAbilityCost_ItemTagStack");
static_assert(offsetof(UAbilityCost_ItemTagStack, bClearAllStacks) == 0x000028, "Member 'UAbilityCost_ItemTagStack::bClearAllStacks' has a wrong offset!");
static_assert(offsetof(UAbilityCost_ItemTagStack, CostTag) == 0x00002C, "Member 'UAbilityCost_ItemTagStack::CostTag' has a wrong offset!");
static_assert(offsetof(UAbilityCost_ItemTagStack, Tag) == 0x000034, "Member 'UAbilityCost_ItemTagStack::Tag' has a wrong offset!");
static_assert(offsetof(UAbilityCost_ItemTagStack, bCanFail) == 0x00003C, "Member 'UAbilityCost_ItemTagStack::bCanFail' has a wrong offset!");
static_assert(offsetof(UAbilityCost_ItemTagStack, FailureTag) == 0x000040, "Member 'UAbilityCost_ItemTagStack::FailureTag' has a wrong offset!");
static_assert(offsetof(UAbilityCost_ItemTagStack, StatModifier) == 0x000048, "Member 'UAbilityCost_ItemTagStack::StatModifier' has a wrong offset!");

// Class GASIW.AbilitySystemComponentIW
// 0x00C0 (0x1308 - 0x1248)
class UAbilitySystemComponentIW : public UAbilitySystemComponent
{
public:
	TArray<class UGameplaySet*>                   DefaultGameplaySets;                               // 0x1248(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UInputConfig*                           InputConfig;                                       // 0x1258(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UInputMappingContext*                   DefaultContext;                                    // 0x1260(0x0008)(Edit, ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameplayEffectAppliedDelegateToSelfBP;           // 0x1268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnGameplayEffectAppliedDelegateToTargetBP;         // 0x1278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EGameplayEffectReplicationMode                GameplayEffectReplicationMode;                     // 0x1288(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1289[0x47];                                    // 0x1289(0x0047)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnhancedInputLocalPlayerSubsystem*     LocalPlayerSubsystem;                              // 0x12D0(0x0008)(ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12D8[0x8];                                     // 0x12D8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPendingMontageRepForMesh;                         // 0x12E0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12E1[0x7];                                     // 0x12E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FGameplayAbilityLocalAnimMontageForMesh> LocalAnimMontageInfoForMeshes;                     // 0x12E8(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplayAbilityRepAnimMontageForMesh> RepAnimMontageInfoForMeshes;                       // 0x12F8(0x0010)(Net, ZeroConstructor, RepNotify, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AbilityInputTagPressed(const struct FGameplayTag& InputTag);
	void AbilityInputTagReleased(const struct FGameplayTag& InputTag);
	void AddGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	struct FActiveGameplayEffectHandle ApplyGameplayEffectSpecToTargetWithChange(const struct FGameplayEffectSpecHandle& SpecHandle, class UAbilitySystemComponent* Target, bool* Changed);
	bool CancelAbilitiesByTag(const struct FGameplayTagContainer& GameplayTagContainer);
	void CheckInputComponent();
	void ExecuteGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	bool GetCooldownRemainingForTag(const struct FGameplayTagContainer& CooldownTags, float* TimeRemaining, float* CooldownDuration);
	struct FGameplaySetHandle GiveGameplaySet(const class UGameplaySet* GameplaySet, class UObject* SourceObject);
	TArray<struct FGameplaySetHandle> GiveGameplaySets(const TArray<class UGameplaySet*>& GameplaySets, class UObject* SourceObject);
	void OnRep_ReplicatedAnimMontageForMesh();
	void ProcessInput();
	void RemoveGameplayCueLocal(const struct FGameplayTag& GameplayCueTag, const struct FGameplayCueParameters& GameplayCueParameters);
	void RemoveGameplaySet(const struct FGameplaySetHandle& Handle);
	void ServerCurrentMontageJumpToSectionNameForMesh(class USkeletalMeshComponent* InMesh, class UAnimMontage* ClientAnimMontage, class FName SectionName);
	void ServerCurrentMontageSetNextSectionNameForMesh(class USkeletalMeshComponent* InMesh, class UAnimMontage* ClientAnimMontage, float ClientPosition, class FName SectionName, class FName NextSectionName);
	void ServerCurrentMontageSetPlayRateForMesh(class USkeletalMeshComponent* InMesh, class UAnimMontage* ClientAnimMontage, float InPlayRate);
	bool SetGameplayEffectDurationHandle(const struct FActiveGameplayEffectHandle& Handle, float NewDuration);

	int32 GetNumAbilities() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilitySystemComponentIW">();
	}
	static class UAbilitySystemComponentIW* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemComponentIW>();
	}
};
static_assert(alignof(UAbilitySystemComponentIW) == 0x000008, "Wrong alignment on UAbilitySystemComponentIW");
static_assert(sizeof(UAbilitySystemComponentIW) == 0x001308, "Wrong size on UAbilitySystemComponentIW");
static_assert(offsetof(UAbilitySystemComponentIW, DefaultGameplaySets) == 0x001248, "Member 'UAbilitySystemComponentIW::DefaultGameplaySets' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, InputConfig) == 0x001258, "Member 'UAbilitySystemComponentIW::InputConfig' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, DefaultContext) == 0x001260, "Member 'UAbilitySystemComponentIW::DefaultContext' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, OnGameplayEffectAppliedDelegateToSelfBP) == 0x001268, "Member 'UAbilitySystemComponentIW::OnGameplayEffectAppliedDelegateToSelfBP' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, OnGameplayEffectAppliedDelegateToTargetBP) == 0x001278, "Member 'UAbilitySystemComponentIW::OnGameplayEffectAppliedDelegateToTargetBP' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, GameplayEffectReplicationMode) == 0x001288, "Member 'UAbilitySystemComponentIW::GameplayEffectReplicationMode' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, LocalPlayerSubsystem) == 0x0012D0, "Member 'UAbilitySystemComponentIW::LocalPlayerSubsystem' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, bPendingMontageRepForMesh) == 0x0012E0, "Member 'UAbilitySystemComponentIW::bPendingMontageRepForMesh' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, LocalAnimMontageInfoForMeshes) == 0x0012E8, "Member 'UAbilitySystemComponentIW::LocalAnimMontageInfoForMeshes' has a wrong offset!");
static_assert(offsetof(UAbilitySystemComponentIW, RepAnimMontageInfoForMeshes) == 0x0012F8, "Member 'UAbilitySystemComponentIW::RepAnimMontageInfoForMeshes' has a wrong offset!");

// Class GASIW.PickupSpawner
// 0x0050 (0x02E0 - 0x0290)
class APickupSpawner final : public AActor
{
public:
	class FName                                   InteractionProfileName;                            // 0x0290(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InteractionComponentTag;                           // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A0[0x10];                                     // 0x02A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UStaticMeshComponent*                   PadMesh;                                           // 0x02B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMeshComponent*                   PickupMesh;                                        // 0x02B8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PickupMeshRotationSpeed;                           // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C4[0x4];                                      // 0x02C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPickupSpawnerDefinition*               PickupDefinition;                                  // 0x02C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPickupAvailable;                                // 0x02D0(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2D1[0x3];                                      // 0x02D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CoolDownTime;                                      // 0x02D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoolDownPercentage;                                // 0x02D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2DC[0x4];                                      // 0x02DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttemptPickUpItem(class APawn* Pawn);
	bool GivePickup(TSoftObjectPtr<class UItemDefinition>* PickupItemClass, class APawn* ReceivingPawn);
	void OnCoolDownTimerComplete();
	void OnInteractBegin(class AActor* OtherActor);
	void OnPickupAvailable(const bool PickupAvailability);
	void OnRep_PickupAvailability();
	void PlayPickupEffects();
	void PlayRespawnEffects();
	void ResetCoolDown();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupSpawner">();
	}
	static class APickupSpawner* GetDefaultObj()
	{
		return GetDefaultObjImpl<APickupSpawner>();
	}
};
static_assert(alignof(APickupSpawner) == 0x000008, "Wrong alignment on APickupSpawner");
static_assert(sizeof(APickupSpawner) == 0x0002E0, "Wrong size on APickupSpawner");
static_assert(offsetof(APickupSpawner, InteractionProfileName) == 0x000290, "Member 'APickupSpawner::InteractionProfileName' has a wrong offset!");
static_assert(offsetof(APickupSpawner, InteractionComponentTag) == 0x000298, "Member 'APickupSpawner::InteractionComponentTag' has a wrong offset!");
static_assert(offsetof(APickupSpawner, PadMesh) == 0x0002B0, "Member 'APickupSpawner::PadMesh' has a wrong offset!");
static_assert(offsetof(APickupSpawner, PickupMesh) == 0x0002B8, "Member 'APickupSpawner::PickupMesh' has a wrong offset!");
static_assert(offsetof(APickupSpawner, PickupMeshRotationSpeed) == 0x0002C0, "Member 'APickupSpawner::PickupMeshRotationSpeed' has a wrong offset!");
static_assert(offsetof(APickupSpawner, PickupDefinition) == 0x0002C8, "Member 'APickupSpawner::PickupDefinition' has a wrong offset!");
static_assert(offsetof(APickupSpawner, bIsPickupAvailable) == 0x0002D0, "Member 'APickupSpawner::bIsPickupAvailable' has a wrong offset!");
static_assert(offsetof(APickupSpawner, CoolDownTime) == 0x0002D4, "Member 'APickupSpawner::CoolDownTime' has a wrong offset!");
static_assert(offsetof(APickupSpawner, CoolDownPercentage) == 0x0002D8, "Member 'APickupSpawner::CoolDownPercentage' has a wrong offset!");

// Class GASIW.AbilityTask_RepeatContinuous
// 0x0000 (0x00B8 - 0x00B8)
class UAbilityTask_RepeatContinuous : public UAbilityTask_Repeat
{
public:
	static class UAbilityTask_RepeatContinuous* RepeatContinuousAction(class UGameplayAbility* OwningAbility, float TimeBetweenActions, int32 TotalActionCount);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_RepeatContinuous">();
	}
	static class UAbilityTask_RepeatContinuous* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_RepeatContinuous>();
	}
};
static_assert(alignof(UAbilityTask_RepeatContinuous) == 0x000008, "Wrong alignment on UAbilityTask_RepeatContinuous");
static_assert(sizeof(UAbilityTask_RepeatContinuous) == 0x0000B8, "Wrong size on UAbilityTask_RepeatContinuous");

// Class GASIW.AbilityTasks_TraceForObjects
// 0x0000 (0x00B8 - 0x00B8)
class UAbilityTasks_TraceForObjects final : public UAbilityTask_RepeatContinuous
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTasks_TraceForObjects">();
	}
	static class UAbilityTasks_TraceForObjects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTasks_TraceForObjects>();
	}
};
static_assert(alignof(UAbilityTasks_TraceForObjects) == 0x000008, "Wrong alignment on UAbilityTasks_TraceForObjects");
static_assert(sizeof(UAbilityTasks_TraceForObjects) == 0x0000B8, "Wrong size on UAbilityTasks_TraceForObjects");

// Class GASIW.AbilityTask_AddTagStackOverTime
// 0x0050 (0x00D0 - 0x0080)
class UAbilityTask_AddTagStackOverTime final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnTick;                                            // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	FMulticastInlineDelegateProperty_             OnFinished;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class UItemInstance*                          ItemInstance;                                      // 0x00C0(0x0008)(ZeroConstructor, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAbilityTask_AddTagStackOverTime* AddTagStackOverTimeAction(class UGameplayAbility* OwningAbility, const struct FGameplayTag& Tag, int32 StacksPerTick, int32 TicksPerSecond, int32 MaxCharges, float TotalTime);

	void PerformAction();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilityTask_AddTagStackOverTime">();
	}
	static class UAbilityTask_AddTagStackOverTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilityTask_AddTagStackOverTime>();
	}
};
static_assert(alignof(UAbilityTask_AddTagStackOverTime) == 0x000008, "Wrong alignment on UAbilityTask_AddTagStackOverTime");
static_assert(sizeof(UAbilityTask_AddTagStackOverTime) == 0x0000D0, "Wrong size on UAbilityTask_AddTagStackOverTime");
static_assert(offsetof(UAbilityTask_AddTagStackOverTime, OnTick) == 0x000080, "Member 'UAbilityTask_AddTagStackOverTime::OnTick' has a wrong offset!");
static_assert(offsetof(UAbilityTask_AddTagStackOverTime, OnFinished) == 0x000090, "Member 'UAbilityTask_AddTagStackOverTime::OnFinished' has a wrong offset!");
static_assert(offsetof(UAbilityTask_AddTagStackOverTime, ItemInstance) == 0x0000C0, "Member 'UAbilityTask_AddTagStackOverTime::ItemInstance' has a wrong offset!");

// Class GASIW.GameplaySet
// 0x0030 (0x0060 - 0x0030)
class UGameplaySet final : public UPrimaryDataAsset
{
public:
	TArray<struct FGameplaySet_GameplayAbility>   GameplayAbilitiesToGrant;                          // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplaySet_GameplayEffect>    GameplayEffectsToGrant;                            // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FGameplaySet_AttributeSet>      AttributesToGrant;                                 // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplaySet">();
	}
	static class UGameplaySet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplaySet>();
	}
};
static_assert(alignof(UGameplaySet) == 0x000008, "Wrong alignment on UGameplaySet");
static_assert(sizeof(UGameplaySet) == 0x000060, "Wrong size on UGameplaySet");
static_assert(offsetof(UGameplaySet, GameplayAbilitiesToGrant) == 0x000030, "Member 'UGameplaySet::GameplayAbilitiesToGrant' has a wrong offset!");
static_assert(offsetof(UGameplaySet, GameplayEffectsToGrant) == 0x000040, "Member 'UGameplaySet::GameplayEffectsToGrant' has a wrong offset!");
static_assert(offsetof(UGameplaySet, AttributesToGrant) == 0x000050, "Member 'UGameplaySet::AttributesToGrant' has a wrong offset!");

// Class GASIW.PlayMontageForMeshAndWaitForEvent
// 0x00D0 (0x0150 - 0x0080)
class UPlayMontageForMeshAndWaitForEvent final : public UAbilityTask
{
public:
	FMulticastInlineDelegateProperty_             OnCompleted;                                       // 0x0080(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnBlendOut;                                        // 0x0090(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnInterrupted;                                     // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnCancelled;                                       // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             EventReceived;                                     // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 Mesh;                                              // 0x00D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           MontageToPlay;                                     // 0x00D8(0x0008)(ZeroConstructor, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FGameplayTagContainer                  EventTags;                                         // 0x00E0(0x0020)(NativeAccessSpecifierPrivate)
	float                                         Rate;                                              // 0x0100(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   StartSection;                                      // 0x0104(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AnimRootMotionTranslationScale;                    // 0x010C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bStopWhenAbilityEnds;                              // 0x0110(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bReplicateMontage;                                 // 0x0111(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_112[0x2];                                      // 0x0112(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideBlendOutTimeForCancelAbility;              // 0x0114(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         OverrideBlendOutTimeForStopWhenEndAbility;         // 0x0118(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11C[0x34];                                     // 0x011C(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UPlayMontageForMeshAndWaitForEvent* PlayMontageForMeshAndWaitForEvent(class UGameplayAbility* OwningAbility, class FName TaskInstanceName, class USkeletalMeshComponent* Mesh_0, class UAnimMontage* MontageToPlay_0, const struct FGameplayTagContainer& EventTags_0, float Rate_0, class FName StartSection_0, bool bStopWhenAbilityEnds_0, float AnimRootMotionTranslationScale_0, bool bReplicateMontage_0, float OverrideBlendOutTimeForCancelAbility_0, float OverrideBlendOutTimeForStopWhenEndAbility_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PlayMontageForMeshAndWaitForEvent">();
	}
	static class UPlayMontageForMeshAndWaitForEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPlayMontageForMeshAndWaitForEvent>();
	}
};
static_assert(alignof(UPlayMontageForMeshAndWaitForEvent) == 0x000008, "Wrong alignment on UPlayMontageForMeshAndWaitForEvent");
static_assert(sizeof(UPlayMontageForMeshAndWaitForEvent) == 0x000150, "Wrong size on UPlayMontageForMeshAndWaitForEvent");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, OnCompleted) == 0x000080, "Member 'UPlayMontageForMeshAndWaitForEvent::OnCompleted' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, OnBlendOut) == 0x000090, "Member 'UPlayMontageForMeshAndWaitForEvent::OnBlendOut' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, OnInterrupted) == 0x0000A0, "Member 'UPlayMontageForMeshAndWaitForEvent::OnInterrupted' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, OnCancelled) == 0x0000B0, "Member 'UPlayMontageForMeshAndWaitForEvent::OnCancelled' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, EventReceived) == 0x0000C0, "Member 'UPlayMontageForMeshAndWaitForEvent::EventReceived' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, Mesh) == 0x0000D0, "Member 'UPlayMontageForMeshAndWaitForEvent::Mesh' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, MontageToPlay) == 0x0000D8, "Member 'UPlayMontageForMeshAndWaitForEvent::MontageToPlay' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, EventTags) == 0x0000E0, "Member 'UPlayMontageForMeshAndWaitForEvent::EventTags' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, Rate) == 0x000100, "Member 'UPlayMontageForMeshAndWaitForEvent::Rate' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, StartSection) == 0x000104, "Member 'UPlayMontageForMeshAndWaitForEvent::StartSection' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, AnimRootMotionTranslationScale) == 0x00010C, "Member 'UPlayMontageForMeshAndWaitForEvent::AnimRootMotionTranslationScale' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, bStopWhenAbilityEnds) == 0x000110, "Member 'UPlayMontageForMeshAndWaitForEvent::bStopWhenAbilityEnds' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, bReplicateMontage) == 0x000111, "Member 'UPlayMontageForMeshAndWaitForEvent::bReplicateMontage' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, OverrideBlendOutTimeForCancelAbility) == 0x000114, "Member 'UPlayMontageForMeshAndWaitForEvent::OverrideBlendOutTimeForCancelAbility' has a wrong offset!");
static_assert(offsetof(UPlayMontageForMeshAndWaitForEvent, OverrideBlendOutTimeForStopWhenEndAbility) == 0x000118, "Member 'UPlayMontageForMeshAndWaitForEvent::OverrideBlendOutTimeForStopWhenEndAbility' has a wrong offset!");

// Class GASIW.AttributeSetIW
// 0x0000 (0x0030 - 0x0030)
class UAttributeSetIW : public UAttributeSet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AttributeSetIW">();
	}
	static class UAttributeSetIW* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAttributeSetIW>();
	}
};
static_assert(alignof(UAttributeSetIW) == 0x000008, "Wrong alignment on UAttributeSetIW");
static_assert(sizeof(UAttributeSetIW) == 0x000030, "Wrong size on UAttributeSetIW");

// Class GASIW.BlueprintFunctionLibraryIW
// 0x0000 (0x0028 - 0x0028)
class UBlueprintFunctionLibraryIW final : public UBlueprintFunctionLibrary
{
public:
	static void EffectContextAddTargetData(const struct FGameplayEffectContextHandle& EffectContextHandle, const struct FGameplayAbilityTargetDataHandle& TargetData);
	static struct FGameplayAbilityTargetDataHandle EffectContextGetTargetData(const struct FGameplayEffectContextHandle& EffectContext);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"BlueprintFunctionLibraryIW">();
	}
	static class UBlueprintFunctionLibraryIW* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBlueprintFunctionLibraryIW>();
	}
};
static_assert(alignof(UBlueprintFunctionLibraryIW) == 0x000008, "Wrong alignment on UBlueprintFunctionLibraryIW");
static_assert(sizeof(UBlueprintFunctionLibraryIW) == 0x000028, "Wrong size on UBlueprintFunctionLibraryIW");

// Class GASIW.EquipmentRemovalConditions
// 0x0000 (0x0028 - 0x0028)
class UEquipmentRemovalConditions : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentRemovalConditions">();
	}
	static class UEquipmentRemovalConditions* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentRemovalConditions>();
	}
};
static_assert(alignof(UEquipmentRemovalConditions) == 0x000008, "Wrong alignment on UEquipmentRemovalConditions");
static_assert(sizeof(UEquipmentRemovalConditions) == 0x000028, "Wrong size on UEquipmentRemovalConditions");

// Class GASIW.RemovalCondition_ItemTagStack
// 0x0038 (0x0060 - 0x0028)
class URemovalCondition_ItemTagStack final : public UEquipmentRemovalConditions
{
public:
	struct FScalableFloat                         Quantity;                                          // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	struct FGameplayTag                           Tag;                                               // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EItemTagStackOperatorType                     Operator;                                          // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"RemovalCondition_ItemTagStack">();
	}
	static class URemovalCondition_ItemTagStack* GetDefaultObj()
	{
		return GetDefaultObjImpl<URemovalCondition_ItemTagStack>();
	}
};
static_assert(alignof(URemovalCondition_ItemTagStack) == 0x000008, "Wrong alignment on URemovalCondition_ItemTagStack");
static_assert(sizeof(URemovalCondition_ItemTagStack) == 0x000060, "Wrong size on URemovalCondition_ItemTagStack");
static_assert(offsetof(URemovalCondition_ItemTagStack, Quantity) == 0x000028, "Member 'URemovalCondition_ItemTagStack::Quantity' has a wrong offset!");
static_assert(offsetof(URemovalCondition_ItemTagStack, Tag) == 0x000050, "Member 'URemovalCondition_ItemTagStack::Tag' has a wrong offset!");
static_assert(offsetof(URemovalCondition_ItemTagStack, Operator) == 0x000058, "Member 'URemovalCondition_ItemTagStack::Operator' has a wrong offset!");

// Class GASIW.Equipable
// 0x0000 (0x0290 - 0x0290)
class AEquipable : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Equipable">();
	}
	static class AEquipable* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEquipable>();
	}
};
static_assert(alignof(AEquipable) == 0x000008, "Wrong alignment on AEquipable");
static_assert(sizeof(AEquipable) == 0x000290, "Wrong size on AEquipable");

// Class GASIW.EquipmentAction
// 0x0000 (0x0028 - 0x0028)
class UEquipmentAction : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentAction">();
	}
	static class UEquipmentAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentAction>();
	}
};
static_assert(alignof(UEquipmentAction) == 0x000008, "Wrong alignment on UEquipmentAction");
static_assert(sizeof(UEquipmentAction) == 0x000028, "Wrong size on UEquipmentAction");

// Class GASIW.EquipmentAction_PassiveRecharge
// 0x0080 (0x00A8 - 0x0028)
class UEquipmentAction_PassiveRecharge final : public UEquipmentAction
{
public:
	struct FGameplayTag                           Tag;                                               // 0x0028(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           LastEquippedTime;                                  // 0x0030(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FScalableFloat                         Stacks;                                            // 0x0038(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         GrantInterval;                                     // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldGrantWhileActive;                           // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BlockingTag;                                       // 0x0068(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MaxDurabilityTag;                                  // 0x0070(0x0008)(Edit, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConditions;                                    // 0x0078(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EItemTagStackOperatorType                     ConditionOperator;                                 // 0x0079(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FScalableFloat                         ConditionQuantity;                                 // 0x0080(0x0028)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentAction_PassiveRecharge">();
	}
	static class UEquipmentAction_PassiveRecharge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentAction_PassiveRecharge>();
	}
};
static_assert(alignof(UEquipmentAction_PassiveRecharge) == 0x000008, "Wrong alignment on UEquipmentAction_PassiveRecharge");
static_assert(sizeof(UEquipmentAction_PassiveRecharge) == 0x0000A8, "Wrong size on UEquipmentAction_PassiveRecharge");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, Tag) == 0x000028, "Member 'UEquipmentAction_PassiveRecharge::Tag' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, LastEquippedTime) == 0x000030, "Member 'UEquipmentAction_PassiveRecharge::LastEquippedTime' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, Stacks) == 0x000038, "Member 'UEquipmentAction_PassiveRecharge::Stacks' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, GrantInterval) == 0x000060, "Member 'UEquipmentAction_PassiveRecharge::GrantInterval' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, bShouldGrantWhileActive) == 0x000064, "Member 'UEquipmentAction_PassiveRecharge::bShouldGrantWhileActive' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, BlockingTag) == 0x000068, "Member 'UEquipmentAction_PassiveRecharge::BlockingTag' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, MaxDurabilityTag) == 0x000070, "Member 'UEquipmentAction_PassiveRecharge::MaxDurabilityTag' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, bUseConditions) == 0x000078, "Member 'UEquipmentAction_PassiveRecharge::bUseConditions' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, ConditionOperator) == 0x000079, "Member 'UEquipmentAction_PassiveRecharge::ConditionOperator' has a wrong offset!");
static_assert(offsetof(UEquipmentAction_PassiveRecharge, ConditionQuantity) == 0x000080, "Member 'UEquipmentAction_PassiveRecharge::ConditionQuantity' has a wrong offset!");

// Class GASIW.EquipmentActorToSpawnModifier
// 0x0000 (0x0028 - 0x0028)
class UEquipmentActorToSpawnModifier : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentActorToSpawnModifier">();
	}
	static class UEquipmentActorToSpawnModifier* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentActorToSpawnModifier>();
	}
};
static_assert(alignof(UEquipmentActorToSpawnModifier) == 0x000008, "Wrong alignment on UEquipmentActorToSpawnModifier");
static_assert(sizeof(UEquipmentActorToSpawnModifier) == 0x000028, "Wrong size on UEquipmentActorToSpawnModifier");

// Class GASIW.ItemAction_DamageMultiplierStructures
// 0x0008 (0x0030 - 0x0028)
class UItemAction_DamageMultiplierStructures final : public UItemAction
{
public:
	float                                         DamageMultiplier;                                  // 0x0028(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const class UItemAction_DamageMultiplierStructures* GetMultiplierActionFromDefinition(TSubclassOf<class UObject> ItemDefinition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_DamageMultiplierStructures">();
	}
	static class UItemAction_DamageMultiplierStructures* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_DamageMultiplierStructures>();
	}
};
static_assert(alignof(UItemAction_DamageMultiplierStructures) == 0x000008, "Wrong alignment on UItemAction_DamageMultiplierStructures");
static_assert(sizeof(UItemAction_DamageMultiplierStructures) == 0x000030, "Wrong size on UItemAction_DamageMultiplierStructures");
static_assert(offsetof(UItemAction_DamageMultiplierStructures, DamageMultiplier) == 0x000028, "Member 'UItemAction_DamageMultiplierStructures::DamageMultiplier' has a wrong offset!");

// Class GASIW.EquipmentDefinition
// 0x0040 (0x0068 - 0x0028)
class UEquipmentDefinition : public UObject
{
public:
	TSubclassOf<class UEquipmentInstance>         EquipmentType;                                     // 0x0028(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UGameplaySet*>                   GameplaySets;                                      // 0x0030(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FEquipmentActorToSpawn>         ActorsToSpawn;                                     // 0x0040(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UEquipmentAction*>               Actions;                                           // 0x0050(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DefaultSkin;                                       // 0x0060(0x0008)(Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentDefinition">();
	}
	static class UEquipmentDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentDefinition>();
	}
};
static_assert(alignof(UEquipmentDefinition) == 0x000008, "Wrong alignment on UEquipmentDefinition");
static_assert(sizeof(UEquipmentDefinition) == 0x000068, "Wrong size on UEquipmentDefinition");
static_assert(offsetof(UEquipmentDefinition, EquipmentType) == 0x000028, "Member 'UEquipmentDefinition::EquipmentType' has a wrong offset!");
static_assert(offsetof(UEquipmentDefinition, GameplaySets) == 0x000030, "Member 'UEquipmentDefinition::GameplaySets' has a wrong offset!");
static_assert(offsetof(UEquipmentDefinition, ActorsToSpawn) == 0x000040, "Member 'UEquipmentDefinition::ActorsToSpawn' has a wrong offset!");
static_assert(offsetof(UEquipmentDefinition, Actions) == 0x000050, "Member 'UEquipmentDefinition::Actions' has a wrong offset!");
static_assert(offsetof(UEquipmentDefinition, DefaultSkin) == 0x000060, "Member 'UEquipmentDefinition::DefaultSkin' has a wrong offset!");

// Class GASIW.EquipmentInstance
// 0x0080 (0x00A8 - 0x0028)
class UEquipmentInstance : public UObject
{
public:
	class FText                                   PrimaryFireDescription;                            // 0x0028(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FText                                   SecondaryFireDescription;                          // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FGameplayTag                           PrimaryCooldownTag;                                // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           SecondaryCooldownTag;                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HUDBarTagToUse;                                    // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           HUDBarTagToUseMaxValue;                            // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataAsset*                             ItemTooltip;                                       // 0x0068(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Instigator;                                        // 0x0070(0x0008)(Net, ZeroConstructor, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FSpawnedActorData>              SpawnedActors;                                     // 0x0078(0x0010)(Net, ZeroConstructor, RepNotify, NativeAccessSpecifierPrivate)
	TSubclassOf<class UEquipmentDefinition>       DefinitionType;                                    // 0x0088(0x0008)(Net, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FGameplaySetHandle>             GrantedGameplaySetHandles;                         // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A0[0x8];                                       // 0x00A0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void K2_OnEquipped();
	void K2_OnRemoved();
	void K2_OnUnequipped();
	void OnRep_Instigator();
	void OnRep_SpawnedActors();
	void SetPrimaryDescription(const class FText& PrimaryDescription);
	void SetSecondaryDescription(const class FText& SecondaryDescription);

	const class UEquipmentAction* FindActionByType(TSubclassOf<class UEquipmentAction> ActionType) const;
	class UObject* GetInstigator() const;
	class APawn* GetPawn() const;
	TArray<struct FSpawnedActorData> GetSpawnedActors() const;
	class APawn* GetTypedPawn(TSubclassOf<class APawn> PawnType) const;
	EEquipmentViewMode GetViewMode() const;
	void OnGrantPassiveStacks() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentInstance">();
	}
	static class UEquipmentInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentInstance>();
	}
};
static_assert(alignof(UEquipmentInstance) == 0x000008, "Wrong alignment on UEquipmentInstance");
static_assert(sizeof(UEquipmentInstance) == 0x0000A8, "Wrong size on UEquipmentInstance");
static_assert(offsetof(UEquipmentInstance, PrimaryFireDescription) == 0x000028, "Member 'UEquipmentInstance::PrimaryFireDescription' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, SecondaryFireDescription) == 0x000038, "Member 'UEquipmentInstance::SecondaryFireDescription' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, PrimaryCooldownTag) == 0x000048, "Member 'UEquipmentInstance::PrimaryCooldownTag' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, SecondaryCooldownTag) == 0x000050, "Member 'UEquipmentInstance::SecondaryCooldownTag' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, HUDBarTagToUse) == 0x000058, "Member 'UEquipmentInstance::HUDBarTagToUse' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, HUDBarTagToUseMaxValue) == 0x000060, "Member 'UEquipmentInstance::HUDBarTagToUseMaxValue' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, ItemTooltip) == 0x000068, "Member 'UEquipmentInstance::ItemTooltip' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, Instigator) == 0x000070, "Member 'UEquipmentInstance::Instigator' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, SpawnedActors) == 0x000078, "Member 'UEquipmentInstance::SpawnedActors' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, DefinitionType) == 0x000088, "Member 'UEquipmentInstance::DefinitionType' has a wrong offset!");
static_assert(offsetof(UEquipmentInstance, GrantedGameplaySetHandles) == 0x000090, "Member 'UEquipmentInstance::GrantedGameplaySetHandles' has a wrong offset!");

// Class GASIW.EquipmentManagerComponent
// 0x03D0 (0x0470 - 0x00A0)
class UEquipmentManagerComponent final : public UActorComponent
{
public:
	FMulticastInlineDelegateProperty_             OnSlotGrantedInstance;                             // 0x00A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnSlotRemovedInstance;                             // 0x00B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnEquippedItem;                                    // 0x00C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             OnUnequippedItem;                                  // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UEquipmentActorToSpawnModifier*> ActorToSpawnModifiers;                             // 0x00E0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	struct FEquipmentArray                        EquipmentArray;                                    // 0x00F0(0x0120)(Net, RepNotify, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_210[0x1C0];                                    // 0x0210(0x01C0)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EEquipmentViewMode, class USceneComponent*> SocketParents;                                     // 0x03D0(0x0050)(ExportObject, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TMap<TSubclassOf<class UEquipmentDefinition>, struct FModifiedGameSetsArray> ModifiedGameplaySetsByPerk;                        // 0x0420(0x0050)(NativeAccessSpecifierPrivate)

public:
	void AddPerkModifiedEquipment(TSubclassOf<class UEquipmentDefinition> EquipmentDefinition, const TArray<class UGameplaySet*>& NewGameplaySet);
	void AddSocketParent(EEquipmentViewMode ViewMode, class USceneComponent* Parent);
	bool AssignEquipmentToSlot(class UEquipmentInstance* Instance, const struct FGameplayTag& Slot);
	void BindOnSlotAddedInstance(const struct FGameplayTag& Slot, TDelegate<void(class UEquipmentInstance* Instance)> Delegate);
	void BindOnSlotRemovedInstance(const struct FGameplayTag& Slot, TDelegate<void(class UEquipmentInstance* Instance)> Delegate);
	bool ClearSlot(const struct FGameplayTag& Slot);
	bool DoesSlotContainInstance(class UEquipmentInstance* Instance, const struct FGameplayTag& Slot);
	bool DoesSlotContainItem(const struct FGameplayTag& Slot, TSoftObjectPtr<class UItemDefinition> Item);
	class UEquipmentInstance* EquipDefinition(TSubclassOf<class UEquipmentDefinition> EquipmentDefinition, class UObject* SourceObject);
	class UEquipmentInstance* EquipItem(class UItemInstance* Item);
	void ForceAssignEquipmentToSlot(class UEquipmentInstance* Instance, const struct FGameplayTag& Slot);
	class UEquipmentInstance* GetFirstInstanceOfType(TSubclassOf<class UEquipmentInstance> InstanceType);
	class AActor* GetFirstSpawnedActor(TSubclassOf<class AActor> ActorType);
	class AActor* GetFirstSpawnedActorWithInterface(TSubclassOf<class IInterface> InterfaceType);
	TArray<class UGameplaySet*> GetGameplaySetModifiedByPerk(TSubclassOf<class UEquipmentDefinition> EquipmentDefinition);
	class UEquipmentInstance* GetInstanceFromSlot(const struct FGameplayTag& Slot, bool* IsInstanceValid);
	void OnItemMarkedForRemoval(class UItemInstance* Item);
	void OnItemRemoved(class UItemInstance* Item);
	void OnRep_EquipmentArray();
	bool RemoveInstanceFromSlot(class UEquipmentInstance* Instance);
	void UnequipItem(class UEquipmentInstance* ItemInstance);

	TArray<class UEquipmentInstance*> GetEquipmentInstancesOfType(TSubclassOf<class UEquipmentInstance> InstanceType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EquipmentManagerComponent">();
	}
	static class UEquipmentManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UEquipmentManagerComponent>();
	}
};
static_assert(alignof(UEquipmentManagerComponent) == 0x000008, "Wrong alignment on UEquipmentManagerComponent");
static_assert(sizeof(UEquipmentManagerComponent) == 0x000470, "Wrong size on UEquipmentManagerComponent");
static_assert(offsetof(UEquipmentManagerComponent, OnSlotGrantedInstance) == 0x0000A0, "Member 'UEquipmentManagerComponent::OnSlotGrantedInstance' has a wrong offset!");
static_assert(offsetof(UEquipmentManagerComponent, OnSlotRemovedInstance) == 0x0000B0, "Member 'UEquipmentManagerComponent::OnSlotRemovedInstance' has a wrong offset!");
static_assert(offsetof(UEquipmentManagerComponent, OnEquippedItem) == 0x0000C0, "Member 'UEquipmentManagerComponent::OnEquippedItem' has a wrong offset!");
static_assert(offsetof(UEquipmentManagerComponent, OnUnequippedItem) == 0x0000D0, "Member 'UEquipmentManagerComponent::OnUnequippedItem' has a wrong offset!");
static_assert(offsetof(UEquipmentManagerComponent, ActorToSpawnModifiers) == 0x0000E0, "Member 'UEquipmentManagerComponent::ActorToSpawnModifiers' has a wrong offset!");
static_assert(offsetof(UEquipmentManagerComponent, EquipmentArray) == 0x0000F0, "Member 'UEquipmentManagerComponent::EquipmentArray' has a wrong offset!");
static_assert(offsetof(UEquipmentManagerComponent, SocketParents) == 0x0003D0, "Member 'UEquipmentManagerComponent::SocketParents' has a wrong offset!");
static_assert(offsetof(UEquipmentManagerComponent, ModifiedGameplaySetsByPerk) == 0x000420, "Member 'UEquipmentManagerComponent::ModifiedGameplaySetsByPerk' has a wrong offset!");

// Class GASIW.GameplayAbilityIW
// 0x00B0 (0x0460 - 0x03B0)
class alignas(0x10) UGameplayAbilityIW : public UGameplayAbility
{
public:
	FMulticastInlineDelegateProperty_             K2_OnGameplayAbilityActivated;                     // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	FMulticastInlineDelegateProperty_             K2_OnGameplayAbilityEnded;                         // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D0[0x4];                                      // 0x03D0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	EAbilityActivationPolicy                      ActivationPolicy;                                  // 0x03D4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAbilityCostBase*>               ActivationCosts;                                   // 0x03D8(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x68];                                     // 0x03E8(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAbilityMeshMontage>            CurrentAbilityMeshMontages;                        // 0x0450(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void ActivateStaminaCost();
	class UAnimMontage* GetCurrentMontageForMesh(class USkeletalMeshComponent* InMesh);
	bool K2_CanActivate(struct FGameplayTagContainer& RelevantTags);
	void K2_GetHitActorsWithTags(const TArray<struct FHitResult>& Hits, const struct FGameplayTagContainer& TagsToLookFor, bool AllTagsMustMatch, TArray<class AActor*>* MatchingActors, bool* NoHits);
	bool K2_IsActive();
	void K2_OnAbilityAdded();
	void K2_OnAbilityFailed(const struct FGameplayTagContainer& FailureReason);
	void K2_OnAbilityRemoved();
	void MontageJumpToSectionForMesh(class USkeletalMeshComponent* InMesh, class FName SectionName);
	void MontageSetNextSectionNameForMesh(class USkeletalMeshComponent* InMesh, class FName FromSectionName, class FName ToSectionName);
	void MontageStopForAllMeshes(float OverrideBlendOutTime);
	void MontageStopForMesh(class USkeletalMeshComponent* InMesh, float OverrideBlendOutTime);

	float GetLastActivationTime() const;
	bool IsInCooldownGracePeriod(float TotalDurationBeforeDeath) const;
	bool K2_GetCooldownTimeRemainingAndDuration(float* TimeRemaining, float* CooldownDuration) const;
	bool K2_IsInstantiated() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbilityIW">();
	}
	static class UGameplayAbilityIW* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityIW>();
	}
};
static_assert(alignof(UGameplayAbilityIW) == 0x000010, "Wrong alignment on UGameplayAbilityIW");
static_assert(sizeof(UGameplayAbilityIW) == 0x000460, "Wrong size on UGameplayAbilityIW");
static_assert(offsetof(UGameplayAbilityIW, K2_OnGameplayAbilityActivated) == 0x0003B0, "Member 'UGameplayAbilityIW::K2_OnGameplayAbilityActivated' has a wrong offset!");
static_assert(offsetof(UGameplayAbilityIW, K2_OnGameplayAbilityEnded) == 0x0003C0, "Member 'UGameplayAbilityIW::K2_OnGameplayAbilityEnded' has a wrong offset!");
static_assert(offsetof(UGameplayAbilityIW, ActivationPolicy) == 0x0003D4, "Member 'UGameplayAbilityIW::ActivationPolicy' has a wrong offset!");
static_assert(offsetof(UGameplayAbilityIW, ActivationCosts) == 0x0003D8, "Member 'UGameplayAbilityIW::ActivationCosts' has a wrong offset!");
static_assert(offsetof(UGameplayAbilityIW, CurrentAbilityMeshMontages) == 0x000450, "Member 'UGameplayAbilityIW::CurrentAbilityMeshMontages' has a wrong offset!");

// Class GASIW.GameplayAbilityEquipment
// 0x0020 (0x0480 - 0x0460)
class UGameplayAbilityEquipment : public UGameplayAbilityIW
{
public:
	uint8                                         Pad_460[0x8];                                      // 0x0460(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UEquipmentRemovalConditions*>    RemovalConditions;                                 // 0x0468(0x0010)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_478[0x8];                                      // 0x0478(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnTagStacksChanged(const struct FGameplayTag& Tag, int32 NewStacks);

	class USkeletalMeshComponent* GetEquipableSkeletalMesh() const;
	struct FGameplayCueParameters GetEquipableTargetCueParameters() const;
	int32 GetTagStackCount(const struct FGameplayTag& Tag) const;
	int32 GetTagStackCountSafe(const struct FGameplayTag& Tag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbilityEquipment">();
	}
	static class UGameplayAbilityEquipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayAbilityEquipment>();
	}
};
static_assert(alignof(UGameplayAbilityEquipment) == 0x000010, "Wrong alignment on UGameplayAbilityEquipment");
static_assert(sizeof(UGameplayAbilityEquipment) == 0x000480, "Wrong size on UGameplayAbilityEquipment");
static_assert(offsetof(UGameplayAbilityEquipment, RemovalConditions) == 0x000468, "Member 'UGameplayAbilityEquipment::RemovalConditions' has a wrong offset!");

// Class GASIW.GameplayAbilityItemHandler
// 0x0000 (0x0028 - 0x0028)
class IGameplayAbilityItemHandler final : public IInterface
{
public:
	class UEquipmentInstance* GetAssociatedEquipment() const;
	class UItemInstance* GetAssociatedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayAbilityItemHandler">();
	}
	static class IGameplayAbilityItemHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<IGameplayAbilityItemHandler>();
	}
};
static_assert(alignof(IGameplayAbilityItemHandler) == 0x000008, "Wrong alignment on IGameplayAbilityItemHandler");
static_assert(sizeof(IGameplayAbilityItemHandler) == 0x000028, "Wrong size on IGameplayAbilityItemHandler");

// Class GASIW.GameplayEffectUIData_Icon
// 0x0028 (0x0050 - 0x0028)
class UGameplayEffectUIData_Icon final : public UGameplayEffectUIData
{
public:
	TSoftObjectPtr<class UTexture2D>              Icon;                                              // 0x0028(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEffectUIData_Icon">();
	}
	static class UGameplayEffectUIData_Icon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectUIData_Icon>();
	}
};
static_assert(alignof(UGameplayEffectUIData_Icon) == 0x000008, "Wrong alignment on UGameplayEffectUIData_Icon");
static_assert(sizeof(UGameplayEffectUIData_Icon) == 0x000050, "Wrong size on UGameplayEffectUIData_Icon");
static_assert(offsetof(UGameplayEffectUIData_Icon, Icon) == 0x000028, "Member 'UGameplayEffectUIData_Icon::Icon' has a wrong offset!");

// Class GASIW.GameplayEffectUIData_IsNegativeEffect
// 0x0000 (0x0028 - 0x0028)
class UGameplayEffectUIData_IsNegativeEffect final : public UGameplayEffectUIData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GameplayEffectUIData_IsNegativeEffect">();
	}
	static class UGameplayEffectUIData_IsNegativeEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGameplayEffectUIData_IsNegativeEffect>();
	}
};
static_assert(alignof(UGameplayEffectUIData_IsNegativeEffect) == 0x000008, "Wrong alignment on UGameplayEffectUIData_IsNegativeEffect");
static_assert(sizeof(UGameplayEffectUIData_IsNegativeEffect) == 0x000028, "Wrong size on UGameplayEffectUIData_IsNegativeEffect");

// Class GASIW.ItemAction_Equipment
// 0x0008 (0x0030 - 0x0028)
class UItemAction_Equipment final : public UItemAction
{
public:
	TSubclassOf<class UEquipmentDefinition>       EquipmentDefinition;                               // 0x0028(0x0008)(Edit, ZeroConstructor, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ItemAction_Equipment">();
	}
	static class UItemAction_Equipment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UItemAction_Equipment>();
	}
};
static_assert(alignof(UItemAction_Equipment) == 0x000008, "Wrong alignment on UItemAction_Equipment");
static_assert(sizeof(UItemAction_Equipment) == 0x000030, "Wrong size on UItemAction_Equipment");
static_assert(offsetof(UItemAction_Equipment, EquipmentDefinition) == 0x000028, "Member 'UItemAction_Equipment::EquipmentDefinition' has a wrong offset!");

// Class GASIW.PickupSpawnerDefinition
// 0x0080 (0x00B0 - 0x0030)
class UPickupSpawnerDefinition final : public UDataAsset
{
public:
	TSoftObjectPtr<class UItemDefinition>         ItemDefinition;                                    // 0x0030(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UStaticMesh*                            DisplayMesh;                                       // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             PickedUpSound;                                     // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             RespawnedSound;                                    // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         PickedUpEffect;                                    // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNiagaraSystem*                         RespawnedEffect;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PickupMeshOffset;                                  // 0x0080(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PickupMeshScale;                                   // 0x0098(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"PickupSpawnerDefinition">();
	}
	static class UPickupSpawnerDefinition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UPickupSpawnerDefinition>();
	}
};
static_assert(alignof(UPickupSpawnerDefinition) == 0x000008, "Wrong alignment on UPickupSpawnerDefinition");
static_assert(sizeof(UPickupSpawnerDefinition) == 0x0000B0, "Wrong size on UPickupSpawnerDefinition");
static_assert(offsetof(UPickupSpawnerDefinition, ItemDefinition) == 0x000030, "Member 'UPickupSpawnerDefinition::ItemDefinition' has a wrong offset!");
static_assert(offsetof(UPickupSpawnerDefinition, DisplayMesh) == 0x000058, "Member 'UPickupSpawnerDefinition::DisplayMesh' has a wrong offset!");
static_assert(offsetof(UPickupSpawnerDefinition, PickedUpSound) == 0x000060, "Member 'UPickupSpawnerDefinition::PickedUpSound' has a wrong offset!");
static_assert(offsetof(UPickupSpawnerDefinition, RespawnedSound) == 0x000068, "Member 'UPickupSpawnerDefinition::RespawnedSound' has a wrong offset!");
static_assert(offsetof(UPickupSpawnerDefinition, PickedUpEffect) == 0x000070, "Member 'UPickupSpawnerDefinition::PickedUpEffect' has a wrong offset!");
static_assert(offsetof(UPickupSpawnerDefinition, RespawnedEffect) == 0x000078, "Member 'UPickupSpawnerDefinition::RespawnedEffect' has a wrong offset!");
static_assert(offsetof(UPickupSpawnerDefinition, PickupMeshOffset) == 0x000080, "Member 'UPickupSpawnerDefinition::PickupMeshOffset' has a wrong offset!");
static_assert(offsetof(UPickupSpawnerDefinition, PickupMeshScale) == 0x000098, "Member 'UPickupSpawnerDefinition::PickupMeshScale' has a wrong offset!");

// Class GASIW.SpawnedActorViewModeHandler
// 0x0000 (0x0028 - 0x0028)
class ISpawnedActorViewModeHandler final : public IInterface
{
public:
	void OnHandleViewMode(EEquipmentViewMode ViewMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SpawnedActorViewModeHandler">();
	}
	static class ISpawnedActorViewModeHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<ISpawnedActorViewModeHandler>();
	}
};
static_assert(alignof(ISpawnedActorViewModeHandler) == 0x000008, "Wrong alignment on ISpawnedActorViewModeHandler");
static_assert(sizeof(ISpawnedActorViewModeHandler) == 0x000028, "Wrong size on ISpawnedActorViewModeHandler");

// Class GASIW.AbilitySystemGlobalsIW
// 0x0000 (0x02F8 - 0x02F8)
class UAbilitySystemGlobalsIW final : public UAbilitySystemGlobals
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AbilitySystemGlobalsIW">();
	}
	static class UAbilitySystemGlobalsIW* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAbilitySystemGlobalsIW>();
	}
};
static_assert(alignof(UAbilitySystemGlobalsIW) == 0x000008, "Wrong alignment on UAbilitySystemGlobalsIW");
static_assert(sizeof(UAbilitySystemGlobalsIW) == 0x0002F8, "Wrong size on UAbilitySystemGlobalsIW");

}

